#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 16 15:31:24 2019

@author: kyle
"""

import os
import numpy as np


def create_directories(ion, method="lambdas"):
    """
    Create Directory based on the ion, and method in the 'results' folder 
    and returns directory location.General format:
    
        results/isoelectronic/isoelectronic-sequence/ion-species + charge/method
        
    Inputs:
    
        ion: State, used to specify iso-electronic sequence, species and charge
        
        method: str, 
        
            'lambdas' - vary orbital scaling parameters/lambdas  
            'shift' - use energy shifts to get the right location  
            'combined' - vary orbitals and use energy shifts
            
        
    Outputs: 
    
        direc: str, name of directory
    """
    
    # Base directory 
    if not os.access("results", os.F_OK):
        os.mkdir("results")
    
    # Base subdirectory
    if not os.access(f"results/isoelectronic", os.F_OK):
        os.mkdir("results/isoelectronic")
        
    # Subdirectory for isoelectronic sequence
    if not os.access(f"results/isoelectronic/{ion.isoelec_seq}", os.F_OK):
        os.mkdir(f"results/isoelectronic/{ion.isoelec_seq}")
    
    # Subdirectory for species and charge
    if not os.access(f"results/isoelectronic/{ion.isoelec_seq}/{ion.species}{ion.ion_charge}", os.F_OK):
        os.mkdir(f"results/isoelectronic/{ion.isoelec_seq}/{ion.species}{ion.ion_charge}")
    
    # Subdirectory for methods
    if method == "lambdas":
        direc = f"results/isoelectronic/{ion.isoelec_seq}/{ion.species}{ion.ion_charge}/lambda_method/"
        if not os.access(direc, os.F_OK):
            os.mkdir(direc)
        return direc
    elif  method == "shift":
        direc = f"results/isoelectronic/{ion.isoelec_seq}/{ion.species}{ion.ion_charge}/shift_method/"
        if not os.access(direc, os.F_OK):
            os.mkdir(direc)
        return direc
    elif method == "combined":
        direc = f"results/isoelectronic/{ion.isoelec_seq}/{ion.species}{ion.ion_charge}/combined_method/"
        if not os.access(direc, os.F_OK):
            os.mkdir(direc)
        return direc

    
def get_nist_energy(fname):
    """
    Look up energy from file
    
    Inputs:
    
        fname: str, name of file with NIST energy
        
    
    Outputs:
    
        E_nist: double, NIST energy
    """
    nist = np.transpose(np.genfromtxt(fname, skip_header=1))
    all_nist = nist

    E_nist = nist[-1]
#    print('NIST energies= ',E_nist,all_nist)
    return E_nist,all_nist


def read_levels(levels_file):
    """
    Read a LEVELS file generated by Autostructure (AS)
    
    Inputs: 
    
        levels_file: str, name of levels file
        
    Output:
    
        y:
        
        ground: 
    """
    data = np.transpose(np.genfromtxt(levels_file, skip_header=1))
    y = data[-1][:len(data[-1])-1]
    all_levels=data
    ground = data[-1][-1]
#    print('LEVELS CHECK',all_levels)
    return y, ground,all_levels


def compare_to_nist(y_comp, y_nist, all_nist, all_levels):
    """
    Compute signed relative error based on NIST value.
    
    Inputs:
        
        y_comp: double, array of values to compare with NIST
        
        y_nist: double, NIST reference value
        
    
    Outputs:
    
        err: double, relative error
    """

    err=np.zeros(len(y_nist))
    nist_reorder=np.zeros(len(y_nist))
    icount=0
    for i in range(1,len(y_comp)):
        for j in range(1,len(y_nist)):
            if (np.array_equal(all_nist[:,j][0:4],all_levels[:,i][0:4])):
               err[i] = ((y_comp[i] - y_nist[j]) / (1+y_nist[j]))
               nist_reorder[i] = y_nist[j]
               icount=icount+1
               if(i != j):
                  print('NIST Order changed')
#               print('NIST MATCH',i,j, y_nist[j], y_comp[i])
     
#    print('NIST COMPARE',y_comp, y_nist, nist_reorder)
    
    err[err==0]=1e-30
    return err,nist_reorder
