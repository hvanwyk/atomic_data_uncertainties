C N. R. BADNELL                   NRB  v27.133.5                03/03/21
C
C                          A U T O S T R U C T U R E
C                          *************************
C                      (Copyright (c) 1985-2021 BADNELL)
C
C                                incorporating
C
C                         S U P E R S T R U C T U R E
C                         ***************************
C          (Copyright (c) 1969-1984 EISSNER/JONES/NUSSBAUMER/STOREY)
C
C***********************************************************************
C
C  COMBINED SOURCE DECK FOR SERIAL & PARALLEL (+/- BLAS/LAPACK) VERSIONS
C         - EACH VERSION CAN BE PRODUCED BY A SIMPLE EDIT STRING -
C           ALL ARE PROVIDED AT HTTP://WWW.APAP-NETWORK.ORG/AUTOS
C
C***********************************************************************
cparc                                                               !par
cparc                            + Parallel +                       !par
cparc                                                               !par
cparc     v25.11 First parallelization of resonant n-loop           !par
cparc     v23.10 Parallelization of collision strengths by LSp, Jp  !par
cparc     v22.16 Parallelization of collision algebra by LSp, Jp    !par
cparc     v21.14 nproc restriction removed                          !par
cparc     v20.2  First parallelization of resonant l-loop (CPB)     !par
cparc                                                               !par
cpar!***************************************************************!par
cparc                                                               !par
cpar      module mpi                ! For broken mpi f90 build      !par
cpar      include 'mpif.h'          ! Can comment-out if O.K.       !par
cpar      end                                                       !par
cparc                                                               !par
cpar      module comm_interface                                     !par
cparc                                                               !par
cpar      use mpi                                                   !par
cparc                                                               !par
cpar      implicit none                                             !par
cparc                                                               !par
cpar      public comm_init          ! Initialize MPI                !par
cpar      public comm_barrier       ! MPI barrier                   !par
cpar      public comm_finalize      ! Terminate MPI                 !par
cpar      integer(kind(mpi_integer)), public  :: iam                !par
cpar      integer(kind(mpi_integer)), public  :: nproc              !par
cparc                                                               !par
cpar      SAVE                                                      !par
cparc                                                               !par
cpar      private                                                   !par
cpar      integer(kind(mpi_integer)) :: mpicom                      !par
cparc                                                               !par
cpar      CONTAINS                                                  !par
cparc                                                               !par
cpar!---------------------------------------------------------------!par
cpar      subroutine comm_init()                                    !par
cparc                                                               !par
cpar      use mpi                                                   !par
cparc                                                               !par
cpar      implicit none                                             !par
cparc                                                               !par
cpar      integer(kind(mpi_integer)) :: ier                         !par
cparc                                                               !par
cpar      mpicom = MPI_COMM_WORLD                                   !par
cparc                                                               !par
cpar      call mpi_init(ier)                                        !par
cpar      call mpi_comm_rank(mpicom, iam, ier)                      !par
cpar      call mpi_comm_size(mpicom, nproc, ier)                    !par
cparc                                                               !par
cpar      return                                                    !par
cparc                                                               !par
cpar      end subroutine comm_init                                  !par
cparc                                                               !par
cpar!---------------------------------------------------------------!par
cpar      subroutine comm_barrier()                                 !par
cparc                                                               !par
cpar      use mpi                                                   !par
cparc                                                               !par
cpar      implicit none                                             !par
cparc                                                               !par
cpar      integer(kind(mpi_integer)) :: ier                         !par
cparc                                                               !par
cpar      call mpi_barrier(mpicom, ier)                             !par
cparc                                                               !par
cpar      return                                                    !par
cparc                                                               !par
cpar      end subroutine comm_barrier                               !par
cpar!---------------------------------------------------------------!par
cparc                                                               !par
cpar      subroutine comm_finalize()                                !par
cparc                                                               !par
cpar      use mpi                                                   !par
cparc                                                               !par
cpar      implicit none                                             !par
cparc                                                               !par
cpar      integer(kind(mpi_integer)) :: ier                         !par
cparc                                                               !par
cpar      call mpi_finalize(ier)                                    !par
cparc                                                               !par
cpar      return                                                    !par
cparc                                                               !par
cpar      end subroutine comm_finalize                              !par
cpar!---------------------------------------------------------------!par
cparc                                                               !par
cpar      end module comm_interface                                 !par
cparc                                                               !par
cparc***************************************************************!par
C
C                             *******************
C
      MODULE PRECSN
C
C-----------------------------------------------------------------------
C
C MODULE SPECIFYING INTEGER/REAL WORD PRECISIONS 
C (IN GENERAL, DO NOT SET A "SHORTER" PRECISION .GT. A "LONGER" ONE.)
C
C
C  QP= SHORT INTEGER (NORMALLY 2; USE 4 IF UNSUPPORTED)
C  SP= DEFAULT INTEGER (NORMALLY 4)
C  EP= EXTENDED INTEGER (NORMALLY 8)     *** DO NOT SET EP.lt.SP !!! ***
C  RP= SHORT REAL (NORMALLY 4)
C  WP= DEFAULT REAL (NORMALLY 8)
C  XP= EXTENDED REAL (NORMALLY 8)                   !16 FOR TESTING ONLY
C  BP= DEFAULT LOGICAL (NORMALLY 1; USE 4 IF UNSUPPORTED)
C
C N.B.THESE NAMES ARE CONSTRAINED SOMEWHAT BY HISTORIC USAGE,
C    E.G. DP IS A WIDELY USED VARIABLE NAME, AS ARE ALL IP-NP.
C
C   THESE NAMES ARE NOT USED ANYWHERE ELSE - UNLESS SOMEONE INTRODUCES
C   CODE BLINDLY - THE PARAMETER STATEMENT WILL FLAG ANY CONFLICT.
C
C INTEGER NOTES:
C
C  EP=4 CAN BE USED SAFELY FOR MANY/MOST CASES.
C    =8 IS NEEDED  FOR LARGE CASES WHERE VARIABLE VALUE EXCEEDS 2**31 -1.
C  SP=8 IS NEEDED IN EXTREME CASES WHERE AN ARRAY INDEX EXCEEDS 2**31 -1.
C  QP=2 SUFFICES EVEN WHEN SP=8.
C
C REAL NOTES:
C
C  RP   IS ONLY USED FOR ARCHIVING COLLISION STRENGTHS.
C  WP=4 IS *NOT* RECOMMENDED: INACCURATE FOR SMALL CASES, FAILS LARGE.
C  XP=16 IS NOT CURRENTLY NEEDED BY THE PRODUCTION CODE, ALTHOUGH
C        SOME COULOMB FUNCTION ROUTINES MIGHT BENEFIT E.G. FN.FMON1.
C        N.B. IT CANNOT BE USED "WIDELY" (YET) SINCE THERE ARE NO
C        XP VERSIONS OF THE GENERIC RE_ALLOC AND RE_ALLOC2 INTRINSICS.
C
C LOGICAL NOTES
C
C  BP=1 IS ALL THAT THE CODE REQUIRES, SINCE WE ONLY USE .T. OR .F.
C       I.E. WE DON'T TRY TO PACK LOGICAL VARIABLES. BUT SYSTEM
C       DEFAULT TENDS TO BE BP=4. THERE ARE A FEW LOGICAL ARRAYS
C       IN USE AND SO BP=1 IS USEFUL (IF AVAILABLE).
C
C-----------------------------------------------------------------------
C
      IMPLICIT NONE
C
      INTEGER QP
      INTEGER SP
      INTEGER EP
C
      INTEGER RP
      INTEGER WP
      INTEGER XP
C
      INTEGER BP
C
      INTEGER SHORTI
      INTEGER DEFLTI
      INTEGER LONGI
C
      INTEGER SHORTR
      INTEGER DEFLTR
      INTEGER LONGR                                    !FOR TESTING ONLY
C
      PARAMETER (SHORTI=SELECTED_INT_KIND(4))          !INTEGER SHORT
      PARAMETER (DEFLTI=SELECTED_INT_KIND(9))          !INTEGER DEFAULT
      PARAMETER (LONGI=SELECTED_INT_KIND(12))          !INTEGER EXTENDED
C
      PARAMETER (SHORTR=SELECTED_REAL_KIND(5,30))      !REAL SHORT 
      PARAMETER (DEFLTR=SELECTED_REAL_KIND(10,100))    !REAL DEFAULT
      PARAMETER (LONGR=SELECTED_REAL_KIND(20,1000))    !REAL EXTENDED
C
      PARAMETER (QP=KIND(1_SHORTI))                    !INTEGER*2
      PARAMETER (SP=KIND(1_DEFLTI))                    !INTEGER*4
C      PARAMETER (SP=KIND(1_LONGI))  !***CASE ARRAY INDEX .GE. 2**31 ***
      PARAMETER (EP=KIND(1_LONGI))                     !INTEGER*8
C
      PARAMETER (RP=KIND(1.0_SHORTR))                  !REAL*4 
      PARAMETER (WP=KIND(1.0_DEFLTR))                  !REAL*8
      PARAMETER (XP=WP)                                !REAL*8
C      PARAMETER (XP=KIND(1.0_LONGR))                   !REAL*16
C
      PARAMETER (BP=KIND(.TRUE._1))                    !LOGICAL SHORT
C      PARAMETER (BP=KIND(.TRUE.))                      !LOGICAL DEFAULT
C
C-----------------------------------------------------------------------
C
C OR, IF YOU PREFER (GENERIC MACHINE SAFE SETTINGS SHOWN):
C
C-----------------------------------------------------------------------
C
c      PARAMETER (QP=4)                                !INTEGER SHORT
c      PARAMETER (SP=4)                                !INTEGER DEFAULT
c      PARAMETER (EP=8)                                !INTEGER EXTENDED
cC
c      PARAMETER (RP=4)                                !REAL SHORT 
c      PARAMETER (WP=8)                                !REAL DEFAULT
c      PARAMETER (XP=WP)                                !REAL DEFAULT
cC      PARAMETER (XP=16)                               !REAL EXTENDED
cC
c      PARAMETER (BP=4)                                !LOGICAL DEFAULT
cC
      END MODULE PRECSN
CC
CC***********************************************************************
CC***                                                                 ***
CC***   CODE USES MODULE PARAM:                                       ***
CC***                                                                 ***
CC***   SO COMMENT-OUT THE ONE YOU *DON'T* WANT TO USE, DEPENDING     ***
CC***   ON THE FORMAT/CONTENT OF ANY PARAM FILE YOU MAY WISH TO USE.  ***
CC***                                                                 ***
CC***   *** NORMAL OPERATION REQUIRES *NO* PARAM FILE!!! ***          ***
CC***                                                                 ***
CC***********************************************************************
CC
CC                             *******************
CC
C      MODULE PARAM            ! "HISTORIC"
CC
CC-----------------------------------------------------------------------
CC
CC MODULE SPECIFYING (ALL) PRIMARY DIMENSIONS VIA A PARAM/PARAM_f95 FILE
CC *** IF THE FILE WAS USED FOR < V27, NEED TO CHANGE MAXCA TO MXCAS ***
CC
CC-----------------------------------------------------------------------
CC
CC ENSURE INTEGER PRECISION (SP=4 OR 8)
CC
C      INCLUDE './PARAM_f95_ALL'          !THIS SHOULD *NOT* BE A SUBSET
CC
CC BACKWARD COMPATIBLE, SP=4 ONLY.
CC
CC      INCLUDE './PARAM'
CC
C      END MODULE PARAM
CC
CC                             *******************
C
      MODULE PARAM
C
C ENSURE INTEGER PRECISION (SP=4 OR 8)
C
      USE PRECSN, ONLY: BP,SP
C
      LOGICAL(BP) B_MOVE_ALLOC
      PARAMETER (B_MOVE_ALLOC=.false.)    !SET .FALSE. FOR OLD COMPILERS
C
C-----------------------------------------------------------------------
C
C MODULE SPECIFYING PRIMARY DIMENSIONS.
C
C (THE USER WOULD NOT NORMALLY CHANGE THEM, OR THEIR SET-UP BELOW.)
C
C-----------------------------------------------------------------------
C
      INTEGER(SP) MXDIM
      INTEGER(SP) MXAAI,MXAAK,MAXAD,MXADJ,MXAJS,MAXB1,MXBIF,MXBLM,MXCAS
     X           ,MAXCF,MAXCL,MAXDC,MAXDF,MXDFS,MAXDI,MAXDK,MXEL0,MXENG
     X           ,MXEST,MXFSL,MAXGR,MXGRB,MAXJG,MAXJU,MAXLL,MAXLV,MAXMI
     X           ,MXNOR,MXPOT,MAXRK,MXRKO,MAXRL,MXRLO,MXRSS,MAXSL,MXSOC
     X           ,MXSOI,MXST0,MAXTM,MAXTR,MAXUC,MXRKS,MXRLS,MXROS,MXS1C
     X           ,MXS1I,MXS2C,MXS2I,MAXB2,MAXCT,MXVAR,MXFSS,MXFOO
     X           ,MXCHG,MXSTX,MXSYJ
C
C PRIMARY DIMENSIONS FOR AUTOSTRUCTURE; SEE SR.ZERO FOR MORE DETAILED NOTES.
C
C DW: THE FOLLOWING DIMENSIONS ARE GOVERNED BY THE N+1 PROBLEM, REST TARGET ONLY.
C     MAXAD,MXADJ,MAXRK,MXRKO,MAXRL,MXRLO,MXRSS,MAXMI,MAXSL,MAXJG
C
      PARAMETER (MXDIM=        56_SP)   !No. of active dimension variables.
C
C FIRST INCLUDE ANY USER SET DIMENSIONS (*** ANY OCCURRENCE BELOW MUST BE COMMENTED-OUT ***)
C
c      INCLUDE './PARAM_f95'             ! "MINIMALIST"
C
C THESE DIMENSIONS ARE SET AUTOMATICALLY INTERNALLY, SO JUST INITIALIZE:
C
      PARAMETER (MXAAI=        -1_SP)   !No. of distinct bound-continuum LSp H-matrix elements.
      PARAMETER (MXAAK=        -1_SP)   !No. of distinct bound-continuum Jp H-matrix elements.
      PARAMETER (MAXAD=        -1_SP)   !Total no. of distinct H-matrix elements, SLp.
      PARAMETER (MXADJ=        -1_SP)   !Total no. of distinct H-matrix elements, Jp.
      PARAMETER (MXAJS=        -1_SP)   !Ditto, set =MXADJ for 2-body f-s else =1.
      PARAMETER (MXBIF=        -1_SP)   !No. of Born interactions per state (LS or IC)
      PARAMETER (MXBLM=        -1_SP)   !Max Born/E_k lambda multipole retained.
      PARAMETER (MXCAS=        -1_SP)   !No. of cascade coefficients (Jp).
      PARAMETER (MAXCL=        -1_SP)   !No. of closed-shell electrons.
      PARAMETER (MAXDI=        -1_SP)   !No. of terms within an SLp group.
      PARAMETER (MAXDK=        -1_SP)   !No. of levels within a Jp group.
      PARAMETER (MXEL0=        -1_SP)   !No. of valence electrons.
      PARAMETER (MXEST=        -1_SP)   !No. of valence electrons * Total no. of Slater states.
      PARAMETER (MXFSL=        -1_SP)   !No. of bound-continuum Slater integrals.
      PARAMETER (MXFSS=        -1_SP)   !No. of bound-cont 2-body f-s integrals.
      PARAMETER (MXFOO=        -1_SP)   !No. of bound-cont 2-body non-f-s ints. =1 or MXFSL.
      PARAMETER (MXGRB=        -1_SP)   !No. of non-core bound orbitals for Born (min-1).
      PARAMETER (MAXJU=        -1_SP)   !Total no. of CI mixing coefficients (Jp).
      PARAMETER (MXRKO=        -1_SP)   !No. of Orbit-Orbit integral coeffs.=1 or MAXRK.
      PARAMETER (MXRLO=        -1_SP)   !No. of Orbit-Orbit integrals: =1 or MAXRL.
      PARAMETER (MAXTR=        -1_SP)   !No. of term coupling coefficients (<=2*MXADJ-MAXLV).
      PARAMETER (MAXUC=        -1_SP)   !Total no. of CI mixing coefficients (SLp).
C
C THESE DIMENSIONS ARE RE-ALLOCATED INTERNALLY AS NECESSARY:
C
C (THE LARGER THE INITIAL VALUE, THE LESS RE-ALLOCATION -COPYING- REQUIRED, I.E. "FASTER",
C  BUT LARGER, AND MAYBE UNNECESSARY, TEMPORARY MEMORY ALLOCATION.)
C
      PARAMETER (MAXDC=  80000000_SP)   !Total no. of vector coupling coefficients.
      PARAMETER (MAXMI=    100000_SP)   !No. of Breit-Pauli integrals, N and V (2-body).
      PARAMETER (MAXRK=   2500000_SP)   !No. of Slater interaction alg. coeffs. and E1/E2 alg.
      PARAMETER (MAXRL=      9998_SP)   !No. of Slater integrals R.
      PARAMETER (MXRSS=  25000000_SP)   !No. of Breit-Pauli magnetic interaction alg. coeffs.
      PARAMETER (MXSOC=  20000000_SP)   !No. of spin-orbit interaction algebraic coeffs.
      PARAMETER (MXSOI=     15000_SP)   !No. of spin-orbit and M1+BP,M2 integrals (1-body)
      PARAMETER (MXST0=    400050_SP)   !Total no. of Slater states. *Only per config on input*.
      PARAMETER (MXSTX=    400000_SP)   !No. of one-body SS interactions (DW, also for s-o now).
C
C THESE DIMENSIONS MAY NEED TO BE INCREASED IN EXTREME CASES:
C
C (THEY ARE ALL "KNOWN" BUT NOT ALL VECTORS WHICH USE THEM HAVE BEEN ALLOCATED YET,
C  BUT THEIR MEMORY USAGE IS "SMALL" AND SO WE CAN SET THEM "LARGE" FOR NOW.)
C
      PARAMETER (MAXB1=    250000_SP)   !No. of radial mesh points.
      PARAMETER (MAXCF=     46340_SP)   !No. of configurations - .gt. sqrt(2^31) needs I*8.
      PARAMETER (MXENG=       150_SP)   !No. of continuum interpolation energies.
      PARAMETER (MAXGR=      5000_SP)   !No. of (distinct) bound orbitals.
      PARAMETER (MAXSL=       299_SP)   !No. of distinct term (SLp) groups.
      PARAMETER (MAXJG=        99_SP)   !No. of distinct level (Jp) groups.
      PARAMETER (MAXLV=    600000_SP)   !Total no. of levels. (No need to inflate, easy check)
      PARAMETER (MAXTM=    200000_SP)   !Total no. of terms. (No easy check, hence inflation)
C
      PARAMETER (MXCHG=   MAXSL/2_SP)   !No. of target SLp groups contrib to SLp sym (DW).
      PARAMETER (MXSYJ=   MAXJG/2_SP)   !No. of SLp symms which contrib to Jp sym (DW).
C
C CODE ESTIMATES THIS IF NEEDED: NLEVELS*NLEVELS/6 (SET .GT. 1 TO ALLOCATE A USER VALUE).
C (IT IS RE-ALLOCATED AS NECESSARY)
C
      PARAMETER (MXNOR=         1_SP)   !No. of non-vanishing E1 rates for cascade coeffs.
C
C DIMENSIONS PERTAINING TO SLATER STATE INTERACTIONS:
C (THEY ARE RE-ALLOCATED AS NECESSARY)
C
      PARAMETER (MXRKS=        MAXRK)   !As MAXRK, MAXRL but resolved by Slater state
      PARAMETER (MXRLS=        MAXRL)   !AND for a *single* symmetry ONLY.
      PARAMETER (MXROS=        -1_SP)   !As MXRKO but resolved by Slater state, =1 or MXRKS.
      PARAMETER (MXS1C=        MXSOC)   !As MXSOC, MXSOI but resolved by Slater state
      PARAMETER (MXS1I=        MXSOI)   !AND for a *single* LSJP symmetry ONLY.
      PARAMETER (MXS2C=        MXRSS)   !As MXRSS, MXAMI but resolved by Slater state
      PARAMETER (MXS2I=        MAXMI)   !AND for a *single* LSJP symmetry ONLY.
C
C THESE (NOW TRIVIAL) DIMENSIONS SHOULD NOT NORMALLY NEED TO BE RE-SET (INCREASED):
C (CURRENTLY, THEY ARE NOT ALLOCATABLE, UNLESS = -1)
C
      PARAMETER (MAXDF=       120_SP)   !Total no. of terms in a subconfiguration.
      PARAMETER (MXDFS=       500_SP)   !Size of factorial array MAX(n!)=MXDFS/2-1 ~2l.
      PARAMETER (MAXLL=         8_SP)   !Largest angular momentum of stored VCC.
      PARAMETER (MXPOT=         4_SP)   !No. of distinct l-dependent potentials stored.
C
C THESE DIMENSIONS ARE NO LONGER INDEPENDENT OF THE ABOVE AND SHOULD NOT BE CHANGED:
C
      PARAMETER (MAXB2=        MAXB1)
      PARAMETER (MAXCT=        MAXTM)
      PARAMETER (MXVAR=   MAXGR*3_SP)
C
      END MODULE PARAM
C
C                             *******************
C
      MODULE REALLOCATE
C
C-----------------------------------------------------------------------
C
C RE-ALLOCATES AN ARRAY *** PRESERVING THE ORIGINAL CONTENTS ***
C  (N.B. IT CAN REDUCE, AS WELL AS INCREASE, THE SIZE OF AN ARRAY.)
C
C GENERIC INTERFACES (RE_ALLOC,2) FOR RE_ALLOC,2_IM (=2,4,8) &_RN (=4,8)
C WHICH DECIDE HOW TO RE-ALLOCATE RANK ONE OR TWO ARRAYS: BY USING THE
C F2003 INTRINSIC SR.MOVE_ALLOC, OR NOT, AS SET BY B_MOVE_ALLOC=.TRUE.
C OR .FALSE. IN MODULE PARAM.
C
C  IT CONTAINS:
C    SR.RE_ALLOC_I2
C    SR.RE_ALLOC_I4
C    SR.RE_ALLOC_I8
C    SR.RE_ALLOC_R4
C    SR.RE_ALLOC_R8
C    SR.RE_ALLOC_BP
C
C    SR.RE_ALLOC2_I2
C    SR.RE_ALLOC2_I4
C    SR.RE_ALLOC2_I8
C    SR.RE_ALLOC2_R4
C    SR.RE_ALLOC2_R8
C    SR.RE_ALLOC2_BP
C
C-----------------------------------------------------------------------
C
      PRIVATE :: RE_ALLOC_I2, RE_ALLOC_I4, RE_ALLOC_I8,
     X           RE_ALLOC_R4, RE_ALLOC_R8,
     X           RE_ALLOC_BP
C
      INTERFACE RE_ALLOC
C
      MODULE PROCEDURE RE_ALLOC_I2, RE_ALLOC_I4, RE_ALLOC_I8,
     X                 RE_ALLOC_R4, RE_ALLOC_R8,
     X                 RE_ALLOC_BP
C
      END INTERFACE RE_ALLOC
C
      PRIVATE :: RE_ALLOC2_I2, RE_ALLOC2_I4, RE_ALLOC2_I8,
     X           RE_ALLOC2_R4, RE_ALLOC2_R8,
     X           RE_ALLOC2_BP
C
      INTERFACE RE_ALLOC2
C
      MODULE PROCEDURE RE_ALLOC2_I2, RE_ALLOC2_I4, RE_ALLOC2_I8,
     X                 RE_ALLOC2_R4, RE_ALLOC2_R8,
     X                 RE_ALLOC2_BP
C
      END INTERFACE RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      CONTAINS
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_I2(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES INTEGER( 2) ARRAYS - USE RE_ALLOC_RN FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      INTEGER( 2), ALLOCATABLE :: A(:)         !Intel/PGI must not split
      INTEGER( 2), ALLOCATABLE :: T(:)         !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_I2
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_I4(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES INTEGER( 4) ARRAYS - USE RE_ALLOC_R4 FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      INTEGER( 4), ALLOCATABLE :: A(:)         !Intel/PGI must not split
      INTEGER( 4), ALLOCATABLE :: T(:)         !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_I4
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_I8(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES INTEGER( 8) ARRAYS - USE RE_ALLOC_R8 FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      INTEGER( 8), ALLOCATABLE :: A(:)         !Intel/PGI must not split
      INTEGER( 8), ALLOCATABLE :: T(:)         !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_I8
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_R4(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES REAL( 4) ARRAYS - USE RE_ALLOC_I4 FOR INTEGERS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      REAL( 4), ALLOCATABLE :: A(:)            !Intel/PGI must not split
      REAL( 4), ALLOCATABLE :: T(:)            !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_R4
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_R8(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES REAL( 8) ARRAYS - USE RE_ALLOC_I8 FOR INTEGERS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      REAL( 8), ALLOCATABLE :: A(:)            !Intel/PGI must not split
      REAL( 8), ALLOCATABLE :: T(:)            !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_R8
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC_BP(A,I1,NA,NT,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ALLOCATABLE ARRAY A(I1:NA) IS RE-ALLOCATED AS A(I1:NT),
C  PRESERVING THE CONTENTS I1:NAT=MIN(NA,NT)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1) AND NA.LE.UBOUND(A,1), NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1 AND UBOUND(A,1).EQ.NT
C
C ***THIS VERSION HANDLES LOGICAL ARRAYS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,NA,NT
      INTEGER(SP) IERR,NAT
C
      LOGICAL(BP), ALLOCATABLE :: A(:)         !Intel/PGI must not split
      LOGICAL(BP), ALLOCATABLE :: T(:)         !But o.k. to do so here
C
      NAT=MIN(NA,NT)
C
      IF(B_MOVE_ALLOC.and.i1.eq.1)THEN         !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT)=A(I1:NAT)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT)=T(I1:NAT)
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC_BP
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC2_I2(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES INTEGER( 2) ARRAYS - USE RE_ALLOC_R8 FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      INTEGER( 2), ALLOCATABLE :: A(:,:)       !Intel/PGI must not split
      INTEGER( 2), ALLOCATABLE :: T(:,:)       !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_I2
C
      SUBROUTINE RE_ALLOC2_I4(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES INTEGER( 4) ARRAYS - USE RE_ALLOC_R4 FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      INTEGER( 4), ALLOCATABLE :: A(:,:)       !Intel/PGI must not split
      INTEGER( 4), ALLOCATABLE :: T(:,:)       !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_I4
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC2_I8(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES INTEGER( 8) ARRAYS - USE RE_ALLOC_R8 FOR REALS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      INTEGER( 8), ALLOCATABLE :: A(:,:)       !Intel/PGI must not split
      INTEGER( 8), ALLOCATABLE :: T(:,:)       !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_I8
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC2_R4(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES REAL( 4) ARRAYS - USE RE_ALLOC_I4 FOR INTEGERS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      REAL( 4), ALLOCATABLE :: A(:,:)          !Intel/PGI must not split
      REAL( 4), ALLOCATABLE :: T(:,:)          !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_R4
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC2_R8(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES REAL( 8) ARRAYS - USE RE_ALLOC_I8 FOR INTEGERS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      REAL( 8), ALLOCATABLE :: A(:,:)          !Intel/PGI must not split
      REAL( 8), ALLOCATABLE :: T(:,:)          !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_R8
C
C-----------------------------------------------------------------------
C
      SUBROUTINE RE_ALLOC2_BP(A,I1,NA1,I2,NA2,NT1,NT2,IERR)
C
C-----------------------------------------------------------------------
C
C  THE ARRAY A(I1:NA1,I2:NA2) IS RE-ALLOCATED AS A(I1:NT1,I2:NT2).
C  PRESERVING THE CONTENTS I1:NAT1=MIN(NA1,NT1), I2:NAT2=MIN(NA2,NT2)
C
C  INPUT ONLY REQUIRES I1.GE.LBOUND(A,1),  I2.GE.LBOUND(A,2)  AND
C                     NA1.LE.UBOUND(A,1), NA2.LE.UBOUND(A,2)  NOT .EQ.
C  AND SO NT=NA IS STILL RE-ALLOCATED.
C
C  OUTPUT HAS LBOUND(A,1).EQ.I1, LBOUND(A,2).EQ.I2  AND
C             UBOUND(A,1).EQ.NT1,UBOUND(A,2).EQ.NT2
C
C ***THIS VERSION HANDLES LOGICAL ARRAYS
C
C  IT CALLS:
C    SR.MOVE_ALLOC (F2003 INTRINSIC, IF B_MOVE_ALLOC.EQ..TRUE.)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM, ONLY: B_MOVE_ALLOC
C
      IMPLICIT NONE
C
      INTEGER(SP) I1,I2,NA1,NA2,NT1,NT2
      INTEGER(SP) IERR,NAT1,NAT2
C
      LOGICAL(BP), ALLOCATABLE :: A(:,:)       !Intel/PGI must not split
      LOGICAL(BP), ALLOCATABLE :: T(:,:)       !But o.k. to do so here
C
      NAT1=MIN(NA1,NT1)
      NAT2=MIN(NA2,NT2)
C
      IF(B_MOVE_ALLOC.and.i1*i2.eq.1)THEN      !.eq.1 for Oracle Studio
        ALLOCATE (T(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        CALL MOVE_ALLOC(T,A)
      ELSE
        ALLOCATE (T(I1:NAT1,I2:NAT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        T(I1:NAT1,I2:NAT2)=A(I1:NAT1,I2:NAT2)
        DEALLOCATE (A)
        ALLOCATE (A(I1:NT1,I2:NT2),STAT=IERR)
        IF(IERR.NE.0)RETURN
        A(I1:NAT1,I2:NAT2)=T
        DEALLOCATE (T)
      ENDIF
C
      RETURN
C
      END SUBROUTINE RE_ALLOC2_BP
C
C-----------------------------------------------------------------------
C
      END MODULE REALLOCATE
c
c                             *******************
c
      subroutine move_alloc(a,b)
c temporary dummy for old compilers
      integer a,b
      dimension a(*),b(*)
      write(6,*)
     x     'MOVE_ALLOC Dummy - set B_MOVE_ALLOC=.FALSE. in module param'
      stop 'MOVE_ALLOC Dummy - set B_MOVE_ALLOC=.FALSE. in module param'
      end subroutine move_alloc
C
C                             *******************
C
      MODULE CONSTANTS_INTEGER
C
C-----------------------------------------------------------------------
C
C SET INTEGER CONSTANTS
C   CURRENTLY, ONLY USED IN SUBPROGRAM ARGUMENTS AND REAL EXPRESIONS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: SP
C
      IMPLICIT INTEGER(SP) (I)
C
      PARAMETER (IZERO=   0)
      PARAMETER (IONE=    1)
      PARAMETER (ITWO=    2)
      PARAMETER (ITHREE=  3)
      PARAMETER (IFOUR=   4)
      PARAMETER (IFIVE=   5)
      PARAMETER (ISIX=    6)
      PARAMETER (ISEVEN=  7)
      PARAMETER (IEIGHT=  8)
      PARAMETER (ININE=   9)
      PARAMETER (ITEN=   10)
      PARAMETER (IELEVN= 11)
      PARAMETER (ITWELV= 12)
      PARAMETER (I3TEEN= 13)
      PARAMETER (I4TEEN= 14)
      PARAMETER (I5TEEN= 15)
      PARAMETER (I6TEEN= 16)
      PARAMETER (I7TEEN= 17)
      PARAMETER (I8TEEN= 18)
      PARAMETER (I9TEEN= 19)
      PARAMETER (I20=    20)
      PARAMETER (I30=    30)
      PARAMETER (I40=    40)
      PARAMETER (I50=    50)
      PARAMETER (I60=    60)
      PARAMETER (I70=    70)
      PARAMETER (I80=    80)
      PARAMETER (I90=    90)
      PARAMETER (I100=  100)
      PARAMETER (I999=  999)
      PARAMETER (I1000=1000)
      PARAMETER (I10000=10000)
      PARAMETER (I100000=100000)
      PARAMETER (I1000000=1000000)
C
      END MODULE CONSTANTS_INTEGER
C
C                             *******************
C
      MODULE CONSTANTS_REAL
C
C-----------------------------------------------------------------------
C
C SET REAL CONSTANTS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: WP
C
      IMPLICIT REAL(WP) (D)
C
      PARAMETER (DZERO=   0.0D0)
      PARAMETER (DONE=    1.0D0)
      PARAMETER (DTWO=    2.0D0)
      PARAMETER (DTHREE=  3.0D0)
      PARAMETER (DFOUR=   4.0D0)
      PARAMETER (DFIVE=   5.0D0)
      PARAMETER (DSIX=    6.0D0)
      PARAMETER (DSEVEN=  7.0D0)
      PARAMETER (DEIGHT=  8.0D0)
      PARAMETER (DNINE=   9.0D0)
      PARAMETER (DTEN=   10.0D0)
      PARAMETER (DELEVN= 11.0D0)
      PARAMETER (DTWELV= 12.0D0)
      PARAMETER (D3TEEN= 13.0D0)
      PARAMETER (D4TEEN= 14.0D0)
      PARAMETER (D5TEEN= 15.0D0)
      PARAMETER (D6TEEN= 16.0D0)
      PARAMETER (D7TEEN= 17.0D0)
      PARAMETER (D8TEEN= 18.0D0)
      PARAMETER (D9TEEN= 19.0D0)
      PARAMETER (D20=    20.0D0)
      PARAMETER (D30=    30.0D0)
      PARAMETER (D40=    40.0D0)
      PARAMETER (D50=    50.0D0)
      PARAMETER (D60=    60.0D0)
      PARAMETER (D70=    70.0D0)
      PARAMETER (D80=    80.0D0)
      PARAMETER (D90=    90.0D0)
      PARAMETER (D100=  100.0D0)
      PARAMETER (D200=  200.0D0)
      PARAMETER (D300=  300.0D0)
C
      PARAMETER (DHALF=  DONE/DTWO)
      PARAMETER (D3HALF= DTHREE/DTWO)
      PARAMETER (DQUART= DONE/DFOUR)
      PARAMETER (D3QRT=  DTHREE/DFOUR)
      PARAMETER (D8TH=   DONE/DEIGHT)
C
      PARAMETER (D1THRD= DONE/DTHREE)
      PARAMETER (D2THRD= DTWO/DTHREE)
      PARAMETER (D4THRD= DFOUR/DTHREE)
      PARAMETER (D5THRD= DFIVE/DTHREE)
C
      PARAMETER (DFIFTH= DONE/DFIVE)
      PARAMETER (DSIXTH= DONE/DSIX)
      PARAMETER (DTWELF= DONE/DTWELV)
C
      PARAMETER (D1M1= 1.0D-1)
      PARAMETER (D1M2= 1.0D-2)
      PARAMETER (D1M3= 1.0D-3)
      PARAMETER (D1M4= 1.0D-4)
      PARAMETER (D1M5= 1.0D-5)
      PARAMETER (D1M6= 1.0D-6)
      PARAMETER (D1M7= 1.0D-7)
      PARAMETER (D1M8= 1.0D-8)
      PARAMETER (D1M9= 1.0D-9)
      PARAMETER (D1M10=1.0D-10)
      PARAMETER (D1M12=1.0D-12)
      PARAMETER (D1M15=1.0D-15)
      PARAMETER (D1M18=1.0D-18)
      PARAMETER (D1M20=1.0D-20)
      PARAMETER (D1M30=1.0D-30)
      PARAMETER (D1M40=1.0D-40)
      PARAMETER (D1M50=1.0D-50)
      PARAMETER (D1M60=1.0D-60)
      PARAMETER (D1M70=1.0D-70)
      PARAMETER (D1M75=1.0D-75)
      PARAMETER (D1M99=1.0D-99)
C
      PARAMETER (D1P1= 1.0D+1)
      PARAMETER (D1P2= 1.0D+2)
      PARAMETER (D1P3= 1.0D+3)
      PARAMETER (D1P4= 1.0D+4)
      PARAMETER (D1P5= 1.0D+5)
      PARAMETER (D1P6= 1.0D+6)
      PARAMETER (D1P7= 1.0D+7)
      PARAMETER (D1P8= 1.0D+8)
      PARAMETER (D1P9= 1.0D+9)
      PARAMETER (D1P10=1.0D+10)
      PARAMETER (D1P12=1.0D+12)
      PARAMETER (D1P15=1.0D+15)
      PARAMETER (D1P18=1.0D+18)
      PARAMETER (D1P20=1.0D+20)
      PARAMETER (D1P30=1.0D+30)
      PARAMETER (D1P40=1.0D+40)
      PARAMETER (D1P50=1.0D+50)
      PARAMETER (D1P60=1.0D+60)
      PARAMETER (D1P70=1.0D+70)
      PARAMETER (D1P75=1.0D+75)
      PARAMETER (D1P99=1.0D+99)
C
      END MODULE CONSTANTS_REAL
C
C                             *******************
C
      MODULE CONSTANTS_MATHS
C
C-----------------------------------------------------------------------
C
C SET MATHEMATICAL CONSTANTS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: WP
c      USE CONSTANTS_REAL
C
      IMPLICIT REAL(WP) (A-H,O-Z)
C
      PARAMETER (EULER=0.57721566490153D0)
      PARAMETER (XPI=3.141592653589793D0)
C      PI=ACOS(-DONE)                            !USED INSTEAD GENERALLY
C
      END MODULE CONSTANTS_MATHS
C
C                             *******************
C
      MODULE CONSTANTS_PHYSICS
C
C-----------------------------------------------------------------------
C
C SET PHYSICAL CONSTANTS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: WP
      USE CONSTANTS_REAL
C
      IMPLICIT REAL(WP) (A-H,O-Z)
C
      PARAMETER (CLIGHT=137.03599976D0)
C      PARAMETER (DFSC=DONE/CLIGHT)
      PARAMETER (DFSC=7.2973525333D-03)     !HISTORIC
      PARAMETER (DALF=DFSC*DFSC)            !not ideal...
      PARAMETER (DALF4=DALF/DFOUR)
      PARAMETER (DKCM=109737.31D0)
      PARAMETER (HBAR=4.8377687D-17)
C
      END MODULE CONSTANTS_PHYSICS
C
C                             *******************
C
      MODULE CONSTANTS
C
C-----------------------------------------------------------------------
C
C SET CONSTANTS
C
C-----------------------------------------------------------------------
C
      USE CONSTANTS_INTEGER
      USE CONSTANTS_REAL
      USE CONSTANTS_MATHS
      USE CONSTANTS_PHYSICS
C
      END MODULE CONSTANTS
C
C                             *******************
C
      MODULE COMMON_CACC
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /CACC/ACC(MAXGR,MAXGR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BACC
C
      REAL(WP) ACC
C
      ALLOCATABLE :: ACC(:,:)
C
      END MODULE COMMON_CACC
C
C                             *******************
C
      MODULE COMMON_CCLSH
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /CCLSH/NW,NNL(MAXCL,3)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) NW,NNL,IAXCL
C
      ALLOCATABLE :: NNL(:,:)
C
      END MODULE COMMON_CCLSH
C
C                             *******************
C
      MODULE COMMON_COEFF
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /COEFF/DRKP(MXSOC),NRKP(MXSOC),QRLP(4,MXSOI),IRLP
C    X             ,NADP(0:MXADJ)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BCOEFF
C
      INTEGER(QP) QRLP
      INTEGER(SP) IRLP,NADP,IWORD1,IXSOC,IXSOI     !LEAVE THIS AS SP(=4)
C
      REAL(WP) DRKP
C
      INTEGER(SP) NRKP,N81,IPLANT_SOI     !USE EP (=8) HERE IF REQUESTED
      PARAMETER (IWORD1=SP)              !MATCH NRKP INTEGER DECLARATION
C
      DATA IXSOC/0/,IXSOI/0/
C
      ALLOCATABLE :: DRKP(:),QRLP(:,:),NRKP(:),NADP(:)
C
      END MODULE COMMON_COEFF
C
C                             *******************
C
      MODULE COMMON_COEFFS
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /COEFFS/DRKPS(MXS1C),QRLPS(4,MXS1I),NRKPS(MXS1C)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(QP) QRLPS
      INTEGER(SP) NRKPS,IXS1C,IXS1I
C
      REAL(WP) DRKPS
C
      DATA IXS1C/0/,IXS1I/0/
C
      ALLOCATABLE :: DRKPS(:),NRKPS(:),QRLPS(:,:)
C
      END MODULE COMMON_COEFFS
C
C                             *******************
C
      MODULE COMMON_DBD2
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /DBD2/QCG(MXEL0,MAXCF),QL(MAXGR),QN(MAXGR)
C PLUS QCGS(MXEL0) FROM /NRBVCX/
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(QP) QCG,QL,QN,QCGS
      INTEGER(SP) IXEL0
C
      ALLOCATABLE :: QCG(:,:),QL(:),QN(:),QCGS(:)
C
      END MODULE COMMON_DBD2
C
C                             *******************
C
      MODULE COMMON_DC
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR,
C     DIMENSION DC(0:MAXDC),IDC(MAXDC)
C                        WHICH WAS PASSED THROUGH ARGUMENTS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BFAST
C
      INTEGER(SP) LREC,IREC,IAXDC,IXIDC
C
      INTEGER(SP), ALLOCATABLE :: IDC(:)
      DATA IREC/SP/                     !SET TO BYTE LENGTH OF IDC ARRAY
C
      REAL(WP), ALLOCATABLE :: DC(:)                 !*4 NOT RECOMMENDED
      DATA LREC/WP/                     !SET TO BYTE LENGTH OF  DC ARRAY
C
      DATA IAXDC/1/,IXIDC/1/
C
      END MODULE COMMON_DC
C
C                             *******************
C
      MODULE COMMON_DMQSS3
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /DMQSS3/DSS(MXRSS),MSS(MXRSS),QSS(5,MAXMI)
C    X              ,NADR(0:MXAJS)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BDMQSS3
C
      INTEGER(QP) QSS
      INTEGER(SP) NADR,IWORD2,IXRSS,IAXMI         !LEAVE THIS AS SP (=4)
C
      REAL(WP) DSS
C
      INTEGER(SP) MSS,N82,IPLANT_MI       !USE EP (=8) HERE IF REQUESTED
      PARAMETER (IWORD2=SP)               !MATCH MSS INTEGER DECLARATION
C
      DATA IXRSS/0/,IAXMI/0/
C
      ALLOCATABLE :: DSS(:),MSS(:),QSS(:,:),NADR(:)
C
      END MODULE COMMON_DMQSS3
C
C                             *******************
C
      MODULE COMMON_DMQSSS
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /DMQSSS/DSSS(MXS2C),MSSS(MXS2C),QSSS(5,MXS2I)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      REAL(WP) DSSS
C
      INTEGER(QP) QSSS
      INTEGER(SP) MSSS,IXS2C,IXS2I
C
      DATA IXS2C/0/,IXS2I/0/
C
      ALLOCATABLE :: DSSS(:),MSSS(:),QSSS(:,:)
C
      END MODULE COMMON_DMQSSS
C
C                             *******************
C
      MODULE COMMON_DXRL
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /DXRL/DRK(MAXRK),QRL(5,MAXRL),NRK(MAXRK),IRL
C    X            ,NAD(0:MAXAD)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BDXRL
C
      REAL(WP) DRK
C
      INTEGER(EP) N8               !KEEP AS EP (=8) AS TEST FOR OVERFLOW
C
      INTEGER(QP) QRL
      INTEGER(SP) IRL,NAD,IWORD,IAXRK,IAXRL,IRLAST!LEAVE THIS AS SP (=4)
C
      INTEGER(EP) NRK,IPLANT_RL           !USE EP (=8) HERE IF REQUESTED
      PARAMETER (IWORD=EP)                !MATCH NRK INTEGER DECLARATION
C
      DATA IAXRK/0/,IAXRL/0/
C
      ALLOCATABLE :: DRK(:),QRL(:,:),NRK(:),NAD(:),IRLAST(:)
C
      END MODULE COMMON_DXRL
C
C                             *******************
C
      MODULE COMMON_DXRLS
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /DXRLS/DRKS(MXRKS),DEKS(MXROS),QRLS(5,MXRLS)
C    X             ,NRKS(MXRKS),BFALLS(MXROS),IRKS,IRLS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BFALLS
C
      REAL(WP) DRKS,DEKS
C
      INTEGER(QP) QRLS
      INTEGER(SP) NRKS,IRLS,IRKS,IXRKS,IXRLS                  !,IXROS
C
      DATA IXRKS/0/,IXRLS/0/                                  !,IXROS/0/
C
      ALLOCATABLE :: DRKS(:),DEKS(:),QRLS(:,:),NRKS(:),BFALLS(:)
C
      END MODULE COMMON_DXRLS
C
C                             *******************
C
      MODULE COMMON_INTS
C
C-----------------------------------------------------------------------
C
C MODULE (PARTIAL) REPLACEMENT FOR
C      PARAMETER (MXD09=MXBLM+2)                           !+2 CASE BREL
C            COMMON /TRANS/DRL(MAXRL),DOSC(0:MXD09,MAXGR,MAXGR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      REAL(WP) DRL,DOSC
C
      ALLOCATABLE :: DRL(:),DOSC(:,:,:)
C
      END MODULE COMMON_INTS
C
C                             *******************
C
      MODULE COMMON_MQVC
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /MQVC/MODD,KCUT,QCL0,QCS0,NEL(MAXGR,MAXCF)
C PLUS KMAX FROM /TERMS/ AND /NRBAL1/ TO REMOVE CONFLICT.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(QP) QCL0,QCS0
      INTEGER(SP) MODD,KCUT,KMAX,NEL,IAXGR,IAXCF
C
      ALLOCATABLE :: NEL(:,:)
C
      END MODULE COMMON_MQVC
C
C                             *******************
C
      MODULE COMMON_NSTS
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     PARAMETER (MXD27=MAXCF*MAXCF)
C     COMMON /NSTS/NADS(-1:MXD27),NSTJ(MXRKS),NSTJD(MXRKS)
C    X            ,IORIG(MXRLS),JORIG(MXRLS),JPLANT(MXRLS)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
C
      ALLOCATABLE :: NADS(:),NSTJ(:),NSTJD(:),IORIG(:),JORIG(:)
     X              ,JPLANT(:)
C
      END MODULE COMMON_NSTS
C
C                             *******************
C
      MODULE COMMON_NSTS1
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     PARAMETER (MXD27=MAXCF*MAXCF)
C     COMMON /NSTS1/NADS1(0:MXD27),NSTJ1(MXS1C),NSTJ1D(MXS1C)
C    X             ,IORIG1(MXS1I),JORIG1(MXS1I)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
C
      ALLOCATABLE :: NADS1(:),NSTJ1(:),NSTJ1D(:),IORIG1(:),JORIG1(:)
C
      END MODULE COMMON_NSTS1
C
C                             *******************
C
      MODULE COMMON_NSTS2
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD27=MAXCF*MAXCF)
C      COMMON /NSTS2/NADS2(0:MXD27),NSTJ2(MXS2C),NSTJ2D(MXS2C)
C     X             ,IORIG2(MXS2I),JORIG2(MXS2I)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
C
      ALLOCATABLE :: NADS2(:),NSTJ2(:),NSTJ2D(:),IORIG2(:),JORIG2(:)
C
      END MODULE COMMON_NSTS2
C
C                             *******************
C
      MODULE COMMON_RADF
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /RADF/DPNL(MAXB1,MAXGR),DUY(MAXGR,MAXGR),DX(MAXB1)
C     X            ,DORIG(MAXGR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BRADF
      INTEGER(SP) MXPIN
      REAL(WP) DPNL,DUY,DX,DORIG
C
      ALLOCATABLE :: DPNL(:,:),DUY(:,:),DX(:),DORIG(:)
C
      END MODULE COMMON_RADF
C
C                             *******************
C
      MODULE COMMON_REL
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNF1
      REAL(WP) DMASS,DCD,D2LL
C
      ALLOCATABLE :: DMASS(:,:),DCD(:,:),D2LL(:,:)
C
      END MODULE COMMON_REL
C
C                             *******************
C
      MODULE COMMON_RELINT
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /EX/DRLP1(MXSOI),DNL(MAXMI)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BRELINT1,BRELINT2
      REAL(WP) DRLP1,DNL
C
      ALLOCATABLE :: DRLP1(:),DNL(:)
C
      END MODULE COMMON_RELINT
C
C                             *******************
C
      MODULE COMMON_TRANS
C
C-----------------------------------------------------------------------
C
C MODULE (PARTIAL - SEE ALSO MODULE COMMONT_INTS) REPLACEMENT FOR
C            COMMON /TRANS/DRL(:),DOSC(:,:,:),TFU(MAXUC)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) IAXUC
      REAL(WP) TFU
C
      ALLOCATABLE :: TFU(:)
C
      END MODULE COMMON_TRANS
C
C                             *******************
C
      MODULE COMMON_NRBBBB
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBBBB/BXIST0(MAXCF,MAXCF),BXIST1(MAXCF)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBBBB,BXIST0,BXIST1
C
      ALLOCATABLE :: BXIST0(:,:),BXIST1(:)
C
      END MODULE COMMON_NRBBBB
C
C                             *******************
C
      MODULE COMMON_NRBCAS
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBCAS/AP(MXNOR),MADD(MXNOR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BCASC
      INTEGER(SP) MADD,IXNOR
      REAL(WP) AP
C
      ALLOCATABLE :: AP(:),MADD(:)
C
      END MODULE COMMON_NRBCAS
C
C                             *******************
C
      MODULE COMMON_NRBDQE
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBDQE/DQNL(MAXB2,MAXGR)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBDQE
      INTEGER(SP) MXQIN
      REAL(WP) DQNL
C
      ALLOCATABLE :: DQNL(:,:)
C
      END MODULE COMMON_NRBDQE
C
C                             *******************
C
      MODULE COMMON_NRBEKP
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBEKP/NED(2,MAXSL,MAXTM)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBEKP
      INTEGER(SP) NED
C
      ALLOCATABLE :: NED(:,:,:)
C
      END MODULE COMMON_NRBEKP
C
C                             *******************
C
      MODULE COMMON_NRBFL0
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD02=14)               !MAX TARGET L (NOT X2)
C      PARAMETER (MXD03=MXD02+1)
C      PARAMETER (MXD19=(MAXCF*(MAXCF+1))/2)
C      COMMON /NRBFL0/KINTI(MXSTX),KINTF(MXSTX),KEN2(MXSTX)
C     X              ,KPTCFM(-MXD02:MXD03,-MXD02:MXD03,0:MXD19)
C     X              ,MPOINT(-MXD02:MXD03,MAXCF),KINT
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBFL0
      INTEGER(SP) KINTI,KINTF,KEN2,KPTCFM,MPOINT,KINT,IXSTX
C
      ALLOCATABLE :: KINTI(:),KINTF(:),KEN2(:),KPTCFM(:,:,:)
     X              ,MPOINT(:,:)
C
      DATA IXSTX/0/
C
      END MODULE COMMON_NRBFL0
C
C                             *******************
C
      MODULE COMMON_NRBFSI
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /NRBFSI/DNLI(MXENG,MXFSS),NLI(MAXMI)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBFSI
      REAL(WP) DNLI
      INTEGER(SP) NLI,IXFSS
C
      ALLOCATABLE :: DNLI(:,:),NLI(:)
C
      END MODULE COMMON_NRBFSI
C
C                             *******************
C
      MODULE COMMON_NRBGCF
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /NRBGCF/KGSL(MAXCF,MAXSL),KGCF(0:MAXCF),NKSL(MAXSL,MAXCF)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBGCF
      INTEGER(SP) KGSL,KGCF,NKSL
C
      ALLOCATABLE :: KGSL(:,:),KGCF(:),NKSL(:,:)
C
      END MODULE COMMON_NRBGCF
C
C                             *******************
C
      MODULE COMMON_NRBIAD
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBIAD/IADD,IADJ,IADJT
C NOTE: IADJT IS DEFINED IN SR.SYMLSJ BUT IS NOT CURRENTLY IN USE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP) IADD,IADJ,IADJT
      INTEGER(EP) IADJ8,NP8
C
      END MODULE COMMON_NRBIAD
C
C                             *******************
C
      MODULE COMMON_NRBINT
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBINT/DRLI(MXENG,MXFSL),DYY(MXENG),IYY(MAXGR)
C     X              ,NRLI(MAXRL),MENG,NREL,BLAG,BBC2,NLAG,NLAGP
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BLAG,BBC2
      INTEGER(SP) IYY,NRLI,MENG,NREL,NLAG,NLAGP,IXFSL
      REAL(WP) DRLI,DYY
C
      ALLOCATABLE :: DRLI(:,:),DYY(:),IYY(:),NRLI(:)
C
      END MODULE COMMON_NRBINT
C
C                             *******************
C
      MODULE COMMON_NRBLSP
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /NRBLSP/LSPIP(MAXSL,MAXCF),NLSPIP(MAXCF),NASTP
C    X              ,MINSTP,MAXSTP,MINLTP,MAXLTP
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBLSP
      INTEGER(SP) LSPIP,NLSPIP,NASTP,MINSTP,MAXSTP,MINLTP,MAXLTP
C
      ALLOCATABLE :: LSPIP(:,:),NLSPIP(:)
C
      END MODULE COMMON_NRBLSP
C
C                             *******************
C
      MODULE COMMON_NRBMKP
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBMKP/NMD1(2,MAXJG,MAXLV),NMD2(2,MAXJG,MAXLV)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBMKP
      INTEGER(SP) NMD1,NMD2
C
      ALLOCATABLE :: NMD1(:,:,:),NMD2(:,:,:)
C
      END MODULE COMMON_NRBMKP
C
C                             *******************
C
      MODULE COMMON_NRBNF1
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C     COMMON /NRBNF1/DEK(MXRKO),BFALL(MXRKO)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBNF1,BFALL
      REAL(WP) DEK
C
      ALLOCATABLE :: DEK(:),BFALL(:)
C
      END MODULE COMMON_NRBNF1
C
C                             *******************
C
      MODULE COMMON_NRBNF2
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBNF2/DETA(MXRLO),DXSI(MAXGR,MAXGR),DZL(MXRLO)
C     X       ,DXTWO(MXRLO)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBNF2
      REAL(WP) DETA,DXSI,DZL,DXTWO
C
      ALLOCATABLE :: DETA(:),DXSI(:,:),DZL(:),DXTWO(:)
C
      END MODULE COMMON_NRBNF2
C
C                             *******************
C
      MODULE COMMON_NRBNFI
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBNFI/DZLI(MXENG,MXFOO),DXTWOI(MXENG,MXFOO)
C     X              ,DETAI(MXENG,MXFOO),FRI(MAXB1),GRI(MAXB1)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBNFI
      REAL(WP) DZLI,DXTWOI,DETAI,FRI,GRI
C
      ALLOCATABLE :: DZLI(:,:),DXTWOI(:,:),DETAI(:,:),FRI(:),GRI(:)
C
      END MODULE COMMON_NRBNFI
C
C                             *******************
C
      MODULE COMMON_NRBOLP
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD25=(MAXGR*(MAXGR-1))/2)
C      PARAMETER (MXD26=(MAXCF*(MAXCF-1))/2)
C      COMMON /NRBOLP/OVLPGR(MXD25),OVLPCF(MXD26),IPAIR(MXD26)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBOLP
      INTEGER(SP) IPAIR
      REAL(WP) OVLPGR,OVLPCF
C
      ALLOCATABLE :: OVLPGR(:),OVLPCF(:),IPAIR(:)
C
      END MODULE COMMON_NRBOLP
C
C                             *******************
C
      MODULE COMMON_NRBORN
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD33=(MXGRB*(MXGRB+1))/2)
C      PARAMETER (MXD34=((MXD33+1)*MXD33)/2)
C      PARAMETER (MXD37=MXBLM/2)
C      PARAMETER (MXD39=MXGRB/MAXGR) !=0 (FINITE E) OR 1 (INF. E ONLY)
C                                    !BORN MOM. TRANSFER (K) INFO
C      PARAMETER (NPDEC=4)           !NO. OF K-STEPS PER DECADE
C      PARAMETER (IVV0=3)            !STARTING AT 10**-IVV0
C      PARAMETER (NDEC=IVV0+2)       !NO. OF DECADES (ALLOW K-SHELL)
C      PARAMETER (MXNXV=NDEC*NPDEC+3)     !NO. OF K_MAX (INC ZERO & INF)
C      PARAMETER (MXD21=IVV0*NPDEC-NPDEC/4+3)   !NO. OF K_MIN: UP TO 1.0
C      PARAMETER (MXD38=(1-MXD39)*((MXNXV*(MXNXV-1))/2
C     X                -((MXNXV-MXD21)*(MXNXV-1-MXD21))/2)+MXD39)
C      COMMON /NRBORN/BL(MXD38,MXD34,0:MXD37),OBO(MXD38),TM2(MXD34)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBORN
      INTEGER(SP) IXBLM
      REAL(WP) BL,OBO,TM2
C
      ALLOCATABLE :: BL(:,:,:),OBO(:),TM2(:)
C
      END MODULE COMMON_NRBORN
C
C                             *******************
C
      MODULE COMMON_NRBRN1
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD28=(MAXGR*(MAXGR+1))/2)
C      PARAMETER (MXD33=(MXGRB*(MXGRB+1))/2)
C      PARAMETER (MXD34=((MXD33+1)*MXD33)/2)
C      COMMON /NRBRN1/SBL(MXD33),DBL(MXD33,MXBIF)
C     X              ,MB3(0:MXD33),MB4(0:MXD33),INDX(MXD28)
C     X              ,INDK(MXD34),INDL(MXD34)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBRN1
      REAL(WP) SBL,DBL
      INTEGER(SP) MB3,MB4,INDX,INDL,INDK,IXD33
C
      ALLOCATABLE :: SBL(:),DBL(:,:),MB3(:),MB4(:)
     X              ,INDX(:),INDK(:),INDL(:)
C
      END MODULE COMMON_NRBRN1
C
C                             *******************
C
      MODULE COMMON_NRBRN2
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      PARAMETER (MXD28=(MAXGR*(MAXGR+1))/2)
C      PARAMETER (MXD37=MXBLM/2)
C      COMMON /NRBRN2/BINDB(MXD28,0:MXD37),MENGB
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBRN2,BINDB
      INTEGER(SP) MENGB
C
      ALLOCATABLE :: BINDB(:,:)
C
      END MODULE COMMON_NRBRN2
C
C                             *******************
C
      MODULE COMMON_NRBRN3
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR
C      COMMON /NRBRN3/V0(MXNXV),V1(MXNXV),XB(MXNXB),XS(0:MXNXB1)
C     X              ,DB0(MXNXV),DB1(MXNXV),OMEGAB(0:MXNXB1)
C     X              ,MV0,MV1,XMANT(0:MXNXB1),IEXP(0:MXNXB1),MINFB
C
C ITS PURPOSE IS TO ENSURE A SINGLE SOURCE DEFINITION OF PWB SET-UP
C ACROSS SR.CARATE, SR.DIAGFS AND SR.DIAGON (AND SR.RKINT)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      INTEGER(SP), PRIVATE :: I
C
      REAL(WP) V0,V1,XB,XS,DB0,DB1,OMEGAB
C
      INTEGER(SP) MV0,MV1,MINFB,MXNXV,MXD21,MXNXB,MXNXB1
      INTEGER(SP) NLAGB,NPDEC,IVV0,NDEC
C
      CHARACTER(LEN=3) IEXP
      CHARACTER(LEN=5) XMANT
C                               !BORN MOM. TRANSFER (K) INFO
      PARAMETER (NLAGB=4)       !PT LAG, EVEN, CORRELATE WITH NPDEC
      PARAMETER (NPDEC=4)       !NO. OF K-STEPS PER DECADE
      PARAMETER (IVV0=3)        !STARTING AT 10**-IVV0
      PARAMETER (NDEC=IVV0+2)   !NO. OF DECADES (ALLOW K-SHELL)
C
      PARAMETER (MXNXV=NDEC*NPDEC+3)  !NO. OF K_MAX (INC ZERO & INF)
      PARAMETER (MXD21=IVV0*NPDEC-NPDEC/4+3)!NO. OF K_MIN: UP TO 1.0
C
      PARAMETER (MXNXB=10)      !NO. OF PWB X-VALUES (THRESH. UNITS)
      PARAMETER (MXNXB1=MXNXB+1)
C
      DIMENSION V0(MXNXV),V1(MXNXV),XB(MXNXB),XS(0:MXNXB1)
     X         ,DB0(MXNXV),DB1(MXNXV),OMEGAB(0:MXNXB1)
     X         ,XMANT(0:MXNXB1),IEXP(0:MXNXB1)
C
C      DATA XB(1:MXNXB)/1.001D0,1.1D0,1.2D0,1.3D0,1.55D0,2.D0
C     X  ,3.D0,5.5D0,1.D1,2.D1,3.D1,5.5D1,1.D2,2.D2,3.D2,5.5D2,1.D3/
C                                                          !17-vals
      DATA XB(1:MXNXB)/1.1D0,1.2D0,1.55D0,2.D0,3.D0,5.5D0,1.D1
     X                      ,2.D1,5.5D1,1.D2/
C                                                          !10-vals
      END MODULE COMMON_NRBRN3
C
C                             *******************
C
      MODULE COMMON_NRBTS1
C
C-----------------------------------------------------------------------
C
C MODULE REPLACEMENT FOR (PLUS DFOTm - could merge M_K with E_K IN DFOT)
C      PARAMETER (MXD24=MXBLM*MAXGR)
C      PARAMETER (MXD37=MXBLM/2)
C      COMMON /NRBTS1/DFOT(MXENG),DFOSS(MXD24,MXENG,2),PMIN
C     X              ,NFOSS(0:MXD37,MAXGR,MAXGR),IPIG,IGAG(0:MXENG)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C
      IMPLICIT NONE
C
      LOGICAL(BP) BNRBTS1
      REAL(WP) DFOT,DFOTm,DFOSS,PMIN
      INTEGER(SP) NFOSS,IPIG,IGAG,IXD24
C
      ALLOCATABLE :: DFOT(:),DFOTm(:),DFOSS(:,:,:),NFOSS(:,:,:),IGAG(:)
C
      END MODULE COMMON_NRBTS1
C
C***********************************************************************
C
C-----------------------------------------------------------------------
C
Cadas701      SUBROUTINE ASDECK27
C
C-----------------------------------------------------------------------
C
      PROGRAM MAIN
C
C-----------------------------------------------------------------------
C
C  PR.MAIN CONTROLS THE CALCULATION.
C  IT SETS-UP THE NECESSARY FILES AND THEN
C
C  IT CALLS:
C    SR.DEIE
CC    SR.DEII
C    SR.TARGET
C    SR.ZERO
C
C-----------------------------------------------------------------------
C
cparc                                                               !par
cpar      use comm_interface, only : iam,nproc,comm_init,           !par
cpar     x                           comm_barrier,comm_finalize     !par
C
      USE COMMON_CCLSH,  ONLY: NNL
      USE COMMON_COEFF,  ONLY: BCOEFF,DRKP,QRLP,NRKP,NADP
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR
      USE COMMON_MQVC,   ONLY: NEL
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,NAD
      USE COMMON_NRBEKP, ONLY: BNRBEKP,NED
      USE COMMON_NRBGCF, ONLY: BNRBGCF,KGSL,KGCF,NKSL
      USE COMMON_NRBMKP, ONLY: BNRBMKP,NMD1,NMD2
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
      USE COMMON_NRBORN, ONLY: BNRBORN,BL,OBO,TM2
      USE COMMON_NRBRN1, ONLY: BNRBRN1,SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD14=100)
C
      CHARACTER(LEN=6) NAM
      CHARACTER(LEN=3) NAM0
      CHARACTER(LEN=5) KNAM
cparc                                                               !par
cpar      character(len=1) :: num(0:9)                              !par
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRBDIM/MXUSED(MXDIM),KNAM(MXDIM)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
cparc                                                               !par
cpar      data num/'0','1','2','3','4','5','6','7','8','9'/         !par
cparc                                                               !par
cparc---------------------------------------------------------------!par
cparc                                                               !par
cparc initialize for parallel                                       !par
cparc                                                               !par
cparc---------------------------------------------------------------!par
cparc                                                               !par
cpar      call comm_init()                                          !par
cpar      write(0,*)'Starting proc', iam                            !par
C
C-----------------------------------------------------------------------
C
C START TIME COUNTER
C
C-----------------------------------------------------------------------
C
      TIME=DZERO
      CALL CPU_TIME(TTIME)
C
C-------------------------------------------------------------------
C
C INITIALIZE ALLOCATE FLAGS
C
C-------------------------------------------------------------------
C
      BCOEFF=.FALSE.
      BDMQSS3=.FALSE.
      BDXRL=.FALSE.
      BNRBEKP=.FALSE.
      BNRBGCF=.FALSE.
      BNRBMKP=.FALSE.
      BNRBNF1=.FALSE.
      BNRBORN=.FALSE.
      BNRBRN1=.FALSE.
      BNRBRN2=.FALSE.
C
C-----------------------------------------------------------------------
C
C SUMMARY OF FILE/UNIT USAGE
C
C-----------------------------------------------------------------------
C
C NUNIT IS THE MAX UNIT NUMBER IN CURRENT USE
C
C IUNIT KEEPS TRACK OF WHETHER A UNIT IS OPEN OR CLOSED, AS NEEDED, OR
C NOT. NOTE, CORRESPONDING (OUTPUT) FILE MAY EXIST FROM A PREVIOUS RUN,
C SO ITS EXISTENCE IS OF NO USE IN THIS CASE.
C
      NUNIT=33
      IF(NUNIT.GT.MXD14)THEN
        WRITE(0,*)'*** ERROR: UNIT NUMBER TOO LARGE, INCREASE MXD14 TO:'
     X            ,NUNIT
        NUNIT=0
        NF=-1
        GO TO 1999
      ENDIF
      DO I=1,NUNIT                                !INITIALIZE ALL CLOSED
        IUNIT(I)=0
      ENDDO
C
C
C FILES OPENED IN RELEVANT SUBPROGRAM, ONLY IF NEEDED, ARE COMMENTED OUT
C HERE FOR INFO ONLY.
C
C     OPEN(1,FILE='TCC.DAT',STATUS='REPLACE')    ! OPTIONAL TCC'S JAJOM
C     OPEN(2,FILE='CASC',STATUS='REPLACE')    ! OPTIONAL CASCADE COEFFS
C     OPEN(3,FILE='CONFIG.DAT',STATUS='UNKNOWN')     ! OPTIONAL CONFIGS
C     OPEN(4,FILE='TCCDW.DAT',STATUS='REPLACE') ! OPTIONAL TCC'S STGICF
C
C UNIT 5 IS THE READ INPUT DATAFILE, ALL MACHINES
C
cparc                                                               !par
cpar      iunit(5)=-1                                               !par
C
C UNCOMMENT cpar ABOVE IF *NOT* RE-DIRECTING FROM COMMAND LINE (serial)
C
      IF(IUNIT(5).LT.0)THEN
        INQUIRE(FILE='das',EXIST=BEX)
        IF(BEX)THEN
          IUNIT(5)=1
          OPEN(5,FILE='das',STATUS='OLD')            !STANDARD INPUT
        ELSE
          WRITE(0,*)'UNIT5 USER INPUT FILE "das" MISSING, '
     X             ,'BUT IS REQUIRED!'
          NF=-1
          GO TO 1999
        ENDIF
      ENDIF
C
C INQUIRE CHECKS FOR OPTIONAL INPUT FILES, REST MAYBE OUTPUT TO
C
      IUNIT(6)=1
      NAM0=''
cparc                                                               !par
cpar      i1=iam/100                                                !par
cpar      i2=(iam-100*i1)/10                                        !par
cpar      i3=iam-100*i1-10*i2                                       !par
cpar      nam0=num(i1)//num(i2)//num(i3)                            !par
cparc                                                               !par
      NAM='olg'//NAM0
      OPEN(6,FILE=NAM,STATUS='REPLACE')                 !STANDARD OUTPUT
C
C     OPEN(7,FILE='oca',STATUS='REPLACE')    !CA AA, AR RATES & ENERGIES
C     OPEN(7,FILE='ols',STATUS='REPLACE')    !LS AA, AR RATES & ENERGIES
C     OPEN(8,FILE='oic',STATUS='REPLACE')    !IC "   "             "
C
      INQUIRE(FILE='hffcin',EXIST=BEX)
      IF(BEX)THEN
        IUNIT(9)=1
        OPEN(9,FILE='hffcin',STATUS='OLD')    !OPT POT (E.G. HF-FC, FAC)
      ENDIF
      INQUIRE(FILE='potin',EXIST=BEX)
      IF(BEX)THEN
        IF(IUNIT(9).EQ.0)THEN
          IUNIT(9)=1
          OPEN(9,FILE='potin',STATUS='OLD')  !OPT POTS (E.G. HF-FC, FAC)
        ELSE
          WRITE(6,*)'FILES "hffcin" AND "potin" BOTH PRESENT, IGNORING',
     X              ' THE LATTER...'
          WRITE(0,*)'FILES "hffcin" AND "potin" BOTH PRESENT, IGNORING',
     X              ' THE LATTER...'
        ENDIF
      ENDIF
C
C     OPEN(10,FILE='RESTART',FORM='UNFORMATTED',STATUS='UNKNOWN') !ALGEB
C
      IUNIT(11)=1
      OPEN(11,STATUS='SCRATCH',FORM='UNFORMATTED')      !NEED I SAY MORE
C
      INQUIRE(FILE='radwin',EXIST=BEX)
      IF(BEX)THEN
        IUNIT(12)=1
        OPEN(12,FILE='radwin',STATUS='OLD')      !INPUT BOUND ORBS (OPT)
      ENDIF
C
C     OPEN(13,FILE='radout',STATUS='REPLACE')   !OUTPUT BOUND ORBS (OPT)
C
C     OPEN(14,FILE='CAVES',STATUS='REPLACE')                   !CFG LIST
C     OPEN(14,FILE='TERMS',STATUS='REPLACE')                  !TERM LIST
C     OPEN(15,FILE='LEVELS',STATUS='REPLACE')                !LEVEL LIST
C
C     OPEN(16,FILE='OVRLAP',STATUS='REPLACE')      !ORBITAL OVERLAP LIST
C
C     OPEN(17,FILE='opca',STATUS='REPLACE')     !CA PHOTOIONIZATION DATA
C     OPEN(17,FILE='opls',STATUS='REPLACE')     !LS PHOTOIONIZATION DATA
C     OPEN(18,FILE='opic',STATUS='REPLACE')     !IC       "         "
C
      INQUIRE(FILE='SHFTLS',EXIST=BEX)          !can use for ca shift...
      IF(BEX)THEN
        IUNIT(19)=1
        OPEN(19,FILE='SHFTLS',STATUS='OLD')     !TERM ENERGY CORRECTIONS
      ENDIF
C
      INQUIRE(FILE='SHFTIC',EXIST=BEX)
      IF(BEX)THEN
        IUNIT(20)=1
        OPEN(20,FILE='SHFTIC',STATUS='OLD')    !LEVEL ENERGY CORRECTIONS
      ENDIF
C
C     OPEN(21,FILE='adasex.in.form',STATUS='REPLACE')   !adasex TEMPLATE
C     OPEN(22,FILE='adasexj.in.form',STATUS='REPLACE') !adasexj TEMPLATE
C
C     OPEN(23,FILE='OMGINFCA',STATUS='REPLACE')!INFINITE ENERGY OMEGA-CA
C     OPEN(23,FILE='OMGINFLS',STATUS='REPLACE')!INFINITE ENERGY OMEGA-LS
C     OPEN(24,FILE='OMGINFIC',STATUS='REPLACE')!INFINITE ENERGY OMEGA-IC
C
C     OPEN(25,FILE='adf04ca',STATUS='REPLACE')   !FINITE ENERGY OMEGA-CA
C     OPEN(25,FILE='adf04ls',STATUS='REPLACE')   !FINITE ENERGY OMEGA-LS
C     OPEN(26,FILE='adf04ic',STATUS='REPLACE')   !FINITE ENERGY OMEGA-IC
C
C     OPEN(27,FILE='ocau',FORM='UNFORMATTED',STATUS='REPLACE')   !AS oca
C     OPEN(27,FILE='olsu',FORM='UNFORMATTED',STATUS='REPLACE')   !AS ols
C     OPEN(28,FILE='oicu',FORM='UNFORMATTED',STATUS='REPLACE')   !AS oic
C
C     OPEN(29,FILE='opcau',FORM='UNFORMATTED',STATUS='REPLACE') !AS opca
C     OPEN(29,FILE='oplsu',FORM='UNFORMATTED',STATUS='REPLACE') !AS opls
C     OPEN(30,FILE='opicu',FORM='UNFORMATTED',STATUS='REPLACE') !AS opic
C
C     OPEN(31,FILE='ITANAL',STATUS='OLD')     !TERM ENERGY CONTRIBUTIONS
C
C     OPEN(32,FILE='DISKDC',FORM='UNFORMATTED',STATUS='REPLACE') !FOR DC
C     OPEN(33,FILE='DSKDMP',FORM='UNFORMATTED',STATUS='REPLACE') !FOR DC
C
C-----------------------------------------------------------------------
C
C SR.ZERO PRINTS DIMENSIONS FOR THIS RUN
C
C-----------------------------------------------------------------------
C
      CALL ZERO
C
C-----------------------------------------------------------------------
C
C SR.TARGET DESCRIBES BOTH BOUND-BOUND AND BOUND-CONTINUUM PROBLEMS,
C TREATING THE LATTER AS AN (N+1)-ELECTRON STRUCTURE PROBLEM.
C
C-----------------------------------------------------------------------
C
      CALL TARGET(TIME,TTIME)
C
      if(nf.ne.nf0)write(0,*)'nf,nf0=',nf,nf0
      IF(NF.Le.0.OR.NF0.LT.0)GO TO 1999
C
C-----------------------------------------------------------------------
C
C SR.DEIE DESCRIBES DIRECT ELECTRON-IMPACT EXCITATION
C
C-----------------------------------------------------------------------
C
      IF(ABS(IDW).EQ.1)CALL DEIE(TIME,TTIME)
C
C-----------------------------------------------------------------------
C
C SR.DEII DESCRIBES DIRECT ELECTRON-IMPACT IONIZATION (PLACEHOLDER)
C
C-----------------------------------------------------------------------
C
C      IF(ABS(IDW).EQ.2)CALL DEII(TIME,TTIME)
C
C-----------------------------------------------------------------------
C
C SR.ZERO PRINTS STORAGE USED FOR THIS RUN
C
C-----------------------------------------------------------------------
C
 1999 CALL ZERO
C
C-----------------------------------------------------------------------
C
c 1999 CONTINUE
C
C-----------------------------------------------------------------------
C
C CLOSE-OFF ANY UNITS STILL OPEN
C
C-----------------------------------------------------------------------
C
      DO I=1,NUNIT
        IF(IUNIT(I).GT.0)CLOSE(I)
      ENDDO
C
C-------------------------------------------------------------------
C
C TIDY-UP: DE-ALLOCATE ANYTHING LEFT ALLOCATED
C (E.G. JOB HAS ALREADY FAILED IN ALGEB AND SO BYPASSES DE-ALLOCATE
C       IN MINIM)
C
C-------------------------------------------------------------------
C
      IF(ALLOCATED(NEL))DEALLOCATE (NEL,STAT=IERR)
      IF(ALLOCATED(NNL))DEALLOCATE (NNL,STAT=IERR)
      IF(ALLOCATED(QCG))DEALLOCATE (QCG,QL,QN,STAT=IERR)
      IF(BDXRL)DEALLOCATE (DRK,QRL,NRK,NAD,STAT=IERR)
      IF(BNRBEKP)DEALLOCATE (NED,STAT=IERR)
      IF(BNRBGCF)DEALLOCATE (KGCF,NKSL,STAT=IERR)
      IF(ALLOCATED(KGSL))DEALLOCATE (KGSL,STAT=IERR)
      IF(BNRBMKP)DEALLOCATE (NMD1,NMD2,STAT=IERR)
      IF(BNRBNF1)DEALLOCATE (DEK,BFALL,STAT=IERR)
      IF(BNRBORN)DEALLOCATE (BL,OBO,TM2,STAT=IERR)
      IF(BNRBRN1)DEALLOCATE (SBL,MB3,MB4,INDX,INDL,INDK
     X                            ,STAT=IERR)                      !,DBL
      IF(BNRBRN2)DEALLOCATE (BINDB,STAT=IERR)
      IF(BCOEFF)DEALLOCATE (DRKP,QRLP,NRKP,NADP,STAT=IERR)
      IF(BDMQSS3)DEALLOCATE (DSS,MSS,QSS,NADR,STAT=IERR)
C
cparc                                                               !par
cparc---------------------------------------------------------------!par
cparc                                                               !par
cparc finish-up parallel                                            !par
cparc                                                               !par
cparc---------------------------------------------------------------!par
cparc                                                               !par
cpar      write(0,*)'Ending proc', iam                              !par
cpar      call comm_barrier()                                       !par
cpar      call comm_finalize()                                      !par
C
      IF(NF.Lt.0)THEN                                      !.OR.NF0.Lt.0
cpar        if(iam.eq.0)then                                        !par
        iu=nunit+1
        open(iu,file='errlog')
        rewind(iu)
        write(iu,*)'ERROR: SOMETHING BAD HAPPENED...'
c        if(nf.eq.0)write(iu,*)'DE/ALLOCATION FAILURE'
        if(nf.lt.0)write(iu,*)' !!! ABNORMAL END - SEE OLG FILE ): !!!'
        close(iu)
cpar        endif                                                   !par
        STOP ' !!! ABNORMAL END - SEE OLG FILE ): !!!'
      ELSE
c        STOP !' (: *** NORMAL END *** ' !COMMENT-OUT FOR SILENT SUCCESS
      ENDIF
C
C-----------------------------------------------------------------------
C
Cadas701      RETURN
C
C-----------------------------------------------------------------------
C
      END PROGRAM MAIN
CADASC
CADASC                             *******************
CADASC
CADAS      function adasip(elemu,iz1)
CADASC
CADAS      USE PRECSN, ONLY: BP,QP,SP,EP,WP
CADASC
CADASC------------------------------------------------------------------
CADASC Get ionisation potential for arbitrary ionisation stage
CADASC
CADASC The user must have a valid ADASCENT environment variable set.
CADASC
CADASC Compile and link :
CADASC       f77 adasip.for -L/home/adas/lib -ladaslib
CADASC------------------------------------------------------------------
CADASC
CADAS      implicit none
CADASc
CADASC------------------------------------------------------------------
CADAS      INTEGER(SP) iz1,i,L1,L2
CADASC------------------------------------------------------------------
CADAS      REAL(WP) adasip,fip
CADASC------------------------------------------------------------------
CADAS      LOGICAL(BP) badas
CADASC------------------------------------------------------------------
CADAS      character(len=2) elem,esym,elemu
CADAS      character(len=30) adascent
CADAS      character(len=120) dsfull
CADASC------------------------------------------------------------------
CADAS      common /hps/badas
CADASC------------------------------------------------------------------
CADASc
CADAS      badas=.true.
CADASc
CADASctest
CADASc      elemu='FE'
CADASc      iz1=13
CADASc
CADAS      call xxcase(elemu,elem,'LC')               !  for lowercase
CADASc
CADAS      call getenv("ADASCENT",adascent)
CADASc
CADASc---------------------hps 19 Aug 2011 -----------------------------
CADASc       adascent='/home/hps/adas_dev/adas'
CADASc------------------------------------------------------------------
CADASc
CADAS      do i=len(adascent),1,-1
CADAS        if(adascent(i:i).NE.' ')go to 20
CADAS      enddo
CADAS  20  L1=i
CADAS      do i=len(elem),1,-1
CADAS        if(elem(i:i).NE.' ')go to 30
CADAS      enddo
CADAS  30  L2=i
CADASc
CADAS      dsfull=adascent(1:L1)//'/adf00/'//elem(1:L2)//'.dat'
CADASc
CADAS      open(unit=99,file=dsfull)
CADASc
CADAS      read(99,'(A)')esym      ! skip line 1
CADAS      do i=1,iz1            ! skip lines up to stage of interest
CADAS        read(99,'(A)')esym
CADAS      enddo
CADAS      read(99,*)i,fip
CADASc
CADAS      adasip=fip*8066.0693
CADASc
CADASctest      print *,'Ionisation potential: ',adasip
CADASc
CADAS      close(99)
CADASc
CADAS      end function adasip
C                                                                  !ADAS
C                             *******************                  !ADAS
c                                                                  !ADAS
      function adasip(elemu,iz1)                                   !ADAS
c                                                                  !ADAS
c dummy routine for normal (non-ADAS) useage.                      !ADAS
c                                                                  !ADAS
      USE PRECSN, ONLY: BP,QP,SP,EP,WP                             !ADAS
      USE PARAM                                                    !ADAS
      USE CONSTANTS                                                !ADAS
C                                                                  !ADAS
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)                            !ADAS
      IMPLICIT LOGICAL(BP) (B)                                     !ADAS
      IMPLICIT INTEGER(SP) (I-N)                                   !ADAS
      IMPLICIT INTEGER(QP) (Q)                                     !ADAS
C                                                                  !ADAS
C      INCLUDE './INCLUDE'                                         !ADAS
C                                                                  !ADAS
      character(len=2) elemu,cdum                                  !ADAS
c                                                                  !ADAS
      common /hps/badas                                            !ADAS
c                                                                  !ADAS
      badas=.false.                         !.true. for test       !ADAS
c                                                                  !ADAS
c suppress compiler warnings (sigh...)                             !ADAS
c                                                                  !ADAS
      cdum=elemu                                                   !ADAS
      idum=iz1                                                     !ADAS
c                                                                  !ADAS
      adasip=dzero                                                 !ADAS
c                                                                  !ADAS
      return                                                       !ADAS
      end function adasip                                          !ADAS
C
C                             *******************
C
      SUBROUTINE ALGEB(IRET)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB CONTROLS THE ALGEBRAIC BRANCH, INCLUDING RESTART FACILITY.
C
C  NOTE: ANGULAR QUANTUM NUMBERS WILL BE INTERNALLY STORED AS TWICE
C  THEIR VALUE; THIS ALLOWS FOR INTEGER NOTATION AND MEETS THE
C  REQUIREMENTS OF THE COPENHAGEN PACKAGE OF ANGULAR SUBROUTINES.
C
C  IT CALLS:
C    SR.ALGEB0
C    SR.ALGEB1
C    SR.ALGEB2
C    SR.ALGEB3
C    SR.ALGEB4
C    SR.CALGEB
C    SR.DISKDC
C    SR.REDSS
C    SR.VCU
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL,IAXCL
      USE COMMON_COEFF,  ONLY: BCOEFF,DRKP,QRLP,IRLP,NRKP,NADP,IXSOC
     X                        ,IXSOI,IPLANT_SOI
      USE COMMON_DBD2,   ONLY: QCG,QL,QN,QCGS,IXEL0
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC,LREC,IREC
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR,IXRSS,IAXMI
     X                        ,IPLANT_MI
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBEKP, ONLY: BNRBEKP,NED
      USE COMMON_NRBGCF, ONLY: BNRBGCF,KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADD,IADJ,IADJ8,NP8
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
      USE COMMON_NRBMKP, ONLY: BNRBMKP,NMD1,NMD2
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXDC0=1000000)
      PARAMETER (MAXMI0=  1000)
      PARAMETER (MXRSS0= 25000)
      PARAMETER (MXSOC0= 10000)
      PARAMETER (MXSOI0=   500)
C
C      PARAMETER (MXD01=14)                 !FOR /NRBDW/IDW,IGAP(MXD01)
      PARAMETER (MXD07=100)       !S.S. NO. OF UNIT5 CONFIG INPUT LINES
      PARAMETER (MXD08=MXD07*21)  !S.S. MXD07*NO. OF CHARS/LINE *FIXED*
      PARAMETER (MXD12=100)                !NO. OF NON-SEQ RYD N-VALUES
      PARAMETER (MXD14=100)                !NO. OF FILE UNITS
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
      PARAMETER (IRL5=6)                        !5+1 NOW ALG3/4 SEPARATE
C
      CHARACTER(LEN=2) NAME0
      CHARACTER(LEN=4) CODE,MLIT
      CHARACTER(LEN=9) NAME
cparc                                                               !par
cpar      character(len=1) :: num(0:9)                              !par
C
      INTEGER(EP) MDCF8,MDCFT8
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      ALLOCATABLE :: MAM(:),NAM(:),QLMC(:),QLMS(:),QBML(:),QBMS(:)
C
      ALLOCATABLE :: JYI(:),JYF(:)
C
      DIMENSION DE(1),DS(1),NDI(1)           !DUMMY FOR VCU DIMENS CHECK
C
      COMMON /BASIC/NF,MGAP1(5),MSST,NLEV,MGAP2(4)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NXRLP/IRKP,IRKP0
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL,NL000
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /SSWRK/IWRK1(MXD08),IWRK2(MXD08)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL0/IRET0,LORIG,LMIN,MPRNT0,MOD0,MSTRT0,BPASS,MLIT(2)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDUM/MXDC0,MXGR0         !NOT USED ANYWHERE, BUT RESTART
      COMMON /NRBDW/IDW
     X             ,NASTB,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,NASTJB,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFAN/BFANO
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBNV/MAXNV
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPNT/NTGP(MAXCT),NTGS(MAXCT),NTP1,NTP2
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVCX/NFS,KF,NB,JAS,JBS,KSI,KSF,NTGA,NTGB   !,QCGS(MXEL0)
c
cpar      common /nrbpar/niam,liam,jiam,lproc,nprocperl,mapiam      !par
      common /nrbtim/iw,iwp,btime,btimex
cparc                                                               !par
cpar      data num/'0','1','2','3','4','5','6','7','8','9'/         !par
C
C
      bpar=.false.
cpar      bpar=.true.                                               !par
cparc                                                               !par
c
      if(btime)call cpu_time(time0)
C
C      QBMS(1)=2                         !NO LONGER USED (AS I*2)
C      QBML(1)=0                         !NO LONGER USED (AS I*2)
C
      MSTART=0                                       !to silence ftnchek
      MXMTGD=3*2**26                    !MAX REC LEN FOR DC ARRAY (<2GB)
      MXMTGD=MXMTGD*(8/LREC)            !NECESS FOR PGI, BUT ORACLE FINE
C***
      QQCUTX=1                          !TBD (OR COULD USE TARGET QQCUT)
C***
C
C SET NEW L FOR L-LOOP, OR RETURN AND EXIT
C
      IF(BLOOP)THEN
        LSUM=LSUM+1
        IF(LNEW.LT.LMAX)REWIND(5)               !REWIND USER INPUT FILE
        IF(LNEW.EQ.LMAX)LSUM=0
        IF(LNEW.EQ.LMAX)THEN
           IF(IUNIT(MR).GT.0)THEN                         !CLOSE RESTART
             IUNIT(MR)=-1
             CLOSE(MR)                                       !idw=0 here
           ENDIF
           IF(BNAME)THEN
            IRET=1
            RETURN
          ENDIF
        ENDIF
      ENDIF
C
      BMNAM=.FALSE.
      BQXXX=.FALSE.
      BQLMS=.FALSE.
      BALLDC=.FALSE.
C
      NF0=0
C
C READ USER INPUT, AND SET-UP ACCORDINGLY.
C   IRET=1 SIGNALS A TERMINATOR AND SO FLAGS EXIT WITHOUT CALL TO MINIM
C
C***********************************************************************
C
      CALL ALGEB0(DC0,MAXEL)                                        !-0-
C
C***********************************************************************
c
      if(.not.btime.and.btimex)then
cparc       if(iam.eq.0)then                                        !par
          write(iw,*)'Starting target'
cparc       endif                                                   !par
      endif
C
      IF(NF.LE.0)GO TO 80
C
      IRET=IRET0
      IF(IRET.EQ.1)GO TO 998                    !RETURN
C
      IXEL0=MAXEL               !MAXEL=NF+1 CASE DW, FOR HISTORIC COMMON
      ALLOCATE (QCG(IXEL0,KMAX),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB0: ALLOCATION FAILS FOR QCG'
        GO TO 999
      ENDIF
C
      CALL DIMUSE('MXEL0',MAXEL)
C
C SCRATCH
C
      MRP=MR+1
      REWIND(MRP)
C
C-----------------------------------------------------------------------
C
C CONFIGURATION-AVERAGE ALGEBRA BRANCH, BYPASS REST OF ALGEB ON RETURN
C
C-----------------------------------------------------------------------
C
      IF(NSL0.LT.0)THEN                         !CONFIGURATION AVERAGE
C
        IF(IUNIT(MR).EQ.0.AND.IDW.NE.0)THEN !CADW PASS FILE,NO RESTART
          OPEN(MR,FORM='UNFORMATTED',STATUS='SCRATCH')
          IUNIT(MR)=1
          REWIND(MR)
          WRITE(MR)MXORB,MA,MB
c         write(0,*)mxorb,ma,mb
        ENDIF
C
        CALL CALGEB(MAXEL)
C
        IF(NF.LE.0)GO TO 80
        GO TO 998                               !RETURN
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C T-TERM SELECTION
C
      IF(ITANAL.NE.0)THEN                         !WANTED,
        IF(IUNIT(31).EQ.0)THEN                    !BUT NOT YET OPENED
          INQUIRE(FILE='ITANAL',EXIST=BEX)
          IF(BEX)THEN
            OPEN(31,FILE='ITANAL',STATUS='OLD')
            IUNIT(31)=1
          ELSE
            WRITE(0,*)'USER INPUT ITANAL REQUIRES FILE "ITANAL", '
     X               ,'BUT NOT FOUND!'
            WRITE(6,*)'USER INPUT REQUIRES FILE "ITANAL", '
     X               ,'BUT NOT FOUND: ITANAL=',ITANAL
            GO TO 995
          ENDIF
        ELSEIF(IUNIT(31).GT.0)THEN                !FOR L-LOOP
          REWIND(31)
        ENDIF
      ENDIF
C
C INITIALIZE FOR RESTART
C
      MST5=MOD(MSTRT0,IRL5)
      BSTART=(MST5.EQ.0.OR.MPRINT.LT.-3).AND.IDW.EQ.0
      IF(MST5.NE.0)BPASS=.FALSE.         !ENABLE PARTIAL RESTART-1,2,3,4
C                                        !.T. REDUCES I/O BUT NEGLIGIBLE
      IF(MST5.NE.5)ALLOCATE (JYI(KMAX),JYF(KMAX))   !IF 5 THE ALGEB DONE
C
C INITIAL DISKDC STORAGE
C
      BDISK=MOD(KUTDSK,I10000).LT.KMAX.AND.MST5.NE.5   !IF 5, ALGEB DONE
      IF(BDISK)THEN
        IUD=32                                  !DISKDC
        MDCF8=0
        MDCFT8=0
      ENDIF
      MDCBUF=0                                  !BEST NOT UNDEFINED
C
      IF(BSTART)GO TO 71                        !<----- NO RESTART -----
C
      IF(IUNIT(MR).EQ.0)THEN                    !RESTART FILE
        if(idw.eq.0)then
          NAME0=''
cparc                                                               !par
cpar          j1=liam/10                                            !par
cpar          j2=liam-(10*(liam/10))                                !par
cpar          name0=num(j1)//num(j2)                                !par
cparc                                                               !par
          NAME='RESTART'//NAME0
          INQUIRE(FILE=NAME,EXIST=BEX)
C
          IF(ABS(MST5).EQ.1)THEN
            OPEN(MR,FILE=NAME,FORM='UNFORMATTED',STATUS='REPLACE')
            IF(.NOT.BEX)LORIG=LMIN
          ELSE
            IF(BEX)THEN
              OPEN(MR,FILE=NAME,FORM='UNFORMATTED',STATUS='OLD')
            ELSE
              WRITE(0,*)'USER INPUT MSTART REQUIRES FILE "RESTART", '
     X                 ,'BUT NOT FOUND!'
              WRITE(6,*)'USER INPUT REQUIRES FILE "RESTART", '
     X                 ,'BUT NOT FOUND: MSTART=',MSTRT0
              GO TO 995
            ENDIF
          ENDIF
        else
          OPEN(MR,FORM='UNFORMATTED',STATUS='SCRATCH')
          BEX=.TRUE.
        endif
        IUNIT(MR)=1
        IF(BEX)REWIND(MR)
      ENDIF
C
      IF(IDW.EQ.0.and.mstrt0.ne.5.and..not.bpar)THEN
       WRITE(0,*)'** NOTE: MSTART=5 RESTARTS A COMPLETED ALGEBRA RUN **'
       WRITE(6,*)'** NOTE: MSTART=5 RESTARTS A COMPLETED ALGEBRA RUN **'
      ENDIF
C
      GO TO 60
C
C WRITE RESTART INFO AFTER EVERY CALL TO ALGEBN, N=1,2,3,4
C
  76  WRITE(6,800)MLIT,MSTRT0
      call flush(mr)
C
      IF(ABS(MSTRT0).GE.IRL5)THEN      !EXIT AFTER ONE STAGE
        IF(LMAX.GT.LMIN)THEN
          WRITE(0,*)'*** WARNING: CAN/HAVE ONLY RUN ONE L-PER-PROC FOR'
     X             ,' MSTART=',MSTRT0
          WRITE(6,*)'*** WARNING: CAN/HAVE ONLY RUN ONE L-PER-PROC FOR'
     X             ,' MSTART=',MSTRT0
cparc                                                               !par
cpar      write(0,*)'*** Aborting parallel run for (your) safety!'  !par
cpar      go to 995                                                 !par
cparc
        ENDIF
        GO TO 999
      ENDIF
C
      MSTRT0=MSTRT0+MSTRT0/MSTART
      IF(MSTRT0.LT.0)THEN               !REWIND AND RE-READ AT EACH STEP
        IF(BLOOP)THEN                !NEED TO BACKSPACE APPROPRIATE NREC
          WRITE(6,*)'*** ERROR: CANOT USE MSTART.LT.0 WITH L-LOOP'
          WRITE(0,*)'*** ERROR: CANOT USE MSTART.LT.0 WITH L-LOOP'
          GO TO 995
        ENDIF
        REWIND(MR)
        GO TO 60
      ENDIF
C
      IF(MSTART.EQ.1)GO TO 75           !<--------------- RESTART SWITCH
      IF(MSTART.EQ.2)GO TO 77           !<--------------- RESTART SWITCH
      IF(MSTART.EQ.3)GO TO 72           !<--------------- RESTART SWITCH
      IF(MSTART.GT.3)GO TO 79           !<--------------- RESTART SWITCH
C
  60  CONTINUE
C
C LORIG IS FIRST L FOR WHICH RESTART ALGEBRA WAS WRITTEN (=LMIN DEFAULT)
C LMIN  IS FIRST L FOR WHICH RESTART ALGEBRA IS TO BE READ
C
      IF(BLOOP.AND.LSUM.EQ.0.AND.LMIN.NE.LORIG)THEN
        IF(LMIN.LT.LORIG)THEN
          WRITE(6,1007)LORIG,LMIN
          WRITE(0,*)'ERROR IN RESTART ALGEBRA L-LOOP'
          GO TO 995
        ENDIF
C
C PARTIAL ALGEBRA RUNS CANNOT BE HANDLED BY L-LOOP, I.E. ONLY MSTART=1,5
c        IF(MSTART.GT.1.AND.MSTART.LT.5)THEN
c          WRITE(6,*)'RESTART ERROR: NEED LMIN=LORIG FOR MSTART=2,3,4'
c          WRITE(0,*)'RESTART ERROR: NEED LMIN=LORIG FOR MSTART=2,3,4'
c          GO TO 995
c        ENDIF
c should be handled minimally by preceding two tests on MSTRT0...
C
        READ(MR)MLIT,MXORB,NW,NF,MODD      !IN CASE IC NOW OFF
        BACKSPACE(MR)
        IF(ABS(MODD).GT.1)THEN             !LS WAS WRITTEN
          LREC5=1
        ELSE                               !IC WAS WRITTEN
          LREC5=7
        ENDIF
        LREC3=6
C
        NREC=1+1+LREC3+1+LREC5+1+1
        MRD=NREC*(LMIN-LORIG)
        DO M=1,MRD
          READ(MR,END=41)
        ENDDO
        GO TO 42
  41    WRITE(6,*)'*** ATTEMPT TO READ PAST END OF RESTART FILE...'
        WRITE(0,*)'*** ATTEMPT TO READ PAST END OF RESTART FILE...'
        GO TO 995
      ENDIF
C
  42  MSTART=MOD(ABS(MSTRT0),IRL5)
C
      IF(MSTART.GT.1)GO TO 73           !<--------------- RESTART SWITCH
C
  71  MSTART=1
C
C USE DIMENSION CHECK MODE TO GET NUMBER OF TERMS AND SLATER-STATES
C MAX "BUFFER" DIMENSION REQUIRED FOR THIS IS PER CONFIGURATION.
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for vcu dimensions'  !par
cpar        else                                                    !par
          write(iw,*)'Starting vcu dimensions'
cpar        endif                                                   !par
        if(bloop)write(iw,*)'l=',lnew
        call cpu_time(timei)
      endif
C
      MPRNT0=MPRINT
      MPRINT=-3
      MOD0=MODD
      IF(IDW.NE.0)MODD=0
c
c temp; if selection used then ixst0 can be too small for vcg buffer, so
      kcut0=kcut
      kcutp0=kcutp
      nastp0=nastp
      nast0=nast
      nastj0=nastj
      kcut=0
      kcutp=0
      nastp=0
      nast=0
      nastj=0
c if this generates too large an ixst0, then use mstart=7 to exit after
c call algeb1 and restart with mstart=8. this uses exact/minimum ixst0
c for algeb2,3,4.
C
      NTGA=0
      IAXTM=0
      IXST0=1
C
      KSI=1
      KSF=MXORB
      KF1=1
C
      ALLOCATE (DC(0:1),IDC(1))
      BALLDC=.TRUE.
      DC(0)=DZERO
C
      ALLOCATE (QCGS(IXEL0))                               !FOR VCU
C
C MAKE BEST USE OF ARRAYS QLMC,QLMS(MAXEL,MAXST) - OPTIMIZE MAXST.
C
cold      MAXST=MXEST
cold      IF(MAXEL.GT.0)MAXST=MAXST/MAXEL
cold      IF(MAXST.GT.MXST0)MAXST=MXST0
c
c historically, user could inflate mxst0 but be bounded by mxest.
c now, with allocate, and knowing maxel, we should use mxest=maxel*mxst0
c internally, since the interplay of mxest/mxst0/maxel is unknown to
c users, but need to safeguard against any historic inflation of mxst0.
c
      IAXST=MXST0
      IAXST=MIN(IAXST,IBUFF4/MAXEL)               !DO NOT INFLATE
C
C RE-ENTRY POINT IF MXST0 BUFFER TOO SMALL FOR VCU
C
  44  IXEST=MAXEL*IAXST
C
      ALLOCATE (QLMC(IXEST),QLMS(IXEST),QBML(IAXST),QBMS(IAXST)
     X,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR    QXXX'
        GO TO 999
      ENDIF
      BQXXX=.TRUE.
      BQLMS=.TRUE.
C
      MSST=2                             !INITIAL SS STAT WEIGHT COUNTER
C
      DO KF=KF1,KMAX
C
        MTGD=0
        NTG(0)=0
        JTGD(0)=0
c        KGCF(0)=0
        QCP(KF)=0
C
        JBS=1
C
        CALL VCU(QLMC,QLMS,QBML,QBMS,DE,DS,NDI,IAXST,MAXEL)
C
        IF(NFS.LE.0)THEN
          NF=NFS
          GO TO 990
        ENDIF
C
        IF(NB.EQ.-3)THEN
C
          IXXX=7*(IAXST/5+1)
C
          WRITE(6,*)'*** ALGEB: increasing MXST0 from ',IAXST,' to: '
     X              ,IXXX
          WRITE(0,*)'*** ALGEB: increasing MXST0 from ',IAXST,' to: '
     X              ,IXXX
C
          IAXST=IXXX
C
          DEALLOCATE (QBMS,QBML,QLMS,QLMC,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR QXXX'
            GO TO 990
          ENDIF
C
          KF1=KF                                                 !RE-SET
          GO TO 44                                               !RE-RUN
C
        ENDIF
C
        IF(NB.LT.0)THEN                     !DIMENSION FAILURE, BAIL OUT
          WRITE(6,90)NB
          NF=-1
          GO TO 990
        ENDIF
C
        IAXTM=IAXTM+NTGB
        JX=JBS-JAS+1
        IXST0=IXST0+JX
        JXMX=0
        CALL DIMUSE('MXST0',JXMX)
c        write(6,*)'algeb: jxmx=',jxmx
c        write(0,*)kf,ntgb,jx,iaxtm,ixst0,jxmx
C
      ENDDO
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for vcu dimensions:'   !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending vcu dimensions: time=',nint(times)
     x               ,'sec,     ',nint(times/60),'min'
cpar        endif                                                   !par
      endif
c
c      if(mprint.eq.-3)stop 'dim test'
      MPRINT=MPRNT0
      MODD=MOD0
c
c temp; re-instate
      kcut=kcut0
      kcutp=kcutp0
      nastp=nastp0
      nast=nast0
      nastj=nastj0
C
C NEED TO BUFFER IAXTM IF ALLOCATING IN SR.ALGEB1 FOR SR.VCG.
C AND CASE L/S=0 FINAL NO. TERMS PER CF IS LESS THAN INTERMEDIATE
C SO CAN'T JUST ADD FINAL NO. AS MAX INTERMEDIATE BUFFER.
C     IAXTM=IAXTM+...
C
      DEALLOCATE (QCGS)                      !ALGEB1 RE-ALLOCATES ACTUAL
C
      BQXXX=.FALSE.
      BQLMS=.FALSE.
      DEALLOCATE (QLMC,QLMS,QBML,QBMS,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR QXXX'
        IF(NF.GT.0)NF=0
        GO TO 999
      ENDIF
C
      IAXST=IXST0+JXMX                              !+BUFFER FOR VCG ETC
c      if(kcut+kcutp+nastp+nast+nastj.ne.0)iaxst=iaxst+jxmx    !kcut alt
      IXEST=MAXEL*IAXST
      IF(IXEST.GT.MXEST)THEN
        IF(MXEST.GT.0)WRITE(6,1137)IXEST,MXEST
      ENDIF
C
      ALLOCATE (QLMC(IXEST),QLMS(IXEST),QBML(IAXST),QBMS(IAXST)
     X,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR    QXXX'
        GO TO 999
      ENDIF
      BQXXX=.TRUE.
      BQLMS=.TRUE.
C
      DEALLOCATE (DC,IDC)
      BALLDC=.FALSE.
C
      IAXDC=MAX(MAXDC0,MAXDC,IAXDC)
      IXIDC=IAXDC
      IF(DC0.LT.DZERO)IXIDC=1
C
      ALLOCATE (DC(0:IAXDC),IDC(IXIDC),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR DC,IDC'
        GO TO 999
      ENDIF
      BALLDC=.TRUE.
C
      DC(0)=DC0                               !FLAGS OPT MEMORY OR SPEED
C
C INITIALIZE (OPEN) WRITE/READ DC ARRAY TO/FROM DISK.
C
      IF(BDISK)
     X   CALL DISKDC(IUD,IZERO,IZERO,IZERO,IZERO,IZERO,MSTRT0)
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algeb1'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algeb1'
cpar        endif                                                   !par
        if(bloop)write(iw,*)'l=',lnew
        call cpu_time(timei)
      endif
C
C***********************************************************************
C
      CALL ALGEB1(QLMC,QLMS,QBML,QBMS,JYI,JYF,IAXST,MAXEL)          !-1-
C
C***********************************************************************
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algeb1:'           !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algeb1: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
c
      IF(NF.LE.0)GO TO 80
C
      NSS=JYF(KMAX)                !FINAL TOT NO. SLATER STATES RETAINED
C
      ALLOCATE (MAM(NSS),NAM(NSS),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR MAM,NAM'
        GO TO 999
      ENDIF
      BMNAM=.TRUE.
C
      IF(BSTART)GO TO 75                        !<----- NO RESTART -----
C
      IF(IDW.NE.0)THEN    !DW DUMP IS NOW AFTER ALGEB3 SO CAN STRIKE-OUT
        BSTART=.TRUE.          !M_S CASES NOT NEEDED FOR BP WHEN NO 2-FS
        GO TO 75
      ENDIF
C
      IF(BREL)NPRINT=MIN(-IFIVE,NPRINT-IFIVE)
      NESS=MAXEL*NSS                     !NO. ELECTRONS*SLATER STATES
      IF(DC0.LT.DZERO)THEN
        MDCBUF=-MDCBUF
        MTGDI=1
        IDC(1)=0
      ELSE
        MTGDI=MTGD
      ENDIF                                                        !REC1
CC
      WRITE(MR)
     X MLIT,MXORB,NW,NF,MODD,KCUT,KUTDSK,QQCUT,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRINT,MA,MB,MAXNV,IRLX,ITANAL
     X,((NEL(I,J),I=1,MXORB),J=1,KMAX),((NNL(I,J),I=1,NW),J=1,3)
     X,((QCG(I,J),I=1,MAXEL),J=1,KMAX),(QL(I),I=1,MXORB)
     X,(QN(I),I=1,MXORB),(DEY(I),I=1,MXORB),(MSTAT(I),I=1,KMAX)
     X,(IEQ(I),I=0,MXORB),(IGRCF(I),I=1,MXORB),(BANAL(I),I=1,KMAX)
     X,(KGCF(I),I=0,KMAX),((NKSL(I,J),I=1,KGCF(J)-KGCF(J-1)),J=1,KMAX)
     X,(NTG(I),I=0,KMAX),(QCP(I),I=1,KMAX)
C
      MDCBUF=ABS(MDCBUF)
C
      IF(BPASS)GO TO 76
C
      WRITE(MR)(QLMS(I),I=1,NESS)                                  !REC2
CC
      NMTGD=MTGD/MXMTGD
      MTGD0=0
      MTGD1=-1
      DO N=1,NMTGD
        MTGD1=MTGD1+MXMTGD
        WRITE(MR)(DC(I),I=MTGD0,MTGD1)                             !REC3
        MTGD0=MTGD1+1
      ENDDO
      WRITE(MR)(DC(I),I=MTGD0,MTGD)                                !REC3
CC
      IMTGD=(MTGDI-1)/MXMTGD
      IMTGD=IMTGD/(LREC/IREC)
      MTGD0=1
      MTGD1=0
      DO N=1,IMTGD
        MTGD1=MTGD1+MXMTGD*(LREC/IREC)
        WRITE(MR)(IDC(I),I=MTGD0,MTGD1)                            !REC3
        MTGD0=MTGD1+1
      ENDDO
      WRITE(MR)(IDC(I),I=MTGD0,MTGDI)                              !REC3
CC                                                                 !REC3
      WRITE(MR)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
CC
      GO TO 76
CC        !TBD SPLIT, BUT KEEP BACKWARD COMPAT 4 NOW               !REC1
  73  READ(MR,ERR=994)
     X MLIT,MXORB,NW,NF,MODD,KCUT,KUTDSK,QQCUT,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRNT0,MA,MB,MAXNV,IRLX,ITANAL
      BACKSPACE(MR)
c
c temp for still to be alloc
c
      if(MXORB.gt.MAXGR)then
        write(6,*)'RESTART: INCREASE MAXGR TO',MXORB
        write(0,*)'RESTART: INCREASE MAXGR TO',MXORB
        go to 995
      endif
c
      if(KMAX.gt.MAXCF)then
        write(6,*)'RESTART: INCREASE MAXCF TO',KMAX
        write(0,*)'RESTART: INCREASE MAXCF TO',KMAX
        go to 995
      endif
c
      if(NTT.gt.MAXTM)then
        write(6,*)'RESTART: INCREASE MAXTM TO',NTT
        write(0,*)'RESTART: INCREASE MAXTM TO',NTT
        go to 995
      endif
C
      IF(ALLOCATED(NEL))DEALLOCATE (NEL)            !SHOULD KNOW THIS...
      ALLOCATE (NEL(MXORB,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR NEL'
        GO TO 999
      ENDIF
C
      IF(ALLOCATED(NEL))DEALLOCATE (NNL)            !SHOULD KNOW THIS...
      IAXCL=MAX(IONE,NW)
      ALLOCATE (NNL(IAXCL,3),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR NNL'
        GO TO 999
      ENDIF
C
      IF(ALLOCATED(QCG))DEALLOCATE (QCG)            !SHOULD KNOW THIS...
      IF(ALLOCATED(QL))DEALLOCATE (QL,QN)           !SHOULD KNOW THIS...
      ALLOCATE (QCG(MAXEL,KMAX),QL(MXORB),QN(MXORB),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR QCG,QL,QN'
        GO TO 999
      ENDIF
C
      ALLOCATE (KGCF(0:KMAX),NKSL(MAXSL,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB1: ALLOCATION FAILS FOR KGCF,NKSL'
        GO TO 999
      ENDIF
      BNRBGCF=.TRUE.
CC                              !temp 994->991                     !REC1
      READ(MR,ERR=991)
     X MLIT,MXORB,NW,NF,MODD,KCUT,KUTDSK,QQCUT,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRNT0,MA,MB,MAXNV,IRLX,ITANAL
     X,((NEL(I,J),I=1,MXORB),J=1,KMAX),((NNL(I,J),I=1,NW),J=1,3)
     X,((QCG(I,J),I=1,MAXEL),J=1,KMAX),(QL(I),I=1,MXORB)
     X,(QN(I),I=1,MXORB),(DEY(I),I=1,MXORB),(MSTAT(I),I=1,KMAX)
     X,(IEQ(I),I=0,MXORB),(IGRCF(I),I=1,MXORB),(BANAL(I),I=1,KMAX)
     X,(KGCF(I),I=0,KMAX),((NKSL(I,J),I=1,KGCF(J)-KGCF(J-1)),J=1,KMAX)
     X,(NTG(I),I=0,KMAX),(QCP(I),I=1,KMAX)      !v27 moved from REC3 v26
CC
  991 continue            !backward compat v27<-v26 (mstart=1 or 5 only)
c
      IF(BDISK)THEN
        IF(MDCBUF.LT.0)THEN
          MDCBUF=-MDCBUF
          MXTGDI=1
        ELSE
          MXTGDI=MDCBUF
        ENDIF
        MXTGD=MDCBUF
      ELSE
        MXTGD=MTGD
        MXTGDI=MTGDI
      ENDIF
C
      NMTGD=MTGD/MXMTGD
      IMTGD=(MTGDI-1)/MXMTGD
      IMTGD=IMTGD/(LREC/IREC)
      NESS=MAXEL*NSS
C
      IF(MSTART.EQ.2)THEN
C
        ALLOCATE (QLMS(NESS),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR    QLMS'
          GO TO 999
        ENDIF
        BQLMS=.TRUE.
CC
        READ(MR)(QLMS(I),I=1,NESS)                                 !REC2
CC
      ENDIF
C
      IF(MSTART.LT.5)THEN
C
        ALLOCATE (QLMC(NESS),QBML(NSS),QBMS(NSS),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR    QXXX'
          GO TO 999
        ENDIF
        BQXXX=.TRUE.
C
        ALLOCATE (MAM(NSS),NAM(NSS),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR MAM,NAM'
          GO TO 999
        ENDIF
        BMNAM=.TRUE.
C
        ALLOCATE (DC(0:MXTGD),IDC(MXTGDI),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR DC,IDC'
          GO TO 999
        ENDIF
        BALLDC=.TRUE.
C
        DC(0)=DC0                             !FLAGS OPT MEMORY OR SPEED
C
C INITIALIZE (OPEN) WRITE/READ DC ARRAY TO/FROM DISK.
C
        IF(BDISK)
     X     CALL DISKDC(IUD,IZERO,IZERO,IZERO,IZERO,IZERO,MSTRT0)
C
      ENDIF
C
      KCUTX=SIGN(KCUT,KCUTX)
      BREL0=NPRNT0.LE.-5
      MPRINT=MOD(NPRNT0,IFIVE)
      IF(MPRNT0.GT.MPRINT)NPRINT=MPRINT+5*(NPRINT/5)
      BREL=BREL.OR.NPRINT.LE.-5
C
      IF(BREL.AND..NOT.BREL0)THEN
C        WRITE(0,1011)
        WRITE(6,1011)
      ENDIF
C
      WRITE(6,700)MLIT,MSTART
C
      IF(MSTART.GT.2)GO TO 74           !<--------------- RESTART SWITCH
CC
      MTGD0=0
      MTGD1=-1
      DO N=1,NMTGD
        MTGD1=MTGD1+MXMTGD
        READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD1)                      !REC3
        MTGD0=MTGD1+1
      ENDDO
      READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD)                         !REC3
CC
      MTGD0=1
      MTGD1=0
      DO N=1,IMTGD
        MTGD1=MTGD1+MXMTGD*(LREC/IREC)
        READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGD1)                     !REC3
        MTGD0=MTGD1+1
      ENDDO
      READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGDI)                       !REC3
CC                                                                 !REC3
      READ(MR,ERR=994)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
CC
  75  MSTART=2
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algeb2'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algeb2'
cpar        endif                                                   !par
        if(bloop)write(iw,*)'l=',lnew
        call cpu_time(timei)
      endif
C
C***********************************************************************
C
      CALL ALGEB2(MAM,NAM,QLMC,QLMS,QBML,QBMS,JYI,JYF,MAXEL)        !-2-
C
C***********************************************************************
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algeb2:'           !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algeb2: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
c
      DEALLOCATE (QLMS,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR QLMS'
        GO TO 999
      ENDIF
      BQLMS=.FALSE.
C
C
      IF(NF.LE.0)GO TO 80
C
      IF(BSTART)GO TO 77                        !<----- NO RESTART -----
C
      IF(.NOT.BPASS)THEN
        DO N=1,NMTGD+IMTGD+3
          BACKSPACE(MR)                                            !REC3
        ENDDO
        BACKSPACE(MR)                                              !REC2
      ENDIF
C
      IRKK=MAX(IOS,IRK)
      IRKO=1
      IF(KUTOO.NE.0)IRKO=IRK
      IF(MPOL00.GE.0)THEN           !BORN CODING NOW USED MORE GENERALLY
        MXORB2=(MXORB*(MXORB+1))/2
        LHM=MPOLE/4
        IF(BREL)LHM=LHM+1
      ELSE
        MXORB2=1
        LHM=0
      ENDIF
      IF(MPRNT0.EQ.-2)THEN
        ID1=1
        ID2=1
      ELSE
        ID1=NSL0
        ID2=NTT
      ENDIF
C
C LEGACY: MODERN COMPILERS HANDLE RECORD MARKER LENGTH TRANSPARENTLY
C-LEG     IF(IADD.GT.2**29)GO TO 996                      !*4 RECL > 2GB
C-LEG     IF(IRKK.GT.2**28)GO TO 996                      !*8 RECL > 2GB
CC                                                                 !REC2
      WRITE(MR)IADD,IRK,IRKO,IRL,MTGD,MPOL00,MPOLE,IOS,NXLL
     X        ,KUTLS,NSL0,NMETA,MXORBR
C                                                                  !REC3
      WRITE(MR)(NSL(I),I=1,NSL0),(QSI(I),I=1,NSL0)
     X        ,(QLI(I),I=1,NSL0),(QPI(I),I=1,NSL0),(NMETAG(I),I=1,NSL0)
     X        ,((KGSL(I,J),I=1,KMAX),J=1,NSL0),(NADG(I),I=1,NSL0)
     X        ,(NFI(I),I=1,NTT),(NFK(I),I=1,NTT),(NFQ(I),I=1,NTT)
      WRITE(MR)(NAD(I),I=0,IADD)
      WRITE(MR)(DRK(I),I=1,IRKK)
      WRITE(MR)(NRK(I),I=1,IRKK)
      WRITE(MR)(((NED(I,J,K),I=1,2),J=1,ID1),K=1,ID2) !SHOULD BE O.K.
      WRITE(MR)((QRL(J,I),J=1,5),I=1,IRL)
     X        ,(DEK(I),I=1,IRKO),(BFALL(I),I=1,IRKO)
     X        ,((BINDB(I,LH),I=1,MXORB2),LH=0,LHM)
C               (DEK(I),I=1,IRKO),(BFALL(I),I=1,IRKO)  !OFF, LARGE CASES
      LREC3=6
C
      IF(BPASS)GO TO 76
CC
      MTGD0=0
      MTGD1=-1
      DO N=1,NMTGD
        MTGD1=MTGD1+MXMTGD
        WRITE(MR)(DC(I),I=MTGD0,MTGD1)                             !REC4
        MTGD0=MTGD1+1
      ENDDO
      WRITE(MR)(DC(I),I=MTGD0,MTGD)                                !REC4
CC
      MTGD0=1
      MTGD1=0
      DO N=1,IMTGD
        MTGD1=MTGD1+MXMTGD*(LREC/IREC)
        WRITE(MR)(IDC(I),I=MTGD0,MTGD1)                            !REC4
        MTGD0=MTGD1+1
      ENDDO
      WRITE(MR)(IDC(I),I=MTGD0,MTGDI)                              !REC4
CC                                                                 !REC4
      WRITE(MR)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
      GO TO 76
CC                                                                 !REC2
  74  READ(MR,ERR=994)IADD,IRK,IRKO,IRL,MTGD,MPOL0,MPOLX,IOS,NXLL
     X               ,KUTLS,NSL0,NMETA,MXORBR
CC
c
c temp for still to be alloc
c
      if(NSL0.gt.MAXSL)then
        write(6,*)'RESTART: INCREASE MAXSL TO',NSL0
        write(0,*)'RESTART: INCREASE MAXSL TO',NSL0
        go to 995
      endif
C
      MPOLE=MIN(MPOLE,MPOLX)      !CAN DO BECAUSE BINDB AT END OF RECORD
      MPOL00=MAX(MPOL00,MPOL0)
      IF(MPOL00.GE.0)THEN                 !OLD .EQ.0, NOW USED GENERALLY
        MXORB2=(MXORB*(MXORB+1))/2
        LHM=MPOLE/4
        if(brel0)then
          if(brel)lhm=lhm+1
          lhm0=lhm
        else
          if(brel)lhm=lhm+1
          lhm0=min(lhm,mpolx/4)
        endif
      ELSE
        MXORB2=1
        LHM=0
        lhm0=0
      ENDIF
C
      IF(IRKO.EQ.1)KUTOO=0
      IRKK=MAX(IRK,IOS)
      IXSOC=IRKK
      IXSOI=IRL
C
      IF(MPRINT.EQ.-2)THEN
        ID1=1
        ID2=1
      ELSE
        ID1=NSL0
        ID2=NTT
      ENDIF
C
C EX-COMMON/DXRL/
      ALLOCATE (DRK(IRKK),QRL(5,IRL),NRK(IRKK),NAD(0:IADD)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  DRK,QRL,NRK,NAD'
        GO TO 999
      ENDIF
      BDXRL=.TRUE.
C
C EX-COMMON/NRBEKP/
      ALLOCATE (NED(2,ID1,ID2),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  NED'
        GO TO 999
      ENDIF
      BNRBEKP=.TRUE.
C
C EX-COMMON/NRBGCF/
      ALLOCATE (KGSL(KMAX,NSL0),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR KGSL'
        GO TO 999
      ENDIF
C
C EX-COMMON/NRBNF1/
      ALLOCATE (DEK(IRKO),BFALL(IRKO),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  DEK, BFALL'
        GO TO 999
      ENDIF
      BNRBNF1=.TRUE.
C
C EX-COMMON/NRBRN2/
      ALLOCATE (BINDB(MXORB2,0:LHM),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  BINDB'
        GO TO 999
      ENDIF
      BNRBRN2=.TRUE.
CC                                                                 !REC3
      READ(MR,ERR=994)(NSL(I),I=1,NSL0),(QSI(I),I=1,NSL0)
     X      ,(QLI(I),I=1,NSL0),(QPI(I),I=1,NSL0),(NMETAG(I),I=1,NSL0)
     X      ,((KGSL(I,J),I=1,KMAX),J=1,NSL0),(NADG(I),I=1,NSL0)
     X      ,(NFI(I),I=1,NTT),(NFK(I),I=1,NTT),(NFQ(I),I=1,NTT)
      READ(MR,ERR=994)(NAD(I),I=0,IADD)
      READ(MR,ERR=994)(DRK(I),I=1,IRKK)
      READ(MR,ERR=994)(NRK(I),I=1,IRKK)
      READ(MR,ERR=994)(((NED(I,J,K),I=1,2),J=1,ID1),K=1,ID2)
      READ(MR,ERR=994)((QRL(J,I),J=1,5),I=1,IRL)
     X      ,(DEK(I),I=1,IRKO),(BFALL(I),I=1,IRKO)
     X      ,((BINDB(I,LH),I=1,MXORB2),LH=0,lhm0)
c
      do lh=lhm0+1,lhm
        do i=1,mxorb2
          bindb(i,lh)=.false.    !brel but no retardation as brel0 false
        enddo
      enddo
C
      IF(MSTART.GT.3)GO TO 78
CC
      MTGD0=0
      MTGD1=-1
      DO N=1,NMTGD
        MTGD1=MTGD1+MXMTGD
        READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD1)                      !REC4
        MTGD0=MTGD1+1
      ENDDO
      READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD)                         !REC4
CC
      MTGD0=1
      MTGD1=0
      DO N=1,IMTGD
        MTGD1=MTGD1+MXMTGD*(LREC/IREC)
        READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGD1)                     !REC4
        MTGD0=MTGD1+1
      ENDDO
      READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGDI)                       !REC4
CC                                                                 !REC4
      READ(MR,ERR=994)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
CC
  77  MSTART=3
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algeb3'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algeb3'
cpar        endif                                                   !par
        if(bloop)write(iw,*)'l=',lnew
        call cpu_time(timei)
      endif
C
C***********************************************************************
C
      CALL ALGEB3(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)             !-3-
C
C***********************************************************************
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algeb3:'           !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algeb3: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
c
      IF(NF.LE.0)GO TO 80
C
      IF(BSTART)GO TO 72                        !<----- NO RESTART -----
C
      IADJ0=0
      IF(NL.GT.0)IADJ0=IADJ
      IRLP000=IRLP
CC
      IF(.NOT.BPASS)THEN
        DO N=1,NMTGD+IMTGD+3
          BACKSPACE(MR)                                            !REC4
        ENDDO
      ENDIF
C
      WRITE(MR)NJO,IRS,NL,IADJ8,IADJ0,IRKP,IRLP,NLEV,NMETAJ        !REC4
C
C LEGACY: MODERN COMPILERS HANDLE RECORD MARKER LENGTH TRANSPARENTLY
C-LEG     IF(IADJ.GT.2**29)GO TO 996                      !*4 RECL > 2GB
C-LEG     IF(IRKP.GT.2**28)GO TO 996                      !*8 RECL > 2GB
C-LEG     IF(IADJ0.GT.2**29)GO TO 996                     !*4 RECL > 2GB
C-LEG     IF(IRS.GT.2**28)GO TO 996                       !*8 RECL > 2GB
CC
      IF(NJO.EQ.0)THEN                          !LS
        WRITE(MR)NJO                                               !REC5
        LREC5=1
      ELSE
C                                                                  !REC5
        WRITE(MR)NJO,(NRR(I),I=1,NLEV),(NT(I),I=1,NJO)
     X         ,(JN(I),I=1,NLEV),(NGR(I),I=1,NLEV),(NMETGJ(I),I=1,NJO)
     X         ,((NSLJ(J,I),J=1,NSL0),I=1,NJO),(NGSLJ(I),I=1,NJO)
     X         ,(NTJ(I),I=1,KMAX),(NFJ(I),I=1,NLEV)
     X         ,((QRLP(J,I),J=1,4),I=1,IRLP),((QSS(J,I),J=1,5),I=1,NL)
CT        WRITE(MR)(NADP(NP8),NP8=0,IADJ8)
        WRITE(MR)(NADP(NP8),NP8=1,IADJ8)             !*** TEMP 0->1 ****
        WRITE(MR)(DRKP(I),I=1,IRKP)
        WRITE(MR)(NRKP(I),I=1,IRKP)
        WRITE(MR)(NADR(I),I=0,IADJ0)
        WRITE(MR)(DSS(I),I=1,IRS)
        WRITE(MR)(MSS(I),I=1,IRS)
        LREC5=7
C
        IF(BPASS)GO TO 76
CC
        MTGD0=0
        MTGD1=-1
        DO N=1,NMTGD
          MTGD1=MTGD1+MXMTGD
          WRITE(MR)(DC(I),I=MTGD0,MTGD1)                           !REC6
          MTGD0=MTGD1+1
        ENDDO
        WRITE(MR)(DC(I),I=MTGD0,MTGD)                              !REC6
CC
        MTGD0=1
        MTGD1=0
        DO N=1,IMTGD
          MTGD1=MTGD1+MXMTGD*(LREC/IREC)
          WRITE(MR)(IDC(I),I=MTGD0,MTGD1)                          !REC6
          MTGD0=MTGD1+1
        ENDDO
        WRITE(MR)(IDC(I),I=MTGD0,MTGDI)                            !REC6
CC                                                                 !REC6
        WRITE(MR)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
      ENDIF
      GO TO 76
CC
  78  READ(MR,ERR=994)NJO,IRS,NL,IADJ8,IADJ0,IRKP,IRLP,NLEV,NMETAJ !REC4
CC
c
c temp for still to be alloc
c
      if(NJO.gt.MAXJG)then
        write(6,*)'RESTART: INCREASE MAXJG TO',NJO
        write(0,*)'RESTART: INCREASE MAXJG TO',NJO
        go to 995
      endif
c
      if(NLEV.gt.MAXLV)then
        write(6,*)'RESTART: INCREASE MAXLV TO',NLEV
        write(0,*)'RESTART: INCREASE MAXLV TO',NLEV
        go to 995
      endif
C
      IF(ABS(MOD0).GT.1.OR.NJO.EQ.0)THEN
        READ(MR,ERR=994)NJO                                        !REC5
        NJO=0
      ELSE
C SET ALLOCATE SIZE
        IXSOC=IRKP
        IXSOI=IRLP
        IXRSS=IRS
        IAXMI=NL
        IF(MSTART.LT.5)THEN       !NOT YET MAXIMAL
          IXSOC=MAX(MXSOC0,MXSOC,IXSOC)           !USE LARGEST PREVIOUS
          IXSOI=MAX(MXSOI0,MXSOI,IXSOI)           !USE LARGEST PREVIOUS
          IXRSS=MAX(MXRSS0,MXRSS,IXRSS)           !USE LARGEST PREVIOUS
          IAXMI=MAX(MAXMI0,MAXMI,IAXMI)           !USE LARGEST PREVIOUS
          IRLP000=IRLP
        ELSE
          IRLP000=IRLP-1       !SINGLE PASS, DON'T HAVE, TRY & LOOK FOR
        ENDIF
C
C EX-COMMON/COEFF/
        ALLOCATE (DRKP(IXSOC),QRLP(4,IXSOI),NRKP(IXSOC),NADP(0:IADJ8)
     X           ,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB:ALLOCATION FAILS FOR DRKP,QRLP,NRKP,NADP'
          GO TO 999
        ENDIF
        BCOEFF=.TRUE.
C
C EX-COMMON/DMQSS3/
        ALLOCATE (DSS(IXRSS),MSS(IXRSS),QSS(5,IAXMI),NADR(0:IADJ0)
     X           ,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  DSS,MSS,QSS,NADR'
          GO TO 999
        ENDIF
        BDMQSS3=.TRUE.
CC                                                                 !REC5
        READ(MR,ERR=994)NJO,(NRR(I),I=1,NLEV),(NT(I),I=1,NJO)
     X        ,(JN(I),I=1,NLEV),(NGR(I),I=1,NLEV),(NMETGJ(I),I=1,NJO)
     X        ,((NSLJ(J,I),J=1,NSL0),I=1,NJO),(NGSLJ(I),I=1,NJO)
     X        ,(NTJ(I),I=1,KMAX),(NFJ(I),I=1,NLEV)
     X        ,((QRLP(J,I),J=1,4),I=1,IRLP),((QSS(J,I),J=1,5),I=1,NL)
        nadp(0)=0                                          !*** TEMP ***
        READ(MR,ERR=994)(NADP(NP8),NP8=1,IADJ8)       !*** TEMP 0->1 ***
CT        READ(MR,ERR=994)(NADP(NP8),NP8=0,IADJ8)
        READ(MR,ERR=994)(DRKP(I),I=1,IRKP)
        READ(MR,ERR=994)(NRKP(I),I=1,IRKP)
        READ(MR,ERR=994)(NADR(I),I=0,IADJ0)               !+/- ALGEB4
        READ(MR,ERR=994)(DSS(I),I=1,IRS)
        READ(MR,ERR=994)(MSS(I),I=1,IRS)
C
        IF(MSTART.EQ.4)THEN
          MTGD0=0
          MTGD1=-1
          DO N=1,NMTGD
            MTGD1=MTGD1+MXMTGD
            READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD1)                  !REC6
            MTGD0=MTGD1+1
          ENDDO
          READ(MR,ERR=994)(DC(I),I=MTGD0,MTGD)                     !REC6
CC
          MTGD0=1
          MTGD1=0
          DO N=1,IMTGD
            MTGD1=MTGD1+MXMTGD*(LREC/IREC)
            READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGD1)                 !REC6
            MTGD0=MTGD1+1
          ENDDO
          READ(MR,ERR=994)(IDC(I),I=MTGD0,MTGDI)                   !REC6
CC                                                                 !REC6
          READ(MR,ERR=994)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X         ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X         ,(JTGD(I),I=0,NTT)
     X         ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
        ENDIF
      ENDIF
CC
      IF(MSTART.GT.4)THEN
        NL000=NL
        GO TO 70
      ENDIF
C
  72  MSTART=4
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algeb4'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algeb4'
cpar        endif                                                   !par
        if(bloop)write(iw,*)'l=',lnew
        call cpu_time(timei)
      endif
C
C***********************************************************************
C
      CALL ALGEB4(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)             !-4-
C
C***********************************************************************
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algeb4:'           !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algeb4: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
c
      IF(NF.LE.0)GO TO 80
C
      IF(BSTART)GO TO 79                        !<----- NO RESTART -----
C
C      NJO=JSP(1)
C      IF(NJO.LT.0)GO TO 79                   !NO LONGER POSSIBLE,=0 OFF
C
      IF(NJO.GT.0.AND..NOT.BPASS)THEN
        DO N=1,NMTGD+IMTGD+3
          BACKSPACE(MR)                                            !REC6
        ENDDO
      ENDIF
C
COLD      IF(NL000.LT.NL)NL000=NL000+1
CC
      IF(NL000.LE.NL.AND.IRLP.LE.IRLP000)THEN    !NO CONTRIBS
        WRITE(MR)NL                                                !REC6
        WRITE(MR)MBP1MX                                            !REC7
      ELSE
        DO L=1,LREC5
          BACKSPACE(MR)                                            !REC5
        ENDDO
        BACKSPACE(MR)                                              !REC4
        DO L=1,LREC3
          BACKSPACE(MR)                                            !REC3
        ENDDO
CC                                                                 !REC3
        WRITE(MR)(NSL(I),I=1,NSL0),(QSI(I),I=1,NSL0)
     X        ,(QLI(I),I=1,NSL0),(QPI(I),I=1,NSL0),(NMETAG(I),I=1,NSL0)
     X        ,((KGSL(I,J),I=1,KMAX),J=1,NSL0),(NADG(I),I=1,NSL0)
     X        ,(NFI(I),I=1,NTT),(NFK(I),I=1,NTT),(NFQ(I),I=1,NTT)
        WRITE(MR)(NAD(I),I=0,IADD)
        WRITE(MR)(DRK(I),I=1,IRKK)
        WRITE(MR)(NRK(I),I=1,IRKK)
        WRITE(MR)(((NED(I,J,K),I=1,2),J=1,ID1),K=1,ID2)
        WRITE(MR)((QRL(J,I),J=1,5),I=1,IRL)
     X          ,(DEK(I),I=1,IRKO),(BFALL(I),I=1,IRKO)
     X          ,((BINDB(I,LH),I=1,MXORB2),LH=0,LHM)
C
        WRITE(MR)NJO,IRS,NL000,IADJ8,IADJ0,IRKP,IRLP,NLEV,NMETAJ   !REC4
C                                                                  !REC5
        WRITE(MR)NJO,(NRR(I),I=1,NLEV),(NT(I),I=1,NJO)
     X        ,(JN(I),I=1,NLEV),(NGR(I),I=1,NLEV),(NMETGJ(I),I=1,NJO)
     X        ,((NSLJ(J,I),J=1,NSL0),I=1,NJO),(NGSLJ(I),I=1,NJO)
     X        ,(NTJ(I),I=1,KMAX),(NFJ(I),I=1,NLEV)
     X        ,((QRLP(J,I),J=1,4),I=1,IRLP),((QSS(J,I),J=1,5),I=1,NL000)
CT      WRITE(MR)(NADP(NP8),NP8=0,IADJ8)                           !^^^
        WRITE(MR)(NADP(NP8),NP8=1,IADJ8)             !*** TEMP 0->1 ****
        WRITE(MR)(DRKP(I),I=1,IRKP)
        WRITE(MR)(NRKP(I),I=1,IRKP)
        WRITE(MR)(NADR(I),I=0,IADJ0)
        WRITE(MR)(DSS(I),I=1,IRS)
        WRITE(MR)(MSS(I),I=1,IRS)
C
        WRITE(MR)NL,IPLANT_SOI,IPLANT_MI                           !REC6
C                                                                  !REC7
        WRITE(MR)MBP1MX,MBP2MX,MEKVMX
     X         ,(((NMD1(I,J,K),I=1,2),J=1,NJO),K=1,NLEV)
     X         ,(((NMD2(I,J,K),I=1,2),J=1,NJO),K=1,NLEV)
      ENDIF
c
c enable RESTART to be read anew during existing calc. else
c      call flush(mr)!
c
      GO TO 76
C
 771  IF(IRLP000.LT.IRLP)THEN                !TRY FOR NO ALEGB4 CONTRIBS
        IRLP000=IRLP
        BACKSPACE(MR)
      ELSE
        GO TO 994                                              !BAIL OUT
      ENDIF
CC
  70  READ(MR,ERR=772,end=772)NL                                   !REC6
      go to 773
CC
 772  nl=nl000                         !for non-flush, hope for the best
c      write(0,*)nl,nl000,mbp1mx
 773  IF(ABS(MOD0).GT.1.OR.NL000.LE.NL.AND.IRLP.LE.IRLP000)THEN    !NONE
C     X                     .AND.MBP1MX.LT.0.AND.MPOLE.LT.6)THEN !FOR M2
C EX-COMMON/NRBMKP/
        ALLOCATE (NMD1(1,1,1),NMD2(1,1,1),STAT=IERR)
CC
        READ(MR,ERR=775,end=775)MBP1MX                             !REC7
CC
 775    IF(ABS(MOD0).GT.1.OR.KUTSS.EQ.-1)NL=0
        NL000=NL
        MBP1MX=-2
        MBP2MX=0
        MEKVMX=-2
        NMD1(1,1,1)=-1
        NMD2(1,1,1)=-1
      ELSE                             !E3, M1+BP etc not v26 compatible
        BACKSPACE(MR)
        READ(MR,ERR=771)NL,IPLANT_SOI,IPLANT_MI                    !REC6
C
C EX-COMMON/NRBMKP/
        ALLOCATE (NMD1(2,NJO,NLEV),NMD2(2,NJO,NLEV),STAT=IERR)
CC                                                                 !REC7
        READ(MR,ERR=994)MBP1MX,MBP2MX,MEKVMX
     X         ,(((NMD1(I,J,K),I=1,2),J=1,NJO),K=1,NLEV)
     X         ,(((NMD2(I,J,K),I=1,2),J=1,NJO),K=1,NLEV)
CC
      ENDIF
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB: ALLOCATION FAILS FOR  NMD1,NMD2'
        GO TO 999
      ENDIF
      BNRBMKP=.TRUE.
C
C-----------------------------------------------------------------------
C
  79  CONTINUE
C
      IF(IDW.NE.0)THEN
C
C SEE IF WE CAN REDUCE THE TARGET SLATER-STATE EXPANSION FOR THE
C COLLISION PROBLEM AT HAND.
C
        CALL REDSS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)
C
        NPRNT0=NPRINT
        IF(BREL)NPRNT0=MIN(-IFIVE,NPRINT-IFIVE)
C
        NSS=JYF(KMAX)                      !TOT NO. SLATER STATES NEEDED
        NESS=MAXEL*NSS                     !NO. ELECTRONS*SLATER STATES
        IF(DC0.LT.DZERO)THEN
          MDCBUF=-MDCBUF
          MTGDI=1
          IDC(1)=0
        ELSE
          MTGDI=MTGD
        ENDIF
C
C THIS DUMP IS JUST THE RESTART DUMP AFTER THE CALL TO ALGEB1
C (NOT EVERYTHING IS NECESSARILY NEEDED).
C
        REWIND(MR)
C                                                                  !REC1
        WRITE(MR)
     X   MLIT,MXORB,NW,NF,MODD,KCUTX,KUTDSK,QQCUTX,QCL0,QCS0,MDCBUF
     X  ,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRNT0,MA,MB,MAXNV,IRLX,ITANAL
     X  ,((NEL(I,J),I=1,MXORB),J=1,KMAX),((NNL(I,J),I=1,NW),J=1,3)
     X  ,((QCG(I,J),I=1,MAXEL),J=1,KMAX),(QL(I),I=1,MXORB)
     X  ,(QN(I),I=1,MXORB),(DEY(I),I=1,MXORB),(MSTAT(I),I=1,KMAX)
     X  ,(IEQ(I),I=0,MXORB),(IGRCF(I),I=1,MXORB),(BANAL(I),I=1,KMAX)
     X  ,(KGCF(I),I=0,KMAX),((NKSL(I,J),I=1,KGCF(J)-KGCF(J-1)),J=1,KMAX)
     X  ,(NTG(I),I=0,KMAX),(QCP(I),I=1,KMAX)
C
        WRITE(MR)(DC(I),I=0,MTGD)                                  !REC3
        WRITE(MR)(IDC(I),I=1,MTGDI)                                !REC3
        WRITE(MR)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X      ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X      ,(JTGD(I),I=0,NTT)
     X      ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
C
C THIS IS A PARTIAL DUMP OF THE RESTART AFTER THE CALL TO ALGEB2
C (NOT EVERYTHING IS NECESSARILY NEEDED).
C                                                                  !REC2
        WRITE(MR)IADD,IRK,IRKO,IRL,MTGD,MPOL00,MPOLE,IOS,NXLL
     X          ,KUTLS,NSL0,NMETA,MXORBR
C                                                                  !REC3
        WRITE(MR)(NSL(I),I=1,NSL0),(QSI(I),I=1,NSL0)
     X        ,(QLI(I),I=1,NSL0),(QPI(I),I=1,NSL0),(NMETAG(I),I=1,NSL0)
     X        ,((KGSL(I,J),I=1,KMAX),J=1,NSL0),(NADG(I),I=1,NSL0)
     X        ,(NFI(I),I=1,NTT),(NFK(I),I=1,NTT),(NFQ(I),I=1,NTT)
C
C THIS IS A PARTIAL DUMP OF THE RESTART AFTER THE CALL TO ALGEB3
C (NOT EVERYTHING IS NECESSARILY NEEDED).
C
        WRITE(MR)NJO,IRS,NL,IADJ8,IADJ0,IRKP,IRLP,NLEV,NMETAJ      !REC4
C
        IF(NJO.EQ.0)THEN                          !LS
          WRITE(MR)NJO                                             !REC5
        ELSE                                                       !REC5
          WRITE(MR)NJO,(NRR(I),I=1,NLEV),(NT(I),I=1,NJO)
     X           ,(JN(I),I=1,NLEV),(NGR(I),I=1,NLEV),(NMETGJ(I),I=1,NJO)
     X           ,((NSLJ(J,I),J=1,NSL0),I=1,NJO),(NGSLJ(I),I=1,NJO)
C     X           ,(NTJ(I),I=1,KMAX),(NFJ(I),I=1,NLEV)
        ENDIF
C
C ANY/EVERYTHING ELSE IS RE-CREATED OR STILL HELD IN MEMORY.
C TBD: ALL IS DUMPED/RE-CREATED SO THAT CAN IMPLEMENT COLLISION ALGEBRA
C RESTARTX.
C
      ELSE
        IF(IUNIT(MR).GT.0.AND..NOT.BLOOP)THEN
          IUNIT(MR)=-1
          CLOSE(MR)
        ENDIF
      ENDIF
C
  80  CONTINUE
C
      IF(MPRINT.LE.-3)THEN
        WRITE(6,190)MPRINT
        IF(BLOOP.AND.LNEW.LT.LMAX)NF0=NF
        IF(NF.GT.0)NF=0
      ENDIF
C
      IF(NF.LT.0.AND..NOT.BSTART.AND.BPASS.AND.MSTART.GT.1)WRITE(6,1012)
c      write(0,*)nl,nl000,mbp1mx,mbp2mx,mekvmx,mpole
C
      IF(BREL)NPRINT=MOD(NPRINT,IFIVE)
C
C
 990  CONTINUE
C
C FINALIZE:
C
C IDW=0 (CLOSE) WRITE/READ DC ARRAY TO/FROM DISK
C IDW>0 REPOINT/REWIND FOR ALGX BRANCH
C
      IF(BDISK)THEN                                      !BREAK TESTS...
        IF(IUNIT(IUD).GT.0)
     X     CALL DISKDC(IUD,IDW,IZERO,IZERO,IZERO,IZERO,MSTRT0)
      ENDIF
C
C DE-ALLOCATE
C
      IF(ALLOCATED(JYI))DEALLOCATE (JYI,JYF)
C
      IF(ALLOCATED(LSPIP))THEN
        DEALLOCATE (LSPIP,NLSPIP,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR LSPIP,NLSPIP'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BNRBGCF)THEN
        DEALLOCATE (KGCF,NKSL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR KGCF,NKSL'
          IF(NF.GT.0)NF=0
        ENDIF
        BNRBGCF=.FALSE.
      ENDIF
C
      IF(ALLOCATED(KGSL))THEN
        DEALLOCATE (KGSL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR KGSL'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BALLDC)THEN
        DEALLOCATE (DC,IDC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR DC,IDC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BMNAM)THEN
        DEALLOCATE (MAM,NAM,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR MAM,NAM'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BQXXX)THEN
        DEALLOCATE (QBMS,QBML,QLMC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR QXXX'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BQLMS)THEN
        DEALLOCATE (QLMS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB: DE-ALLOCATION FAILS FOR QLMS'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C
 998  CONTINUE
C
      if(btime)then
        call cpu_time(timef)
        times=timef-time0
c
        if(bloop)write(iw,*)'l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algeb:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Total algeb: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
C
      RETURN
C
C
 994  WRITE(6,*)'*** RESTART ERROR - PROBABLY DUE TO INCONSISTENT',
     X             ' MSTART FOR STATE OF RESTART FILE...'
      WRITE(0,*)'*** RESTART ERROR - CHECK MSTART ***'
      NF=0
      GO TO 990
C
 995  NF=-1
      GO TO 990
C
C LEGACY: MODERN COMPILERS HANDLE RECORD MARKER LENGTH TRANSPARENTLY
C-LEG996  WRITE(6,*)'*** RECORD LENGTH .GT. 2GB, CANNOT USE RESTART:',
C-LEG    X          ' MSTART=',MSTART
C-LEG     NF=0
C-LEG     GO TO 990
C
 999  NF=0
      GO TO 990
C
C-----------------------------------------------------------------------
C
C     COMMENT TO SR VCU AND VCG (CALLED IN SR ALGEB1)
C
C-----------------------------------------------------------------------
C
C  KF.GT.KCUT(.GT.0):  ONLY THOSE TERMS RETAINED THAT SERVE AS
C           CORRELATION TERMS TO TERMS OF PREVIOUS CONFIGURATIONS KF.
C
C  MODD.EQ.0:
C      ALL VCC FOR ALL COMPLETE TERMS I OF CONFIG C  STORED IN DC
CWE    PROVIDED KCUT=0 IS SPECIFIED (WHICH DEFAULTS TO KCUT.GE.KF)
CWE    OTHERWISE RESTRICTIONS ON MS APPLY: SEE LOOP DO33.
CWE    COLFS MAY HAVE TO BE OPENED FOR FS-COLLISION PROBLEMS.
CNRB***OLD RESTRICTIONS SUPPRESSED NOW THAT WE RE-COUPLE SUB-SHELLS
C
C  MODD.EQ.1:
C      ONLY VCC FOR SLATER-STATES WITH /ML=MS/=MIN OF ALL TERMS I OF C
C
C  MODD.EQ.2:
C      ONLY VCC FOR SLATER-STATES WITH ML=0,MS=MIN OF ALL TERMS I OF C
C
C  MODD.EQ.-1,-2
C      EQUIV TO +1,+2 FOR ML,MS.LT.0, BUT ALL -,-.GT.0 RETAINED
C
C  MODD.GE.3:
C      ONLY SLATER-STATES AND VCC WITH ML=L,MS=S OF TERM 2S=QCS0,2L=QCL0
C
C  MODD.LE.-3:
C      ANY ML=L-1 ALSO INCLUDED (KCUT IGNORED FOR ABS(MODD).GE.3)
C
C-----------------------------------------------------------------------
C
   90 FORMAT(//"SR.ALGEB: STORAGE EXCEEDED IN VCU" //"
     X'DISK'=-3 IF TOO MANY SLATER STATES ((JB').GT.MAXST), -2 IF TOO ",
     X"MANY TERMS (SUM(ND).GT.MAXCT), -1 IF TOO MANY VCC ",
     X",(MTGD.GT.MAXDC)"//"  AUGMENT MXST0 (IN CASE -3),  AUGMENT  ",
     X"MAXTM (IN CASE -2),  AUGMENT  MAXDC (IN CASE -1):   DISK=",I8)
  190 FORMAT(/' THIS WAS NO MORE THAN A DIMENSION CHECK -- MPRINT=',I2/)
  700 FORMAT(//"RESTART FILE '",2A4,"' READ BACK WITH MSTART=",I2//)
  800 FORMAT(//"SR.ALGEB CREATES RESTART FILE '",2A4,"', MSTART=",I2/)
 1007 FORMAT(' ERROR IN RESTART ALGEBRA L-LOOP, FIRST L WRITTEN=',I3
     X,' BUT FIRST L TO BE READ=',I3)
 1011 FORMAT('*** WARNING: READ OF RESTART FILE GENERATED BY NON-',
     X       'RELATIVISTIC ORBITAL RUN - RETARDATION NEGLECTED!!')
 1012 FORMAT(//'INCOMPLETE ALGEBRA RUN, BUT RESTART CANNOT BE RECOVERED'
     X/'FIX PROBLEM AND RUN WITH MSTART=1, SET BPASS=.FALSE. TO BE ABLE'
     X/' TO RECOVER ANY FUTURE INCOMPLETE RUN.')
 1137 FORMAT('SR.ALGEB: ALLOCATION INCREASES TOTAL NO. OF SLATER STATES'
     X       ,' IXEST=',I10,' .GT. MXEST=',I10)
C
      END SUBROUTINE ALGEB
C
C                             *******************
C
      SUBROUTINE ALGEB0(DC0,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB0 READS USER INPUT, CONFIGURATIONS ETC, CONTROLLING ANGULAR
C  ALGEBRA OPERATION AND SETS-UP ACCORDINGLY FOR ITS SUBSEQUENT
C  GENERATION.
C  ALSO, CASE A.S., AUTOMATICALLY GENERATES N+1 ELECTRON CONFIGS FROM
C  N-ELECTRON TARGET, FOR BOUND-CONTINUUM PROBLEMS (DR/RR ETC.)
C
C     THIS ROUTINE IS SOMEWHAT MESSY DUE RETENTION OF EARLIER INPUT
C     FORMATS, SOME OF WHICH MAY NO LONGER WORK.......
C
C  IT CALLS:
C    SR.CONFG0
C    SR.CONFG1
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,nproc                      !par
C
      USE COMMON_DBD2,   ONLY: QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,KMAX,NEL,IAXGR,IAXCF
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
      USE COMMON_NRBRN2, ONLY: MENGB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=8) TITLE
      CHARACTER(LEN=5) RAD
      CHARACTER(LEN=4) MLIT,MLIT0,PHASE,CODE,COD,RUN
      CHARACTER(LEN=4) CUP,BORN,BASIS
      CHARACTER(LEN=3) CPU,TARGET,RAD3
      CHARACTER(LEN=1) XDR,XDR0,QLIT,C2C
cparc                                                               !par
cpar      character(len=1) :: num(0:9)                              !par
cpar      character(len=2) name0                                    !par
cpar      character(len=9) name                                     !par
cparc                                                               !par
cpar      logical bex                                               !par
C
      INTEGER(EP) MDCF8,MDCFT8
C
      PARAMETER (MXD07=100)       !S.S. NO. OF UNIT5 CONFIG INPUT LINES
      PARAMETER (MXD08=MXD07*21)  !S.S. MXD07*NO. OF CHARS/LINE *FIXED*
      PARAMETER (MXD10=MXD07*5)   !S.S. MXD10*NO. CFGS PER LINE (APPROX)
      PARAMETER (MXD12=100)                 !NO. OF NON-SEQ RYD N-VALUES
      PARAMETER (MXD14=100)
cparc                                                               !par
cpar      parameter (irl5=6)              !5+1 now alg3/4 separate  !par
C
      ALLOCATABLE :: ITMP(:)
C
      DIMENSION MLIT0(2),COD(20),QLIT(0:10),C2C(21)
      DIMENSION KCFS0(MXD10),I2I(21)
C
      COMMON /BASIC/NF,KX,KG,K1,K2,MGAP(7)
      COMMON /OUTP1/MPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /SSWRK/IWRK1(MXD08),IWRK2(MXD08)
      COMMON /NRBAL0/IRET0,LORIG,LMIN,MPRNT0,MOD0,MSTRT0,BPASS,MLIT(2)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBDW3/LSPIB(MAXSL)   !TBD: COMBINE WITH /NRBDW/ IN MODULE
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW
     X             ,NASTB,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,NASTJB,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFAN/BFANO
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBJP/JPIP(MAXJG),NASTJP,MINJTP,MAXJTP
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBLSS/NESSH(MAXSL),NASTS,MINSTS,MAXSTS,MINLTS,MAXLTS
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
c
      common /nrbone/ione1,ione0
cpar      common /nrbpar/niam,liam,jiam,lproc,nprocperl,mapiam      !par
      common /nrbtim/iw,iwp,btime,btimex
cparc                                                               !par
cpar      data num/'0','1','2','3','4','5','6','7','8','9'/         !par
C
c      EQUIVALENCE (TITLE,MLIT(1)),(PHASE,MLIT0(1))
C
      NAMELIST/SALGEB/
     X BASIS,BDISK,BFOT,BORN,BPASS,btop,
     X CPU,CUP,
     X ECNTRB,
     X FACTJ,FACTL,
     X ICFG,IDIAG,IDW,IFILL,INAST,INASTJ,IPAR,ISCALR,ITANAL,
     X J2MIN,J2MAX,JNAST,IJNAST,
     X K1,K2,KCOR1,KCOR2,KCUT,KCUT0,KCUTCC,KCUTI,KCUTP,KORB1,KORB2,
     X KPOL0,KPOL1,KPOLE,KPOLM,KSUBCF,KUTDSK,KUTLS,KUTM1,KUTOO,KUTOOX,
     X KUTSO,KUTSS,KUTSSX,
     X LCMIN,LCON,LCON0,LCONI,LCONDW,LCONDWJ,LMAX,
     X LRGLAM,LVMIN,LVMAX,LXTRA,
     X MBP1MX,MBP2MX,MEKVMX,
     X MAXJFS,MAXLAM,MXLAMX,MAXLX,MAXLOO,MCFSS,MDEL,MENGB,
     X MINJT,MAXJT,MINJTP,MAXJTP,
     X MINLT,MAXLT,MINLTP,MAXLTP,MINLTS,MAXLTS,
     X MINST,MAXST,MINSTP,MAXSTP,MINSTS,MAXSTS,
     X MODD,MPRINT,MSTART,MSTRT0,MXCCF,MXCONF,MXVORB,
     X NAST,NASTJ,NASTJP,NASTP,NASTS,
     X NMETA,NMETAJ,NMETAG,NMETGJ,NMULTE,NXTRA               !ANSI LIMIT
      NAMELIST/SALGEB/
     X PHASE,
     X QCL0,QCS0,QCUT,QQCUT,
     X RAD,RUN,
     X TARGET,TITLE,
     X XDR
      NAMELIST/SALGEB/
     x iw,iwp,btime,btimex,ione1                   !,ione0
cpar      namelist/salgeb/                                          !par
cpar     x lproc,mapiam                                             !par
c
C N.B.
C     BREAK NAMELIST/SLAGEB/ FOR ANSI LIMIT 19 CONTINUATION LINES.
C
C     J2MIN,J2MAX,JNAST,IJNAST                    !RM STGJK VARIABLES
C     MBP1MX,MBP2MX,MEKVMX             !NOT FOR USER JOE TO MESS WITH
C !TBD IMPLEMENT: QQCUTX
C
      NAMELIST/DRR/
     X JND,LCON,LINC,LMIN,LMAX,LORIG,LRANGE,
     X NMIN,NMAX,NRAD,NS0,NSW,NSX,RATN
C
      NAMELIST/SRADWIN/KEY                                 !FOR CHECK
C
      DATA QLIT/' ','0','1','2','3','4','F','S','Q','W','X'/
C
      QKCUT=ICHAR('1')
      LBLNK=ICHAR(' ')
C
      IF(MOD(MXDFS,ITWO).NE.0)THEN                         !MUST BE EVEN
        WRITE(6,*)'SET FACTORIAL ARRAY MXDFS EVEN, E.G.',MXDFS+1
        WRITE(0,*)'SET FACTORIAL ARRAY MXDFS EVEN, E.G.',MXDFS+1
        GO TO 999
      ENDIF
C
      MXDFS0=40                    !CHECK FACTORIAL ARRAY FOR STUPIDITY
      IF(MXDFS.LT.MXDFS0)THEN
        WRITE(6,*)'INCREASE FACTORIAL ARRAY TO MXDFS=',MXDFS0
        WRITE(0,*)'INCREASE FACTORIAL ARRAY, MXDFS'
        GO TO 999
      ENDIF
C
      MXDFS0=680                   !REAL *8 GOOD TO ABOUT MXDFS=680
      IF(MXDFS.GT.MXDFS0)THEN      !THIS GIVES MAX L APPROX MXDFS0/4=170
        WRITE(6,*)'DECREASE FACTORIAL ARRAY TO MXDFS=',MXDFS0
        WRITE(0,*)'DECREASE FACTORIAL ARRAY, MXDFS'
        GO TO 999
      ENDIF
C
C SOME INITIALISATIONS (MANY CAN BE SET VIA NAMELIST)
C
      btime=.false.                 !detailed structure timing
      btimex=.false.                !detailed collision timing
      iw=0                    !=0 to screen, =6 to file, if btime .true.
      iwp=0                         !just initialize for non-par common
cparc                                                               !par
cpar      iwp=6                   !suppress some screen writes      !par
cpar      lproc=0                   !nproc used for mstart=1        !par
cpar      mapiam=0          !.le.0 nprocperl;.eq.1 for 1 proc per n !par
cpar      nprocperl=1               !default, no n-parallel         !par
c
      KMAX=999                      !POSSIBLE NASTP BUFFER FOR S.S.
      KUTDSK=9999                   !VCC FOR CF.LE.KUTDSK IN MEMORY
      NSL0=0                        !LS/IC FLAG
      DC0=DONE
      NF=0
      IRET0=0
      IDW=0
      MR=10
      IDR=0
      BFOT=.FALSE.
      BMVD=.FALSE.
      KPOLE=-999
      KPOL0=-999
      KPOL1=60                        !MAX SAFE E-POLE (AVOID OVERFLOW)
      KPOLM=100
      IEQ(0)=0
      MENGB=-2
      IRLX=0
      IDIAG=0         ! TRY SR.DIAG FIRST FOR DIAGONALIZATION OF S/L**2
      ICFG=0
      QQCUT=0         ! 1 ALL 2FS, 2 SO, 3 SOO, 4 SS
      MAXLAM=1000     !MAX LAMBDA MULTIPOLE INTERACTION
      NMULTE=999      !NUMBER OF MULTIPOLES PER INTERACTION
      KUTLS=99999
      KUTM1=0
      ISCALR=0
      ITANAL=0
      ECNTRB=9999999
      LCMIN=-999
C
      INASTJ=0
      NASTJ=0
      MINJT=0
      MAXJT=2000
      NASTJP=0
      MINJTP=0
      MAXJTP=2000
      INAST=0
      NAST=0
      MINST=0
      MAXST=100
      MINLT=0
      MAXLT=1000
      IPAR=2
      NASTS=0
      MINSTS=0
      MAXSTS=100
      MINLTS=0
      MAXLTS=1000
      NASTP=0
      MINSTP=0
      MAXSTP=100
      MINLTP=0
      MAXLTP=1000
      MAXLX=MAXLT
      MAXLOO=MAXLT
      MXLAMX=1000
      MAXJFS=-999
      KUTSSX=-999
      QQCUTX=1
      KUTOOX=-999
      LFACT=100
      JFACT=200
C
      NMETA=0
      NMETAJ=0
      DO I=1,MAXSL
        NMETAG(I)=0
      ENDDO
      DO I=1,MAXJG
        NMETGJ(I)=0
      ENDDO
      ione0=0         !algxls/fs ione1, elastic needed for mixing
      ione1=1          !=1/0 exc/inc elastic transitions: idw.ne.0
C
      LCONDW=0
      LCONDWJ=0
      LRGLAM=-999     !TOP-UP FLAG (L/2J)
      LVMIN=0         !RYDBERG L-RANGE FOR THRESHOLD DW
      LVMAX=-1        !WRITES TO ADF04 FOR ADF46 BBGP USE
      btop=.true.     !fix for born top-up failure
C
      KSUBCF=999      !FULL SUBCONFIGURATION RESOLUTION
      KCUTP=-9999     !PARENT CF CORRELATION
      KCUTCC=0        !N+1 BOUND CF CORRELATION
      KCUT0=0         !CONT CORE RE-ARRANGE CORRELATION (=KCUTI)
C
C READ CODE
C CODE(1).EQ.'S.S.' FOR ORIGINAL EISSNER (SS) INPUT OF CONFIGURATIONS
C CODE(1).EQ.'A.S.' FOR OCCUPATION NUMBERS.
C CODE(2-20) FOR INFORMATION PURPOSES.
C
      READ(5,1000)COD
      WRITE(6,1001)COD
C
      CODE=COD(1)
      IF(CODE.NE.'S.S.'.AND.CODE.NE.'A.S.')THEN
        IF(CODE.EQ.'STOP')THEN                               !CANCEL JOB
          IRET0=1
          GO TO 996                                              !RETURN
        ENDIF
        WRITE(6,1002)CODE
        WRITE(0,*)"INPUT ERROR:NEED 'S.S.' OR 'A.S.' AT START OF LINE 1"
        GO TO 999
      ENDIF
C
C ORIGINAL SS INPUT (EISSNER NOTATION FOR CONFIGS)
C
      IF(CODE.EQ.'S.S.')THEN
C
        BNAME=.FALSE.
        READ(5,SALGEB,END=94)          !BUT SEE IF WE HAVE NAMELIST ELSE
        BNAME=.TRUE.
  94    REWIND(5)
        READ(5,*)
C
C IN IF-LOOP 96 CARDS ARE READ UNTIL A TERMINATOR IS FOUND
C (A CARD THAT IS BLANK IN T10,I2 IS REFERRED TO AS A C-TERMINATOR).
C
        I=0
        KH=I
  96    KG=KH
        I=I+21
        IF(I.LE.MXD08)THEN
          KF=KH+1
          KH=I
        ENDIF
C
        READ(5,150)MSTRT0,IFREE,QCS0,QCL0,XDR0,(I2I(J),C2C(J),J=1,21)
     X            ,MLIT
C
        J=0
        DO K=KF,KH
          J=J+1
          IWRK2(K)=I2I(J)
          IWRK1(K)=ICHAR(C2C(J))
        ENDDO
C
C A TERMINATOR AS FIRST CONFIGURATION CARD CANCELS THE JOB
C
        IF(IWRK2(1).EQ.0)THEN
          IRET0=1
          GO TO 996                                         !RETURN
        ENDIF
C
C OTHERWISE (T10,21(I2,Z1)) EXCEPT ON THE TERMINATOR ARE READ AS A
C STRING OF Q=MOD(C(I2),50) EQUIVALENT ELECTRONS NL=FUNCTION(C(Z1));
C Q+50 STANDS FOR: THESE Q ELECTRONS FORM A CONFIGURATION TOGETHER
C WITH WHAT STANDS LEFT OF IT.
C EXAMPLE: ' 22523 12533' IN COLUMNS 10..21 WILL BE INTERPRETED (IN
C SR ALGEB1) AS TWO CONFIGURATIONS, 2S**2+2P**2 AND 2S+2P**3,
C PROVIDED THE TERMINATOR IS BLANK IN COLUMNS 16..60; THEN K=C(Z1)=
C 1,2,3,..9,A,..F STANDS FOR 1S,2S,2P,..4D,4F,..5G.
C THE STRING MAY BE BROKEN BY A MULTIPLE OF THREE GAPS AFTER ANY
C CONFIGURATION, BUT ON THE NEXT CARD IT MUST CONTINUE IN T10,I2,Z1.
C
C MPRINT=-5,-6,-7: SAME AS 0,-1,-2 BUT KAPPA-AVERAGE RADIAL FUNCTIONS.
C
        IF(KF.EQ.1.AND..NOT.BNAME)THEN   !FIRST LINE DEFINES CONTROLS
          MPRINT=MSTRT0
          MODD=IFREE
          MLIT0(1)=MLIT(1)
          MLIT0(2)=MLIT(2)
          K1=QCS0
          K2=QCL0
          XDR=XDR0
        ENDIF
C
C ON THE SECOND AND FOLLOWING CARDS COLUMNS 1..9 AND 73..80 ARE
C IGNORED; THE LAST 8 COLUMNS OF THE FIRST CARD ARE PRINTED AT THE
C BEGINNING OF THE HEADLINE (AS LITERAL DATA); C(T1,I2)=BLANK SUP-
C PRESSES PRINTOUT OF SLATER STATES AND OF ALL ANGULAR COEFFICIENTS.
C C(T3,I2)=MODD IS INPUT TO SR VCU AND IS DESCRIBED BELOW;
C FOR THE PROBLEMS DEALT WITH HERE MODD=-1 SUFFICES.
C C(T5,I2)=K1 AND C(T7,I2)=K2 WILL BE INTERPRETED AS FOLLWS: K1..K2
C FORM A CORE CONFIGURATION C0 OF CLOSED SUBSHELLS WHICH WILL BE ADD
C ED ONTO ALL CONFIGURATIONS LISTED IN THE STRING BEHIND (AN ORBITAL
C (N,L) SPECIFIED IN BOTH PLACES WILL BE IGNORED IN THE LATTER).
C
        IF(IWRK2(KF).NE.0)GO TO 96
        IF(I.GT.MXD08)THEN                      !NOT ENOUGH BUFFER SPACE
          KGG=I
          GO TO 97
        ENDIF
C
      ELSE
C
C 'A.S.' R-MATRIX STYLE INPUT, AND SO .....
C
        BNAME=.TRUE.
C
      ENDIF
C
      IF(BNAME)THEN               !INITIALIZE CONTROLS FOR S.S. AND A.S.
C
        K1=0
        K2=0
        MPRINT=-2
        MODD=-999
        XDR=' '
        PHASE='    '
        TITLE='        '
C
      ENDIF
C
C SYNCHRONISE FILES
C
      IF(.NOT.BLOOP.OR.LSUM.LE.0)THEN
        IF(IUNIT(7).GT.0)BACKSPACE(7)
        IF(IUNIT(8).GT.0)BACKSPACE(8)
        IF(IUNIT(17).GT.0)BACKSPACE(17)
        IF(IUNIT(18).GT.0)BACKSPACE(18)
        IF(IUNIT(27).GT.0)BACKSPACE(27)
        IF(IUNIT(28).GT.0)BACKSPACE(28)
        IF(IUNIT(29).GT.0)BACKSPACE(29)
        IF(IUNIT(30).GT.0)BACKSPACE(30)
      ENDIF
C
C
      IF(CODE.EQ.'S.S.')THEN
C
C
C COLUMNS 16..60 OF THE TERMINATOR ALLOW FOR REDEFINING K=1,2,3..15:
C IF THE K'TH (I2,I1) IS NOT BLANK  NK=C(I2)+LK=C(I1) (IN ALGEB1).
C IF(T63,A1) IS NON-ZERO CODING CONTINUES ON NEXT CARD 15(I2,A1)
C COLUMNS 16 TO 60.
C THIS PROVIDES AN ALTERNATIVE DEFINITION OF ORBITALS TO SCREENING
C PARAMETER IN SR.MINIM ( IF BOTH ARE USED THE LATTER HOLDS TRUE)
C NAMELY:
C N=1-69 BOUND ORBITALS CALCULATED IN SR.RADIAL
C N=70-79 ORBITALS INPUT FROM SR.RADWIN
C N=80-89 VALENCE ORBITALS TO BE SUMMED OVER IN DR PART OF PROGRAM
C N=90-99 CONTINUUM ORBITALS CALCULATED IN SR.RADCON
C
C EVT  IF(IWRK1(KH).EQ.QX)GO TO 96 ,  WHERE  DATA..QX/'X'/.
C
        IF(.NOT.BNAME)THEN
C
C IFREE COULD SERVE TO SPECIFY INDIVIDUAL RESTARTFILES
C IF(IFREE.GT.0)MR=IFREE                   !REDEFINE RESTART UNIT NUMBER
C
          QCUT=IWRK1(KH)
          MDEL=IFREE               !OMIT RADIATION WITH N-N' .LT. MDEL
          KCUT=IWRK2(KF+1)
          IF(IWRK1(KF).EQ.QKCUT)KCUT=KCUT+100
          KUTSS=IWRK2(KH)
          MCFSS=0
C         MCFSS=IWRK2(KH-1)
C         KUTOO=0
          KUTOO=IWRK2(KH-1)
          KUTSO=IWRK2(KG+19)
          MBP1MX=-1
          MBP2MX=1
          MEKVMX=1
          BPASS=.FALSE.
        ENDIF
C
        KGG=KG+18
        I=KH
  63    IF(IWRK1(KGG).EQ.LBLNK)GO TO 61
        I=I+21
        IF(I.LE.MXD08)THEN
          KF=KH+1
          KH=I
        ENDIF
        READ(5,151)(I2I(J),C2C(J),J=1,21)
        J=0
        DO K=KF,KH
          J=J+1
          IWRK2(K)=I2I(J)
          IWRK1(K)=ICHAR(C2C(J))
        ENDDO
        IF(I.LE.MXD08)KGG=KGG+21
        GO TO 63
  61    IF(I.GT.MXD08)THEN                      !NOT ENOUGH BUFFER SPACE
          KGG=I
          GO TO 97
        ENDIF
C
      ENDIF
C
C BOTH CODES ('A.S.' IS NAME ONLY ALLOWED).
C
      IF(BNAME)THEN
C
        MSTRT0=0
        MSTART=0
        BPASS=.TRUE.
        MCFSS=0
        KUTSS=-1
        KUTSO=-1
        KUTOO=0
        MDEL=0
        KCUT=0
        QCS0=0
        QCL0=0
        QCUT=0
        CUP='  '
        RAD='  '                !TAKES DEFAULT MPRINT=-2, NONE
        RUN='  '
        KORB1=0
        KORB2=0
        KCOR1=0
        KCOR2=0
C        NAST=0
        LRANGE=-1
        BORN='  '
        BASIS='    '
        MBP1MX=-1               !MAX MULTIPOLE 1-BODY BP MK
        MBP2MX=0                !MAX MULTIPOLE 2-BODY BP MK - ONLY M1
        MEKVMX=-1               !MAX MULTIPOLE FOR EK REL VEL
        FACTL=DONE
        FACTJ=DONE
        CPU='MEM'               !OPTIMIZE FOR MEMORY ANYTHING ELSE SPEED
        TARGET='NEW'            !FLAG USE OF OLD/NEW TERMS/LEVELS FILES
        BDISK=.FALSE.           !STORE *ALL* DC ARRAY ON DISK
C
C THESE NEXT ARE ONLY USED BY 'A.S.'
C
        MXVORB=0                !MUST BE RESET
        MXCONF=0                !MUST BE RESET
        MXCCF=-999
        NXTRA=-1
        LXTRA=-1
        IFILL=-11
        LMAX=-1
        LCON=-1
        LCON0=-1                !INNER-SHELL
        LCONI=LCON0             !ALTERNATE
        KCUTI=KCUT0             !ALTERNATE
C
        JNAST=-1                !RM
        IJNAST=-1               !RM
        J2MIN=-1                !RM
        J2MAX=-1                !RM
C
C
        READ(5,SALGEB,END=997,ERR=997)    ! <------------------ NAMELIST
C
C
C SYNC. ALTERNATES
C
        LCON0=MAX(LCON0,LCONI)
        KCUT0=MAX(KCUT0,KCUTI)
        NASTJ=MAX(JNAST,NASTJ)
        INASTJ=MAX(IJNAST,INASTJ)
        MINJT=MAX(J2MIN,MINJT)
        MAXJT=MAX(J2MAX,MAXJT)
C
        MLIT0(1)=PHASE
        MLIT(1)=TITLE(1:4)
        MLIT(2)=TITLE(5:8)
C
C SET MAIN "RUN" SWITCHES:
C
        BDR=RUN.EQ.'DR'.OR.RUN.EQ.'RR'.OR.RUN.EQ.'RE'.OR.RUN.EQ.'PE'
        BFOT=BFOT.OR.RUN.EQ.'RR'.OR.RUN.EQ.'PI'
C
C HISTORIC READ TOO LATE FOR LCON & LMAX...(ALTHOUGH ALSO IN SALGEB NOW)
C
        IF(BDR)THEN
          IDR=1                                     !FLAG EXPECT RYDBERG
          READ(5,DRR,END=998,ERR=998)             !case LCON only in DRR
          REWIND(5)                                      !REPOSITION FOR
          READ(5,SALGEB)                             !NON-NAMELIST READS
c          if(lcon.gt.0)lcon=2*(lcon/2)+1                    !ensure odd
        ENDIF
C
        IF(CODE.EQ.'A.S.'.AND.MXVORB.GT.0)THEN  !CHECK FOR ANY (ILLEGAL)
C                                               !ORBITAL FLAGS
          IF(KCOR2.LT.0)THEN
            MXVORB=MXVORB-KCOR2
          ELSEIF(KORB2.LT.0)THEN
            MXVORB=MXVORB-KORB2
          ENDIF
          ALLOCATE (ITMP(MXVORB))
          READ(5,*)(ITMP(I),JTMP,I=1,MXVORB)
          IFLAG100=0
          IFLAG70=0
          IFLAG60=0
          IFLAG00=0
          DO I=MXVORB,1,-1
            IF(ITMP(I).GE.100)IFLAG100=ITMP(I)
            IF(ITMP(I).GE.80.AND.ITMP(I).LE.89)IDR=1    !RYDBERG PRESENT
            IF(ITMP(I).GE.70.AND.ITMP(I).LE.79)IFLAG70=ITMP(I)
            IF(ITMP(I).GE.60.AND.ITMP(I).LE.69)IFLAG60=ITMP(I)
            IF(ITMP(I).LE.0)IFLAG00=ITMP(I)
          ENDDO
          DEALLOCATE (ITMP)
C
          IF(IFLAG00.NE.0)THEN
            WRITE(6,700)IFLAG00
            WRITE(0,*)'*** ERROR: ILLEGAL INPUT N-VALUE=',IFLAG00
          ENDIF
          IF(IFLAG100.GT.0)THEN
            WRITE(6,701)IFLAG100
            WRITE(0,*)'*** ERROR: UNSUITABLE INPUT N-VALUE=',IFLAG100
          ENDIF
          IF(IFLAG70.GT.0)THEN
            KEY=0
            READ(5,SRADWIN,END=111,ERR=111)
  111       IF(IUNIT(12).EQ.0.AND.KEY.NE.-10)THEN
              WRITE(6,702)IFLAG70
              WRITE(0,*)'*** ERROR: NO radwin FILE FOUND FOR N-VALUE='
     X       ,IFLAG70
            ELSE
              IFLAG70=0
            ENDIF
          ENDIF
          IF(IFLAG60.GT.0)THEN
            WRITE(6,703)IFLAG60
            WRITE(0,*)'*** ATTENTION: USER INPUT N-VALUE=',IFLAG60
     X      ,' IS RESERVED...'
          ENDIF
C
          REWIND(5)                                      !REPOSITION FOR
          READ(5,SALGEB)                             !NON-NAMELIST READS
C
          IF(ABS(IFLAG00)+IFLAG70+IFLAG100.GT.0)THEN
            NF=-1
            GO TO 995
          ENDIF
C
        ENDIF
        LCONT=LCON
C
C NOW SAFE TO REDEFINE NAMELIST VARIABLES
C
        IF(MSTART.NE.0)MSTRT0=MSTART                     !RESTART SWITCH
C
        IF(CPU.NE.'MEM')DC0=-DONE           !THEN OPTIMIZE VCC FOR SPEED
C
        IF(KUTDSK.LT.0)KUTDSK=0
        IF(BDISK.AND.KUTDSK.EQ.999)KUTDSK=0
C        IF(MSTRT0.GE.5)KUTDSK=999
c
        ione1=mod(abs(ione1),itwo)        !in/exclude elastic EIE
C
        IF(MAXLAM.LT.0)THEN                !HISTORIC USER FLAG NO CF-MIX
          MAXLAM=-MAXLAM
          IF(KUTLS.EQ.99999)THEN           !SET DIAG/ON/FS FLAG
            KUTLS=-1
          ELSE
            WRITE(0,*)'NOTE: USER SETTING OF KUTLS OVERRIDES MAXLAM < 0'
            WRITE(6,*)'NOTE: USER SETTING OF KUTLS OVERRIDES MAXLAM < 0'
          ENDIF
        ENDIF
C
        IF(KPOLE.LT.-100.AND.NMULTE.GT.100)NMULTE=7 !RESTRICT NO. LAMDAS
c weak high-l ic transitions need nmulte=l+1, where l=ql(n)/2 orbital-l,
c at least if PWB is anything to go by.
C
        IF(KUTLS.LT.0)THEN
          WRITE(0,*)
     X        '*** SR.ALGEB: ATTENTION, CI-MIXING WITHIN A CONFIG ONLY!'
          WRITE(6,*)
     X        '*** SR.ALGEB: ATTENTION, CI-MIXING WITHIN A CONFIG ONLY!'
          KUTLS=-1
          IF(KUTSO.LT.-1.OR.KUTSO.EQ.0)THEN
            KUTSO=-1
            WRITE(0,*)
     X     '*** WARNING: ONE-BODY FINE-STRUCTURE IS NOW RESTRICTED TO '
            WRITE(0,*)
     X     '    BEING *WITHIN* A CONFIGURATION AS KUTLS OVERRIDES KUTSO'
            WRITE(6,*)
     X  '*** WARNING: KUTLS RESTRICTS ONE-BODY FINE-STRUCTURE TO BEING'
     X              ,' *WITHIN* A CONFIGURATION, RESETTING KUTSO=',KUTSO
          ENDIF
          IF(KUTSS.LT.-1)THEN
            IF(KUTSS.EQ.-9)THEN
              KUTSS=999                                           !MAXCF
            ELSE
              KUTSS=-KUTSS
            ENDIF
            WRITE(0,*)
     X     ' *** WARNING: TWO-BODY FINE-STRUCTURE IS NOW RESTRICTED TO '
            WRITE(0,*)
     X    '     BEING *WITHIN* A CONFIGURATION AS KUTLS OVERRIDES KUTSS'
            WRITE(6,*)
     X  ' *** WARNING: KUTLS RESTRICTS TWO-BODY FINE-STRUCTURE TO BEING'
     X              ,' *WITHIN* A CONFIGURATION, RESETTING KUTSS=',KUTSS
          ENDIF
        ENDIF
C
        IF(KUTOO.EQ.-1)KUTOO=0
C
COLD        IF(IFILL.LT.0)IFILL=11      !NOW LET SR.CONFG USE NXCITE(CF)
C
C CANNOT DIFFERENTIATE BETWEEN USER OMISSION OF ICFG AND SCRIPTGENERATED
C STRUCTURE INPUT FOR SUBSEQUENT DR RUN. WRITEUP IS PLAIN...
C
        IF(MOD(MXCCF,I999).LT.0.AND.MOD(ICFG,ITEN).EQ.0)THEN
c          WRITE(0,*)
c     X        'NOTE: REQUIRE N-CFG ICFG.NE.0 TO AUTO-GENERATE N+1 CFGS'
          WRITE(6,*)
     X         'NOTE: REQUIRE N-CFG ICFG.NE.0 TO AUTO-GENERATE N+1 CFGS'
     X                    ,' (CASE MXCCF.LT.0)'
        ENDIF
C
C PROCESS RUN OPTIONS:
C              (DR, RR, PE, PI, DE, RE, YLD - ALLOWED, DI NOT YET CODED)
C
        IF(RUN.EQ.'DIM'.OR.RUN.EQ.'DIM0'.OR.
     X     RUN.EQ.'DIM1'.OR.RUN.EQ.'DIM2')THEN            !MUST OVERRIDE
          RAD3=RUN
          RAD=RAD3
          RUN='   '
        ENDIF
C
        IF(RUN.NE.'  ')THEN             !CHECK FOR ALLOWED RUN VALUE
          IF(.NOT.BDR.AND..NOT.BFOT)THEN
            IF(RUN.EQ.'DI')THEN
              WRITE(6,*)'*** DIRECT ELECTRON IONIZATION NOT YET CODED'
              WRITE(0,*)'*** DIRECT ELECTRON IONIZATION NOT YET CODED'
              GO TO 999
            ENDIF
            IF(RUN.EQ.'REDA')THEN      !'YLD' SHOULD NOT NEED A FLAG NOW
              WRITE(6,*)"*** RUN REDA AS 'RE' THEN 'YLD'"
              WRITE(0,*)"*** RUN REDA AS 'RE' THEN 'YLD'"
              GO TO 999
            ENDIF
            IF(RUN.NE.'YLD'.AND.RUN.NE.'BBGP'.AND.RUN.NE.'DE')THEN
              WRITE(0,1200)
              WRITE(6,1200)
              WRITE(6,*)'*** UNRECOGNIZED RUN OPTION: "',RUN,'"'
              WRITE(0,*)'*** UNRECOGNIZED RUN OPTION'
              GO TO 999
            ENDIF
          ENDIF
        ENDIF
C
        IF(RUN.EQ.'PE')THEN
          IDR=-1
          RUN='DR'      !PE JUST INVERSE OF DR
        ENDIF
C
        IF(RUN.EQ.'BBGP')THEN
          RUN='DE'
          IF(LVMAX.LT.0)LVMAX=8
        ENDIF
C
        IF(RUN.EQ.'DE')THEN
          LVMAX=MIN(LVMAX,I20)
          BTHRSH=LVMAX.GE.0.AND.LVMAX.GE.LVMIN
          IF(BTHRSH)LVMIN=MAX(IZERO,LVMIN)
        ELSE
          BTHRSH=.FALSE.
        ENDIF
        IF(.NOT.BTHRSH)THEN
          LVMAX=-1
          LVMIN=0
        ENDIF
C
        IF(RUN.EQ.'DE')IDW=1
        IF(RUN.EQ.'DI')IDW=2
C
        if(mstrt0.ne.0.and.IDW.NE.0)
     x     stop "temp: restart not yet coded for RUN='DE' OR 'DI'"
C
        IF(IDW.NE.0.AND.KUTLS.LT.0)THEN
          WRITE(6,*)
     X     '*** ELECTRON IMPACT EXCITATION NOT YET CODED FOR KUTLS.LT.0'
     X    ,', RE-SETTING KUTLS=0'
          WRITE(0,*)
     X     '*** ELECTRON IMPACT EXCITATION NOT YET CODED FOR KUTLS.LT.0'
     X    ,', RE-SETTING KUTLS=0'
          KUTLS=0
        ENDIF
C
C HISTORIC DIMENSION CHECK MODE IS OBSOLETE - (NOW) ONLY 10% FASTER BUT
C SIGNIFICANTLY OVERESTIMATED SOME DIMENSIONS. AN ACCURATE, BUT PARTIAL,
C DIMENSION CHECK HAS BEEN INTRODUCED INSTEAD.
C
C N.B. E1 OR E2 IS NO LONGER RELEVANT SINCE, LIKE MANY OTHER DIMENSIONS,
C ASSOCIATED ARRAYS ARE ALL ALLOCATABLE. DIMENSION CHECK JUST PICKS-UP
C THE CURRENT REMAINING (ALGEBRAIC) DIMENSIONS THAT ARE NOT FULLY
C ALLOCATABLE.
C
        IF(RAD.EQ.'DIM'.OR.RAD.EQ.'DIM1')MPRINT=-4  !E1 DIMENSION CHECK
        IF(RAD.EQ.'DIM0'.OR.RAD.EQ.'DIM2')MPRINT=-3 !E2 DIMENSION CHECK
        IF(MPRINT.EQ.-3.OR.MPRINT.EQ.-4)THEN
          RAD3=RAD
          RAD=RAD3
        ENDIF
C
        IFLAG=0
        IF(RAD.EQ.'DIM')THEN
          RAD='  '
          IF(IDW.NE.0)THEN
            IDW=-ABS(IDW)
          ELSE
            IFLAG=1
          ENDIF
        ENDIF
        IF(IDW.LT.0)THEN
          IDW=-IDW
          IFLAG=-1
        ENDIF
        IF(IFLAG.EQ.1)THEN
          WRITE(0,*)'NOTE: THIS IS ONLY A *PARTIAL* DIMENSION TEST'
          WRITE(6,1120)
        ENDIF
        IF(IFLAG.EQ.-1)THEN
          WRITE(0,*)'CURRENTLY, THERE IS NO DIMENSION CHECK MODE HERE..'
          WRITE(6,1121)
        ENDIF
C
C SET BORN SWITCHES (INTERACTS WITH RAD)
C
        IF(RAD.EQ.'NO')THEN
          IF(BORN.EQ.'  ')BORN='NO'
          IF(BORN.NE.'NO')THEN
            WRITE(6,*)'***SWITCHING-OFF BORN SINCE RAD.EQ."NO"'
            WRITE(0,*)'***SWITCHING-OFF BORN SINCE RAD.EQ."NO"'
            BORN='NO'
          ENDIF
        ENDIF
        IF(RAD.EQ.'ALL')THEN
          IF(BORN.NE.'YES'.AND.BORN.NE.'NO')BORN='INF'
          IF(BORN.EQ.'NO')MENGB=-1
          KPOLM=MIN(KPOLM,IFIVE)
          RAD='BP'
        ENDIF
        IF(IDW.EQ.0)THEN
          IF(BORN.EQ.'  ')BORN='NO'
          IF(RUN.NE.'  '.AND.BORN.NE.'NO')THEN
            WRITE(6,*)'***SWITCHING-OFF BORN SINCE RUN.NE." "'
            WRITE(0,*)'***SWITCHING-OFF BORN SINCE RUN.NE." "'
            BORN='NO'
          ENDIF
        ELSE
          IF(BTHRSH)THEN
            IF(LRGLAM.GT.0)THEN
              WRITE(6,*)'***SWITCHING-OFF TOP-UP SINCE NONE FOR'
     X           ,' THRESHOLD PARTIAL COLLISION STRENGTHS (LVMAX.GE.0)'
              WRITE(0,*)'***SWITCHING-OFF TOP-UP SINCE NONE FOR'
     X           ,' THRESHOLD PARTIAL COLLISION STRENGTHS (LVMAX.GE.0)'
            ENDIF
            LRGLAM=-2
          ENDIF
          IF(BORN.EQ.'YES')THEN
           WRITE(6,*)'*** CANNOT GENERATE FINITE ENERGY BORN WITH RUN="'
     X      ,RUN,'"'
            WRITE(6,*)'*** SWITCHING OFF FINITE ENERGY BORN...'
            WRITE(0,*)'*** SWITCHING OFF FINITE ENERGY BORN...'
            BORN='INF'
          ELSEIF(BORN.EQ.'NO')THEN
            MENGB=-1                             !GET DIPOLE & FLAG BORN
            IF(RAD.EQ.'NO')THEN
              ITEST=ABS(INAST)+ABS(INASTJ)
              IF(LRGLAM.GT.0.OR.LRGLAM.EQ.-999.AND.ITEST.EQ.0)THEN
                WRITE(6,*)'*** DIPOLE LIMIT REQUIRED FOR TOP-UP'
     X          ,', SWITCHING-ON RADIATION, SWITCH-OFF TOP-UP IF'
     X          ,' REALLY WANT RAD="NO"'
                WRITE(0,*)'*** SWITCHING-ON DIPOLE LIMIT FOR TOP-UP'
                KPOLE=1
              ELSE
                MENGB=-2
                WRITE(0,*)'*** NO ADF04 AS RAD="NO" !!!'
              ENDIF
            ELSE
              IF(BTHRSH)THEN
                IF(MPRINT.GE.0)THEN
                  KPOLE=MAX(KPOLE,ITWO)
                ELSE
                  KPOLE=MAX(KPOLE,IONE)
                ENDIF
              ENDIF
              WRITE(6,*)'*** INFINITE ENERGY BORN REQUIRED FOR A'
     X        ,' COMPLETE ADF04, PRESSING ON REGARDLESS...'
              WRITE(0,*)'*** ADF04 INCOMPLETE AS BORN="NO" !!!'
            ENDIF
          ELSE
            BORN='INF'
          ENDIF
        ENDIF
        IF(BORN.EQ.'YES')MENGB=0                   !FINITE ENERGY BORN
        IF(BORN.EQ.'INF')MENGB=1                   !INFINITE ENERGY BORN
        IF(MENGB.LT.0.AND.BORN.NE.'NO')THEN
          WRITE(6,*)'*** UNRECOGNIZED BORN OPTION: "',BORN,'"'
          WRITE(0,*)'*** UNRECOGNIZED BORN OPTION!'
          GO TO 999
        ENDIF
        if(rad.eq.'NO'.and.born.eq.'NO'.and.mprint.gt.0)kpole=-1
C
C SET RELAXED ORBITAL SWITCHES:
C NEW ORBITAL BASIS FOR EACH CFG 'RLX', OR GROUP OF CFGS 'SRLX'.
C
        IF(BASIS.EQ.'RLX'.OR.BASIS.EQ.'RLX1'.OR.BASIS.EQ.'RLX2')THEN
          IEQ(0)=-1
          IRLX=1                                       !DEFAULT
          IF(BASIS.EQ.'RLX2')THEN                      !EXCEPT
            IRLX=2
            IF(IDW.NE.0)THEN
              WRITE(6,*)"*** NOTE: BASIS='RLX2' TARGET OVERLAP MATRIX",
     X        "IS APPLIED TO TARGET H ONLY, NOT THE SCATTERING MATRIX"
               WRITE(0,*)"*** NOTE: BASIS='RLX2' TARGET OVERLAP MATRIX",
     X        "IS APPLIED TO TARGET H ONLY, NOT THE SCATTERING MATRIX"
            ENDIF
          ENDIF
        ELSEIF(BASIS.EQ.'SRLX')THEN
          IF(CODE.EQ.'S.S.')THEN
            WRITE(6,*)
     X          "*** CANNOT USE BASIS='SRLX' WITH S.S. INPUT - USE A.S."
            WRITE(0,*)
     X          "*** CANNOT USE BASIS='SRLX' WITH S.S. INPUT - USE A.S."
            GO TO 999
          ENDIF
          IEQ(0)=1
          IF(KCOR1.LT.0.OR.KORB1.LT.0)IRLX=-1          !NON-UNIQUE CORE
        ELSEIF(BASIS.NE.'    ')THEN
          WRITE(6,*)'*** UNRECOGNIZED BASIS OPTION: "',BASIS,'"'
          WRITE(0,*)'*** UNRECOGNIZED BASIS OPTION!'
          GO TO 999
        ENDIF
        IF(IEQ(0).NE.0)MDEL=0      !FORCE OFF SINCE USES NEL, NEVER USED
C
C SET COUPLING SWITCHES
C
        IF(CUP.EQ.'CA'.OR.CUP.EQ.'CAR'.OR.CUP.EQ.'CAM')THEN
          NSL0=-1                            !FLAG CONFIGURATION-AVERAGE
          IF(KUTOO.NE.0)THEN
            WRITE(0,*)' *** SWITCHING-OFF KUTOO AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF KUTOO AS CUP=',CUP
            KUTOO=0
          ENDIF
          IF(KUTSS.NE.-1)THEN
            WRITE(0,*)' *** SWITCHING-OFF KUTSS AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF KUTSS AS CUP=','"',CUP,'"'
            KUTSS=-1
          ENDIF
          IF(KUTSO.NE.-1)THEN
            WRITE(0,*)' *** SWITCHING-OFF KUTSO AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF KUTSO AS CUP=','"',CUP,'"'
            KUTSO=-1
          ENDIF
          IF(RAD.NE.'YES'.AND.RAD.NE.'NO'.AND.RAD.NE.'  '.AND.
     X       RAD.NE.'E1'.AND.RAD.NE.'E2'.AND.RAD.NE.'E3'.AND.RAD.NE.'E4'
     X                .AND.RAD.NE.'DIM1'.AND.RAD.NE.'DIM2')THEN
            WRITE(0,*)'*** ILLEGAL RAD OPTION FOR CUP="CA"...'
            WRITE(6,*)'*** ILLEGAL RAD OPTION: "',RAD,'" FOR CUP=',CUP
            GO TO 999
          ENDIF
          IF(MSTRT0.NE.0)THEN
            WRITE(0,*)' *** SWITCHING-OFF RESTART AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF RESTART AS CUP=','"',CUP,'"'
            MSTRT0=0
          ENDIF
          IF(KUTLS.LE.0)THEN
            WRITE(0,*)' *** SWITCHING-OFF KUTLS AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF KUTLS AS CUP=','"',CUP,'"'
            KUTLS=1
          ENDIF
          IF(KCUT.NE.0.OR.KCUTCC.NE.0.OR.KCUTP.NE.-9999)THEN
            WRITE(0,*)' *** SWITCHING-OFF ALGEBRAIC CORRELATION AS CUP='
     X               ,'"CA"...'
            WRITE(6,*)' *** SWITCHING-OFF ALGEBRAIC CORRELATION AS CUP='
     X               ,'"',CUP,'"'
            KCUT=0
            KCUTP=0
            KCUTCC=0
          ENDIF
          if(ione1.eq.0)then
            WRITE(0,*)' *** SWITCHING-OFF ELASTIC AS CUP="CA"...'
            WRITE(6,*)' *** SWITCHING-OFF ELASTIC AS CUP=','"',CUP,'"'
            ione1=1
          endif
          IF(CUP.EQ.'CAR')THEN
            CUP='LSR'
          ELSEIF(CUP.EQ.'CAM')THEN
            CUP='LSM'
          ELSE
            CUP='LS'
          ENDIF
        ENDIF
C
        IF(CUP.EQ.'  '.AND.MODD.EQ.-999)CUP='LS'
        IF(CUP.EQ.'LS'.AND.KUTOO.NE.0)THEN
          WRITE(0,*)" *** SWITCHING-OFF KUTOO AS CUP='LS' ..."
          WRITE(6,*)" *** SWITCHING-OFF KUTOO AS CUP='LS' ..."
          KUTOO=0
        ENDIF
C
        BMVD=CUP.EQ.'LSM'.OR.CUP.EQ.'MVD'
        IF(BMVD)THEN
          CUP='LS'
        ELSE
          BMVD=CUP.EQ.'ICM'
          IF(BMVD)CUP='IC'
        ENDIF
C
        IF(CUP.EQ.'JK'.OR.CUP.EQ.'jK')THEN
          IF(IDW.EQ.0)WRITE(6,*)'*** JK-COUPLING NOT USED FOR A ',
     X                          'STRUCTURE RUN, SWITCHING TO IC'
          CUP='IC'         !IF IDW.NE.0 WE ONLY HAVE JK, NO NEED TO FLAG
        ENDIF
        IF(CUP.EQ.'JKR'.OR.CUP.EQ.'jKR')THEN
          IF(IDW.EQ.0)WRITE(6,*)'*** JK-COUPLING NOT USED FOR A ',
     X                          'STRUCTURE RUN, SWITCHING TO ICR'
          CUP='ICR'        !IF IDW.NE.0 WE ONLY HAVE JK, NO NEED TO FLAG
        ENDIF
C
        IF(CUP.EQ.'LS'.OR.CUP.EQ.'LSR')MODD=-2
        IF(CUP.EQ.'IC'.OR.CUP.EQ.'ICR')MODD=-1
C
        IF(MODD.EQ.-999)THEN
          WRITE(6,*)'*** UNRECOGNIZED CUP OPTION: "',CUP,'"'
          WRITE(0,*)'*** UNRECOGNIZED CUP OPTION'
          GO TO 999
        ENDIF
C
C SET RADIATION SWICTHES
C
        IF(RAD.EQ.'LANDE')THEN
          ione1=0                                          !need elastic
          RAD='M1'               !set ione1 manually for alternative RAD
        ENDIF
C
        IF(MBP2MX.GT.1)THEN
          WRITE(6,*)'*** ERROR: 2-BODY BP CORRECTION TO M1 ONLY, NOT: M'
     X            ,MBP2MX
          WRITE(0,*)' *** ERROR: 2-BODY BP CORRECTION TO M1 ONLY'
          GO TO 999
        ENDIF
        IF(MEKVMX.GT.1)THEN
          WRITE(6,*)' *** ERROR: BP CORRECTION TO E1 VEL ONLY, NOT: E',
     X            MEKVMX
          WRITE(0,*)' *** ERROR: BP CORRECTION TO E1 VEL ONLY'
          GO TO 999
        ENDIF
C        IF(RAD.NE.'  '.AND.MBP1MX.LT.0)MBP1MX=0
C
        IF(RAD.EQ.'BP1')THEN
          MBP1MX=0
          MBP2MX=-1
          MEKVMX=1
          RAD='M2'
        ENDIF
        IF(RAD.EQ.'BP'.OR.RAD.EQ.'BP2')THEN
          MBP1MX=0
c          MBP1MX=2
          MBP2MX=1
          MEKVMX=1
          RAD='M2'
        ENDIF
        IF(RAD.EQ.'M1BP')THEN
          MBP1MX=0
          MBP2MX=1
          MEKVMX=1
          RAD='M1'
        ENDIF
        IF(RAD.EQ.'M2BP')THEN
          MBP1MX=2
          MBP2MX=1
          MEKVMX=1
          RAD='M2'
        ENDIF
        IF(RAD.EQ.'M3BP')THEN
          MBP1MX=3
          MBP2MX=1
          MEKVMX=1
          RAD='M3'
        ENDIF
        IF(RAD.EQ.'M1')THEN
          IF(KPOLM.GE.100)KPOLM=1
          RAD='E2'
        ENDIF
        IF(RAD.EQ.'M2')THEN
          IF(KPOLM.GE.100)KPOLM=2
          RAD='E3'
        ENDIF
        IF(RAD.EQ.'M3')THEN
          IF(KPOLM.GE.100)KPOLM=3
          RAD='E4'
        ENDIF
C
        IF(RAD.NE.'YES'.AND.RAD.NE.'NO'.AND.RAD.NE.'  '.AND.
     X     RAD.NE.'E1'.AND.RAD.NE.'E2'.AND.RAD.NE.'E3'.AND.RAD.NE.'E4'
     X                .AND.RAD.NE.'DIM1'.AND.RAD.NE.'DIM2')THEN
          WRITE(6,*)'*** UNRECOGNIZED RAD OPTION: "',RAD,'"'
          WRITE(0,*)'*** UNRECOGNIZED RAD OPTION'
          GO TO 999
        ENDIF
C
        IF(KPOLE.GT.KPOL1)THEN           !USER ASKING FOR V LARGE E-POLE
          WRITE(0,*)
     X      '*** DO YOU REALLY NEED ALL THESE MULTIPOLES? KPOLE=',KPOLE
          WRITE(0,*)
     X      '*** REDUCING KPOLE TO A SAFE VALUE (AVOID OVERFLOW) KPOLE='
     X      ,KPOL1
          WRITE(6,*)
     X      '*** DO YOU REALLY NEED ALL THESE MULTIPOLES? KPOLE=',KPOLE
          WRITE(6,*)
     X      '*** REDUCING KPOLE TO A SAFE VALUE (AVOID OVERFLOW) KPOLE='
     X      ,KPOL1
          KPOLE=KPOL1
        ENDIF
C
        IF(MENGB.GE.-1)THEN
          IF(KPOLE.LT.-100)THEN
             KPOLE=6
             IF(MENGB.GE.0)KPOLE=KPOL1      !NOW RESTRICT BORN IN ALGEB2
          ENDIF
          KPOL0=MAX(IZERO,KPOL0)
          IF(IDW*KPOLM.GE.100)KPOLM=1
          MPRINT=MAX(IZERO,MPRINT)
        ENDIF
C
        IF(MPRINT.EQ.-2.AND.(BFOT.OR.RUN.EQ.'DR'.OR.RUN.EQ.'YLD'))THEN
          IF(RAD.EQ.'  ')THEN
            KPOLE=MAX(IONE,KPOLE)                          !SWITCH-ON E1
            IF(KPOL0.LT.-100)KPOL0=-1                      !SWITCH-ON E1
          ELSEIF(RAD.EQ.'NO')THEN
            WRITE(6,*)" ***ATTENTION: YOU HAVE SET RUN.EQ.'",RUN
     X  ,"' BUT ALSO RAD.EQ.'",RAD,"', WHICH DOESN'T MAKE MUCH SENSE..."
            WRITE(0,*)'***ATTENTION: YOU HAVE SET A RUN/RAD COMBINATION'
     X      ,' WHICH DOES NOT MAKE MUCH SENSE...'
            GO TO 999
          ENDIF
        ENDIF
C
        IF(RAD.EQ.'E1'.OR.RAD.EQ.'YES')KPOLE=MAX(IONE,KPOLE)
        IF(RAD.EQ.'E2')KPOLE=MAX(ITWO,KPOLE)
        IF(RAD.EQ.'E3')KPOLE=MAX(ITHREE,KPOLE)
        IF(RAD.EQ.'E4')KPOLE=MAX(IFOUR,KPOLE)
        IF(KPOLM.GE.100)KPOLM=KPOLE-1
        MPOLE=2*KPOLE        !KPOLE=EK
        MPOL00=2*KPOL0
        MPOLM=2*KPOLM        !KPOLM=MK
c        IF(MBP1MX.LT.0.AND.MBP2MX.GT.0)MBP1MX=0
c        IF(MPOLM.LE.2.AND.MBP1MX.EQ.0.AND.MBP2MX.EQ.0)MBP1MX=-1
c        write(0,*)mbp1m,mbp2mx,kpolm
        MBP1MX=2*MBP1MX
        MBP2MX=2*MBP2MX
        MEKVMX=2*MEKVMX
        IF(KPOLE.EQ.1)MPRINT=MAX(-IONE,MPRINT)
        IF(KPOLE.GT.1)MPRINT=MAX(IZERO,MPRINT)
        QCUT=ICHAR(QLIT(QCUT))                !OLD M1+BP CUT
C
C SET "DW" SWITCHES
C
        IF(IDW.NE.0)THEN
          BPASS=.FALSE.                           !NEED DC ARRAY WRITTEN
          RUN='  '
          IF(FACTL.GT.1.D0.AND.FACTL.LT.1.26D0)LFACT=NINT(100*FACTL)
          IF(FACTJ.GT.1.D0.AND.FACTJ.LT.1.26D0)JFACT=NINT(200*FACTJ)
          IF(MXCCF.GT.0)THEN
            WRITE(6,*)' ***ATTENTION: YOU HAVE SPECIFIED CORRELATION ',
     X      'CONFIGS FOR DIRECT EXCITATION...ATTEMPTING TO IGNORE THEM!'
            WRITE(0,*)' ***ATTENTION: YOU HAVE SPECIFIED CORRELATION ',
     X      'CONFIGS FOR DIRECT EXCITATION...ATTEMPTING TO IGNORE THEM!'
          ENDIF
          IF(NMETA.LE.0)THEN
            IF(BTHRSH)THEN
              NMETA=MAXTM           !all for Augers
            ELSE
              NMETA=1               !defaults to ground term
            ENDIF
          ENDIF
          IF(NMETAJ.eq.0)THEN
            IF(BTHRSH)THEN
              NMETAJ=MAXLV-1        !all for Augers
            ELSE
              NMETAJ=MAXLV+1        !defaults to levels of ground term
            ENDIF
          ENDIF
          if(nmetaj.gt.0)then       !omit 2fs between excited terms
            nmetag(0)=-1            !that only s.o. mix with metastables
          else                      !include all allowed by a.m. selectn
            nmetag(0)=0
            nmetaj=-nmetaj
          endif
        ELSE
          IF(BDR.OR.MXCCF.GT.0)THEN
            NMETA=0
            NMETAJ=0
          ELSE
            IF(NMETA.LT.0)NMETA=0
            IF(NMETAJ.LT.0)NMETAJ=MAXLV+1
          ENDIF
        ENDIF
C
C        NMETA=MAX(NMETA,0)
C        NMETA=MIN(NMETA,MAXTM)
        IF(ABS(MODD).GT.1)NMETAJ=0
C
        IF(TARGET.EQ.'OLD')THEN
          NMETA=-NMETA
          NMETAJ=-NMETAJ
        ELSEIF(TARGET.NE.'NEW'.AND.TARGET.NE.'   ')THEN
          WRITE(6,*)'*** UNRECOGNIZED TARGET OPTION: "',TARGET,'"'
          WRITE(0,*)'*** UNRECOGNIZED TARGET OPTION'
          GO TO 999
        ENDIF
C
C SET K2.LT.0 TO READ ALL NL DEFN'S BUT ONLY VALENCE OCCUPATION NOS.
C
        IF(KORB1.GT.0)K1=KORB1
        IF(KORB2.NE.0)K2=KORB2
        IF(KCOR1.GT.0)K1=KCOR1
        IF(KCOR2.NE.0)K2=KCOR2
        K1=ABS(K1)
c misc
        iw=abs(6*(mod(iw,iseven)/6))
        iwp=abs(6*(mod(iwp,iseven)/6))
C
      ENDIF
C
C END OF MAIN BNAME READS
C
      KCUTP0=KCUTP
      IF(KCUTP.EQ.-9999)THEN
        KCUTP=KCUT
      ELSEIF(KCUT.NE.KCUTP)THEN
        WRITE(6,*)' ***ATTENTION: YOU HAVE SPECIFIED KCUTP .NE. KCUT...'
     X           ,KCUTP,KCUT,' I HOPE YOU KNOW WHAT YOU ARE DOING!'
        WRITE(0,*)' ***ATTENTION: YOU HAVE SPECIFIED KCUTP .NE. KCUT...'
      ENDIF
C
      KCUTX=KCUT                                !<0 KEEP DW CORR.-CORR.
      KCUT=ABS(KCUT)
      KCUTP=ABS(KCUTP)                          !ONLY SIGN OF KCUT FLAGS
      KCUTCC=ABS(KCUTCC)                        !ONLY SIGN OF KCUT FLAGS
C
      IF((KCUT+KCUTP+KCUTCC)*KUTLS.LT.0)THEN
        WRITE(6,*)' ***ATTENTION: YOU HAVE FLAGGED CORRELATION CONFIGS'
     X           ,' AND SINGLE CONFIG MIXING...'
        WRITE(0,*)' ***ATTENTION: YOU HAVE SPECIFIED KCUT AND KUTLS...'
      ENDIF
C
      IF(KPOLE.LT.-100)MPOLE=4                  !2K-POLE
      IF(KPOL0.LT.-100)MPOL00=2
      IF(MDEL.GT.0)MDEL=1                       !JAC-DIAG
C
      IF(XDR.EQ.'X'.OR.XDR.EQ.'P')THEN          !XDR IS HISTORIC
        BDR=.TRUE.
        IDR=1
      ENDIF
      IF(XDR.EQ.'F'.OR.XDR.EQ.'P')BFOT=.TRUE.
C
C      MTEST=MPRINT
C      IF(BFOT.AND.MTEST.EQ.0)MPRINT=-1
C      IF(BFOT.AND.MTEST.EQ.-5)MPRINT=-6
      NPRINT=MPRINT
      MPRINT=MOD(MPRINT,IFIVE)
      MPRNT0=MPRINT
      MOD0=MODD
      BREL=NPRINT.LT.-4.OR.CUP.EQ.'ICR'.OR.CUP.EQ.'LSR'     !HISTORIC...
C                                              !SHOULD BE SET IN SRADCON
C SET PHASE CONVENTION
C  DEFAULT: CONDON & SHORTLEY. FANO NOT CODED FOR 2FS
C
      BFANO=MLIT0(1).EQ.'FANO'
      IF(BFANO)THEN
        IF(KUTSS.NE.-1.AND.ABS(MODD).LE.1)THEN !2-FS NOT CODED FOR FANO
          WRITE(6,*)'CANNOT USE FANO PHASE WITH 2-BODY F-S'
          WRITE(0,*)'CANNOT USE FANO PHASE WITH 2-BODY F-S'
          GO TO 999
        ENDIF
        IF(IDW.NE.0)THEN                        !DW NOT CODED FOR FANO
          WRITE(6,*)'CANNOT USE FANO PHASE WITH DW DIRECT EXCITATION'
          WRITE(0,*)'CANNOT USE FANO PHASE WITH DW DIRECT EXCITATION'
          GO TO 999
        ENDIF
        WRITE(6,145)
      ENDIF
      IF(BNAME)THEN                            !NOW OVERWRITE WITH TITLE
        MLIT0(1)=MLIT(1)
        MLIT0(2)=MLIT(2)
      ENDIF
C
C RESET -1 TO 0, I.E. -1 SWITCHES-OFF 2NFS C.F. KUTSS.
      IF(KUTOO.EQ.-1)KUTOO=0
C
      IF(KUTSO.EQ.-1.AND.KUTSS.EQ.-9)THEN        !WARN USER
        WRITE(0,*)
     X' *** WARNING: TWO-BODY FINE-STRUCTURE IS NOW RESTRICTED TO BEING'
        WRITE(0,*)
     X'        *WITHIN* A CONFIGURATION AS KUTSO=-1 OVERRIDES KUTSS=-9'
        WRITE(6,*)
     X' *** WARNING: TWO-BODY FINE-STRUCTURE IS NOW RESTRICTED TO BEING'
     X,' *WITHIN* A CONFIGURATION AS KUTSO=-1 OVERRIDES KUTSS=-9'
      ENDIF
C
C***+AND-OPTIONS INTERCHANGED 23/11/91 TO ALLOW KUTSO WITHIN A
      KUTSO=-KUTSO
C***  CONFIGURATION ONLY FOR .GT. 9 CONFIGS WITH I2 FORMAT.
C
C
C END SET-UP BASED-ON USER INPUT
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C NOW SET-UP ORBITALS AND CONFIGURATIONS
C
C-----------------------------------------------------------------------
C
C SET-UP A BUFFER ARRAY NEL(IAXGR,IAXCF) FOR ALL POSSIBLE CONFIGS.
C THIS CAN BE QUITE LARGE SINCE NO ALGEBRA HAS YET BEEN ALLOCATED.
C BUT WE CANNOT "ALLOW" FOR BOTH MAXGR AND MAXCF BEING THEIR LARGEST
C POSSIBLE AT THE SAME TIME  - WHICH CAN NEVER OCCUR - BUT WE WANT
C TO ALLOW SUCH TO BE SET IN THE PARAM FILE.
C ALL OTHER ARRAYS ARE EITHER ALLOCATED TO ACTUAL USAGE OR ARE
C LINEAR IN MAXGR OR MAXCF, I.E. HARD TO INFLATE.
C
      IF(IEQ(0).LT.0)THEN                  !RELAXED ORBIATLS
        IAXGR=MAXGR                        !=(UNIQUE MAXGR)*MAXCF
        IAXCF=MIN(MAXCF,2500_SP)           !SO CAN LIMIT IAXCF
      ELSEIF(NSL0.LT.0)THEN                !CA MAXCF CAN BE LARGE
        IAXGR=MIN(MAXGR,1000_SP)           !BUT CAN LIMIT IAXGR
        IAXCF=MAXCF
      ELSE                                 !LS/BP UNIQUE ORBITAL BASIS
        IAXGR=MIN(MAXGR,250_SP)            !SO CAN LIMIT IAXGR
        IAXCF=MIN(MAXCF,10000_SP)          !AND CAN LIMIT IAXCF
      ENDIF
C
      ALLOCATE (NEL(IAXGR,IAXCF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'SR.ALGEB0: ALLOCATION FAILS FOR NEL'
        NF=0
        GO TO 996
      ENDIF
C
      ALLOCATE (QL(IAXGR),QN(IAXGR),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'SR.ALGEB0: ALLOCATION FAILS FOR QL,QN'
        NF=0
        GO TO 996
      ENDIF
C
C-----------------------------------------------------------------------
C
      IF(CODE.EQ.'A.S.')THEN
c
c initialize so we can check later for any undefined nel - remove now
c        do j=1,iaxcf
c          do i=1,iaxgr
c            nel(i,j)=-1
c          enddo
c        enddo
C
        NF=1                                        !SO CAN FLAG ERROR
C
        CALL CONFG0(RUN,ICFG,MXVORB,MXCONF,MXCCF,KCUTCC,NXTRA,LXTRA
     X             ,LCONT,LCON0,KCUT0,IFILL)
C
        IF(NF.LE.0)GO TO 995
        NF=0                                        !NOT USED
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C DECODE NUMBER OF VALENCE ELECTRONS FROM FIRST CONFIGURATION.
C
      IF(CODE.EQ.'S.S.')THEN
        MPOL00=ABS(MPOL00)                           !REMOVE ANY FLAG
        MAXEL=IWRK2(1)
        DO I=2,KG
          IF(IWRK2(I).LE.50)GO TO 95
          MAXEL=IWRK2(I)-50+MAXEL
        ENDDO
      ELSE                                          !'A.S.'
        MAXEL=0
        I0=ABS(K2)+1
        DO I=I0,MXORB
          MAXEL=MAXEL+NEL(I,1)
        ENDDO
      ENDIF
C
  95  IF(IDW.NE.0)MAXEL=MAXEL+1                     !NEED SPACE FOR CONT
C
C FLAG IF THERE WAS NOT ENOUGH BUFFER SPACE TO READ-IN CONFIGS.
C
  97  IF(CODE.EQ.'S.S.')THEN
        IF(MLIT(1).NE.'    ')WRITE(6,100)MLIT0
        IF(KGG.GT.MXD08)THEN
          WRITE(6,195)MXD08,KGG
          GO TO 999                                 !RETURN
        ENDIF
      ENDIF
C
C END READ (AND PROCESSING OF A.S.) CONFIG INPUT
C
C-----------------------------------------------------------------------
C
C MCFSS .GT. 0 NUMBERS ARE READ-IN (FREE-FORMATTED) FOR WHICH TWO-BODY
C FINE-STRUCTURE OF SR.RES ARE TO APPLY - THIS IS HISTORIC (UNUSED NOW).
C CASE S.S. THEY FOLLOW AFTER THE ORBITAL REDEFINITION LINE.
C CASE A.S. THEY FOLLOW AFTER THE CONFIGS (& BEFORE ANY NAST/S/P/J).
C THESE ARE IN ADDITION TO THOSE SPECIFIED BY *KUTSS*.
C NO INTERACTIONS BETWEEN TWO SETS UNLESS SPECIFIED IN BOTH.
C
      IF(MCFSS.GT.0)THEN
        IF(MCFSS.GT.MXD10)THEN
          WRITE(0,*)
     X      '***SR.ALGEB0: REDUCING MCFSS FROM',MCFSS,' TO MXD10=',MXD10
          WRITE(6,*)
     X      '***SR.ALGEB0: REDUCING MCFSS FROM',MCFSS,' TO MXD10=',MXD10
           MCFSS=MXD10
        ENDIF
        READ(5,*)(KCFS0(I),I=1,MCFSS)         !BOTH S.S. FREE-FORMAT NOW
      ENDIF
C
C-----------------------------------------------------------------------
C
C READ NASTS SUB-SHELL SPECS (SAME FOR IDW.EQ.0 AND. IDW.NE.0),
C OR, NASTS.LT.0, FLAG USE OF RANGE OF 2S+1,L GIVEN BY
C MINSTS,MAXSTS,MINLTS,MAXLTS READ IN NAMELIST,
C FOR SELECTION OF TERMS FROM AN OPEN SPECTATOR SUB-SHELL.
C APPLIES TO *ALL* CONFIGS WITH THE SUB-SHELL:
C
C  IO IS THE SUB-SHELL ORBITAL NUMBER
C  IQ   "     "    "   OCCUPATION "
C  IS, IL DEFINE THE 2S+1, L SYMMETRY REQUIRED
C  (IF IS=0 AND NASTS.GT.0 THEN RANGE IS APPLIED, ELSE RANGE IGNORED.)
C
      IF(NASTS.GT.0)THEN
        DO I=1,NASTS
          READ(5,*)IO,IQ,IS,IL            !,IP - PARITY UNNECESSARY
          NESSH(I)=100000*IO+1000*IQ+10*IS+IL
          IF(IS.EQ.0)IL=0                 !WILL USE RANGE
          IF(IS.LT.0)IS=-IS               !ASSUME ATTEMPT TO FLAG PARITY
          IF(IL.GT.9)THEN
            WRITE(6,*)'CURRENTLY, NASTS CANNOT SELECT TARGET L.GT.9...'
            WRITE(0,*)'CURRENTLY, NASTS CANNOT SELECT TARGET L.GT.9...'
            GO TO 999                              !RETURN
          ENDIF
        ENDDO
      ELSEIF(NASTS.LT.0)THEN       !USER SHOULD SET MIN/LAX S,L ELSE ALL
        DO I=1,-NASTS
          READ(5,*)IO,IQ
          NESSH(I)=100000*IO+1000*IQ
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C READ NAST/P SELECTED (2S+1) L P
C OR, NAST/P.LT.0, FLAG USE OF RANGE OF 2S+1,L GIVEN BY
C MINST/P,MAXST/P,MINLT/P,MAXLT/P READ IN NAMELIST,
C FOR PARENT (NASTP) OR FULL CF (NAST).
C
C FOR PARENTS, NASTP SPECIFIES THE NO. OF SETS OF DATA TO FOLLOW,
C WHICH CONSISTS OF A CF NO. AND A LOCAL NASTP VALUE, FOLLOWED BY
C THE 2S+1,L,P PARENT TERMS.
C *** IF A CONFIG IS NOT LISTED THEN *ALL* OF ITS TERMS ARE INCLUDED.
C
C FOR FULL CF, 2S+1,L,P ARE GLOBAL I.E. THE SAME FOR ALL CFS, SO JUST
C THESE ARE REQUIRED.
C
C (N.B. SPIN RE-LABELLED AS MINSP, MAXSP AT END OF THIS SUBROUTINE, FOR
C /NRBLS/, TO AVOID CONFLICT WITH HISTORIC MAXST SLATER STATE VARIABLE.)
C IN ADDITION, WHEN LOOPING OVER RYDBERG ORBITAL WITH A.M. LNEW
C CAN RESTRICT ***TOTAL*** L-VALUES WITH LRANGE.
C
C *** ONLY NEED READ *DISTINCT* SYMMETRIES, I.E. MAXSL POSSIBLE
C
C CASE IDW.GT.0 (EIE,EII) THEN NASTP REFERS TO N-ELECTRON TARGET AND
C                              NAST  REFERS TO THE N+1 SYMMETRIES
C                         NOTE: *IF* USER SPECIFIES INAST
C                         THEN INTERNALLY RE-SET NASTP=NAST & NAST=INAST
C
C-----------------------------------------------------------------------
C
      IF(IDW.NE.0)THEN
        IF(INAST.GT.0)THEN
          IF(NASTP.GT.0)THEN
            WRITE(6,1112)INAST,NAST,NASTP
            WRITE(0,*)
     X      '***CONFUSION OVER INPUT: SET INAST/NAST .OR. NAST/NASTP'
            GO TO 999                              !RETURN
          ENDIF
C ELSE ALIGN
          NASTP=NAST
          NAST=INAST
        ELSE
          IF(NASTP.LE.0)THEN                      !ASSUME NAST IS TARGET
            NASTP=NAST
            NAST=0
          ENDIF
        ENDIF
C
        IF(ABS(MODD).LE.1)THEN                     !IC
          IF(INASTJ.GT.0)THEN
            IF(NASTJP.GT.0)THEN
              WRITE(6,1113)INASTJ,NASTJ,NASTJP
              WRITE(0,*)
     X     '***CONFUSION OVER INPUT: SET INASTJ/NASTJ .OR. NASTJ/NASTJP'
              GO TO 999
            ENDIF
C ELSE ALIGN
            NASTJP=NASTJ
            NASTJ=INASTJ
          ELSE
            IF(NASTJP.LE.0)THEN                   !ASSUME NAST IS TARGET
              NASTJP=NASTJ
              NASTJ=0
            ENDIF
          ENDIF
        ENDIF
      ENDIF
C
      ILMAX=0
C
C FIRST LOOP OVER FOR PARENT TERMS (TARGET FOR IDW.NE.0)
C
      IF(NASTP.GT.0)THEN
        IF(IDW.EQ.0)THEN                        !"STRUCTURE"
          IF(CODE.EQ.'S.S.')THEN                !SINCE KMAX=0 STILL
            JAXCF=MXD10                         !BUT USER HAS TO TYPE-IN
          ELSE                                  !A.S. WE KNOW
            JAXCF=KMAX
          ENDIF
C
          ALLOCATE (LSPIP(MAXSL,JAXCF),NLSPIP(JAXCF))
C
          DO I=1,JAXCF                          !INITIALIZE
            NLSPIP(I)=0
          ENDDO
          DO I=1,NASTP
            READ(5,*)IPCF,NPCF                  !CF SPECIFIC
            IF(IPCF.LE.0.OR.IPCF.GT.JAXCF)THEN
              WRITE(6,*)' *** ILLEGAL CONFIGURATION NO.:',IPCF
              WRITE(0,*)' *** ILLEGAL CONFIGURATION NO.'
              GO TO 999
            ENDIF
            DO N=1,NPCF
              READ(5,*)IS,IL,IP
              IF(N.LE.MAXSL)LSPIP(N,IPCF)=10000*IS+10*IL+IP
              ILMAX=MAX(ILMAX,IL)
            ENDDO
            IF(NPCF.GT.MAXSL)THEN
              WRITE(6,747)NPCF
              NPCF=MAXSL
            ENDIF
            NLSPIP(IPCF)=NPCF
          ENDDO
        ELSE
          DO I=1,NASTP
            READ(5,*)IS,IL,IP
            IF(I.LE.MAXSL)LSPIB(I)=10000*IS+10*IL+IP        !GLOBAL HERE
            ILMAX=MAX(ILMAX,IL)
          ENDDO
          IF(NASTP.GT.MAXSL)THEN
            WRITE(6,747)NASTP
C            NASTP=MAXSL
          ENDIF
        ENDIF
      ENDIF
C
C NOW FOR FULL CF (TERMS/SYMMETRIES)
C
      IF(NAST.GT.0)THEN
C        NS=0                                              !ALL E-STATES
        IFLAG=0
        DO I=1,NAST
          READ(5,*)IS,IL,IP
          IF(IS.LT.0)THEN
            IS=-IS
            READ(5,*)NS
            IF(NS.LT.0)NS=0                                  !FOR SAFETY
            IFLAG=1
          ELSE
            NS=0
          ENDIF
          IF(I.LE.MAXSL)THEN
            IL=ABS(IL)
            IP=ABS(IP)
            IP=MOD(IP,ITWO)
            IF(IS.NE.0)THEN
              LSPI(I)=10000*IS+10*IL+IP
              NLSPI(I)=NS
            ELSE
              LSPI(I)=IL                                      !ASSUME CA
            ENDIF
          ENDIF
          ILMAX=MAX(ILMAX,IL)
        ENDDO
        IF(IFLAG.GT.0.AND.QN(MXORB).GE.90)THEN                !CONTINUUM
          WRITE(0,*)'***WARNING, SR.ALGEB0: RESTRICTING TERMS TO LOWEST'
     X  ,' NO. IN SYMMETRY GROUP LIKELY LEADS TO NON-DEGENRATE CHANNELS'
          WRITE(6,*)'***WARNING, SR.ALGEB0: RESTRICTING TERMS TO LOWEST'
     X  ,' NO. IN SYMMETRY GROUP LIKELY LEADS TO NON-DEGENRATE CHANNELS'
        ENDIF
        IF(NAST.GT.MAXSL)THEN
          WRITE(6,747)NAST
          IF(IDW.EQ.0)NAST=MAXSL
        ENDIF
      ELSEIF(NAST.LT.0)THEN
        IF(BLOOP.AND.LRANGE.GE.0)THEN
          MINLT=LNEW-LRANGE
          MAXLT=LNEW+LRANGE
        ENDIF
      ENDIF
C
      IF(IDW.NE.0)THEN                  !BACK-UP THEN COPY-IN FOR TARGET
        MX=MAX(NAST,NASTP)
        IF(MX.GT.MAXSL)THEN
          WRITE(0,747)MX
          GO TO 999
        ENDIF
        DO I=1,MX
          II=LSPI(I)
          LSPI(I)=LSPIB(I)              !TARGET SYMMETRIES
          LSPIB(I)=II                   !SCATTERING SYMMETRIES
        ENDDO
        IF(NAST.LE.0)THEN
          IF(MINLT.LT.0)MINLT=0
          IF(MAXLT.LT.0)THEN
            IF(NASTJ.GT.0)THEN
              WRITE(6,*)'*** HINT: CASE INASTJ.GT.0 MAYBE FASTER IF YOU'
     X         ,' SET MAXLT EXPLICITLY'
              WRITE(0,*)'*** HINT: CASE INASTJ.GT.0 MAYBE FASTER IF YOU'
     X         ,' SET MAXLT EXPLICITLY'
            ENDIF
            MAXLT=30
          ENDIF
          IF(MAXLT.LT.250)ILMAX=MAX(ILMAX,MAXLT)
        ENDIF
        MINLTB=MINLT
        MAXLTB=MAXLT
        MINSTB=MINST
        MAXSTB=MAXST
        MINLT=MINLTP
        MAXLT=MAXLTP
        MINST=MINSTP
        MAXST=MAXSTP
        NASTB=NAST
        NAST=NASTP
        NASTP=0                              !I.E. NO TARGET PARENTS NOW
        MINSTP=0
        MAXSTP=2000
        MINLTP=0
        MAXLTP=2000
      ENDIF
C
C DITTO BUT EXTEND TO LEVELS JP (2*J, P=0,1)
C
      IF(ABS(MODD).LE.1)THEN                     !IC
        IJMAX=0
C
        IF(NASTJP.GT.0)THEN
          IF(IDW.EQ.0)THEN            !AS THERE ARE NO STRUCTURE PARENTS
            WRITE(6,*)'*** ATTENTION: NASTJP IS IGNORED FOR IDW=',IDW
            WRITE(0,*)'*** ATTENTION: NASTJP IS IGNORED FOR IDW=',IDW
          ENDIF
          DO I=1,NASTJP
            READ(5,*)IL,IP
            IF(I.LE.MAXJG)JPIP(I)=10*IL+IP
            IJMAX=MAX(IJMAX,IL)
          ENDDO
          IF(NASTJP.GT.MAXJG)THEN
            WRITE(6,748)NASTJ
            IF(IDW.EQ.0)NASTJP=MAXJG
          ENDIF
        ENDIF
C
        IF(NASTJ.GT.0)THEN
C          NS=0                                            !ALL E-STATES
          IFLAG=0
          DO I=1,NASTJ
            READ(5,*)IL,IP
            IF(IL.LT.0.OR.IP.LT.0)THEN
              IL=ABS(IL)
              IP=ABS(IP)
              READ(5,*)NS
              IF(NS.LT.0)NS=0                                !FOR SAFETY
              IFLAG=1
            ELSE
              NS=0
            ENDIF
            IP=MOD(IP,ITWO)
            IF(I.LE.MAXJG)THEN
              JPI(I)=10*IL+IP
              NJPI(I)=NS
            ENDIF
            IJMAX=MAX(IJMAX,IL)
          ENDDO
          IF(IFLAG.GT.0.AND.QN(MXORB).GE.90)THEN              !CONTINUUM
          WRITE(0,*)'***WARNING, SR.ALGEB0: RESTRICTING TERMS TO LOWEST'
     X  ,' NO. IN SYMMETRY GROUP LIKELY LEADS TO NON-DEGENRATE CHANNELS'
          WRITE(6,*)'***WARNING, SR.ALGEB0: RESTRICTING TERMS TO LOWEST'
     X  ,' NO. IN SYMMETRY GROUP LIKELY LEADS TO NON-DEGENRATE CHANNELS'
          ENDIF
          IF(NASTJ.GT.MAXJG)THEN
            WRITE(6,748)NASTJ
            IF(IDW.EQ.0)NASTJ=MAXJG
          ENDIF
        ENDIF
C
        IF(IDW.NE.0)THEN                !BACK-UP THEN COPY-IN FOR TARGET
          MX=MAX(NASTJ,NASTJP)
          IF(MX.GT.MAXJG)THEN
            WRITE(0,748)MX
            GO TO 999
          ENDIF
          DO I=1,MX
            II=JPI(I)
            JPI(I)=JPIP(I)
            JPIP(I)=II
          ENDDO
          IF(NASTJ.LE.0)THEN
            IF(NASTB.GT.0)THEN
              WRITE(6,*)'***ERROR: YOU MUST SPECIFY INASTJ JP ',
     X        'IF YOU SPECIFY INAST LSP SYMMETRIES ELSE MADNESS ENSUES!'
              WRITE(0,*)'***ERROR: MUST SPECIFY INASTJ IF YOU ',
     X                'SPECIFY INAST'
              GO TO 999                                 !RETURN
            ENDIF
            IF(MINJT.LT.0)THEN
              MINJT=2*MINLT
              IF(MAXSTB.LT.100)THEN
                MINJT=MINJT+MIN(MINJT,MAXSTB-1)
              ELSE
                MINJT=MINJT+MIN(MINJT,12_SP)            !SO BEST SPECIFY
              ENDIF
            ENDIF
            IF(MAXJT.LT.0)THEN
              MAXJT=2*MAXLT
              IF(MAXSTB.LT.100)THEN
                MAXJT=MAXJT-MAXSTB+1
              ELSE
                MAXJT=MAXJT-12                          !SO BEST SPECIFY
              ENDIF
            ENDIF
            IF(MAXJT.LT.500)IJMAX=MAX(IJMAX,MAXJT)
          ENDIF
          MINJTB=MINJT
          MAXJTB=MAXJT
          MINJT=MINJTP
          MAXJT=MAXJTP
          NASTJB=NASTJ
          NASTJ=NASTJP
          NASTJP=0                                    !FOR FUTURE SAFETY
          MINJTP=0
          MAXJTP=2000
        ENDIF
C
        IJMAX=IJMAX/2
        ILMAX=MAX(ILMAX,IJMAX)
      ENDIF
C
C***
      MINSP=MINST                              !RELABEL FOR /NRBLS/ TO
      MAXSP=MAXST                              !AVOID SLATER-STATE MAXST
C***
C
      MXDFS0=4*(ILMAX+10)              !RE-CHECK FACTORIAL ARRAY
      IF(MXDFS0.GT.MXDFS)THEN          !REAL *8 GOOD TO ABOUT MXDFS=680
        WRITE(6,*)'INCREASE FACTORIAL ARRAY TO MXDFS=',MXDFS0
        WRITE(0,*)'INCREASE FACTORIAL ARRAY, MXDFS'
        GO TO 999                                     !RETURN
      ENDIF
C
C-----------------------------------------------------------------------
C
C READ AND PROCESS DRR NAMELIST INPUT
C
C***********************************************************************
C
C ORBITAL INPUT DATA (IF XDR.NE.' ' OR RUN.EQ.'DR','RR','RE','PE')
C FOR RYDBERG VALENCE ELECTRON (DEFINED BY INPUT N IN RANGE 80-89)
C TO BE LOOPED OVER NL:
C
C N INCREMENTED BY 1 AT A TIME FROM NMIN TO NMAX.
C
C NSW=N-VALUE FOR SWITCH TO APPROXIMATING BOUND ORBITAL BY CONTINUUM,
C     WHERE NSW=(L*L)/4+NS0  AND L IS THE A.M. (NS0 DEFAULTS TO 15).
C     N.B. THIS APPROXIMATION SHOULD BE TESTED-OUT CAREFULLY. FOR HIGHER
C     RESIDUAL CHARGES LMAX WILL INCREASE BUT IT SHOULD PROVE POSSIBLE
C     TO REDUCE NSW TO E.G. L+NS0  WHERE NS0=20 SAY.
C
C NRAD=N-VALUE FOR SWITCH TO NEGLECTING RADIATION BY VALENCE ELECTRON.
C
C JND>0 ADDITIONAL N-VALUES TO BE READ-IN IN ASCENDING ORDER AND SHOULD
C     DIFFER BY AT LEAST 2 SINCE AN ADDITIONAL POINT IS INSERTED
C     BETWEEN EACH INPUT POINT SUCH THAT STEP LENGTH FOR SIMPSON RULE
C     SUM OVER N HAS STEP LENGTH=N1**(-2)-N2**(-2)=N2**(-2)-N3**(-2)
C     FOR TRANSFORMATION U=N**(-2).
C JND<=-99, USES LOG SPACED N-VALUES FROM NDR1=NMAX+1 TO NDR2=999
C     DEFINED BY: NDR1*RATN**J FOR J=0...JMAX I.E. NDR2=NDR1*RATN**JMAX,
C     WITH RATN=1.2 DEFAULT. THEN RESETS JND.
C -99<JND<0 USES -JND VALUES LOG SPACED AS ABOVE, BUT READ NDR2 AS PER>0
C     I.E. JND DEFINES RATN. IF USER SETS RATN>0 THEN JND IS IGNORED
C     AND OPERATION IS AS <=-99 BUT WITH THE RESTRICTED NDR2.
C    =0, NO ADDITIONAL N.
C
C DEFAULTS:
C     NMIN=MAX TARGET N+1
C     NMAX=24
C     JND=-99, SETS-UP ITS OWN MESH FROM NMAX+1 TO N=999
C     RATN=-1.2 (ONLY AVAILABLE VIA NAMELIST)
C     NS0=15 (DR) 20 (RR)
C     NRAD=1000  (NO DROP)
C
C  LMAX .GE. LMIN (.GE.0)  LOOPS OVER L FOR A SINGLE VALENCE ELECTRON.
C     DEFAULT, NO LOOP - USES THE THE ACTUAL L-VALUE OF THE VALENCE
C     ORBITAL(S). THIS ENABLES N-LOOPING WITH MULTIPLE VALENCE L-ORBS.
C
C  LCON=NO. OF CONTINUUM ORBITALS, THEIR A.M. DETERMINED BY PROGRAM.
C     DEFAULT=2*LA+1, WHERE LA IS THE MAX CORE/TARGET ONE-ELECTRON A.M.
C
C***********************************************************************
C
      IF(IDR.NE.0)THEN                      !IDR<-BDR ALLOW RYD W/O CONT
        LORIG=-1
        LINC=1
        NSX=35
        NSW=-1
        RATN=-1.2D0
        IF(BNAME)THEN
          NMIN=-999
          NMAX=24
          if(bfot)then
            ns0=21
          else
            NS0=15
          endif
          IF(.NOT.BDR)NSW=9999           !DEFAULT TO NO ZERO CONT APPROX
          NRAD=1000
          JND=-99
          LMIN=-1
C          LMAX=-1
C          LCON=-1
C
          READ(5,DRR,END=998,ERR=998)    ! <------------------- NAMELIST
C
        ELSE
C
          READ(5,101)NMIN,NMAX,NS0,NRAD,JND,LMIN,LMAX,LCON
C
        ENDIF
C
        IF(NMIN.LE.0)THEN
C
          IF(CODE.EQ.'S.S.')THEN       !AS DON'T HAVE KMAX YET
            WRITE(6,*)"***SR.ALGEB0: ERROR, MUST DEFINE NMIN FOR 'S.S.'"
            WRITE(0,*)"***SR.ALGEB0: ERROR, MUST DEFINE NMIN FOR 'S.S.'"
            GO TO 999
          ENDIF
C
          I0=ABS(K2)+1
          DO K=1,KMAX                  !AS DON'T HAVE DEY DEFINED YET...
            DO I=I0,MXORB
              IF(NEL(I,K).GT.0.AND.QN(I).LT.60)
     X                                     NMIN=MAX(NMIN,INT(QN(I),SP))
            ENDDO
          ENDDO
          NMIN=NMIN+1

c          write(6,*)'nmin=',nmin
        ENDIF
        NMIN=MAX(NMIN,LMIN+1)
C
        IF(NS0.LT.1)NS0=15
        IF(NSX.LT.1)NSX=35
        IF(NRAD.LT.1)NRAD=1000
        IF(JND.EQ.0)GO TO 106
c
        IF(2*JND.GT.MXD12)THEN
          JND=MXD12/2
          WRITE(6,105)JND
        ENDIF
C
        IF(JND.GT.0)THEN
          READ(5,*)(NDR(2*J-1),J=1,JND)
        ELSE                             !IF(JND.LT.0)THEN
          IF(NMAX.LT.NMIN)NMAX=NMIN
          NDR1=NMAX+1
          JND=-JND
          IF(JND.GE.99)THEN
            RATN=ABS(RATN)
            NDR2=999
          ELSE
            READ(5,*)NDR2
            IF(NDR2.LT.NDR1)NDR2=999
          ENDIF
          IF(NDR2.LT.NDR1)THEN
            JND=0
            GO TO 106
          ENDIF
          IF(RATN.GT.DZERO)THEN
            T2=NDR2
            T1=NDR1
            T=(LOG(T2)-LOG(T1))/LOG(RATN)
c            write(6,*)t
            JND=NINT(T)
          ENDIF
          IF(JND.GT.MXD12)THEN
            JND=MXD12
            WRITE(6,105)JND
          ENDIF
          JND=MAX(JND,ITWO)
          TJ=JND-1
          TJ=DONE/TJ
          T=NDR2
          T=T/NDR1
          RATN=T**TJ
          NDR(1)=NDR1
          NDR(2)=NINT(NDR1*RATN)
          DO J=3,JND
            TN=NDR(J-1)*RATN
            NDR(J)=NINT(TN)
            IF(NDR(J).LE.NDR(J-1))THEN
              WRITE(6,*)'N-MESH TOO DENSE, DECREASE JND=',JND
     X                 ,' OR INCREASE NDR(JND)=',NDR2
              WRITE(0,*)'N-MESH TOO DENSE!'
              GO TO 999
            ENDIF
            IF(NDR(J-1).GT.150)THEN
              T=NDR(J-1)
              T=T/10
              N=NINT(T)
              NDR(J-1)=10*N
            ELSEIF(NDR(J-1).GT.60)THEN
              T=NDR(J-1)
              T=T/5
              N=NINT(T)
              NDR(J-1)=5*N
            ENDIF
          ENDDO
          NDR(JND)=NDR2
          GO TO 106
        ENDIF
C
        IF(NMAX.LT.0.OR.NMAX.LT.NMIN)GO TO 108
        IF(NDR(1).EQ.NMAX+1)GO TO 108
c        if(nmin.gt.0)go to 104                !debug, no extra n-values
C
        DO J=JND,1,-1
          J2=J+J
          NDR(J2+1)=NDR(J2-1)
        ENDDO
C
        JND=JND+1
        NDR(1)=NMAX+1
C
  108   IF(JND.LT.2)GO TO 104
        J22=JND
C
        DO J=2,J22
           J2=J+J
           IF(NDR(J2-1).LE.NDR(J2-3)+1)THEN
            JND=JND-1
            IF(JND.LT.J)GO TO 104
            DO I=J,JND
              J2=J+J
              NDR(J2-1)=NDR(J2+1)
            ENDDO
          ENDIF
        ENDDO
C
  104   IF(JND.GT.1)THEN
          DO J=2,JND
            J1=J+J-3
            J2=J1+2
            T1=NDR(J1)
            T2=NDR(J2)
            T=DONE/(SQRT(DHALF/(T1*T1)+DHALF/(T2*T2)))+DHALF
            NDR(J1+1)=INT(T)
          ENDDO
          JND=JND+JND-1
        ENDIF
C
  106   CONTINUE
C
c        write(6,*)nmin,nmax,ratn,jnd,':',(ndr(j),j=1,jnd)
cparc                                                               !par
cpar        if(nprocperl.gt.1)then    !write n-mesh for adasdr      !par
cpar          open(80,file='n-mesh.dat',status='replace')           !par
cpar          do j=nmin,nmax                                        !par
cpar            write(80,*)j                                        !par
cpar          enddo                                                 !par
cpar          do j=1,jnd                                            !par
cpar            write(80,*)ndr(j)                                   !par
cpar          enddo                                                 !par
cpar          close(80,status='keep')                               !par
cpar        endif                                                   !par
cparc                                                               !par
cpar        if(linc.ne.1)then                                       !par
cpar          write(6,*)                                            !par
cpar     x     'LINC must equal 1 (default) for parallel operation' !par
cpar          if(iam.eq.0)write(0,*)                                !par
cpar     x     'LINC must equal 1 (default) for parallel operation' !par
cpar          go to 999                                             !par
cpar        endif                                                   !par
cparc                                                               !par
cpar        mst5=mod(mstrt0,irl5)                                   !par
cpar        if(mst5.lt.5)then                                       !par
cpar          lproc=nproc                                           !par
cpar          mapiam=0             !ensure as parallel by l here    !par
cpar        elseif(lproc.le.0)then                                  !par
cpar          lproc=0                                               !par
cpar          jam=-1                                                !par
cpar   50     jam=jam+1                                             !par
cpar          j1=jam/10                                             !par
cpar          j2=jam-(10*(jam/10))                                  !par
cpar          name0=num(j1)//num(j2)                                !par
cpar          name='RESTART'//name0                                 !par
cpar          inquire(file=name,exist=bex)                          !par
cpar          if(bex)go to 50                                       !par
cpar          lproc=jam                                             !par
cparc        else          !assume user knows what she is doing     !par
cpar        endif                                                   !par
cparc                                                               !par
cpar        lrangp=lmax-lmin+1                                      !par
cparc                                                               !par
cpar        if(lproc.gt.lrangp)then                                 !par
cpar          write(6,*)'Too many processors for specified l-range,'!par
cpar     x             ,' use nproc=',lrangp                        !par
cpar          if(iam.eq.0)write(0,*)                                !par
cpar     x               'Too many processors for specified l-range'!par
cpar          go to 999                                             !par
cpar        endif                                                   !par
cparc                                                               !par
cpar        lperproc=lrangp/lproc                                   !par
cpar        lxtra=lrangp-lperproc*lproc                             !par
cparc                                                               !par
cpar        if(mapiam.le.0)then      !nprocperl, inc. 1             !par
cparc                                                               !par
cpar          nprocperl=nproc/lproc                                 !par
cparc                                                               !par
cpar          if(lproc*nprocperl.ne.nproc)then                      !par
cpar            write(6,*)'nproc=',nproc,' must be an integer '     !par
cpar     x            ,'multiple of the',lproc,' RESTART files'     !par
cpar            if(iam.eq.0)write(0,*)                              !par
cpar     x                 'Too many n-processors for lproc set-up' !par
cpar            go to 999                                           !par
cpar          endif                                                 !par
cparc                                                               !par
cpar          liam=iam/nprocperl                                    !par
cpar          jiam=mod(iam,nprocperl)                               !par
cparc                                                               !par
cpar        else                    !one nl-per proc                !par
cparc                                                               !par
cpar          i=-1                                                  !par
cpar          do l=0,lproc-1                                        !par
cpar            j=-1                                                !par
cpar            l0=lmin+l*lperproc+min(lxtra,l)                     !par
cpar            n0=max(nmin,l0+1)                                   !par
cpar            do n=n0,nmax                                        !par
cpar              i=i+1                                             !par
cpar              j=j+1                                             !par
cpar              if(iam.eq.i)then                                  !par
cpar                liam=l                    !RESTART file index   !par
cpar                niam=n                                          !par
cpar                jiam=j          !output file index label only   !par
cpar              endif                                             !par
cpar            enddo                                               !par
cparc                                                               !par
cpar            if(j.lt.0)then                                      !par
cpar              write(6,*)'*** need nmax of at least:',n0         !par
cpar              if(iam.eq.0)write(0,*)'*** need nmax of at least:'!par
cpar     x                   ,n0                                    !par
cpar              go to 999                                         !par
cpar            endif                                               !par
cparc                                                               !par
cpar            do nd=1,jnd                                         !par
cpar              i=i+1                                             !par
cpar              j=j+1                                             !par
cpar              if(iam.eq.i)then                                  !par
cpar                liam=l                                          !par
cpar                niam=-ndr(nd)  !minus flags 2nd n-loop (unused) !par
cpar                jiam=j                                          !par
cpar              endif                                             !par
cpar            enddo                                               !par
cpar          enddo                                                 !par
cparc                                                               !par
cpar          i=i+1                              !align             !par
cpar          if(i.ne.nproc)then                                    !par
cpar            write(6,*)"nproc does not match no. nl's =",i       !par
cpar            if(iam.eq.0)write(0,*)"nproc does not match nl's"   !par
cpar            go to 999                                           !par
cpar          endif                                                 !par
cparc                                                               !par
cpar          nprocperl=999                      !flag              !par
cparc                                                               !par
cpar        endif                                                   !par
cparc                                                               !par
cpar        lmin=lmin+liam*lperproc+min(lxtra,liam)                 !par
cpar        nmin=max(nmin,lmin+1)                                   !par
cpar        lmax=lmin+lperproc-1                                    !par
cpar        if(liam.lt.lxtra)lmax=lmax+1                            !par
cparc                                                               !par
cparc        write(0,*)iam,liam,lmin,lmax                           !par
C
        BLOOP=LMIN.LE.LMAX.AND.LMIN.GT.-1
        IF(BLOOP)THEN
          LNEW=LMIN+LSUM*LINC
        ELSE
          LNEW=999                                      !FOR N-LOOP ONLY
        ENDIF
        IF(LORIG.LT.0)LORIG=LMIN                    !NEEDED FOR PARALLEL
C
        IF(LCON.LT.0.AND.LCONT.GT.0)LCON=LCONT
        IF(LCON.LT.1)LCON=3
        IF(LCONT.GT.0.AND.LCONT.NE.LCON)THEN
          WRITE(6,1009)LCON,LCONT
          LCON=LCONT
        ENDIF
C
        MXDFS0=4*(LMAX+LCON+10)         !RE-CHECK FACTORIAL ARRAY
        IF(MXDFS0.GT.MXDFS)THEN         !REAL *8 GOOD TO ABOUT MXDFS=680
          WRITE(6,*)'INCREASE FACTORIAL ARRAY TO MXDFS=',MXDFS0
          WRITE(0,*)'INCREASE FACTORIAL ARRAY, MXDFS'
          GO TO 999
        ENDIF
c
cpar      elseif(idw.eq.0.and.iam.eq.0)then                         !par
cpar        write(0,*)'***STRUCTURE RUN HAS *NOT* BEEN PARALLELIZED'!par
cpar        write(0,*)'***EACH PROCESSOR IS RUNNING A DUPLICATE JOB'!par
      ELSE
        IF(BFOT.AND.LCON.LT.1)LCON=3                     !FOR S.S. IXD24
      ENDIF
c
C SET FOR A NON L-LOOPING RUN
C
      IF(.NOT.BLOOP)LMAX=-1
C
C-----------------------------------------------------------------------
C
C CASE 'S.S.' DECODE CONFIGURATIONS AND PERFORM SOME INITIALIZATIONS.
C CASE 'A.S.' ASSIGN ANY RYDBERG/CONTINUUM ORBITAL ANGULAR MOMEMNTUM.
C BOTH: OPTIONALLY SET RELAXED ORBITALS.
C
C-----------------------------------------------------------------------
C
      NF=MAXEL                             !INITIALIZE TO CHECK CF INPUT
      IF(IDW.NE.0)NF=NF-1
C
      CALL CONFG1
C
      IF(NF.LE.0)GO TO 995       !PROBLEM WITH CONFIG INPUT (BLF=.TRUE.)
C
      KUTLS=MIN(KUTLS,KMAX)                                       !ALIGN
C
C RE-MAP HISTORIC "KUTSS" FLAG
C
      DO I=1,KMAX
        KCFSS(I)=0
      ENDDO
      IF(MCFSS.GT.0)THEN
        DO I=1,MCFSS
          J=KCFS0(I)
          IF(J.LE.KMAX)THEN
            KCFSS(J)=1
          ELSE
            WRITE(0,*)'*** SR.ALGEB0: MCFSS ILLEGAL CONFIG NO.',J
            WRITE(6,*)'*** SR.ALGEB0: MCFSS ILLEGAL CONFIG NO.',J
            NF=-1
            GO TO 995
          ENDIF
        ENDDO
      ENDIF
C
C NOW WE HAVE FINAL "MAXGR" AND "MAXCF" SO CAN REDUCE BUFFER FOR NEL:
C
      IF(IAXGR.NE.MXORB.OR.IAXCF.NE.KMAX)THEN
C
        CALL RE_ALLOC2(NEL,IONE,IAXGR,IONE,IAXCF,MXORB,KMAX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.ALGEB0: RE-ALLOCATION FAILS FOR NEL'
          NF=0
          GO TO 995
        ENDIF
C
      ENDIF
C
C SIMILARLY FOR QL,QN
C
      IF(IAXGR.NE.MXORB)THEN
C
        CALL RE_ALLOC(QL,IONE,IAXGR,MXORB,IERR)
        CALL RE_ALLOC(QN,IONE,IAXGR,MXORB,IERR)
C
        IF(IERR.NE.0)NF=0
C
      ENDIF
C
C HISTORICALLY, DO NOT REFERENCE IAXGR, IAXCF FURTHERMORE.
C RATHER USE MXORB, KMAX, BUT THIS MAY CHANGE, SO:
C
      IAXGR=MXORB
      IAXCF=KMAX
C
C-----------------------------------------------------------------------
C
 995  IF(KCUTP0.EQ.-9999)KCUTP=0                                !TIDY-UP
C
C-----------------------------------------------------------------------
C
 996  RETURN
C
 997  WRITE(6,1997)
      WRITE(0,*)'*** SR.ALGEB0: ERROR READING NAMELIST SALGEB!'   !FATAL
      GO TO 999
C
 998  WRITE(6,1998)
      WRITE(0,*)'*** SR.ALGEB0: ERROR READING NAMELIST DRR!'      !FATAL
C
 999  NF=-1
      GO TO 995
C
C
  100 FORMAT(///' ',2A4)
  101 FORMAT(8I5)
  105 FORMAT(//'SR.ALGEB0: NUMBER OF N VALUES FOR DR HAS BEEN REDUCED'
     X,' TO',I3/)
  145 FORMAT(//' ***** FANO PHASE CONVENTION IN USE *****'/)
  150 FORMAT(4I2,A1,21(I2,A1),2A4)
  151 FORMAT(9X,21(I2,A1))
  195 FORMAT(///'SR.ALGEB0: YOU ARE TRYING TO READ MORE CONFIGURATION ',
     X'INPUT THAN THE BUFFER CAN HOLD-'/11X,'AS BUFFER THE PROGRAM USES'
     X,' THE ARRAYS OF SIZE  *MXD08=',I6,'.'/11X,'EACH C CARD,AND THE ',
     X'TERMINATOR, REQUIRE 21 LOCATIONS.'/11X,'CASE SKIPPED. PUNCH MORE'
     X,' CONFIGURATIONS ON A CARD, OR AUGMENT MXD08 TO',I6/11X,
     X'***LIKELY MAXCF TOO SMALL***')
  700 FORMAT('*** ERROR: ILLEGAL INPUT N-VALUE=',I5,' .LE. 0 FOUND!')
  701 FORMAT('*** ERROR: USER INPUT N-VALUE=',I5,'  FOUND. EXPLICIT '
     X      ,' N-VALUES.GE. 60 ARE RESERVED FOR FLAGS ETC.'/4X
     X      ,'INSTEAD, FLAG AS A RYDBERG ORBITAL AND SET DESIRED N(L) '
     X      ,'VALUE IN NAMELIST &DRR - SEE WRITEUP FOR DETAILS.')
  702 FORMAT('*** ERROR: USER INPUT N-VALUE=',I5,' FLAGS AN EXTERNAL '
     X      ,'ORBITAL BUT NO radwin FILE FOUND!')
  703 FORMAT('*** USER INPUT N-VALUE=',I5,' IS A RESERVED FLAG. I HOPE '
     X      ,'YOU KNOW WHAT YOU ARE DOING!')
  747 FORMAT(//'  *** INCREASE MAXSL IN PARAMETER STATEMENTS TO',I4)
  748 FORMAT(//'  *** INCREASE MAXJG IN PARAMETER STATEMENTS TO',I4)
 1000 FORMAT(20A4)
 1001 FORMAT(////1X,105('-')//1X,20A4//1X,105('-')//)
 1002 FORMAT(' ****INPUT CODE ERROR: CURRENTLY ONLY S.S. AND A.S. ARE'
     X,' ALLOWED WHILE YOUR INPUT IS "',A4,'"')
 1009 FORMAT('***NOTE: LCON HAS BEEN OVERWRITTEN BY EARLIER DEFINITION:'
     X,2I3)
 1112 FORMAT(/'***CONFUSION OVER INPUT: SET INAST/NAST .OR. NAST/NASTP'/
     X        'YOU HAVE SET INAST,NAST,NASTP=',3I5)
 1113 FORMAT(
     X   /'***CONFUSION OVER INPUT: SET INASTJ/NASTJ .OR. NASTJ/NASTPJ'/
     X        'YOU HAVE SET INASTJ,NASTJ,NASTJP=',3I5)
 1120 FORMAT(/'*** COMMENT: HISTORIC DIMENSION CHECK MODD IS OBSOLETE -'
     X,' ONLY 10% FASTER, AND IT SIGNIFICANTLY OVERESTIMATED'/13X,'SOME'
     X,' DIMENSIONS. A FAST, ACCURATE, BUT *PARTIAL* DIMENSION'
     X,' TEST HAS BEEN IMPLEMENTED INSTEAD.'/7X,'NOTE: NZION=0 EXITS'
     X,' AT THE END OF A FULL ALGEBRA RUN.'//)
 1121 FORMAT(/"*** THERE IS, CURRENTLY, NO DIMENSION CHECK FOR RUN='DE'"
     X,' - SWITCHING-OFF!'/3X,' REMOVE THE "SRADCON" NAMELIST TO EXIT'
     X,' AT THE END OF THE COLLISION ALGEBRA.'//)
 1200 FORMAT(//1X,'THANK-YOU FOR CHOOSING AUTOSTRUCTURE (AS) AS YOUR ',
     X'ATOMIC CODE!'//5X,'AS IS A GENERAL DISTORTED-WAVE (DW) CODE'//
     X5X,'PLEASE SET THE DESIRED RUN OPTION FROM THE LIST BELOW:'//
     X5X,'RUN="  " FOR ATOMIC STRUCTURE (DEFAULT)'/
     X5X,'RUN="DR" FOR DIELECTRONIC RECOMBINATION'/
     X5X,'RUN="RR" FOR RADIATIVE RECOMBINATION'/
     X5X,'RUN="PI" FOR PHOTOIONIZATION'/
     X5X,'RUN="PE" FOR PHOTOEXCITATION-AUTOIONIZATION'/
     X5X,'RUN="DE" FOR DIRECT EXCITATION'/
     X5X,'RUN="RE" FOR RESONANT EXCITATION'/
     X5X,'RUN="DI" FOR DIRECT IONIZATION (NOT YET AVAILABLE)'//
     X' HAVE A GREAT DAY!'/)
 1997 FORMAT('*** SR.ALGEB0: ERROR READING NAMELIST SALGEB!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
 1998 FORMAT('*** SR.ALGEB0: ERROR READING NAMELIST DRR!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
C
      END SUBROUTINE ALGEB0
C
C                             *******************
C
      SUBROUTINE ALGEB1(QLML,QLMS,QBML,QBMS,JYI,JYF,IAXST,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB1 DEALS WITH THE PROBLEMS DESCRIBED IN SECTION 3.1 OF E+N
C  IT CALCULATES SLATER-STATES AND VECTOR COUPLING COEFFICIENTS (VCC)
C  FOR THE KMAX INPUT CONFIGURATIONS (FROM THE CODED INPUT IN QBML+QBMS
C  WHICH IS DECODED IN CONFG1).
C
C  OUTPUT:  FOR ANY OF THE KMAX CONFIGURATIONS KF: 1-QCP(KF)=PARITY,
C  SLST'S  NL'S AS QCG(I,KF),I=1,NF=GROUP NUMBER K OF I'TH ELECTRON
C  THE OTHER QUANTUM NUMBERS ARE IN SECTIONS J=JYI(KF)...JYF(KF) OF
C  QLMS,QLML(I,J)=2* LITTLE MS,ML OF I'TH ELECTRON IN SLST J;
C  QBMS,QBML(J)=2* TOTAL MS,ML OF SLST J (=SUM OVER LITTLE M'S).
C  TERMS  QTGS,QTGL(I),I=NTG(KF-1)+1,NTG(KF)=2*S,2*L
C  (QMCS,QMCL=2*SMAX,2*LMAX OF ALL THE NTG(KMAX) TERMS);
C  DC(JTGD(KF)+J)=VCC OF J'TH SLST TO TERM I, WITH I,J LIMITS ABOVE
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.DIMUSE
C    FN.QBINOM
C    SR.VCG
C    SR.VCU
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN,QCGS
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: BNRBGCF,KGCF,NKSL
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C
      CHARACTER(LEN=7) LABT
C
      INTEGER(EP) MDCF8,MDCFT8,M8
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      ALLOCATABLE :: LL(:),KSUB(:),KMAP(:),IWT(:)
C
      DIMENSION  QLMS(MAXEL,*),QBMS(*),QLML(MAXEL,*),QBML(*)
     X          ,JYI(*),JYF(*)
     X          ,DFS(MXDFS)
     X          ,NDI(MAXDF),DS(MAXDF),DE(MAXDF)                 !FOR VCU
C
      COMMON /BASIC/NF,KY,KG,JA,JB,JSP1,MSST,MGAP(5)
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBNV/MAXNV
      COMMON /NRBPNT/NTGP(MAXCT),NTGS(MAXCT),NTP1,NTP2
      COMMON /NRBVCX/NFS,KF,NB,JAS,JBS,KSI,KSF,NTGA,NTGB   !,QCGS(MXEL0)
C
c      EQUIVALENCE (LL(1),NDI(1))
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
      MAXNV=1
C
C EX-COMMON/NRBGCF/
      ALLOCATE (KGCF(0:KMAX),NKSL(MAXSL,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB1: ALLOCATION FAILS FOR KGCF,NKSL'
        NF=0
        GO TO 109
      ENDIF
      BNRBGCF=.TRUE.
C
C EX-COMMON/NRBVCX/ (NOW IN MODULE EX-COMMON/DBD2) ONLY IN ALGEB1 BRANCH
      ALLOCATE (QCGS(NF))
C
C LOCAL
      ALLOCATE (LL(NF),KSUB(0:MXORB),KMAP(MXORB),IWT(MXORB))
C
      IF(KCUT*KCUT.LT.KCUT*KMAX)THEN
        IF(MODD.EQ.0)THEN
          MODD=-1
          WRITE(6,130)
        ENDIF
      ENDIF
C
      IF(KUTDSK.LT.10000)THEN       !MAY SWITCH, THEN CHECK PRELOAD TEST
        KFBUFF=KUTDSK                !BUFFER BY CF, SMALL MEM BUT SLOWER
      ELSE
        WRITE(0,*)"***ATTENTION, SR.ALGEB1: KUTDSK.GE.10000 BUFFERS"
     X," ALL CF'S IN GROUPS, THEN RESETS KUTDSK=MOD(KUTDSK,10000)"
        WRITE(6,*)"***ATTENTION, SR.ALGEB1: KUTDSK.GE.10000 BUFFERS"
     X," ALL CF'S IN GROUPS, THEN RESETS KUTDSK=MOD(KUTDSK,10000)"
        KFBUFF=KMAX          !BUFFER ALL CF'S IN GROUP(S), IF MEM ALLOWS
        KUTDSK=KUTDSK-10000
      ENDIF
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      BPRINT=MPRINT.GE.0.OR.(MPRINT.LE.-1.AND.
     X           IDW.EQ.0.and.qn(mxorb).lt.80)
      BLP2=MPRINT.GE.2
      BLP1=MPRINT.GE.1
c      BLP0=MPRINT.EQ.0
      BLF=.FALSE.
C
C NOW COMPUTE IN SR.VCU/VCG SLATERSTATES (SLST) OF CONFIGURATIONS
C KF=1..KMAX, RESULTING TERMS SL  AND VECTOR COUPLING COEFFICIENTS (VCC)
C WHICH MAY ALSO BE STORED ON DISKDC;
C INPUT  NEL(K,KF)
C
      MTGD=0
      JB=1
      NTG(0)=0
      JTGD(0)=0
      KGCF(0)=0
C
      NASTKP=0                  !INIT. PARENT SYMMETRY SELECTION
      NASTK=0                   !INIT. SYMMETRY SELECTION
      QCSX=0                    !INITIALIZE GLOBAL MAX S
      QCLX=0                    !INITIALIZE GLOBAL MAX L
C
      MOD0=MODD                 !HOLD ORIGINAL INFO
      KCUT0=KCUT
      KCUTP00=KCUTP
      NAST0=NAST
      NASTP0=NASTP
      NASTJ0=NASTJ
      ITANL0=ITANAL
      idw0=idw
c
c      ttvcu=0.
c      ttvcg=0.
C
C LOOP OVER CFS
C
      DO KF=1,KMAX
C
        IF(KF.EQ.KCUT+1.AND.KCUT.NE.0)WRITE(6,120)
        IF(KF.EQ.MAX(IZERO,KUTLS)+1)WRITE(6,121)
C
        IF(ITANL0.NE.0)REWIND(31)
        ITANAL=-ABS(ITANL0)
        BANAL(KF)=.FALSE.
        BDISK=KF.GT.KUTDSK                            !USE DISKDC
        BKMAP=NASTP0.EQ.0.AND.KCUTP00.EQ.0
     X                   .AND.BDISK.AND..NOT.BLP1     !ARB CUP ORD
c*********                       !temp, since need to map new s.s. order
        bkmap=.false.            !as matching kf-kg interact pairs uses
c*********                       !the cf order defined by qcg
        KGCF(KF)=0
C
        NE1=0        !WILL ONLY APPLY KCUTP IF OUTER SS HAS 1 OR 2 ELECS
        BNGE80=.FALSE.
        KSUB0=MXORB
        DO K=MXORB,1,-1          !NL-SUBSHELL RESOLUTION
          N=NEL(K,KF)
          IF(N.GT.0)THEN
            IF(NE1.EQ.0)NE1=N                    !AS QCG NOT YET DEFINED
            IF(.NOT.BNGE80)BNGE80=QN(K).GE.80        !RYD OR CONT CF
            KSUB(KSUB0)=K
            KSUB0=KSUB0-1
            IF(MXORB-KSUB0.EQ.KSUBCF+1)GO TO 5       !NO MORE RESOLUTION
          ENDIF
        ENDDO
C
   5    CONTINUE
C                                !APPLY KCUT/KCUTP TO PARENTS
        BPARNT=.FALSE.
        IF(BNGE80)THEN           !THEN TO PARENT RYD/CONT CF, USES KCUT
          BPARNT=.TRUE.
          KCUTP0=KCUT0
c*********
          bkmap=.false.          !temp, since need to map new pos for nf
c*********
        ELSEIF(NE1.LE.2)THEN     !APPLY KCUTP TO REMAINING PARENT TERMS
          BPARNT=.TRUE.          !.FALSE. FORCES OFF FOR NON-RYD BOUND
          KCUTP0=KCUTP00         !ONLY APPLY IF KCUTP SET
        ENDIF
C
        KSUB(KSUB0)=0
        K0=-1
        DO K=KSUB0,MXORB
          K0=K0+1
          KSUB(K0)=KSUB(K)
C          write(0,*)kf,k0,ksub(k0)
        ENDDO
        KSUB0=K0
C
        IF(BKMAP)THEN
          DO KS=1,KSUB0
            IWT0=1
            KSI=KSUB(KS-1)+1      !KSI,KSF DEFINES SUBSHELL RANGE
            KSF=KSUB(KS)
            DO K=KSI,KSF
              NRJ=NEL(K,KF)
              LRJ=2*QL(K)+2
              IF(NRJ.GT.0)IWT0=IWT0*QBINOM(LRJ,NRJ)
            ENDDO
            DO KSI=1,KS-1
              IF(IWT0.LT.IWT(KMAP(KSI)))THEN
                 DO KSF=KS-1,KSI,-1
                   KMAP(KSF+1)=KMAP(KSF)
                 ENDDO
                 GO TO 4
              ENDIF
            ENDDO
            KSI=KS
    4       IWT(KS)=IWT0
            KMAP(KSI)=KS
          ENDDO
c          do ks=1,ksub0
c            write(0,*)ks,kmap(ks),iwt(kmap(ks))
c          enddo
        ELSE
          DO KS=1,KSUB0
            KMAP(KS)=KS
          ENDDO
        ENDIF
C
        IF(IDW.NE.0)MODD=0
        IF(KSUB0.GT.1)THEN      !NEED ALL M_X AND MUST NOT SELECT YET
          MODD=0
          KCUT=0
          NAST=0
          NASTJ=0
          idw=0
        ENDIF
C
        IF(BPARNT.AND.KSUB0.EQ.2)THEN
          KCUTP=KCUTP0          !MUST SELECT PARENT IN VCU, VCG TOO LATE
          NASTP=NASTP0
          IF(BNGE80)ITANAL=ABS(ITANAL)               !VCU NOT YET CODED
        ELSE
          KCUTP=0               !MAYBE SELECT PARENT IN VCG
          NASTP=0
        ENDIF
C
        NF=0
        QCP(KF)=0               !INITIALIZE FOR PARITY
        NTGA=NTG(KF-1)
        MSST=2                  !INIT. NO. OF SS USED BY VCU FOR KF ONLY
        LABT='PARENTS'
C
C LOOP OVER SUBCONFIGURATIONS
C
c        tvcg=0.
c        tvcu=0.
c
        DO KS0=1,KSUB0
C
          KS=KMAP(KS0)
          KSI=KSUB(KS-1)+1      !KSI,KSF DEFINES SUBSHELL RANGE FOR VCU
          KSF=KSUB(KS)
          JBS=JB
C
c          call cpu_time(timei)
C
          CALL VCU(QLML,QLMS,QBML,QBMS,DE,DS,NDI,IAXST,MAXEL)
C
          IF(NFS.LE.0)GO TO 109
          IF(NB.LT.0)GO TO 6    !DIMENSION FAILURE, BAIL OUT
c
c          call cpu_time(timef)
c          tvcu=tvcu+timef-timei
c          write(71,*)'vcu',timef-timei
c          call flush(71)
C
C
          IF(KS0.EQ.KSUB0)THEN   !NOW RESTRICT M_X AND SELECT
            idw=idw0
            JSP1=0
            IF(IDW.EQ.0)THEN
              MODD=MOD0
            ELSE
              IF(ABS(MOD0).LE.1)JSP1=1
            ENDIF
            KCUT=KCUT0
            NAST=NAST0
            NASTJ=NASTJ0
            IAXST=-IAXST                                  !FLAG BFINAL
            IF(.NOT.BNGE80)ITANAL=ABS(ITANAL)
          ENDIF
          IF(BPARNT.AND.KS0.EQ.KSUB0-1)THEN               !KS=KS0 HERE
            KCUTP=KCUTP0
            NASTP=NASTP0
            IF(BNGE80)ITANAL=ABS(ITANAL)
          ENDIF
c
c          call cpu_time(timei)
c
C
          CALL VCG(QLML,QLMS,QBML,QBMS,DFS,IAXST,MAXEL)
C
          IF(NF.LE.0)GO TO 109
C
c          call cpu_time(timef)
c          tvcg=tvcg+timef-timei
c          write(71,*)'vcg',timef-timei
c          call flush(71)
c
          KCUTP=0
          NASTP=0
C
          IF(BLP2.AND.NB.EQ.0)THEN                        !WRITE PARENTS
            NFW=NF-NFS
            WRITE(6,30)KF,NB,(QN(QCG(I,KF)),QL(QCG(I,KF))/2,I=1,NFW)
            WRITE(6,21)NTP1,LABT,(NFI(I)+1,NFK(I)/2,NFQ(I),I=1,NTP1)
            WRITE(6,29)KS,NB,(QN(QCGS(I)),QL(QCGS(I))/2,I=1,NFS)
            I1=NTP2-NTP1
            I2=NTP1+1
            WRITE(6,21)I1,LABT,(NFI(I)+1,NFK(I)/2,NFQ(I),I=I2,NTP2)
            IF(KS0.GT.1)THEN                                !KS=KS0 HERE
              NT=NTG(KF-1)
              M=NTG(KF)
              NK=M-NT                        !NO. OF TERMS SELECTED
              I=NT
              DO N=1,NK
                I=I+1
                J=NTGP(I)-NT
                L=NTGS(I)-NT
                WRITE(6,82)I,N,QTGS(I)+1,QTGL(I)/2,QTGD(I),
     X                     J,NFI(J)+1,NFK(J)/2,NFQ(J),
     X                     L-NTP1,NFI(L)+1,NFK(L)/2,NFQ(L)
              ENDDO
            ENDIF
          ENDIF
C
          BLT=NB.GT.0           !ACCURACY FAILURE (DIMENSION IF NB.LT.0)
          IF(NB.NE.0)GO TO 6    !BAIL OUT OF SUBCONFIGURATION LOOP
C
        ENDDO                   !END LOOP OVER SUBCONFIGURATIONS
C                               --------------------------------
        KGCF(KF)=KGCF(KF)+KGCF(KF-1)
c
c        write(71,*)'cf=',kf,' vcu time=',tvcu
c        write(71,*)'cf=',kf,' vcg time=',tvcg
c        ttvcu=ttvcu+tvcu
c        ttvcg=ttvcg+tvcg
c        call flush(71)
c
C
C UPDATE GLOBAL MAX S,L (MAY HAVE BEEN INPUT VIA QCS0,QCL0 IN /MQVC/)
C
        QCSX=MAX(QCSX,QCS0)
        QCLX=MAX(QCLX,QCL0)
C
C WRITE-OUT DETAILS, TERM INFO ETC
C
   6    MODD=MOD0                                    !CASE IDW.GT.0
        NASTP=NASTP0
        ITANAL=ITANL0
C
        DO I=1,NF
          K=QCG(I,KF)
          IF(QN(K).LT.80.AND.QN(K).GT.MAXNV.AND.KCUT*KCUT.GE.KCUT*KF)
     X                         MAXNV=MOD(INT(QN(K),SP),I70)        !I60?
          QLMS(I,1)=QN(K)
          LL(I)=QL(K)/2
          QLML(I,1)=QL(K)
        ENDDO
C
C NB.LT.0: STORAGE EXCEEDED;  NB.GT.0: ACCURACY OR PHASE FAILURE
C NB=0: SLATER STATES AND VCC PROPERLY COMPUTED BY VCU/VCE
C
CC  WRITE(6,30)KF,NB,(QN(QCG(I,KF)),QL(QCG(I,KF))/2,I=1,NF)
C
        M8=INT(NB)
        IF(BDISK.AND.M8.EQ.0)M8=MDCF8
        WRITE(6,30)KF,M8,(QLMS(I,1),LL(I),I=1,NF)
C
C        ND=NTGB-NTGA
c        IF(ND.EQ.0)GO TO 99
C
        MSTAT(KF)=MSST-1                          !FOR CONFIG KF HERE
c        write(0,*)msst-1
        MSST=JA-1+MSST-1                          !NOW GLOBAL
C
        NT=NTG(KF-1)
        M=NTG(KF)
        NK=M-NT                                   !NO. OF TERMS SELECTED
        IF(NK.EQ.0)GO TO 11                                !.AND.NB.EQ.0
C        ND=NK
        K=NT+1
C                       ,MSST
        WRITE(6,20)JA,JB     ,IAXST,MTGD,IAXDC,MAXDF,MODD
C
        IF(BLP1.AND.KSUB0.GT.1)THEN             !WRITE FINAL PARENTS
          LABT='FINAL  '
          WRITE(6,21)NTP1,LABT,(NFI(I)+1,NFK(I)/2,NFQ(I),I=1,NTP1)
          LABT='PARENTS'
          I1=NTP2-NTP1
          I2=NTP1+1
          WRITE(6,21)I1,LABT,(NFI(I)+1,NFK(I)/2,NFQ(I),I=I2,NTP2)
          I=NT
          DO N=1,NK
            I=I+1
            J=NTGP(I)-NT
            L=NTGS(I)-NT
            WRITE(6,82)I,N,QTGS(I)+1,QTGL(I)/2,QTGD(I),
     X                 J,NFI(J)+1,NFK(J)/2,NFQ(J),
     X                 L-NTP1,NFI(L)+1,NFK(L)/2,NFQ(L)
          ENDDO
        ENDIF
C
        LABT='TERMS  '
        IF(BPRINT)THEN
          WRITE(6,21)NK,LABT,(QTGS(I)+1,QTGL(I)/2,QTGD(I),I=K,M) !ND
        ELSE
          WRITE(6,21)NK,LABT                                     !ND
        ENDIF
C
        IF(NB.LT.0)GO TO 99
        IF(.NOT.BLP2)GO TO 11
C
        WRITE(6,70)KF,(QLMS(I,1),QLML(I,1),I=1,NF)
        WRITE(6,81)JB,NB,IAXST
C
        DO J=JA,JB
          L=QBMS(J)+QBML(J)
          WRITE(6,80)J,QBML(J),QBMS(J),L,(QLML(I,J),QLMS(I,J),I=1,NF)
        ENDDO
C
        WRITE(6,110)NK,(QTGS(I),QTGL(I),QTGD(I),I=K,M)            !ND
C
        IF(.NOT.BLT.AND..NOT.BDISK)THEN
          N=NTG(KF)
          DO J=JA,JB
            L1=1+(NK-1)/MAXDF
            I1=0
            DO L=1,L1
              I0=I1+1
              I1=MIN(NK,L*MAXDF)
              N=0
              DO I=I0,I1
                N=N+1
                IF(BFAST)THEN
                  K=J+JTGD(I+NT)                 !relative start flagged
                  DS(N)=DC(K)
                ELSE
                  K1=JTGD(I-1+NT)+1                !absolute end flagged
                  K2=JTGD(I+NT)
                  DO K=K1,K2                            !FOR SMALL CASES
                    IF(IDC(K).EQ.J)THEN
                      DS(N)=DC(K)
                      GO TO 10
                    ENDIF
                  ENDDO
                  DS(N)=DZERO
  10              CONTINUE
                ENDIF
              ENDDO
              WRITE(6,59)J,(DS(I),I=1,N)
            ENDDO
          ENDDO
          WRITE(6,110)
        ENDIF
C
  11    JYI(KF)=JA
        IF(BLT)THEN
          BLF=.TRUE.
          IF(NB.LE.MAXDF)THEN
            WRITE(6,96)
          ELSE
            WRITE(6,98)
          ENDIF
        ENDIF
        JYF(KF)=JB
C
      ENDDO                      !END LOOP OVER CONFIGURATIONS
C                                -----------------------------
C
      NTT=NTG(KMAX)                       !TOTAL NO. OF TERMS
C
C REPLACE GLOBAL MAX S,L
C
      QCS0=QCSX
      QCL0=QCLX
C
C
      IF(BDISK)THEN
C
        MDCFT8=MDCFT8+MDCF8               !pick-up final config
        IF(KUTDSK.LT.KFBUFF)THEN
C
          MDCBUF=IAXDC                    !SINCE UNKNOWN AHEAD OF TIME
          IF(MDCFT8.LE.IAXDC)THEN
            M=INT(MDCFT8)
            MDCBUF=MIN(MDCBUF,MTGD+M)     !FOR ANY SUBSEQUENT ALLOCATE
          ENDIF
C
        ELSE
C
          MDCBUF=MDCBUF+MDCBUF+MTGD       !SINCE NEED TO HOLD TWO SLICES
          IF(mdcbuf.le.0)THEN             !.le.0 -> I*4 overflow
            WRITE(0,*)'*** SR.ALGEB1: TOO MANY VCCs FOR I*4'
            WRITE(6,*)'*** SR.ALGEB1: TOO MANY VCCs FOR I*4',
     X                ', SET DEFAULT INTEGER SP=8 IN MODULE PRECSN'
            NF=-1
            GO TO 109
          ENDIF
C
          IF(MDCBUF.GT.IAXDC)THEN
C
            IXXX=MDCBUF
C
            WRITE(6,*)'*** ALGEB1: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** ALGEB1: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'ALGEB1: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 109
            ENDIF
C
            IF(DC(0).GT.DZERO)THEN
C
              CALL RE_ALLOC(IDC,IONE,MTGD,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'ALGEB1: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 109
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
C            MDCBUF=IAXDC
C
          ENDIF
C
        ENDIF
C
      ENDIF
C
      MTGDMX=0
      CALL DIMUSE('MAXDC',MTGDMX)
      JBMX=0
      CALL DIMUSE('MXST0',JBMX)
      MXCTM=0
      CALL DIMUSE('MAXCT',MXCTM)
      WRITE(6,19)MXCTM,MAXCT,JBMX,IAXST,MTGDMX,IAXDC
      IF(BDISK)WRITE(6,22)MDCFT8
C
      CALL DIMUSE('MXEST',NF*JBMX)
c
c      write(71,*)'total vcu time=',ttvcu
c      write(71,*)'total vcg time=',ttvcg
c      call flush(71)
C      if(tvcg.gt.0)stop 'test algeb1'
C
      IF(NTT.EQ.0)GO TO 9
      IF(BLF)GO TO 9
C
      GO TO 109
C
  99  WRITE(6,90)
   9  NF=-1
 109  CONTINUE
C
C LOCAL
      IF(ALLOCATED(LL))DEALLOCATE (LL,KSUB,KMAP,IWT)
C
C EX-COMMON/NRBVCX/ (NOW IN MODULE EX-COMMON/DBD2) ONLY IN ALGEB1 BRANCH
      IF(ALLOCATED(QCGS))DEALLOCATE (QCGS)
C
      RETURN
C
   19 FORMAT(//I8,'=BUFFER',3X,'MAXCT=',I8,';',4X,I10,'=JBF MXST0=',I10
     X,';',17X,I10,'=MTGD, MAXDC=',I10,' BUFFER STORAGE USED')
   20 FORMAT(' SLATER-STATES STORED IN' ,I10,'=JA',I10
     X,'=JB, MAXST=',I10,'; VCC STORED UP TO',I10
     X,'=MTGD, MAXDC=',I10,'; MAXDF=',I4,'; MOD=',I2)
   21 FORMAT(I8,' SPECTROSCOPIC ',A7,' (2S+1 L DP):'
     X,9(2X,I3,I2,I3)/(43X,9(2X,I3,I2,I3)))
   22 FORMAT(/47X,"TOTAL NUMBER OF VCC'S STORED ON DISK:",I12/)
   29 FORMAT(//' SUBCONFIGURATION=',I4,',', I4,' ON DISK, (N-L)-'
     X,'COMBINATIONS  ', 12(I4,I2) )
   30 FORMAT(//' CONFIGURATION CF=',I4,',',I11,' ON DISK, (N-L)-'
     X,'COMBINATIONS  ', 12(I4,I2)/64X,12(I4,I2))
   59 FORMAT(I4,16F8.4/(4X,16F8.4))
   70 FORMAT(/I4,'=CF 2ML 2MS 2MJ',1X,(14(I5,I3)))
   80 FORMAT( I6, I5,I4,I4, 1X, (14(I5,I3)) )
   81 FORMAT(I6,I6,I8)
   82 FORMAT(I5,I5,I4,I2,I3,2X,':',1X,I4,I4,I2,I3,2X,I4,I4,I2,I3)
   90 FORMAT(//"SR.ALGEB1: STORAGE EXCEEDED IN VCU - OR VCG - CALL"//
     X"'DISK'=-3 IF TOO MANY SLATER STATES ((JB').GT.MAXST), -2 IF TOO "
     X,"MANY TERMS (SUM(ND).GT.MAXCT), -1 IF TOO MANY VCC "
     X,"(MTGD.GT.MAXDC)"//  "  AUGMENT MXST0 (IN CASE -3),  AUGMENT  ",
     X"MAXTM (IN CASE -2),  AUGMENT  MAXDC (IN CASE -1)")
   96 FORMAT(//' SR.ALGEB1: SR VCU HAS FAILED -IN PHASES OR ACCURACY'//)
   98 FORMAT(  " SR.ALGEB1: WORKING ARRAYS D2,DU,DV,DS,DE,NDI TOO SMALL"
     X," ('DISK'.GT. MAXDF)")
  110 FORMAT(/I4,16(I3,I2,I3)/(4X,16(I3,I2,I3)))
  120 FORMAT(// " ATTENTION: THE FOLLOWING CF'S ARE MERE CORRELATION"
     X," CONFIGURATIONS")
  121 FORMAT(// " ATTENTION: THE FOLLOWING CF'S ARE RESTRICTED TO"
     X," CI-MIXING WITHIN EACH CONFIGURATION ONLY!")
  130 FORMAT(// ' MOD=0 RESET TO -1, BECAUSE SR.VCU DOES NOT LIKE'
     X,' CORRELATION CONFIGURATIONS IN THAT MODE.')
c  140 FORMAT(/'*** SR.ALGEB1: INCREASE MAXDC TO AT LEAST:',I10,' FOR',
c     X' SUBSEQUENT USE BY ALGEB2,3,4')
C
      END SUBROUTINE ALGEB1
C
C                             *******************
C
      SUBROUTINE ALGEB2(MAM,NAM,QLML,QLMS,QBML,QBMS,JYI,JYF,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB2 DEALS WITH THE PROBLEMS DESCRIBED IN SECTION 3.2 OF E&N:
C  IT CALCULATES THE PURELY ALGEBRAIC COEFFICIENTS FOR EACH NONVAN-
C  ISHING ENERGY MATRIX ELEMENT, ASSUMING ELECTROSTATIC INTERACTION;
C  ALSO, REDUCED ELECTRIC MULTIPOLE MATRIX ELEMENTS ARE COMPUTED.
C
C  IT CALLS:
C    SR.DISKDC
C    SR.DIMUSE
C    SR.EKALG1
C    SR.EKALG2
C    SR.FLGL1
C    SR.FLGL2
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,N8,IWORD,IAXRK
     X                        ,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBEKP, ONLY: BNRBEKP,NED
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADD
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB,MENGB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXRK0=100000)
      PARAMETER (MXRKS0=MAXRK0)
      PARAMETER (MAXRL0=  2500)
      PARAMETER (MXRLS0=MAXRL0)
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD14=100)
      PARAMETER (MXD20=100)
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (MG=-2)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      INTEGER(EP) MDCF8,MDCFT8
C
      CHARACTER(LEN=4) CODE,MBLANK,MYRGE
C
      LOGICAL BEX,BEXJ                    !INQUIRE REQUIRES DEFAULT KIND
C
      DIMENSION MAM(*),NAM(*),JYI(*),JYF(*)
     X         ,QLML(MAXEL,*),QBML(*),QLMS(MAXEL,*),QBMS(*)
C
      DIMENSION DFS(MXDFS),DVC(0:MXD20),JMG(MAXJG)
C
      ALLOCATABLE :: BAM(:),BBM(:),B1B(:),B2B(:),KSTART(:,:)
C
      COMMON /BASIC/NF,KF,KG,NC,ND,mb1,mb2,ND1,NDP1,ND2,NDP2,NGAP
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /CHARY/DEY(MAXGR)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBLSS/NESSH(MAXSL),NASTS,MINSTS,MAXSTS,MINLTS,MAXLTS
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      DATA MBLANK/'    '/
C
c      MVC(M1,M2)=((M1+2)*M1/2+M2)/2+1!SEE INTRNL FUNCTN ABVE END ALGEB2
C
C-----------------------------------------------------------------------
C
C INITIALIZATIONS
C
C-----------------------------------------------------------------------
C
      BPRINT=MPRINT.GT.0.OR.MPRINT.EQ.0.AND.IDW.EQ.0
C
      BKUTLS=KUTLS.LT.0                          !.T. FOR SINGLE CF MIX
      KUTLS=MIN(KUTLS,KMAX)
C
      BAMBM=.FALSE.
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
      MOD2=MODD                  !CAN RE-SET TO TEST VARIOUS TOTAL ML,MS
c      mod2=1                     !MODD.LE.0 NOW
      BMOD2=(MOD2+1)/2.EQ.1      !SLOWER
C
      BKUTOO=KUTOO.NE.0
      BDLBD=ABS(MODD).LT.2.OR.BKUTOO
C
C CAN MAKE BIG CASES MORE EFFICIENT IF WE NO LONGER ALLOW THIS - NRB
C
      IF(MPRINT.NE.MG.AND.MODD.GT.0)THEN
        WRITE(6,*)'***MOD.GT.0 WILL NO LONGER COMPUTE RADIATION'
        WRITE(6,*)'***SET MOD.LE.0 OR SWITCH-OFF RADIATION'
        WRITE(0,*)'***MOD.GT.0 WILL NO LONGER COMPUTE RADIATION'
        GO TO 99
      ENDIF
C
C NEED MAX ORBITRAL L FOR VCC STORAGE AND BORN.
C
      MXLL=-1
      DO K=1,MXORB
        IF(DEY(K).NE.DZERO.AND.QL(K).GT.MXLL)MXLL=QL(K)
      ENDDO
C
      IF(MENGB.GE.0)THEN                  !CAN NOW RESTRICT MPOLE (BORN)
        MPOLE=MIN(MPOLE,2*MXLL)
        IF(MPOLM.GE.198)THEN                                    !DEFAULT
          MPOLM=MIN(ITEN,MPOLE-2)                        !FOR LARGE MXLL
        ELSE
          MPOLM=MIN(MPOLM,MPOLE+2)           !DON'T ALLOW USER TO GO MAD
          MPOLE=MAX(MPOLE,MPOLM+2)  !FIX FOR USER M_K WITH NO E_K+1 PAIR
C          MPOLM=MPOLE-2                     !ALLOW USER TO RESTRICT M_K
        ENDIF
      ELSE
        IF(MPOLM.GT.MPOLE-2)THEN
          MPOLE=MPOLM+2
          WRITE(0,*)'*** NOTE; INCREASING KPOLE TO',MPOLE/2
     X              ,'BECAUSE YOUR INPUT KPOLM=',MPOLM/2
          WRITE(6,*)'*** NOTE; INCREASING KPOLE TO',MPOLE/2
     X              ,'BECAUSE YOUR INPUT KPOLM=',MPOLM/2
        ENDIF
      ENDIF
C
C FOR MPRINT.GE.0 MPOLE HAS ALREADY BEEN SET (DEFAULT=4)
C
      IF(MPRINT.EQ.-1.OR.MPRINT.EQ.-4)MPOLE=2
      IF(MPRINT.EQ.MG)MPOLE=-1                                 !FOR INFO
      IF(MPOLE.GT.2*MXBLM)THEN
        IF(MXBLM.GT.0)THEN
          WRITE(6,955)MPOLE/2,MXBLM
C          WRITE(0,955)MPOLE/2,MXBLM
        ENDIF
C        IXBLM=MPOLE/2               !NOT NEEDED UNTIL MINIM
      ENDIF
C
      CALL DIMUSE('MXBLM',MAX(IONE,MPOLE/2))
C
      MPOLX=MPOLE
      IF(MPOLX/2.GT.MXD20)THEN
        WRITE(6,*)'*** ALGEB2: DO YOU REALLY NEED ALL THESE MULTIPOLES?'
        WRITE(0,*)'*** ALGEB2: DO YOU REALLY NEED ALL THESE MULTIPOLES?'
        WRITE(6,*)'*** IN NAMELIST SALGEB: reduce KPOLE from ',MPOLX/2
     X                ,' to: ',MXD20
        WRITE(0,*)'*** IN NAMELIST SALGEB: reduce KPOLE from ',MPOLX/2
     X                ,' to: ',MXD20
        GO TO 99
      ENDIF
C
CB      BBORN=MENGB.GE.0            !BORN CODING NOW USED MORE GENERALLY
CB      IF(BBORN)THEN
      MPOL0=MPOL00
      IF(MPOL0.GE.0)THEN            !BORN CODING NOW USED MORE GENERALLY
        MXORB2=(MXORB*(MXORB+1))/2
        LHM=MPOLE/4
        IF(BREL)LHM=LHM+1
      ELSE
        MXORB2=1
        LHM=0
      ENDIF
C
C-----------------------------------------------------------------------
C
C EX-COMMON/NRBGCF/
      ALLOCATE (KGSL(KMAX,MAXSL),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR KGSL'
        NF=0
        RETURN
      ENDIF
C
C EX-COMMON/NRBRN2/
      ALLOCATE (BINDB(MXORB2,0:LHM),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  BINDB'
        NF=0
        RETURN
      ENDIF
      BNRBRN2=.TRUE.
C
C-----------------------------------------------------------------------
C
      DO LH=0,LHM
        DO I=1,MXORB2
          BINDB(I,LH)=.FALSE.
        ENDDO
      ENDDO
C
      IF(NASTS.NE.0)THEN
        WRITE(6,1111)
        WRITE(6,1130)
        IF(NASTS.GT.0)THEN
          WRITE(6,1131)
          ISM=999
          DO I=1,NASTS
            IO=NESSH(I)/100000
            IS=NESSH(I)-IO*100000
            IQ=IS/1000
            IL=IS-IQ*1000
            IS=IL/10
            IL=IL-IS*10
            WRITE(6,1132)IO,IQ,IS,IL
            ISM=MIN(IS,ISM)
          ENDDO
         IF(ISM.EQ.0)WRITE(6,1134)MINSTS,MAXSTS,MINLTS,min(99_SP,MAXLTS)
        ELSE
          WRITE(6,1133)
          DO I=1,-NASTS
            IO=NESSH(I)/100000
            IQ=(NESSH(I)-IO*100000)/1000
            WRITE(6,1132)IO,IQ
          ENDDO
          WRITE(6,1134)MINSTS,MAXSTS,MINLTS,min(99_SP,MAXLTS)
        ENDIF
        WRITE(6,1111)
      ENDIF
C
      IF(NASTP.NE.0)THEN
        WRITE(6,1111)
        WRITE(6,1116)
        IF(NASTP.GT.0)THEN
          DO IPCF=1,KMAX                              !MAXCF
            NPCF=NLSPIP(IPCF)
            IF(NPCF.GT.0)THEN
              WRITE(6,1118)IPCF
              WRITE(6,1113)
              DO I=1,NPCF
                IS=LSPIP(I,IPCF)/10000
                IP=LSPIP(I,IPCF)-IS*10000
                IL=IP/10
                IP=IP-IL*10
                WRITE(6,1114)I,IS,IL,IP
              ENDDO
            ENDIF
          ENDDO
        ELSE
          WRITE(6,1117)MINSTP,MAXSTP,MINLTP,min(99_SP,MAXLTP)
        ENDIF
        IF(NAST.EQ.0)THEN
          WRITE(6,1111)
        ELSE
          WRITE(6,*)' '
        ENDIF
      ENDIF
C
      IF(NAST.NE.0)THEN
        IF(NASTP.EQ.0)THEN
          WRITE(6,1111)
        ELSE
          WRITE(6,*)' '
        ENDIF
        WRITE(6,1112)
        IF(NAST.GT.0)THEN
          WRITE(6,1113)
          DO I=1,NAST
            IS=LSPI(I)/10000
            IP=LSPI(I)-IS*10000
            IL=IP/10
            IP=IP-IL*10
            WRITE(6,1114)I,IS,IL,IP
          ENDDO
        ELSE
          WRITE(6,1115)MINSP,MAXSP,MINLT,min(99_SP,MAXLT)
        ENDIF
        WRITE(6,1111)
      ENDIF
C
C PACK CORE M_S AND M_L INTO M_L
C
      DO I=1,NW
        NNL(I,2)=(NNL(I,3)+1)/2+NNL(I,2)
      ENDDO
C
C PACK QLMS AND QLML INTO ONE ARRAY
C
      DO J=JYI(1),JYF(KMAX)
        DO I=1,NF
          QLML(I,J)=(QLMS(I,J)+1)/2+QLML(I,J)
        ENDDO
      ENDDO
C
C RETABULATE THE NCI=NTG(KMAX) TERMS CASL OF THE KMAX CONFIGURATIONS
C ACCORDING TO TOTAL S,L,KPC(=PARITY  0,2 FOR EVEN,ODD); ONE OBTAINS
C NSL0 BLOCKS OF LENGTH NSL(N), WITH QSI(N)=2S,QLI(N)=2L,QPI(N)=KP;
C
      WRITE(6,400)
C
      BLX=.FALSE.
      NCTOT=0
      NCI=0
      NSL0=0
      NN=0
      ISXDI=1
      IAXDI=1
      IAXUC=0
      IXAAI=0
c      lusum=0
C
      DO I=1,MAXSL
        DO K=1,KMAX
          KGSL(K,I)=0
        ENDDO
      ENDDO
C
C                                    !BEGIN SLP SYMMETRY LOOPS
C
      QCL=QCL0         !L
C
  51  QCS=QCS0         !S
C
  52  KCP=0            !P
C
  53  NC=0
      NCC=0
c
c      if(bkutls)then
      ncft0=0
      ncft=0
c      else
      do i=1,mxorb
        ncc0(i)=0
      enddo
      mx0=mxorb+1
c      endif
C
      DO K=1,KMAX                                 !LOOP OVER ALL CONFIGS
        IF(QCP(K).EQ.KCP)THEN
          II=QCG(NF,K)
          ii=ieq(ii)
          ncf=0
          NG=NTG(K-1)+1
          NT=NTG(K)
          QCSX=QTGS(NG)
          QCLX=QTGL(NG)
          K0=1
          ND0=0
C
          DO I=NG,NT
            IF(QTGL(I).NE.QCLX.OR.QTGS(I).NE.QCSX)THEN
              QCSX=QTGS(I)
              QCLX=QTGL(I)
              K0=K0+1
            ENDIF
            IF(QTGL(I).EQ.QCL.AND.QTGS(I).EQ.QCS)THEN
              ncf=ncf+1
              NCI=NCI+1
              BLP=NCI.GT.MAXTM
              IF(QN(II).GE.90)THEN
                NCC=NCC+1
                ncc0(ii)=ncc0(ii)+1
                mx0=min(mx0,ii)
              else
                NC=NC+1
              endif
              ND=NSL0+1
              ND0=K0
              if(bprint)WRITE(6,180)NCI,QCS+1,QCL/2,KCP/2,K,I,ND
              IF(.NOT.BLP)THEN
                NFQ(NCI)=ND
                NFK(NCI)=K
                NFI(NCI)=I
              ENDIF
            ELSE
              IF(QTGL(I).LT.QCL)GO TO 55                       !BAIL OUT
            ENDIF
          ENDDO
C
  55      BVC=ND.GT.MAXSL
          IF(.NOT.BVC.AND.ND0.GT.0)KGSL(K,ND)=ND0   !GROUP NO. WITHIN CF
          if(bkutls)then
            nn=nn+((ncf+1)*ncf)/2
            ncft=ncft+ncf*ncf
            if(.not.bfot.and.qn(ii).lt.90)ncft0=ncft0+ncf*ncf
c        write(6,*)k,ncft0,ncft,qn(ii)
            isxdi=max(isxdi,ncf)
          endif
        ENDIF
      ENDDO
C
      IF(NC+ncc.GT.0)THEN
c
       if(bkutls)then
c
        nc=nc+ncc
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+ncft
        else                                    !only b-b
          iaxuc=max(iaxuc,nctot+ncft)           !need buffer
          nctot=nctot+ncft0                     !so can overwite c-c
        endif
c
       else
c
        NN=((NC+1)*NC)/2+NN
        isxdi=max(isxdi,nc)
        iorb(mx0-1)=nc*nc
c
        do i=mx0,mxorb
          n=ncc0(i)
          iorb(i)=iorb(i-1)+n*n
          if(n.gt.0)then
            nn=((n+1)*n)/2+nn
            isxdi=max(isxdi,n)
            nc=nc+n
          endif
        enddo
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+iorb(mxorb)
        else                                    !only b-b
          iaxuc=max(iaxuc,nctot+iorb(mxorb))    !need buffer
          nctot=nctot+iorb(mx0-1)               !so can overwite c-c
        endif
c
       endif
c        write(6,*)nc,nn,nctot
C
        WRITE(6,197)ND,QCS+1,QCL/2,KCP/2,NC
C
        IAXDI=MAX(IAXDI,NC)
        IF(NC.GT.MAXDI)THEN
          IF(MAXDI.GT.0)WRITE(6,1966)
        ENDIF
C
        LU=NCC*(NC-NCC)
        IXAAI=MAX(LU,IXAAI)
        NN=NN+LU
c
c        lusum=lusum+lu
c        write(6,*)lu,nn
c        write(6,*)'lusum=',lusum
C
        NSL0=ND
        IF(.NOT.BVC)THEN
          QLI(ND)=QCL
          QSI(ND)=QCS
          QPI(ND)=KCP
          NSL(ND)=NC
          NGRPI(ND)=NCI-NC
        ENDIF
      ENDIF
C
      KCP=KCP+2
      IF(KCP.LE.2)GO TO 53           !LOOP UP TO NEXT PARITY
C
      QCS=QCS-2
      IF(QCS.GE.0)GO TO 52           !LOOP UP FOR NEXT SPIN
C
      QCL=QCL-2
      IF(QCL.GE.0)GO TO 51           !LOOP UP FOR NEXT ORB A.M.
C
C                                    !END SLP SYMMETRY LOOPS
      if(nci.ne.ntt.and..not.blp)
     xwrite(0,*)'sr.algeb2: mis-match between nci & ntt?',nci,ntt
c
      CALL DIMUSE('MAXTM',NCI)
      CALL DIMUSE('MAXSL',ND)
C
      BLP=BLP.OR.BVC
      IF(BLP)GO TO 94                      !DIMENSION EXCEEDED, BAIL OUT
C
      IADD=NN
C
      CALL DIMUSE('MAXAD',IADD)
      IF(IADD.GT.MAXAD)THEN
        IF(MAXAD.GT.0)WRITE(6,133)IADD,MAXAD
      ENDIF
C
C THESE 3 DIMENSIONS ARE FOR INFO ONLY. NOT NEEDED UNTIL DIAGON.
C NOTE: IF MODE=3 OR 4 IS SET IN MINIM THEN THE ACTUAL DIMENSIONS
C REQUIRED (ALLOCATED F95) WILL BE LARGER. THESE MODES ARE (SMALL)
C TEST CASES, NOT PRODUCTION RUNS, SO NOT LIKELY AN ISSUE. WOULD
C NEED USER TO SET MODE IN ALGEB, AND CODE DIAGON DIMENSION VARIATION.
C
      if(bfot)iaxuc=nctot
      WRITE(6,1979)ISXDI,IAXDI,MAXDI
      WRITE(6,198)NCTOT,IAXUC,MAXUC
      WRITE(6,1988)IXAAI,MXAAI
C
      IF(NCTOT.GT.MAXUC)THEN
        IF(MAXUC.GT.0)WRITE(6,1999)
      ENDIF
C
      IF(IXAAI.GT.MXAAI)THEN
        IF(MXAAI.GT.0)WRITE(6,299)IXAAI
      ENDIF
C
      IF(BLX)THEN                                    !NO LONGER POSSIBLE
        WRITE(6,200)
        WRITE(0,*)'*** INCREASE MXAAI OR MAXDI'
        GO TO 99
      ENDIF
C
C-----------------------------------------------------------------------
C
C SET METASTABLE LSP GROUPS BASED-ON PRE-EXISTING TERMS/LEVELS FILES
C SO AS TO RESTRICT UNNECESSARY BORN INTEGRAL EVALUATION ETC.
C
C-----------------------------------------------------------------------
C
      BEX=.FALSE.
      IF(NMETA.LT.0.AND..NOT.BVC)THEN
        NMETA=-NMETA
        INQUIRE(FILE='TERMS',EXIST=BEX)
        IF(BEX)THEN
          OPEN(14,FILE='TERMS',STATUS='OLD')
          READ(14,*,END=331)
          DO K=1,NSL0                            !ASSUME WE CAN RESTRICT
            NMETAG(K)=1
          ENDDO
          DO N=1,NMETA
            READ(14,992,END=331)ISP,LSP,IPP,NDUM,NDUM,DUM,MYRGE
            IF(MYRGE.NE.MBLANK)THEN                     !CANNOT RESTRICT
              DO K=1,NSL0
                NMETAG(K)=0
              ENDDO
              GO TO 331
            ENDIF
            IF(ISP.GT.0)THEN
              ISP=ISP-1
              LSP=LSP+LSP
              IPP=IPP+IPP
              DO K=1,NSL0
                IF(ISP.EQ.QSI(K).AND.LSP.EQ.QLI(K).AND.IPP.EQ.QPI(K)
     X                                                             )THEN
                  NMETAG(K)=0
                  GO TO 330
                ENDIF
              ENDDO
            ELSE
              GO TO 331
            ENDIF
 330      ENDDO
 331      CLOSE(14)
          IUNIT(14)=-1
c          write(6,*)'lsp groups'
c          do k=1,nsl0
c            write(6,*)k,nmetag(k)
c          enddo
        ELSE
          WRITE(6,1120)
          WRITE(0,1120)
        ENDIF
cw      ELSE
cw        IF(IDW.NE.0.AND.NMETA.GT.0)THEN
cw          WRITE(6,1121)
cw          WRITE(0,1121)
cw        ENDIF
      ENDIF
C
      IF(NMETAJ.LT.0.AND..NOT.BVC)THEN    !CATCH EK, ALGEB3 TOO LATE
        INQUIRE(FILE='LEVELS',EXIST=BEXJ)
        IF(BEXJ)THEN
          NMETJ0=NMETAJ
          NMETAJ=-NMETAJ
          OPEN(15,FILE='LEVELS',STATUS='OLD')
          READ(15,*,END=333)
          IF(.NOT.BEX)THEN    !ASSUME WE CAN RESTRICT, IF NOT ALREADY SO
            DO K=1,NSL0
              NMETAG(K)=1
            ENDDO
          ENDIF
          READ(15,993,END=333)JSP,IP0,IS0,LS0,ICF0,NDUM,DUM,MYRGE
          IS0=ABS(IS0)
          REWIND(15)
          READ(15,*,END=333)
          NMG=0
          DO N=1,MAXLV
            READ(15,993,END=333)JSP,IPP,ISP,LSP,ICF,NDUM,DUM,MYRGE
            IF(MYRGE.NE.MBLANK)THEN                     !CANNOT RESTRICT
              DO K=1,NSL0
                NMETAG(K)=0
              ENDDO
              GO TO 333
            ENDIF
            JSP=JSP+1
            IF(ISP.LT.0)THEN
              JSP=-JSP
              ISP=-ISP
            ENDIF
            IF(ISP.GT.0)THEN
              IF(NMETAJ/MAXLV.GT.0)THEN
                IF(ISP.NE.IS0.OR.LSP.NE.LS0
     X                       .OR.IPP.NE.IP0.OR.ICF.NE.ICF0)THEN
                  NMETAJ=N-1
                ELSE
                  ICF0=ICF
                  IS0=ISP
                  LS0=LSP
                  IP0=IPP
                ENDIF
              ENDIF
              DO M=1,NMG
                IF(JSP.EQ.JMG(M))GO TO 334
              ENDDO
              IF(N.LE.NMETAJ)THEN
                NMG=NMG+1
                JMG(NMG)=JSP
              ELSE
                GO TO 332
              ENDIF
 334          ISP=ISP-1
              LSP=LSP+LSP
              IPP=IPP+IPP
              DO K=1,NSL0
                IF(ISP.EQ.QSI(K).AND.LSP.EQ.QLI(K).AND.IPP.EQ.QPI(K)
     X                                                             )THEN
                  NMETAG(K)=0
                  GO TO 332
                ENDIF
              ENDDO
            ELSE
              GO TO 333
            ENDIF
 332      ENDDO
 333      CLOSE(15)
          IUNIT(15)=-1
          NMETAJ=NMETJ0                                      !RE-INSTATE
c          write(6,*)'lsjp groups'
c          do k=1,nsl0
c            write(6,*)k,nmetag(k)
c          enddo
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C FLAG EXISTENCE, OR NOT, OF ONE- OR TWO-BODY INTERACTIONS BETWEEN
C CONFIGURATION PAIRS
C
C-----------------------------------------------------------------------
C
C LOCAL
      IXD19=(KMAX*(KMAX+1))/2
C
      ALLOCATE (B2B(IXD19),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR B2B'
        NF=0
        RETURN
      ENDIF
C
      IF(KUTDSK.LT.KMAX)ALLOCATE (KSTART(KMAX,2))
C
      if(iunit(12).ne.0)then                                 !for radwin
        i69=69
      else
c        i69=79                        !needs radwin present if external
        i69=69           !restrict to 60-9 normally, can extend to 79...
      endif
c
cc      iflagc=0
      KK=0
      DO KF=1,KMAX                                        !BEGIN KF LOOP
C
        II=IEQ(QCG(NF,KF))
        KCF=0
        IF(QN(II).GE.90)KCF=II                                !CONTINUUM
        if(qn(ii).ge.60.and.qn(ii).le.i69)kcf=-ii           !omit ryd ci
cc        iflagc=max(iflagc,kcf)
C
        DO KG=1,KF                                        !BEGIN KG LOOP
          KK=KK+1
C
          B2B(KK)=.FALSE.
C
C OMIT CONT-CONT'
          II=IEQ(QCG(NF,KG))
          KCG=0
          IF(QN(II).GE.90)KCG=II
          if(qn(ii).ge.60.and.qn(ii).le.i69)kcg=-ii         !omit ryd ci
          IF(KCF.NE.KCG.AND.KCF*KCG.NE.0)GO TO 696     !DOES NOT CONTRIB
          if(kcf.ne.kcg.and.(kcf+kcg).lt.0)go to 696
c
c omit corr-corr'
          if(kcutx.gt.0.and.kf.ne.kg.and.kg.gt.kcut)go to 696
cc                     .and.kcf+kcg+iflagc.gt.0
c
c single cf mixing (but keeping b-c)
          if(kf.ne.kg.and.(kcf+kcg.eq.0.or.kcf*kcg.ne.0))then
            if(kf.gt.kutls)go to 696
            if(kg.gt.kutls)go to 696
          endif
C
C SKIP, IF CONFIG KF AND KG DIFFER IN MORE THAN TWO ELECTRONS
C
          DO I=1,NF
            QLML(I,1)=QCG(I,KG)
          ENDDO
C
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(QLML(L,1)).EQ.IEQ(QCG(I,KF)))THEN
                QLML(L,1)=0
                GO TO 50
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.2)GO TO 696  !KF-KG DIFFER BY MORE THAN 2 PAIRS
  50      ENDDO
C
C
C FLAG KF-KG NEEDED
C
          B2B(KK)=.TRUE.
C
 696    ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
C-----------------------------------------------------------------------
C
C CHECK BUFFERS FOR DC ARRAY IF DISKDC IN USE (CAN ALWAYS SELF-INTERACT)
C
C-----------------------------------------------------------------------
C
      MDCBUF2=0
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
      CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
C
        IF(KUTDSK.LT.KFBUFF)THEN
          DO K=1,NSL0
            MTGD1=MTGD+1                                        !RESTORE
            DO KF=KUTDSK+1,KFBUFF
              NGSYM=KGSL(KF,K)                            !POS WITHIN CF
              IF(NGSYM.GT.0)THEN
                ISTRT=MTGD1
C
                CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IZERO,IZERO)
C
                MTGD1=IFIN+1
              ENDIF
            ENDDO
            IFIN=MTGD1-1
            MDCBUF2=MAX(MDCBUF2,IFIN)
          ENDDO
          IF(MDCBUF2.GT.MDCBUF)THEN
c
            if(MDCBUF.ne.IAXDC)stop 'algeb2: buffer index error...'
C
            IXXX=MDCBUF2
C
            WRITE(6,*)'*** ALGEB2: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** ALGEB2: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'ALGEB2: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 90
            ENDIF
C
            IF(.NOT.BFAST)THEN
C
              CALL RE_ALLOC(IDC,IONE,MTGD,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'ALGEB2: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 90
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
            MDCBUF=IAXDC
c            WRITE(6,140)MDCBUF2
c            GO TO 99
          ENDIF
c          write(6,*)'ALGEB2 flgl; ',mdcbuf2
c          write(76,*)'ALGEB2 flgl'
          MDCBUF2=0
        ELSE
          MDCBUF2=MDCBUF
          DO K=KFBUFF+1,KMAX
            KSTART(K,1)=0
          ENDDO
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.LT.MG)THEN
        IF(.NOT.BKUTOO)
     X  WRITE(6,150)MAXAD,MAXSL,MAXTM,MAXTM,IAXRK,IAXRL,MXDFS
        IF(BKUTOO)
     X  WRITE(6,151)MAXAD,MAXSL,MAXTM,MAXTM,IAXRK,IAXRL,MXDFS,KUTOO
        IF(MAXLAM.NE.1000)WRITE(6,152)MAXLAM
        WRITE(6,120)IADD,NSL0,NCI,NCI,0,0
        WRITE(6,1190)MDCBUF2,MAXDC
      ENDIF
C
C-----------------------------------------------------------------------
C
C EX-COMMON/DXRL/
C
      IAXRK=MAX(MAXRK0,MAXRK,IAXRK)               !USE LARGEST PREVIOUS
C      IAXRK=MAX(MAXRK0,MAXRK)                     !RESET
      IAXRL=MAX(MAXRL0,MAXRL,IAXRL)               !USE LARGEST PREVIOUS
C      IAXRL=MAX(MAXRL0,MAXRL)                     !RESET
C
      ALLOCATE (DRK(IAXRK),QRL(5,IAXRL),NRK(IAXRK),NAD(0:IADD)
     X         ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  DRK,QRL,NRK,NAD'
        NF=0
        GO TO 90
      ENDIF
      BDXRL=.TRUE.
C
C EX-COMMON/NRBNF1/
      IRKO=1
      IF(BKUTOO)IRKO=IAXRK                                        !MXRKO
      ALLOCATE (DEK(IRKO),BFALL(IRKO),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  DEK, BFALL'
        NF=0
        GO TO 90
      ENDIF
      BNRBNF1=.TRUE.
C
C EX-COMMON/DXRLS/
C
      IXRKS=MAX(MXRKS0,MXRKS,IXRKS)               !USE LARGEST PREVIOUS
C      IXRKS=MAX(MXRKS0,MXRKS)                     !RESET
      IXRLS=MAX(MXRLS0,MXRLS,IXRLS)               !USE LARGEST PREVIOUS
C      IXRLS=MAX(MXRLS0,MXRLS)                     !RESET
C
      IXROS=1
      IF(BKUTOO)IXROS=IXRKS                                       !MXROS
      ALLOCATE (DRKS(IXRKS),DEKS(IXROS),QRLS(5,IXRLS),NRKS(IXRKS)
     X         ,BFALLS(IXROS),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  DRKS,DEKS,QRLS ETC'
        NF=0
        GO TO 90
      ENDIF
C
C EX-COMMON /NSTS/
C
      IXXXX=MAX(IXRLS,IAXRL)
      IXD27=KMAX*KMAX
      ALLOCATE (NADS(-1:IXD27),NSTJ(IXRKS),NSTJD(IXRKS)
     X         ,IORIG(IXXXX),JORIG(IXRLS),JPLANT(IXRLS),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR NADS,NSTJ,IORIG ETC'
        NF=0
        GO TO 90
      ENDIF
C
C LOCAL
      JMX=JYF(KMAX)
C
      ALLOCATE (BAM(JMX),BBM(JMX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR AM,BM'
        NF=0
        GO TO 90
      ENDIF
      BAMBM=.TRUE.
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.LT.MG)GO TO 90                !EXIT TERM DIMENSION CHECK
C
C-----------------------------------------------------------------------
C
C CALCULATE SOME (PRODUCTS OF) CLEBSCH-GORDAN COEFFICIENTS:
C
C VCA=C(L1,L2,L,0,0,0)*C(L1,L2,KT,ML1,ML2,MLK)/(L+1)
C VCB=C(L1,L2,L,0,0,0)*C(L1,L2,KT+2,ML1,ML2,MLK)
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      NXLL=-1
      BSKP=MPRINT+2.LT.MG                !NO SKIP NOW. OLD +0 -3,-4 SKIP
      IF(.NOT.BSKP)THEN
        NXLL=MXLL
        BVC=MXLL.LE.2*MAXLL
        IF(.NOT.BVC)MXLL=2*MAXLL
        IF(MXLL.GT.0)CALL DIMUSE('MAXLL',MXLL/ITWO)
C
        M1=0
  46    M2=0
C
  45    MK=ABS(M1-M2)
C
  44    MKT=MK+2
        DVC0=VCC(M1,M2,MK,IZERO,IZERO,IZERO,DFS)
        ML1=-M1
C
  42    MB1=MVC(M1,ML1)
        ML2=-M2
C
  43    MB2=MVC(M2,ML2)
        DA=DZERO
        DD=DZERO
        MLK=ML1+ML2
C
        IF(ABS(MLK).LE.MKT)THEN
          IF(BDLBD)DD=VCC(M1,M2,MKT,ML1,ML2,MLK,DFS)*DVC0
          IF(ABS(MLK).LE.MK)
     X    DA=(VCC(M1,M2,MK, ML1,ML2,MLK,DFS)/(MK+1))*DVC0
        ENDIF
C
        MLK=MK/4+1
        VCA(MB1,MB2,MLK)=DA
        VCB(MB1,MB2,MLK)=DD
C
        ML2=ML2+2
        IF(ML2.LE.M2)GO TO 43
C
        ML1=ML1+2
        IF(ML1.LE.M1)GO TO 42
C
        MK=MK+4
        IF(MK.LE.M1+M2)GO TO 44
C
        M2=M2+2
        IF(M2.LE.MXLL)GO TO 45
C
        M1=M1+2
        IF(M1.LE.MXLL)GO TO 46
      ENDIF
C
C-----------------------------------------------------------------------
C
C   PREPARE TO CALCULATE THE ALGEBRA OF THE ENERGY MATRIX IN SL COUPLING
C   I.E., THE COEFFICIENTS A AND B, AS WELL AS FOR EK RADIATION
C   THIS SECTION SHOULD BE STUDIED TOGETHER WITH (COMMENTS IN) SR.FLGL
C   AND SR.EKALG
C
C-----------------------------------------------------------------------
C
      IF(.NOT.BKUTOO)
     XWRITE(6,150)MAXAD,MAXSL,MAXTM,MAXTM,IAXRK,IAXRL,MXDFS
      IF(BKUTOO)
     XWRITE(6,151)MAXAD,MAXSL,MAXTM,MAXTM,IAXRK,IAXRL,MXDFS,KUTOO
      IF(MAXLAM.NE.1000)WRITE(6,152)MAXLAM
C
C DRK(K),K=1,NAD(N=0) WILL BE THE COEFFICIENTS TO THE CLOSED SHELL
C CONFIGURATION C0-IT CONTRIBUTES TO ALL DIAGONAL <T!H!T>, EJN-EQ6
C CHOICE OF ML,MS ACCORDING TO TIME OPTIMUM AND STATES AVAILABLE
C
      IOS=0
      JOS=1
      IRK=0
      IRL=0
      NAD(0)=0
      BAM(1)=.FALSE.
C
      IF(NW.GT.0)THEN
        NCOR=-1
        KCF1=NFK(1)
        NADS(-1)=-1
        NADG(1)=0
      ELSE
        NCOR=0
        NADS(-1)=0
      ENDIF
C
      NCFMX=(KMAX*(KMAX+1))/2
C
      MXIRKS=0
      MXIRLS=0
      JOSS=1
C
      IF(BMOD2)THEN                                              !SLOWER
        QMS=NF-(NF/2)*2
        QML=0
        WRITE(6,*)'SR.ALGEB2: FLGL USING NON-DEFAULT MS, ML:',QMS,QML
        WRITE(0,*)'SR.ALGEB2: FLGL USING NON-DEFAULT MS, ML:',QMS,QML
        DO J=JYI(1),JYF(KMAX)
          BAM(J)=QBML(J).NE.QML .OR. QBMS(J).NE.QMS
        ENDDO
        DO NCF=1,NCFMX
          NADS(NCF)=0
        ENDDO
      ENDIF
C
      BLP=MPRINT.GT.0
C
C****************************
C EXPAND THE NSL0 SUBMATRICES SLP=QSI(K)+1,QLI(K)/2,1-QPI(K)
C****************************
C
      if(btime)then
        time1=dzero
        time2=dzero
      endif
c
      NCI=0
      DO 61 K=1,NSL0                         !START LOOP OVER SLP GROUPS
C
        NC=NSL(K)
        IF(NCOR.GE.0)NADG(K)=NCOR
C
        if(btime)call cpu_time(timei)
c
        IF(.NOT.BMOD2)THEN                  !CHOOSE MIN SLATER STATE SET
          QMS=QSI(K)
          QML=QLI(K)
          QMP=QPI(K)
C
          DO NCF=1,NCFMX
            NADS(NCF)=0
          ENDDO
C                                                    !PRE-SELECT CONFIGS
          DO KK=1,KMAX
            IF(KGSL(KK,K).GT.0)THEN                !CF CONTRIBS TO GROUP
              DO J=JYI(KK),JYF(KK)
                BAM(J)=QBML(J).NE.QML .OR. QBMS(J).NE.QMS
              ENDDO
            ELSE
              K1=(KK*(KK-1))/2
              K2=K1+KK
              K1=K1+1
              DO NCF=K1,K2
                NADS(NCF)=-1
              ENDDO
              NCF=K2
              DO K0=KK+1,KMAX
                NCF=NCF+K0-1
                NADS(NCF)=-1
              ENDDO
            ENDIF
          ENDDO
          KK=0
          DO KF=1,KMAX
            DO KG=1,KF
              KK=KK+1
              IF(.NOT.B2B(KK))NADS(KK)=-1
            ENDDO
          ENDDO
          KONE=1
        ELSE
          KONE=K
        ENDIF
C
        IF(KONE.EQ.1)THEN               !UPDATE SLATER-STATE INTERACTION
C
          CALL FLGL1(KCF1,KMAX,NF,JYI,JYF,QLML,BAM,DFS,MAXEL)
C
          MXIRKS=MAX(MXIRKS,IRKS)
          MXIRLS=MAX(MXIRLS,IRLS)
          IF(IRLS.GT.IXRLS)JOSS=-1
          IF(IRKS.GT.IXRKS)JOSS=0
          IF(JOSS.LE.0)GO TO 67            !DIMENSION EXCEEDED, BAIL OUT
          IF(NF.LE.0)GO TO 999
C
          IF(BAM(1))THEN
            WRITE(6,1955)
            BAM(1)=.FALSE.
          ENDIF
C
        ENDIF
C
      if(btime)then
        call cpu_time(timef)
        time1=time1+timef-timei
      endif
c
        IF(KUTDSK.LT.KFBUFF)THEN
          MTGD1=MTGD+1                                          !RESTORE
          DO KF=KUTDSK+1,KFBUFF                   !LOAD NEW SL GROUP VCC
            KSTART(KF,1)=0
            NGSYM=KGSL(KF,K)                              !POS WITHIN CF
            IF(NGSYM.GT.0)THEN
              ISTRT=MTGD1
              KSTART(KF,1)=ISTRT
C
              CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IONE,IZERO)
C
              MTGD1=IFIN+1
              IF(IFIN.LT.0)THEN           !FAILURE TO READ REQUIRED DATA
                NF=-1
                GO TO 999
              ENDIF
            ENDIF
          ENDDO
          IFIN=MTGD1-1
          MDCBUF2=MAX(MDCBUF2,IFIN)
        ENDIF
c
        if(btime)call cpu_time(timei)
C
        istrt0=0
        KF0=0
  56    DO ND1=1,NC                       !BEGIN LOOP OVER INITIAL TERMS
C
          ND=ND1+NCI
          KF=NFK(ND)
c
          ii=ieq(qcg(nf,kf))
          kcf=0
          if(qn(ii).ge.90)kcf=ii           !continuum
C
          IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
            ISTRT=KSTART(KF,1)
            IF(ISTRT.EQ.0)THEN                           !BUFFERED BY CF
              NGSYM=KGSL(KF,K)                            !POS WITHIN CF
              ISTRT=MTGD1
C
              CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
              IF(IEND.LT.0)THEN           !FAILURE TO READ REQUIRED DATA
                NF=-1
               GO TO 999
              ENDIF
            ENDIF
            ISTRT0=ISTRT-MTGD-1                     !I.E. ORIGINAL MTGD1
            KF0=KF
          ENDIF
C
          II=NFI(ND)
          IF(BFAST)THEN
            ND2=JTGD(II)+ISTRT0            !relative start flagged
          ELSE
            do j=jyi(kf),jyf(kf)
              mam(j)=0
            enddo
            k2=jtgd(ii)                    !absolute end flagged
            if(k2.lt.0)then                !bdisk first
              k2=-k2
              k1=mtgd
            else
              k1=jtgd(ii-1)                !start
              k1=abs(k1)                   !case bdisk second
            endif
            k1=k1+1+istrt0
            k2=k2+istrt0
            do k12=k1,k2
              j=idc(k12)
              mam(j)=k12
            enddo
          ENDIF
C
          istrt=0
          KG0=0
          DO NDP1=1,ND1                     !BEGIN LOOP OVER FINAL TERMS
C
            NG=NDP1+NCI
            KG=NFK(NG)
c
            jj=ieq(qcg(nf,kg))
            kcg=0
            if(qn(jj).ge.90)kcg=jj         !continuum
            if(kcf.ne.kcg.and.kcf*kcg.ne.0)go to 60    !does not contrib
c single cf mixing
            if(bkutls.and.kf.ne.kg
     x               .and.(kcf+kcg.eq.0.or.kcf*kcg.ne.0))go to 60
C
            BEQCFS=KG.EQ.KF
            IF(BEQCFS)THEN
              IF(NCOR.LT.0)THEN
                KK=0
              ELSE
                KK=(KF*(KF+1))/2
              ENDIF
            ELSE
c              if(kf.lt.kg)stop 'flgl2: kf.lt.kg'
              KK=(KF*(KF-1))/2 + KG
            ENDIF
C
            IRK0=IRK+1
            IF(NADS(KK).LE.NADS(KK-1))GO TO 37     !CONFIGS INCOMPATIBLE
C                                                  !but ncor incremented
            IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
              ISTRT=KSTART(KG,1)
              IF(ISTRT.EQ.0)THEN                         !BUFFERED BY CF
                LGSYM=KGSL(KG,K)                          !POS WITHIN CF
                ISTRT=IEND+1                             !AS KF BUFFERED
C
                CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                IF(IFIN.LT.0)THEN         !FAILURE TO READ REQUIRED DATA
                  NF=-1
                  GO TO 999
                ENDIF
              ENDIF
              ISTRT=ISTRT-MTGD-1                    !I.E. ORIGINAL MTGD1
              KG0=KG
            ENDIF
C
            JJ=NFI(NG)
            IF(BFAST)THEN
              NDP2=JTGD(JJ)+ISTRT          !relative start flagged
            ELSE
              do j=jyi(kg),jyf(kg)
                nam(j)=0
              enddo
              k2=jtgd(jj)                  !absolute end flagged
              if(k2.lt.0)then              !bdisk first
                k2=-k2
                k1=mtgd
              else
                k1=jtgd(jj-1)              !start
                k1=abs(k1)                 !case bdisk second
              endif
              k1=k1+1+istrt
              k2=k2+istrt
              do k12=k1,k2
                j=idc(k12)
                nam(j)=k12
              enddo
            ENDIF
C
            CALL FLGL2(mam,nam,KK)
C
  37        NCOR=NCOR+1
C
            IF(IRL.GT.IAXRL)JOS=-1
            IF(IRK.GT.IAXRK)JOS=0
            IF(JOS.LE.0)GO TO 67           !DIMENSION EXCEEDED, BAIL OUT
            IF(NF.LE.0)GO TO 999
C
            IF(BLP.AND.IRK.GE.IRK0)THEN
              IF(IRK-IRK0.NE.5)THEN
               WRITE(6,120)NCOR,K,ND,NG,IRK,IRL
     X                   ,(NRK(I),DRK(I),I=IRK0,IRK)
              ELSE
               WRITE(6,119)NCOR,K,ND,NG,IRK,IRL
     X                   ,(NRK(I),DRK(I),I=IRK0,IRK)
              ENDIF
              IF(BKUTOO)WRITE(6,121)(NRK(I),DEK(I),I=IRK0,IRK)
              WRITE(6,120)
            ENDIF
C
            NAD(NCOR)=IRK
            IF(NCOR.EQ.0)GO TO 56       !THEN THAT WAS CLOSED-SHELL CORE
C
  60      ENDDO                               !END LOOP OVER FINAL TERMS
C
        ENDDO                               !END LOOP OVER INITIAL TERMS
C
        if(btime)then
          call cpu_time(timef)
          time2=time2+timef-timei
        endif
c
        NCI=NCI+NC
C
  61  CONTINUE                                 !END LOOP OVER SLP GROUPS
c
c       do i=1,irks
c         write(6,3333)i,nrks(i),nstj(i),nstjd(i),drks(i)
c 3333  format(i5,i3,2i5,f10.6)
c       enddo
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for algeb2:'                 !par
cpar          write(iwp,*)'    flgl1 time=',nint(time1),'sec'       !par
cpar          write(iwp,*)'    flgl2 time=',nint(time2),'sec'       !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'flgl1 time=',nint(time1),'sec'
          write(iw,*)'flgl2 time=',nint(time2),'sec'
c          call flush(iw)
cpar        endif                                                   !par
      endif
C
C
C RESULTS
C DRK(K),K=NAD(N-1)+1,NAD(N)=STRUCTURE COEFFICIENTS,
C AND NRK(K)=SLATER INTEGRAL ADRESSES L, OF THE N'TH ENERGY MATRIX
C ELEMENT; (T!H!T') IS N-NUMBERED IN REDUCED TRIANGULAR ORDER-COM-
C PARE THE FIRST THREE COLUMNS OF THE COEFFICIENT TABLE, IT REVEALS
C MOST FEATURES. THE FOUR ELECTRON ARGUMENTS (1,2,3..FOR 1S,2S,2P..)
C OF THE L'TH SLATER INTEGRAL ARE IN QRL(1-4,L), QRL(5,L)=2*LAMBDA.
C QRL(5,L)=-1 INDICATES A NONTRIVIAL, OFF-DIAGONAL ONE-BODY INTEGRAL
C
      MM=IRL+IRK-IRK0
      IF(BAM(1))WRITE(6,195)MM
C
      IF(IADD.NE.NCOR)THEN
         WRITE(6,*)'SR.ALGEB2 GLOBAL INDEX ERROR:',IADD,NCOR
         NF=-1
         GO TO 999
      ENDIF
C
  67  CONTINUE
C
      CALL DIMUSE('MAXRK',IRK)
      CALL DIMUSE('MAXRL',IRL)
      CALL DIMUSE('MXRKS',MXIRKS)
      CALL DIMUSE('MXRLS',MXIRLS)
      IF(MDCBUF2.GT.0)CALL DIMUSE('MAXDC',MDCBUF2)
      IF(BKUTOO)THEN
        CALL DIMUSE('MXRKO',IRK)
        CALL DIMUSE('MXRLO',IRL)
        CALL DIMUSE('MXROS',MXIRKS)
      ENDIF
C
      IF(.NOT.BLP.OR.JOS.LE.0.OR.JOSS.LE.0)THEN
        WRITE(6,120)NCOR,NSL0,ND,NG,IRK,IRL
        IF(JOS.LT.0)GO TO 93
        IF(JOS.EQ.0)GO TO 95
        WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS
        WRITE(6,1190)MDCBUF2,MAXDC
        IF(JOSS.LT.0)GO TO 930
        IF(JOSS.EQ.0)GO TO 950
        WRITE(6,900)MPRINT
      ELSE
C
C PRINT SLATER INTEGRAL (ADRESS REFERENCE) LIST
C
        WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS
        WRITE(6,1190)MDCBUF2,MAXDC
        IF(IRL.GT.0)THEN
          IF(BKUTOO)WRITE(6,301)KUTOO
          IF(.NOT.BKUTOO)WRITE(6,300)
          DO  L=1,IRL
            WRITE(6,700)L,(QRL(I,L), I=1,5)
          ENDDO
        ENDIF
      ENDIF
C
      IF(ALLOCATED(B2B))THEN
        DEALLOCATE (B2B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR B2B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C
C-----------------------------------------------------------------------
C
C WORK OUT REDUCED ELECTRIC 2K-MULTIPOLE MATRIX ELEMENTS
C OMIT EK RAD FOR C-C CONFIGURATIONS (AND B-C IF NO PHOTOIONIZATION)
C
C-----------------------------------------------------------------------
C
      IOS=IRK
      IF(MPRINT.EQ.MG)GO TO 10
C
      IF(BLP)WRITE(6,600)
      IF(.NOT.BLP)WRITE(6,601)
C
C EX-COMMON/NRBEKP/
      ALLOCATE (NED(2,NSL0,NTT),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  NED'
        NF=0
        RETURN
      ENDIF
      BNRBEKP=.TRUE.
C
C CHECK WORD LENGTH
C
      ITEST4=IBUFF4
      ITEST4=ITEST4+1
      IF(IWORD.EQ.4.AND.ITEST4.LT.IBUFF4)THEN
        MX=MPOLX
        MX=MX-MPOL0                                          !FLAGX
        MXPOL=MAX(IONE,MX/2+1)
        MXORB2=MXORBR*MXORBR
        N8=NCI
        N8=N8*MXORB2*MXPOL
        IF(N8.GT.IBUFF4)THEN
          WRITE(0,*)'ALGEB2: I*4/SP TOO SHORT FOR E_K RAD'
          WRITE(6,*)'ALGEB2: CHANGE TO I*8/EP IN MODULE COMMON_DXRL'
          NF=0
          GO TO 90
        ENDIF
      ENDIF
C
C FLAG EXISTENCE, OR NOT, OF ONE-BODY INTERACTIONS BETWEEN
C CONFIGURATION PAIRS
C
C LOCAL
      IXD19=(KMAX*(KMAX+1))/2
C
      ALLOCATE (B1B(IXD19),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR B1B'
        NF=0
        GO TO 90
      ENDIF
C
      IFOTMX=0
      IF(BFOT)IFOTMX=1
C
cc      iflagc=0
      KK=0
      DO KF=1,KMAX                                        !BEGIN KF LOOP
        II=QCG(NF,KF)
        IFOT1=0
        IF(QN(II).GE.90)IFOT1=1                               !CONTINUUM
C
        DO KG=1,KF                                        !BEGIN KG LOOP
          KK=KK+1
C
          B1B(KK)=.FALSE.
C
C OMIT CONT-CONT
          II=QCG(NF,KG)
          IFOT2=0
          IF(QN(II).GE.90)IFOT2=1
          IF((IFOT1+IFOT2).GT.IFOTMX)GO TO 69          !DOES NOT CONTRIB
c
cc      iflagc=max(iflagc,ifot2)
c omit corr-corr'
          if(kcutx.gt.0.and.kf.ne.kg.and.kg.gt.kcut)go to 69
cc                     .and.ifot1+ifot2+iflagc.gt.0.
C
C FIND NUMBER MK/2 OF ELECTRON PAIRS IN WHICH KF AND KG DIFFER
C AND THEN SEE IF THIS CF PAIR CONTRIBUTES
C
          IF(KF.NE.KG)THEN
            DO I=1,NF
              QLML(I,1)=QCG(I,KG)
            ENDDO
            MK=0
            DO I=1,NF
              DO L=1,NF
                IF(IEQ(QLML(L,1)).EQ.IEQ(QCG(I,KF)))THEN
                  QLML(L,1)=0
                  GO TO 68
                ENDIF
              ENDDO
              MK=MK+1
              IF(MK.GT.1)GO TO 69  !KF-KG DIFFER BY MORE THAN 1 PAIR
              M1=I
  68        ENDDO
            DO L=1,NF
              IF(QLML(L,1).NE.0)THEN
                M2=L
                GO TO 70
              ENDIF
            ENDDO
  70        M1=QCG(M1,KF)
            M2=QCG(M2,KG)
            M1=QL(M1)
            M2=QL(M2)
            IF(M1+M2.LT.MPOL0)GO TO 69           !NO VALID MULTIPOLE
            IF(ABS(M1-M2).GT.MPOLE)GO TO 69     !NO VALID MULTIPOLE
          ELSE
            M2=0
            DO I=1,NF
              M1=QCG(I,KG)
              M2=MAX(M2,INT(QL(M1),SP))
            ENDDO
            M1=M2
            IF(M1+M2.LT.MPOL0)GO TO 69           !NO VALID MULTIPOLE
            if(mpol0.eq.mpole.and.mod(mpol0,ifour).ne.0)go to 69    !odd
          ENDIF
C
C FLAG KF-KG NEEDED
C
          B1B(KK)=.TRUE.
C
  69    ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
C-----------------------------------------------------------------------
C
C CHECK BUFFERS FOR DC ARRAY IF DISKDC IN USE
C
C-----------------------------------------------------------------------
C
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
      CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
C
        IF(KUTDSK.LT.KFBUFF)THEN
          MDCBUF2=0
          DO K=1,NSL0
            MTGD1=MTGD+1                                        !RESTORE
            DO KF=KUTDSK+1,KFBUFF
              NGSYM=KGSL(KF,K)                            !POS WITHIN CF
              IF(NGSYM.GT.0)THEN
c
                do kg=1,kmax
                  k1=max(kf,kg)
                  k2=min(kf,kg)
                  kk=(k1*(k1-1))/2+k2
                  if(b1b(kk))go to 81                   !need this kf
                enddo
                go to 82
c
  81            ISTRT=MTGD1
C
                CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IZERO,IZERO)
C
                MTGD1=IFIN+1
              ENDIF
  82        ENDDO
            IFIN=MTGD1-1
            MDCBUF2=MAX(MDCBUF2,IFIN)
          ENDDO
          MDCBUF2=MDCBUF2+(MDCBUF2-mtgd)!MAY OVERESTIMATE FOR E1 BUT IC>
          IF(MDCBUF2.GT.MDCBUF)THEN
c
            if(MDCBUF.ne.IAXDC)stop 'algeb2: buffer index error...'
C
            IXXX=MDCBUF2
C
            WRITE(6,*)'*** ALGEB2: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** ALGEB2: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'ALGEB2: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 99
            ENDIF
C
            IF(.NOT.BFAST)THEN
C
              CALL RE_ALLOC(IDC,IONE,MTGD,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'ALGEB2: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 99
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
            MDCBUF=IAXDC
c            WRITE(6,141)MDCBUF2
          ENDIF
c          write(6,*)'ALGEB2 ekalg: ',mdcbuf2
c          write(76,*)'ALGEB2 ekalg'
          MDCBUF2=0
        ELSE
          DO I=1,2
            DO K=KFBUFF+1,KMAX
              KSTART(K,I)=0
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C
C-----------------------------------------------------------------------
C
C   START CALCULATION OF THE ALGEBRA FOR ELECTRIC MULTIPOLES
C
C-----------------------------------------------------------------------
C
      MX000=-MXIRKS          !REMOVE "-" AND COMMENT-OUT NEXT 2 LINES TO
      MXIRKS=0               !SUPPRESS E_K SS STORAGE, UNLESS .GT. FOR H
      MXIRLS=0
c
      if(btime)then
        time1=dzero
        time2=dzero
      endif
c
      NCFMX=KMAX*KMAX                           !FOR INEQUIVALENT GROUPS
      MCI=0
      DO NC=1,NSL0                       !BEGIN LOOP OVER INITIAL GROUPS
        MC=NSL(NC)
C
        QML1=QLI(NC)                                !ENSURE NON-ZERO DVC
        QMS1=QSI(NC)
C
        IF(KUTDSK.LT.KFBUFF)THEN
          MTGD1=MTGD+1                                          !RESTORE
          DO KF=KUTDSK+1,KFBUFF                  !LOAD INITIAL GROUP VCC
            KSTART(KF,1)=0
            NGSYM=KGSL(KF,NC)                             !POS WITHIN CF
            IF(NGSYM.GT.0)THEN
c
              do kg=1,kmax
                k1=max(kf,kg)
                k2=min(kf,kg)
                kk=(k1*(k1-1))/2+k2
                if(b1b(kk))then
                  do nd=1,nc                                !check symms
                    lgsym=kgsl(kg,nd)
                    if(lgsym.gt.0)then
                      if(qsi(nd).eq.qsi(nc).and.
     x                  nmetag(nc)+nmetag(nd).le.1)then
                        mmin=max(mpol0,abs(INT(qli(nc)-qli(nd),SP)))
                     if(mod(qpi(nd)+qpi(nc)+mmin,ifour).ne.0)mmin=mmin+2
                        mmax=min(mpole,INT(qli(nc)+qli(nd),SP))
                     if(mod(qpi(nd)+qpi(nc)+mmax,ifour).ne.0)mmax=mmax-2
                        if(mmin.le.mmax)go to 71       !we have a winner
                      endif
                    endif
                  enddo
                endif
              enddo
              kstart(kf,1)=mtgd1!dummy, else alternate kf read triggered
              go to 72              !no valid kf-kg so skip this kf read
c
  71          ISTRT=MTGD1
              KSTART(KF,1)=ISTRT
c
c              write(6,*)'*** kf=',kf,' nc=',nc
C
              CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IONE,IZERO)
C
              MTGD1=IFIN+1
              IF(IFIN.LT.0)THEN           !FAILURE TO READ REQUIRED DATA
                NF=-1
                GO TO 999
              ENDIF
            ENDIF
  72      ENDDO
          MHOLD=MTGD1
        ENDIF
C                                                    !PRE-SELECT CONFIGS
        DO KK=1,KMAX
          IF(KGSL(KK,NC).GT.0)THEN                 !CF CONTRIBS TO GROUP
            DO J=JYI(KK),JYF(KK)
              BAM(J)=QBML(J).NE.QML1 .OR. QBMS(J).NE.QMS1
            ENDDO
          ENDIF
        ENDDO
C
        MCIP=0
        DO ND=1,NC                         !BEGIN LOOP OVER FINAL GROUPS
          MCP=NSL(ND)
C
          BEQGRP=NC.EQ.ND                                !WITHIN A GROUP
C
C PRE-SELECT SYMMETRIES...
C
          IF(QSI(ND).NE.QSI(NC).OR.NMETAG(NC)+NMETAG(ND).GT.1)THEN
            NED(1,ND,MCI+1)=0
            GO TO 79
          ENDIF
C
          MMIN=MAX(MPOL0,ABS(INT(QLI(NC)-QLI(ND),SP)))
          IF(MOD(QPI(ND)+QPI(NC)+MMIN,IFOUR).NE.0)MMIN=MMIN+2
          MMAX=MIN(MPOLE,INT(QLI(NC)+QLI(ND),SP))
          IF(MOD(QPI(ND)+QPI(NC)+MMAX,IFOUR).NE.0)MMAX=MMAX-2
C
          IF(MMIN.GT.MMAX)THEN
            NED(1,ND,MCI+1)=0
            GO TO 79
          ENDIF
C
      if(btime)call cpu_time(timei)
c
          QML2=QLI(ND)                              !ENSURE NON-ZERO DVC
          QMS2=QSI(ND)
C
          MB1=QLI(NC)
          MB2=QLI(ND)
          ML1=QML1
          ML2=-QML2
          MLK=ML1+ML2
C
          DO MK=MMIN,MMAX,4
            MM=MK/4
            DVC(MM)=VCC(MB1,MB2,MK,ML1,ML2,MLK,DFS)
c     X    *(-1)**(MB2+ML2)
            IF(DVC(MM).EQ.DZERO)then             !this should not happen
              write(6,*)'algeb2: dvc=0 - report to nrb'
              write(6,*)mb1/2,mb2/2,mk/2,'  ',ml1/2,ml2/2,mlk/2
              write(0,*)'algeb2: dvc=0 - report to nrb'
c              write(0,*)mb1/2,mb2/2,mk/2,'  ',ml1/2,ml2/2,mlk/2
            endif
          ENDDO
C
          BBM(1)=BEQGRP
          DO NCF=1,NCFMX                                     !INITIALIZE
            NADS(NCF)=0
          ENDDO
          IF(.NOT.BEQGRP)THEN                           !(RE-)SET FOR KF
            DO KK=1,KMAX
              IF(KGSL(KK,NC).LE.0)THEN              !CF DOES NOT CONTRIB
                K1=KMAX*(KK-1)
                K2=K1+KMAX
                K1=K1+1
                DO NCF=K1,K2
                  NADS(NCF)=-1
                ENDDO
              ENDIF
            ENDDO
            KK=0
            DO KF=1,KMAX
              DO KG=1,KF
                KK=KK+1
                IF(.NOT.B1B(KK))THEN
                  NCF=KMAX*(KF-1)+KG
                  NADS(NCF)=-1
                  NCF=KMAX*(KG-1)+KF
                  NADS(NCF)=-1
                ENDIF
              ENDDO
            ENDDO
          ELSE
            KK=0
            DO KF=1,KMAX
              DO KG=1,KF
                KK=KK+1
                IF(.NOT.B1B(KK))NADS(KK)=-1
              ENDDO
            ENDDO
          ENDIF
C                                                    !PRE-SELECT CONFIGS
          DO KK=1,KMAX
            IF(KGSL(KK,ND).GT.0)THEN               !CF CONTRIBS TO GROUP
              DO J=JYI(KK),JYF(KK)
                BBM(J)=QBML(J).NE.QML2 .OR. QBMS(J).NE.QMS2
              ENDDO
            ELSE                                    !CF DOES NOT CONTRIB
              IF(.NOT.BEQGRP)THEN
                NCF=KK
                DO K0=1,KMAX
                  NADS(NCF)=-1
                  NCF=NCF+KMAX
                ENDDO
              ELSE
                K1=(KK*(KK-1))/2
                K2=K1+KK
                K1=K1+1
                DO NCF=K1,K2
                  NADS(NCF)=-1
                ENDDO
                NCF=K2
                DO K0=KK+1,KMAX
                  NCF=NCF+K0-1
                  NADS(NCF)=-1
                ENDDO
              ENDIF
            ENDIF
          ENDDO
C
C  DETERMINE SLATER STATE INTERACTIONS BETWEEN THESE GROUPS
C
          CALL EKALG1(KMAX,NF,MMIN,MMAX,DVC,BAM,BBM,QLML,JYI,JYF
     X               ,DFS,MAXEL)
c
      if(btime)then
        call cpu_time(timef)
        time1=time1+timef-timei
      endif
C
          MXIRKS=MAX(MXIRKS,IRKS)
          IF(MXIRKS.GT.IXRKS)GO TO 950     !DIMENSION EXCEEDED, BAIL OUT
          MXIRLS=MAX(MXIRLS,IRLS)
          IF(MXIRLS.GT.IXRLS)GO TO 930     !DIMENSION EXCEEDED, BAIL OUT
          IF(NF.LE.0)GO TO 999
C
          IF(IRKS.EQ.0)THEN                !THERE ARE NO INTERACTIONS
            NED(1,ND,MCI+1)=0
            GO TO 79
          ENDIF
C
          IF(KUTDSK.LT.KFBUFF)THEN
            MTGD1=MHOLD                                         !RESTORE
            DO KG=KUTDSK+1,KFBUFF                  !LOAD FINAL GROUP VCC
              IF(BEQGRP)THEN
                KSTART(KG,2)=KSTART(KG,1)
              ELSE
                KSTART(KG,2)=0
                LGSYM=KGSL(KG,ND)                         !POS WITHIN CF
                IF(LGSYM.GT.0)THEN
c
                  do kf=1,kmax
                    kk=kmax*(kf-1)+kg
                    if(nads(kk).gt.nads(kk-1))go to 73     !need this kg
                  enddo
                  go to 74
c
  73              ISTRT=MTGD1
                  KSTART(KG,2)=ISTRT
c
c              write(6,*)'--- kg=',kg,' nd=',nd
C
                  CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                  MTGD1=IFIN+1
                  IF(IFIN.LT.0)THEN       !FAILURE TO READ REQUIRED DATA
                    NF=-1
                    GO TO 999
                  ENDIF
                ENDIF
              ENDIF
  74        ENDDO
            IFIN=MTGD1-1
            MDCBUF2=MAX(MDCBUF2,IFIN)
          ENDIF
c
      if(btime)call cpu_time(timei)
C
          istrt0=0
          KF0=0
          DO MD1=1,MC                     !BEGIN LOOP OVER INITIAL TERMS
C
            ND1=MD1+MCI
            NED(1,ND,ND1)=IOS+1
            NED(2,ND,ND1)=IOS
C
            KF=NFK(ND1)
C
            IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
              ISTRT=KSTART(KF,1)
              IF(ISTRT.EQ.0)THEN                         !BUFFERED BY CF
                NGSYM=KGSL(KF,NC)                         !POS WITHIN CF
                ISTRT=MTGD1
C
                CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
                IF(IEND.LT.0)THEN         !FAILURE TO READ REQUIRED DATA
                  NF=-1
                  GO TO 999
                ENDIF
              ENDIF
              ISTRT0=ISTRT-MTGD-1                   !I.E. ORIGINAL MTGD1
              KF0=KF
            ENDIF
C
            II=NFI(ND1)
            IF(BFAST)THEN
              ND2=JTGD(II)+ISTRT0          !relative start flagged
            ELSE
              do j=jyi(kf),jyf(kf)
                mam(j)=0
              enddo
              k2=jtgd(ii)                  !absolute end flagged
              if(k2.lt.0)then              !bdisk first
                k2=-k2
                k1=mtgd
              else
                k1=jtgd(ii-1)              !start
                k1=abs(k1)                !case bdisk second
              endif
              k1=k1+1+istrt0
              k2=k2+istrt0
              do k12=k1,k2
                j=idc(k12)
                mam(j)=k12
              enddo
            ENDIF
C
            istrt=0
            KG0=0
            DO MDP1=1,MCP                   !BEGIN LOOP OVER FINAL TERMS
C
              NDP1=MDP1+MCIP
              IF(NDP1.GT.ND1)GO TO 11
              KG=NFK(NDP1)
C
              IF(BEQGRP)THEN                !KG.LE.KF HERE
                KK=(KF*(KF-1))/2 + KG
              ELSE
                KK=(KF-1)*KMAX+KG
              ENDIF
C
              IF(NADS(KK).GT.NADS(KK-1))THEN
c
c          write(6,*)'kf=',kf,' kg=',kg
C
                IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
                  ISTRT=KSTART(KG,2)
                  IF(ISTRT.EQ.0)THEN                     !BUFFERED BY CF
                    LGSYM=KGSL(KG,ND)                     !POS WITHIN CF
                    ISTRT=IEND+1                         !AS KG BUFFERED
C
                  CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                    IF(IFIN.LT.0)THEN     !FAILURE TO READ REQUIRED DATA
                      NF=-1
                      GO TO 999
                    ENDIF
                  ENDIF
                  ISTRT=ISTRT-MTGD-1                !I.E. ORIGINAL MTGD1
                  KG0=KG
                ENDIF
C
                JJ=NFI(NDP1)
                IF(BFAST)THEN
                  NDP2=JTGD(JJ)+ISTRT      !relative start flagged
                ELSE
                  do j=jyi(kg),jyf(kg)
                    nam(j)=0
                  enddo
                  k2=jtgd(jj)              !absolute end flagged
                  if(k2.lt.0)then          !bdisk first
                    k2=-k2
                    k1=mtgd
                  else
                    k1=jtgd(jj-1)          !start
                    k1=abs(k1)            !case bdisk second
                  endif
                  k1=k1+1+istrt
                  k2=k2+istrt
                  do k12=k1,k2
                    j=idc(k12)
                    nam(j)=k12
                  enddo
                ENDIF
C
                CALL EKALG2(mam,nam,KK,DVC,JOS,IXY)
C
                IF(IXY.GT.0)GO TO 92       !IXY.NE.0, DIMENSION EXCEEDED
                IF(IXY.LT.0)GO TO 93
                IF(NF.LE.0)GO TO 999
C
              ENDIF
C
            ENDDO                             !END LOOP OVER FINAL TERMS
  11        NED(2,ND,ND1)=IOS
          ENDDO                             !END LOOP OVER INITIAL TERMS
c
      if(btime)then
        call cpu_time(timef)
        time2=time2+timef-timei
      endif
c
  79      CONTINUE
C
          MCIP=MCIP+MCP
        ENDDO                                !END LOOP OVER FINAL GROUPS
        MCI=MCI+MC
      ENDDO                                !END LOOP OVER INITIAL GROUPS
C
C
      IF(IOS.GE.IOS0)JOS=JOS-1
C
      CALL DIMUSE('MAXRK',IOS)
      IF(MXIRKS.GT.MX000)THEN
        CALL DIMUSE('MXRKS',MXIRKS)
        CALL DIMUSE('MXRLS',MXIRLS)
      ENDIF
      IF(MDCBUF2.GT.0)CALL DIMUSE('MAXDC',MDCBUF2)
C
      MPOLE0=MPOLE
      M0=0
      LHM0=LHM
      IF(BREL)THEN
        M0=2
        LHM=LHM-1
      ENDIF
      DO LH=LHM,0,-1
        I=0
        DO K=1,MXORB
          DO J=1,K
            I=I+1
            IF(BINDB(I,LH))THEN
              MP=ABS(QL(J)-QL(K))/2
              MP=MOD(MP,ITWO)
              M=4*LH+2-2*(1-MP)-M0
              MPOLE=MAX(M,MPOLE)
              IF(MP.EQ.1)GO TO 97
            ENDIF
          ENDDO
        ENDDO
        IF(MPOLE.GE.0)GO TO 97
      ENDDO
C
  97  CONTINUE
c      write(0,*)mpole,nmulte
C
      IF(REAL(MPOLE,WP).GE.5*REAL(MPOLE0,WP)/7
     X                 .OR.MPOLE0*MXORB2.LT.I100000)GO TO 98
C
      WRITE(6,*)'*** ALGEB2: decreasing KPOLE from ',MPOLE0/2,' to: '
     X                ,MPOLE/2
      WRITE(0,*)'*** ALGEB2: decreasing KPOLE from ',MPOLE0/2,' to: '
     X                ,MPOLE/2
C
      LHM=MPOLE/4
      IF(BREL)LHM=LHM+1
C
      CALL RE_ALLOC2(BINDB,IONE,MXORB2,IZERO,LHM0,MXORB2,LHM,IERR)
C
  98  IF(.NOT.BLP)THEN
        WRITE(6,701)JOS,NCI,NCI,MPOLE/2,MPOLE/2,IOS
        IF(MXIRKS.GT.MX000)WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS
        WRITE(6,1190)MDCBUF2,MAXDC
        WRITE(6,900)MPRINT
      ELSE
        IF(MXIRKS.GT.MX000)WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS
        WRITE(6,1190)MDCBUF2,MAXDC
      ENDIF
C
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for algeb2:'                 !par
cpar          write(iwp,*)'    ekalg1 time=',nint(time1),'sec'      !par
cpar          write(iwp,*)'    ekalg2 time=',nint(time2),'sec'      !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'ekalg1 time=',nint(time1),'sec'
          write(iw,*)'ekalg2 time=',nint(time2),'sec'
c          call flush(iw)
cpar        endif                                                   !par
      endif
c
      GO TO 90
C
  10  WRITE(6,1000)
C
C EX-COMMON/NRBEKP/
      ALLOCATE (NED(2,1,1),STAT=IERR)
      BNRBEKP=.TRUE.
C
      NED(1,1,1)=-1
      NED(2,1,1)=-1
C
  90  CONTINUE
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MAXRL)/5
      IF(BDXRL.AND.IRL.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGEB2: decreasing MAXRL from ',IAXRL,' to: ',IRL
c       WRITE(0,*)'*** ALGEB2: decreasing MAXRL from ',IAXRL,' to: ',IRL
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IRL,IERR)
C
        IAXRL=IRL
C
      ENDIF
C
      IXXX=(4*MAXRK)/5
      IF(BDXRL.AND.IOS.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGEB2: decreasing MAXRK from ',IAXRK,' to: ',IOS
c       WRITE(0,*)'*** ALGEB2: decreasing MAXRK from ',IAXRK,' to: ',IOS
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IOS,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEK,IONE,IAXRK,IOS,IERR)           !KEEP IN SYNC
          CALL RE_ALLOC(BFALL,IONE,IAXRK,IOS,IERR)         !KEEP IN SYNC
        ENDIF
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IOS,IERR)
C
        IAXRK=IOS
C
      ENDIF
C
C LOCAL
      IF(ALLOCATED(B1B))THEN
        DEALLOCATE (B1B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR B1B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(B2B))THEN
        DEALLOCATE (B2B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR B2B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(KSTART))DEALLOCATE (KSTART)
C
C EX-COMMON /NSTS/
      IF(ALLOCATED(NADS))THEN
        DEALLOCATE (NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR NADS,NSTJ, ETC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/DXRLS/
      IF(ALLOCATED(DRKS))THEN
        DEALLOCATE (DRKS,DEKS,QRLS,NRKS,BFALLS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR DRKS,DEKS, ETC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BAMBM)THEN
        DEALLOCATE (BAM,BBM,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB2: DE-ALLOCATION FAILS FOR AM,BM'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      RETURN                        !<-------------------- NORMAL RETURN
C
C     E R R O R   M E S S A G E S
C
  95  WRITE(6,188)
      MPOLE=-1
  92  IF(MPOLE.GE.4)WRITE(6,192)
      IF(MPOLE.EQ.2)WRITE(6,189)
      IF(IRL.LE.IAXRL)GO TO 96
  93  WRITE(6,193)
  96  IF(MPRINT.EQ.MG-1)GO TO 90
      GO TO 99
  94  WRITE(6,194)NCI, ND
      GO TO 99
 930  WRITE(6,1930)
      GO TO 99
 950  WRITE(6,1880)
C
  99  WRITE(6,190)
c      NF=0
c      GO TO 90
C
 999  NF=-1
      GO TO 90
C
  119 FORMAT(I9,I3, 2I6, I9,I5, 6(I6,F11.6))
  120 FORMAT(I9,I3, 2I6, I9,I5, 6(I6,F11.6)/(38X,6(I6,F11.6)))
  121 FORMAT((38X,6(I6,F11.6)))
  122 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXRKS,MXRLS)',I9,I6,
     X10X,'USED:',I9,I6)
  133 FORMAT('SR.ALGEB2: ALLOCATION INCREASES NUMBER OF MATRIX '
     X,' ELEMENTS IADD =',I10,' .GT. MAXAD=',I10)
c  140 FORMAT(/'*** SR.ALGEB2: INCREASE MAXDC TO AT LEAST: ',I10,' FOR',
c     X' H-BUFFER')
c  141 FORMAT(/'*** SR.ALGEB2: MAY NEED TO INCREASE MAXDC TO AT LEAST: '
c     X,I10,' FOR',' E_K-BUFFER, WILL PLOUGH ON REGARDLESS...')
  150 FORMAT(//' SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING   ',
     X'( T !  H  ! TP ) = SUM( F(A,...) * R(A,...) );   NCYC=0: COMMON '
     X,'DIAGONAL CORE TERM'/I9,I3,2I6,I9,I5,' STORAGE RESTRICTIONS FOR'
     X,' (MAXAD,MAXSL,MAXTM,MAXTM,MAXRK,MAXRL), MXDFS=',I3/
     X'     NCYC GR     T    TP      MNF  MNR',6(3X,'I(R)  F(A,...)'))
  151 FORMAT(//' SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING   ',
     X'( T !  H  ! TP ) = SUM( F(A,...) * R(A,...) );   NCYC=0: COMMON '
     X,'DIAGONAL CORE TERM'/I9,I3,2I6,I9,I5,' STORAGE RESTRICTIONS FOR'
     X,' (MAXAD,MAXSL,MAXTM,MAXTM,MAXRK,MAXRL), MXDFS=',I3,
     X5X,'***** KUTOO=',I2,' *****'
     X/ '     NCYC GR     T    TP      MNF  MNR',6(3X,'I(R)  F(A,...)'))
  152 FORMAT(/' **** SLATER MULTIPOLE EXPANSION LIMITED TO LAMDA=',I5/)
  180 FORMAT(I5,3I4,25X,I3,I6,I3)
  188 FORMAT(/' SR.ALGEB2: *MAXRK TOO SMALL, ARRAYS DRK AND NRK ')
 1880 FORMAT(/' SR.ALGEB2: *MXRKS TOO SMALL, ARRAYS DRKS AND NRKS ')
  189 FORMAT(/' SR.ALGEB2: *MAXRK TOO SMALL, ARRAYS DRK AND NRK;'/
     X' MAYBE SUFFICIENT IF NO RADIATIVE RATES (MPRINT=-2) REQUIRED.' )
  190 FORMAT( ' SR.ALGEB2: STORAGE EXCEEDED - CASE SKIPPED')
  192 FORMAT(/' SR.ALGEB2: *MAXRK TOO SMALL, ARRAYS DRK AND NRK;'/' ',
     X'MAYBE SUFFICIENT IF NO RADIATIVE RATES (MPRINT=-2) OR DIPOLE'
     X,' ONLY (MPRINT=-1) REQUIRED' )
  193 FORMAT(/' SR.ALGEB2: *MAXRL TOO SMALL, ARRAYS DRL AND QRL')
 1930 FORMAT(/' SR.ALGEB2: *MXRLS TOO SMALL, ARRAYS DRLS AND QRLS')
  194 FORMAT(/' SR.ALGEB2: *MAXTM=',I6,' AND  MAXSL=',I3,' REQUIRED')
  195 FORMAT(/28X,'WARNING: SHORTAGE OF BUFFER SPACE RESULTS IN '
     X,'EXCESSIVE SCANNING'/28X,'*******  THIS CASE MAY BE FASTER IF',
     X' YOU CHOOSE MAXRL .GT.',I6)
 1955 FORMAT(/28X,'WARNING: SHORTAGE OF BUFFER SPACE RESULTS IN '
     X,'EXCESSIVE SCANNING'/28X,'*******  THIS CASE MAY BE FASTER IF',
     X' YOU CHOOSE TO INCREASE MAXRL')
 1966 FORMAT(' NOTE: ALLOCATION IN SR.DIAGON WILL INCREASE SIZE OF',
     X' SL MATRIX MAXDI AS BELOW')
  197 FORMAT(' ',56X,'GROUP=',I3,4X,'2S+1=',I2,2X,'L=',I2,3X,'PI=',I2
     X,4X,'NC=',I6//)
 1979 FORMAT(/73X,'(',I6,')',I11,7X,'MAXDI=',I11)
  198 FORMAT(/68X,'(',I11,')',I11,7X,'MAXUC=',I11)
 1988 FORMAT(/81X,I11,7X,'MXAAI=',I11)
 1999 FORMAT(' NOTE: ALLOCATION IN SR.DIAGON WILL INCREASE NO. OF ',
     X'MATRIX ELEMENTS MAXUC AS ABOVE, IF RADIATIVE RATES REQUIRED')
  200 FORMAT(/' SR.ALGEB2: INCREASE MXAAI OR MAXDI - SEE ABOVE')
  299 FORMAT(/' TOO MANY BOUND-FREE INTERACTIONS, EXPECT '
     X,'ALLOCATION IN ','DIAGON, TO INCREASE MXAAI TO',I9)
  300 FORMAT(/' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS',7X,
     X'A,B,C,D=1,2,3,..15: 1S,2S,2P,..5G-ORBITAL',9X,'REFERENCE LIST')
  301 FORMAT(//' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS'
     X,' AND ETA( A, B, C, D, 2LBD) REFERENCE LIST, KUTOO=',I2)
  400 FORMAT(//'    T 2S+1  L  (P-0/1 FOR EVEN/ODD)',8X,'CF    NT GR',
     X 20X,'**** TERM TABLE ****')
  600 FORMAT( ' IOSC      T  TP,   B   D,   MNF,   <T!!CK!!TP>='
     X,'<T,ML!CK!TP,MLP> / C(L,LP,K;ML,MLP) / SF, 2ML 2MLP     K;'
     X,'  SF=(-1)**(LP-MLP)/V(2K+1)')
  601 FORMAT( '  IOSC     T    TP    B   D      MNF')
  700 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,2F19.5, 6X,2I4, 5X,'E',I1,I6)
  701 FORMAT( I6,I6,I6,I5,I4,I9)
  900 FORMAT(/ ' *** PRINTOUT OF COEFFICIENTS SUPPRESSED - MPRINT'
     X,'(MODULO 5)=',I2/)
  992 FORMAT(3I2,I5,I5,F18.6,3X,A4)
  993 FORMAT(2I2,2X,2I2,2I5,F18.8,3X,A4)
  955 FORMAT(//'SR.ALGEB2: ALLOCATION INCREASES MAX 2K-POLE '
     X,'RADIATION IXBLM =',I3,' .GT. MXBLM =',I3)
 1000 FORMAT(/' SR.ALGEB2: RADIATIVE CALCULATIONS SKIPPED'/12X,30('*'))
 1111 FORMAT(//1X,136('-')//)
 1112 FORMAT(' *** USER-SUPPLIED TERM SYMMETRY RESTRICTIONS:'//)
 1113 FORMAT('    T 2S+1  L  (P-0/1 FOR EVEN/ODD)')
 1114 FORMAT(1X,4I4)
 1115 FORMAT(' MINST =',I2,3X,'MAXST =',I2,5X,'MINLT =',I2,3X
     X,'MAXLT =',I2)
 1116 FORMAT(' *** USER-SUPPLIED PARENT TERM SYMMETRY RESTRICTIONS:'//)
 1117 FORMAT(' MINSTP=',I2,3X,'MAXSTP=',I2,5X,'MINLTP=',I2,3X
     X,'MAXLTP=',I2)
 1118 FORMAT(' CF=',I3/)
 1120 FORMAT(/'*** ALGEB2: YOU HAVE FLAGGED READ OF AN OLD TERMS'
     X,' FILE, BUT NONE CAN BE FOUND...'/12X,'SWITCH-OFF FLAG AND'
     X,' RE-RUN (FOR ENERGIES ONLY) TO GENERATE ONE (EFFEICIENTLY)')
cw 1121 FORMAT(/'*** IN LARGE CASES IT IS MORE EFFICIENT TO READ A'
cw     X,' "TERMS" FILE GENERATED BY A PRIOR (ENERGIES ONLY) RUN')
 1130 FORMAT(' *** USER-SUPPLIED (SPECTATOR) SUB-SHELL TERM '
     X,'RESTRICTIONS:'//)
 1131 FORMAT(' GAM',' NE',2X,'2S+1',' L')
 1132 FORMAT(I4,I3,3X,I3,I2)
 1133 FORMAT(' GAM',' NE')
 1134 FORMAT(//' MINSTS=',I2,3X,'MAXSTS=',I2,5X,'MINLTS=',I2,3X
     X,'MAXLTS=',I2)
 1190 FORMAT(/86X,I10,'=MTGD, MAXDC=',I10,' BUFFER STORAGE USED')
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(M1,M2)
C
      MVC=((M1+2)*M1/2+M2)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE ALGEB2
C
C                             *******************
C
      SUBROUTINE ALGEB3(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB3 DEALS WITH THE CALCULATION OF THE ALGEBRA OF THE FINE
C  STRUCTURE INTERACTIONS (SPIN-ORBIT,RESIDUAL MUTUAL-SPIN-ORBIT AND
C  SPIN-SPIN). NOW SOLVES SLATER-STATE PROBLEM BY LSJP GROUP - NRB.
C
C  IT CALLS:
C    SR.DISKDC
C    SR.DIMUSE
C    SR.SPOR0
C    SR.SPOR1
C    SR.SPOR1F
C    SR.SPOR2
C    SR.RES1
C    SR.RES2
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_COEFF,  ONLY: BCOEFF,DRKP,QRLP,IRLP,NRKP,NADP,IXSOC
     X                        ,IXSOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR,IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADJ,IADJ8,NP8
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
      USE COMMON_NRBRN2, ONLY: MENGB
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2,KPTCFM,KINT,MPOINT,IXSTX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXMI0=  1000)
      PARAMETER (MXS2I0=MAXMI0)
      PARAMETER (MXRSS0= 25000)
      PARAMETER (MXS2C0=MXRSS0)
      PARAMETER (MXSOC0= 10000)
      PARAMETER (MXS1C0=MXSOC0)
      PARAMETER (MXSOI0=   500)
      PARAMETER (MXS1I0=MXSOI0)
      PARAMETER (MXSTX0=  5000)
C
      PARAMETER (MXD01=14)
C
      PARAMETER (MXD14=100)
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-6)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      INTEGER(SP) SJ,SJP
C
      INTEGER(EP) MDCF8,MDCFT8,N8,nctot,iaxju
C
      CHARACTER(LEN=1) LIT
      CHARACTER(LEN=4) CODE,MBLANK,MYRGE
C
      LOGICAL BEX,BEXJ                    !INQUIRE REQUIRES DEFAULT KIND
C
      DIMENSION MAM(*),NAM(*),JYI(*),JYF(*)
     X         ,QLMC(MAXEL,*),QBML(*),QBMS(*)
     X         ,nej(2),mej(2)
C
      DIMENSION DFS(MXDFS),LIT(8),QJI(MAXJG)
C
      ALLOCATABLE :: B1B(:),B2B(:),KSTART(:,:)
C
      COMMON /BASIC/NF,KF,KG,J1,J2,J1P,J2P,NLEV,NJ2,NJP2,MGAP(2)
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /COMRES/DVC12,ICLRS,ICLRR,BLX
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRLP/IRKP,IRKP0
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL,NL000
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      DATA MBLANK/'    '/
      DATA LIT(1),LIT(2),LIT(3),LIT(4)/' ','A','B','C'/
      DATA LIT(5),LIT(6),LIT(7),LIT(8)/'*','a','b','c'/
C
c      MVC(MLX,MLY)=((MLX+2)*MLX/2+MLY)/2+1 !SEE INTRNL FN ABVE END ALG3
C
      itest4=ibuff4
      itest4=itest4+1
C
      if(iunit(12).ne.0)then                                 !for radwin
        i69=69
      else
c        i69=79                        !needs radwin present if external
        i69=69           !restrict to 60-9 normally, can extend to 79...
      endif
c
C     IF ABS(MODD).GT.1 NOT ENOUGH VCC'S ARE  AVAILABLE FOR CALCULATING
C     FINESTRUCTURE INTERACTIONS.
C
      NJO=0
      IF(ABS(MODD).GT.1)GO TO 101
C
C-----------------------------------------------------------------------
C
C INITIALIZATIONS
C
C-----------------------------------------------------------------------
C
      BPRINT=MPRINT.GT.0.OR.MPRINT.EQ.0.AND.IDW.EQ.0
C
      BKUTLS=KUTLS.LT.0                          !.T. FOR SINGLE CF MIX
C
c      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
      MOD3=MODD                  !CAN RE-SET TO TEST VARIOUS TOTAL MJ
c      mod3=1                     !MODD.LE.0 NOW
      BMOD3=(MOD3+1)/2.EQ.1      !SLOWER
C
      BFASTSO=KUTSS.EQ.-1        !IF NO 2-BODY PRE-SET 1-BODY SO SS INTS
c      bfastso=.false.           !force if .true. uses too much memory
      IF(BFASTSO)NSS=JYF(KMAX)
C
C     ALIGNS TO THE DEFAULT REQUIREMENTS FOR KUTSS=0 AND -1
C
      MKT=KUTSS
      IF((MKT+3)/2.EQ.1)MKT=1+MKT
      MUTSO=KUTSO
      MUTSO=ABS(MUTSO)
c
c Test swap bra/ket. This is because there is an apparent anti/symmetry
c in the N-coefficient/integral combinations which is not readily taken
c into account. This means that the H symmetry is not readily apparent,
c which needs to be recognized when comparing with algxfs.
c
      bswap=.false.
c
      BLX=.FALSE.
      MPRNT1=MPRINT
      IF(MPRNT1.EQ.0.AND.MENGB.GE.0)MPRNT1=-1                !I.E. BBORN
C
      IF(NASTJ.NE.0)THEN
        WRITE(6,1111)
        WRITE(6,1112)
        IF(NASTJ.GT.0)THEN
          WRITE(6,1113)
          DO I=1,NASTJ
            IJ=JPI(I)/10
            IP=JPI(I)-IJ*10
            WRITE(6,1114)I,IJ,IP
          ENDDO
        ELSE
          WRITE(6,1115)MINJT,MAXJT
        ENDIF
        WRITE(6,1111)
      ENDIF
C
C     THE FOLLOWING SECTION SETS UP THE STATES ACCORDING TO THEIR
C     J-VALUES: J=TOTAL ANGULAR MOMENTUM.
C
      JACT=QCL0+QCS0
      WRITE(6,400)
C
C TBD:LOOP-OVER TWICE, FIRST TO GET THE TOTAL NO. LEVELS, SECOND
C     TO ASSIGN NRR, JN, NGR (AFTER ALLOCATION). COULD SKIP B-C
C     SECTION ON FIRST LOOP, BUT TRIVIAL.
C RE-ENTRY POINT HERE
C
      NJ=0
      NP8=0
      NCTOT=0
      ISXDK=1
      IAXDK=1
      IAXJU=0
      IXAAK=0
c      lusum=0
      bcont=.false.
C
  60  KPI=0
C
  61  IF(NASTJ.GT.0)THEN                                  !SELECT BY JPI
        JT=10*JACT+KPI/2
        DO I=1,NASTJ
          IF(JT.EQ.JPI(I))GO TO 62                                 !WANT
        ENDDO
        GO TO 64                                             !DON'T WANT
      ELSEIF(NASTJ.LT.0)THEN                      !SELECT BY MINJT,MAXJT
        IF(JACT.LT.MINJT.OR.JACT.GT.MAXJT)GO TO 64           !DON'T WANT
      ENDIF
C
  62  N0=0
      NCC=0
      NDJ=NJO+1                                  !NDJ IS JP GROUP NUMBER
      BVC=NDJ.GT.MAXJG
      IF(.NOT.BVC)NGSLJ(NDJ)=0
c
c      if(bkutls)then
      do k=1,kmax
        ntj(k)=0
      enddo
c      else
      do i=1,mxorb
        ncc0(i)=0
      enddo
      mx0=mxorb+1
c      endif
      lu=0
C
C     DO LOOP TO FIND NUMBER OF LEVELS WHICH CAN RESULT IN GIVEN J
C
      IT=0
      DO I=1,NSL0
        NC=NSL(I)
        IT=IT+NC
        IF(QPI(I).NE.KPI)GO TO 63
C
        LJ=QLI(I)
        SJ=QSI(I)
        IF(ABS(LJ-SJ).GT.JACT.OR.(LJ+SJ).LT.JACT)GO TO 63
C
        IT=IT-NC
        IF(.NOT.BVC)THEN
          NGSLJ(NDJ)=NGSLJ(NDJ)+1
          NSLJ(NGSLJ(NDJ),NDJ)=I
        ENDIF
c
        nc0=ncc
        N00=0
        DO N=1,NC
C
          IT=IT+1
          NJ=NJ+1
          KG=NFK(IT)
          II=QCG(NF,KG)
          ii=ieq(ii)
          IF(QN(II).GE.90)THEN
            NCC=NCC+1
            ncc0(ii)=ncc0(ii)+1
            mx0=min(mx0,ii)
          ELSE
            N00=N00+1
          ENDIF
          ntj(kg)=ntj(kg)+1
c
          if(bprint)WRITE(6,180)NJ,SJ+1,LJ/2,JACT,KG,IT
C
          BLF=NJ.GT.MAXLV
          IF(.NOT.BLF)THEN
            NRR(NJ)=IT
            JN(NJ)=JACT
            NGR(NJ)=NDJ
          ENDIF
C
        ENDDO
        N0=N0+N00
        lu=lu+n00*(ncc-nc0)                     !if no 2-fs
C
  63  ENDDO
C
      IF(N0+ncc.GT.0)THEN
c
       if(bkutls)then
c
        n0=n0+ncc
c
        ncft0=0
        ncft=0
        do k=1,kmax
          ncf0=ntj(k)
          isxdk=max(isxdk,ncf0)
          ncft=ncft+ncf0*ncf0
          N8=ncf0
          NP8=NP8+((N8+1)*N8)/2
          if(.not.bfot)then
            II=QCG(NF,K)
            ii=ieq(ii)
            if(qn(ii).lt.90)ncft0=ncft0+ncf0*ncf0
c        write(6,*)nn,k,ncft0,ncft,qn(ii)
          endif
        enddo
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+ncft
        else                                    !only b-b
          iaxju=max(iaxju,nctot+ncft)           !need buffer
          nctot=nctot+ncft0                     !so can overwite c-c
        endif
c
       else
c
        N8=N0                                        !not strictly true
        if(n8*n8.gt.ibuff4.and.itest4.lt.ibuff4)then !but time for I*8
           write(0,*)
     x         'sr.algeb3: I*4 will overflow for diagfs tfu array index'
          go to 998
        endif
        NP8=NP8+((N8+1)*N8)/2
C        NP8=NP8+(INT(N0+1)*INT(N0))/2    !unsafe - Oracle good; PGI bad
        isxdk=max(isxdk,n0)
        iorb(mx0-1)=n0*n0                       !I*4 overflow anyway...
        do i=mx0,mxorb
          n=ncc0(i)
          iorb(i)=iorb(i-1)+n*n
          if(n.gt.0)then
            n8=n
            np8=np8+((n8+1)*n8)/2
            isxdk=max(isxdk,n)
            n0=n0+n
          endif
        enddo
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+iorb(mxorb)
        else                                    !only b-b
          iaxju=max(iaxju,nctot+iorb(mxorb))    !need buffer
          nctot=nctot+iorb(mx0-1)               !so can overwite c-c
        endif
c
       endif
C
        WRITE(6,181)NDJ,JACT,KPI/2,N0
C
        IAXDK=MAX(IAXDK,N0)
        IF(N0.GT.MAXDK)THEN              !AS NOT ALL ALLOCATED IN DIAGFS
          IF(MAXDK.GT.0)WRITE(6,1777)
        ENDIF
C
        IF(.NOT.BFASTSO)then
          LU=NCC*(N0-NCC)  !WE HAVE 2-FS, NEED ND.NE.NC B-C INTERACTIONS
          NP8=NP8+INT(LU)   ! & NEED 2-FS POINTERS (NOW SKIP IF LS ONLY)
        endif
        IXAAK=MAX(LU,IXAAK)
c
c        lusum=lusum+lu
c        write(6,*)lu,np8
c        write(6,*)'lusum=',lusum
c
        bcont=bcont.or.ncc.gt.0
C
        NJO=NDJ
        IF(.NOT.BVC)THEN
          NT(NDJ)=N0
          QJI(NDJ)=JACT
        ENDIF
      ENDIF
C
  64  KPI=KPI+2
      IF(KPI.EQ.2)GO TO 61               !LOOP BACK UP FOR SECOND PARITY
C
      JACT=JACT-2
      IF(JACT.GE.0)GO TO 60                    !LOOP BACK UP FOR NEXT 2J
C
C                                                 !END JP SYMMETRY LOOPS
      CALL DIMUSE('MAXLV',NJ)
      CALL DIMUSE('MAXJG',NJO)
C
      NLEV=NJ
C
      BLF=BLF.OR.BVC
      IF(BLF)THEN
        WRITE(6,670)NLEV,MAXLV,NJO,MAXJG
        GO TO 90
      ENDIF
C
      IADJ8=NP8
      IADJ=INT(IADJ8)                                  !FOR I*4 BRANCHES
C
      CALL DIMUSE('MXADJ',IADJ)
      IF(IADJ8.GT.MXADJ)THEN
        IF(MXADJ.GT.0)WRITE(6,3054)IADJ8,MXADJ
      ENDIF
C
C THESE 3 DIMENSIONS ARE FOR INFO ONLY. NOT NEEDED UNTIL DIAGFS.
C NOTE: IF MODE=3 OR 4 IS SET IN MINIM THEN THE ACTUAL DIMENSIONS
C REQUIRED (ALLOCATED F95) WILL BE LARGER. THESE MODES ARE (SMALL)
C TEST CASES, NOT PRODUCTION RUNS, SO NOT LIKELY AN ISSUE. WOULD
C NEED USER TO SET MODE IN ALGEB, AND CODE DIAGFS DIMENSION VARIATION.
C
      if(bfot)iaxju=nctot
      WRITE(6,131)ISXDK,IAXDK,MAXDK
      WRITE(6,134)NCTOT,IAXJU,MAXJU
      WRITE(6,132)IXAAK,MXAAK
c
      if(iaxju.gt.ibuff4.and.itest4.lt.ibuff4)then
        write(0,*)
     x         'sr.algeb3: I*4 will overflow for diagfs tfu array index'
        go to 998
      endif
C
      IF(IAXJU.GT.MAXJU)THEN
        IF(MAXJU.GT.0)WRITE(6,133)
      ENDIF
C
      IF(IXAAK.GT.MXAAK)THEN
        IF(MXAAK.GT.0)WRITE(6,299)IXAAK
      ENDIF
C
      IF(BLX)THEN
        WRITE(6,136)
        WRITE(0,*)'*** INCREASE MXAAK OR MAXDK'
        GO TO 90
      ENDIF
C
C     INDEX POSITION OF LEVEL WITHIN A CONFIG.
C
      DO K=1,KMAX
        NTJ(K)=0
        DO J=1,NLEV
          IT=NRR(J)
          IF(NFK(IT).EQ.K)THEN
            NTJ(K)=NTJ(K)+1
            NFJ(J)=NTJ(K)
          ENDIF
        ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C SET METASTABLE jp GROUPS BASED-ON PRE-EXISTING LEVELS FILE
C SO AS TO RESTRICT UNNECESSARY MK EVALUATION ETC.
C
C-----------------------------------------------------------------------
C
      IF(NMETAJ.LT.0.AND..NOT.BVC)THEN
C        NMETJ0=NMETAJ
        NMETAJ=-NMETAJ
        INQUIRE(FILE='LEVELS',EXIST=BEXJ)
        IF(BEXJ)THEN
          OPEN(15,FILE='LEVELS',STATUS='OLD')
          READ(15,*,END=333)
          DO K=1,NJO                             !ASSUME WE CAN RESTRICT
            NMETGJ(K)=1
          ENDDO
          READ(15,993,END=333)JSP,IP0,IS0,LS0,ICF0,NDUM,DUM,MYRGE
          IS0=ABS(IS0)
          REWIND(15)
          READ(15,*,END=333)
          DO N=1,NMETAJ
            READ(15,993,END=333)JSP,IPP,ISP,LSP,ICF,NDUM,DUM,MYRGE
            IF(MYRGE.NE.MBLANK)THEN                     !CANNOT RESTRICT
              DO K=1,NJO
                NMETGJ(K)=0
              ENDDO
              GO TO 333
            ENDIF
            ISP=ABS(ISP)
            IF(ISP.GT.0)THEN
              IF(NMETAJ/MAXLV.GT.0)THEN
                IF(ISP.NE.IS0.OR.LSP.NE.LS0
     X                       .OR.IPP.NE.IP0.OR.ICF.NE.ICF0)GO TO 333
                ICF0=ICF
                IS0=ISP
                LS0=LSP
                IP0=IPP
              ENDIF
              ISP=ISP-1
              LSP=LSP+LSP
              IPP=IPP+IPP
              DO KK=1,NJO
                IF(JSP.EQ.QJI(KK))THEN
                  KP=NSLJ(1,KK)
                  IF(IPP.EQ.QPI(KP))THEN
                    NMETGJ(KK)=0
                    DO KP=1,NGSLJ(KK)
                      K=NSLJ(KP,KK)
                      if(nmetag(k).ne.0)stop 'algeb3: nmetag error'
                      NMETAG(K)=0
                    ENDDO
                    GO TO 332
                  ENDIF
                ENDIF
              ENDDO
            ELSE
              GO TO 333
            ENDIF
 332      ENDDO
 333      CLOSE(15)
          IUNIT(15)=-1
C          NMETAJ=NMETJ0                                     !RE-INSTATE
c          write(6,*)'jp groups'
c          do k=1,njo
c            write(6,*)k,nmetgj(k)
c          enddo
c          write(6,*)'lsp groups'
c          do k=1,nsl0
c            write(6,*)k,nmetag(k)
c          enddo
        ELSE
          WRITE(6,1122)
          WRITE(0,1122)
        ENDIF
cw      ELSE
cw        IF(IDW.NE.0.AND.NMETAJ.GT.0)THEN
cw          WRITE(6,1123)
cw          WRITE(0,1123)
cw        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C FLAG EXISTENCE, OR NOT, OF ONE- AND TWO-BODY INTERACTIONS BETWEEN
C CONFIGURATION PAIRS
C
C-----------------------------------------------------------------------
C
C LOCAL
      IXD19=(KMAX*(KMAX+1))/2
C
      ALLOCATE (B1B(IXD19),B2B(IXD19),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR B1B,B2B'
        NF=0
        GO TO 999
      ENDIF
C
cc      iflagc=0
      KK=0
      DO KF=1,KMAX                                        !BEGIN KF LOOP
        II=IEQ(QCG(NF,KF))
        KCF=0
        IF(QN(II).GE.90)KCF=II                                !CONTINUUM
        if(qn(ii).ge.60.and.qn(ii).le.i69)kcf=-ii           !omit ryd ci
cc        iflagc=max(iflagc,kcf)
C
        DO KG=1,KF                                        !BEGIN KG LOOP
          KK=KK+1
          B1BODY=.FALSE.
          B2BODY=.FALSE.
C
C FIRST CHECK GLOBAL SWITCHES
C
C OMIT CONT-CONT'
          II=IEQ(QCG(NF,KG))
          KCG=0
          IF(QN(II).GE.90)KCG=II
          if(qn(ii).ge.60.and.qn(ii).le.i69)kcg=-ii         !omit ryd ci
          IF(KCF.NE.KCG.AND.KCF*KCG.NE.0)GO TO 73      !DOES NOT CONTRIB
          if(kcf.ne.kcg.and.(kcf+kcg).lt.0)go to 73
c
c omit corr-corr'
          if(kcutx.gt.0.and.kf.ne.kg.and.kg.gt.kcut)go to 73
cc                   .and.kcf+kcg+iflagc.gt.0
c
c single cf mixing (but keeping b-c)
          if(kf.ne.kg.and.(kcf+kcg.eq.0.or.kcf*kcg.ne.0))then
            if(kf.gt.kutls)go to 73
            if(kg.gt.kutls)go to 73
          endif
C
          IF(JYI(KG).GT.JYF(KG))GO TO 73                    !NULL CONFIG
C
          IF(KUTSO.GT.0)THEN
            IF(KF.GT.MUTSO.OR.KG.GT.MUTSO)THEN
              IF(KF.NE.KG)GO TO 73
            ENDIF
          ELSEIF(KUTSO.LT.0)THEN
            IF(KF.NE.KG)GO TO 73
            IF(KF.GT.MUTSO)GO TO 73
          ENDIF
C
C NOW, FIND NUMBER MK/2 OF ELECTRON PAIRS IN WHICH KF, KG DIFFER
C
          DO M=1,NF
            QLMC(M,1)=QCG(M,KG)
          ENDDO
          MK=0
          DO M=1,NF
            ICG=IEQ(QCG(M,KF))
            DO L=1,NF
              IF(IEQ(QLMC(L,1)).EQ.ICG)THEN
                QLMC(L,1)=0
                GO TO 53
              ENDIF
            ENDDO
            MK=MK+2
            IF(MK.EQ.2)LD1=QCG(M,KF)
  53      ENDDO
C
          IF(MK-4.GT.0)GO TO 73                     !THREE PAIRS OR MORE
          IF(MK-4.EQ.0.AND.MKT.GE.0)GO TO 73       !TWO, BUT NO TWO-BODY
C
C SEE IF WE NEED TWO-BODY
C
          IF(MKT.NE.-9)THEN
            IF(MKT.GE.0.AND.MK.NE.0)GO TO 15
            IF(KCFSS(KF)*KCFSS(KG).LE.0)THEN
              IF(KF.GT.ABS(MKT))GO TO 15
              IF(KG.GT.ABS(MKT))GO TO 15
            ENDIF
          ENDIF
          IF(NF.GT.1)B2BODY=.TRUE.
  15      IF(.NOT.B2BODY.AND.MK.EQ.4)GO TO 73
C
C SEE IF ONE-BODY EXISTS
C
          IF(MK.EQ.2)THEN
            DO L=1,NF
              IF(QLMC(L,1).NE.0)THEN
                LD2=QCG(L,KG)
                GO TO 54
              ENDIF
            ENDDO
            write(6,*)'algeb3: should not be here - report to nrb'
            write(0,*)'algeb3: should not be here - report to nrb'
  54        IF(QL(LD1).NE.QL(LD2))THEN
              IF(.NOT.B2BODY)GO TO 73
              LDD=-1
            ELSE
              LDD=QL(LD1)
            ENDIF
          ELSEIF(MK.EQ.4)THEN
            LDD=-1
          ELSE
            LDD=1
          ENDIF
          B1BODY=LDD.GT.0
C
C FLAG WHETHER KF-KG NEEDED
C
  73      B1B(KK)=B1BODY
          B2B(KK)=B2BODY
C
        ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
C-----------------------------------------------------------------------
C
C SET-UP LOCATIONS OF ONE-BODY SPIN-ORBIT SLATER-SLATE INTERACTIONS
C
C-----------------------------------------------------------------------
C
      KINT=0
      IF(.NOT.BFASTSO)GO TO 555                 !SKIP
C
C SET POINTERS TO ML BOUNDARIES
C
C
C EX-COMMON/NRBFL0/
C
      IXD02=QCL0/2
      IXD03=IXD02+1
      IF(KUTSO.EQ.-1)THEN      !NORMAL
        IXD19=KMAX
      ELSE         !MAXIMAL FOR KUTSO=0, COULD REDUCE ELSEWISE
        IXD19=(KMAX*(KMAX+1))/2
      ENDIF
C
      IXSTX=MAX(MXSTX0,MXSTX,IXSTX)               !USE LARGEST PREVIOUS
C      IXSTX=MAX(MXSTX0,MXSTX)                     !RESET
      ALLOCATE (KINTI(IXSTX),KINTF(IXSTX),KEN2(IXSTX)
     X         ,KPTCFM(-IXD02:IXD03,-IXD02:IXD03,0:IXD19)
     X         ,MPOINT(-IXD02:IXD03,KMAX)
     X         ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR KPTCFM,MPOINT ETC.'
        NF=0
        GO TO 999
      ENDIF
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.LT.-2)GO TO 555              !SKIP MXSTX DIMENSION CHECK
C
C-----------------------------------------------------------------------
C
      DO K=1,KMAX
        J=JYI(K)
        ML0=QBML(J)
        ML=ML0/2
        J=J-1
        DO M=IXD03,ML,-1
          MPOINT(M,K)=J
        ENDDO
        DO J=JYI(K),JYF(K)
          ML=QBML(J)
          IF(ML.LT.ML0)THEN
            ML0=ML0/2
            ML1=1+ML/2
            DO M=ML0,ML1,-1
              MPOINT(M,K)=J-1
            ENDDO
            ML0=ML
          ENDIF
        ENDDO
        ML=ML/2
        MPOINT(ML,K)=JYF(K)
        ML=ML-1
        DO M=ML,-IXD02,-1
          MPOINT(M,K)=JYF(K)
        ENDDO
      ENDDO
C
C SET-UP POINTERS TO 1-BODY SLATER-STATE INTERACTIONS
C
      KK=0
      KPTCFM(IXD03,IXD02,1)=0
c
      if(btime)call cpu_time(timei)
C
      KB=0
      KG1=1
      DO KF=1,KMAX
        IF(KUTSO.EQ.-1)KG1=KF
        DO KG=KG1,KF
          KK=KK+1
C
          IF(B1B(KB+KG))THEN
            CALL SPOR0(KK,QLMC,QBML,QBMS,MAXEL)
            IF(NF.EQ.0)GO TO 999
          ELSE
            DO M=IXD02,-IXD02,-1
              DO MP=IXD02,-IXD02,-1
                KPTCFM(MP,M,KK)=KINT
               ENDDO
            ENDDO
          ENDIF
c
c          write(0,*)'*** kg, kf, kint:',kg,kf,kint
c
          IF(KK.GT.1)KPTCFM(IXD03,IXD02,KK)=KPTCFM(-IXD02,-IXD02,KK-1)
C
          MPP=-IXD02
          DO M=IXD02-1,-IXD02,-1
            IF(KF.EQ.KG)MPP=M+1
            KPTCFM(IXD03,M,KK)=KPTCFM(MPP,M+1,KK)
c            kptcfm(ixd03,m,kk)=kptcfm(m,ixd03,kk)
          ENDDO
c
c checks and debug print (remove/comment-out eventually)
c
c          do m=ixd02,-ixd02,-1
c            if(kf.eq.kg)mpp=m
c            do mp=ixd02,mpp,-1
c              do k=kptcfm(mp+1,m,kk)+1,kptcfm(mp,m,kk)
c                if(k.gt.mxstx)stop 'increase mxstx'
c                j=kinti(k)
c                jd=kintf(k)
c                if(qbml(jd).ne.2*mp.or.qbml(j).ne.2*m)then
c                  write(6,*)kg,jd,mp,qbml(jd)/2,' cf j ml qbml',
c     x                      kf,j,m,qbml(j)/2,'    kint=',k
c                  stop 'algeb3: ml-mismatch'
c               endif
c              enddo
c            enddo
c          enddo
C
        ENDDO
        KB=KB+KF
      ENDDO
c
      if(btime)then
        call cpu_time(timef)
        time0=timef-timei
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for algeb3:'                 !par
cpar          write(iwp,*)'    spor0 time=',nint(time0),'sec'       !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'spor0 time=',nint(time0),'sec'
c          call flush(iw)
cpar        endif                                                   !par
      endif
C
      CALL DIMUSE('MXSTX',KINT)
C
      IF(KINT.GT.IXSTX)THEN                        !SHOULDN'T HAPPEN NOW
        WRITE(6,*)'SR:ALGEB3: INCREASE MXSTX TO:',KINT
        WRITE(0,*)'INCREASE MXSTX TO:',KINT
        GO TO 90
      ENDIF
C
 555  CONTINUE
C
C-----------------------------------------------------------------------
C
C CHECK BUFFERS FOR DC ARRAY IF DISKDC IN USE
C
C-----------------------------------------------------------------------
C
      MDCBUF3=0
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
      CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
C
        IF(KUTDSK.LT.KFBUFF)THEN
          NGJX=0                                       !DIM FOR ALLOCATE
          DO K=1,NJO
            NGJX=MAX(NGJX,NGSLJ(K))
            MTGD1=MTGD+1                                        !RESTORE
            DO NGJ1=1,NGSLJ(K)
              NC=NSLJ(NGJ1,K)
              DO KF=KUTDSK+1,KFBUFF
                NGSYM=KGSL(KF,NC)                         !POS WITHIN CF
                IF(NGSYM.GT.0)THEN
                  ISTRT=MTGD1
C
                 CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IZERO,IZERO)
C
                  MTGD1=IFIN+1
                ENDIF
              ENDDO
            ENDDO
            IFIN=MTGD1-1
            MDCBUF3=MAX(MDCBUF3,IFIN)
          ENDDO
          IF(MDCBUF3.GT.MDCBUF)THEN
C
            IXXX=MDCBUF3
C
            WRITE(6,*)'*** ALGEB3: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** ALGEB3: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'ALGEB3: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 999
            ENDIF
C
            IF(.NOT.BFAST)THEN
C
              CALL RE_ALLOC(IDC,IONE,MTGD,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'ALGEB3: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 999
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
            MDCBUF=IAXDC
c            WRITE(6,140)MDCBUF3
c            GO TO 90
          ENDIF
c          write(6,*)'ALGEB3: ',mdcbuf3
c          write(76,*)'ALGEB3'
          MDCBUF3=0
        ELSE
          MDCBUF3=MDCBUF
          NGJX=0                                       !DIM FOR ALLOCATE
          DO K=1,NJO
            NGJX=MAX(NGJX,NGSLJ(K))
          ENDDO
        ENDIF
C
        ALLOCATE (KSTART(KMAX,NGJX))
C
        IF(KUTDSK.GE.KFBUFF)THEN
          DO N=1,NGJX
            DO K=KFBUFF+1,KMAX
              KSTART(K,N)=0
            ENDDO
          ENDDO
        ENDIF
C
      ENDIF
C
      IF(MDCBUF3.GT.0)CALL DIMUSE('MAXDC',MDCBUF3)
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.LT.-2)THEN
        WRITE(6,3033)-KUTSO,KUTSS, LIT(QQCUT)
        WRITE(6,3050) MXADJ,MAXLV,MAXLV,IXSOC,IXSOI,
     X                MXADJ,MAXLV,MAXLV,IXRSS,IAXMI
        WRITE(6,110)IADJ8,NJ,NJ,0,0
        WRITE(6,1202)NP8,NJ,NJ,IRS,NL
        WRITE(6,122)IXS1C,IXS1I,0,0,mxstx,kint
        IF(KUTSS.NE.-1)WRITE(6,123)IXS2C,IXS2I,0,0
        WRITE(6,190)MDCBUF3,MAXDC
      ENDIF
C
C-----------------------------------------------------------------------
C
C ex-ALGEB4
C     no 1-body m1+bp
      MMAX0=MIN(MPOLE-2,MPOLM)                  !AS MPOLM NOT IN RESTART
      MMIN0=MAX(MPOL0-2,ITWO)
      bnom1bp1=MPRINT.EQ.-2.OR.MPRINT.EQ.-1.OR.MPRINT.EQ.-4.OR.
     X         MMIN0.GT.MMAX0.OR.
     X         MBP1MX.LT.2.AND.MMAX0.LT.4.AND.MEKVMX.LT.2
C
C EX-COMMON/COEFF/
C
      IXSOC=MAX(MXSOC0,MXSOC,IXSOC)               !USE LARGEST PREVIOUS
C      IXSOC=MAX(MXSOC0,MXSOC)                     !RESET
      IXSOI=MAX(MXSOI0,MXSOI,IXSOI)               !USE LARGEST PREVIOUS
C      IXSOI=MAX(MXSOI0,MXSOI)                     !RESET
C
      ALLOCATE (DRKP(IXSOC),QRLP(4,IXSOI),NRKP(IXSOC),NADP(0:IADJ8)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR DRKP,QRLP,NRKP,NADP'
        NF=0
        GO TO 999
      ENDIF
      BCOEFF=.TRUE.
C
C EX-COMMON/COEFFS/
C
      IXS1C=MAX(MXS1C0,MXS1C,IXS1C)               !USE LARGEST PREVIOUS
C      IXS1C=MAX(MXS1C0,MXS1C)                     !RESET
      IXS1I=MAX(MXS1I0,MXS1I,IXS1I)               !USE LARGEST PREVIOUS
C      IXS1I=MAX(MXS1I0,MXS1I)                     !RESET
C
      ALLOCATE (DRKPS(IXS1C),QRLPS(4,IXS1I),NRKPS(IXS1C)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR  DRKPS,QRLPS,NRKPS'
        NF=0
        GO TO 999
      ENDIF
C
C EX-COMMON /NSTS1/
C
      IXXX1=MAX(IXS1I,IXSOI)
      IXD27=KMAX*KMAX
      ALLOCATE (NADS1(0:IXD27),NSTJ1(IXS1C),NSTJ1D(IXS1C)
     X         ,IORIG1(IXXX1),JORIG1(IXS1I),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR NADS1,NSTJ1, ETC'
        NF=0
        GO TO 999
      ENDIF
C
C ex-ALGEB4
C     no 2-body m1+bp
      bnom1bp2=bnom1bp1.OR.MBP2MX.LT.2
C
C SET ALLOCATE SIZE
C
      IF(bnom1bp2.and.KUTSS.EQ.-1)THEN            !FOR ANY RESTART
        BG2BODY=.FALSE.
        IADJXX=0
        IXRSS=0
        IAXMI=0
        IXS2C=0
        IXS2I=0
        IXD27=0
      ELSE
        ITEST4=IBUFF4
        ITEST4=ITEST4+1
        IF(IADJ8.GT.IBUFF4.AND.ITEST4.LT.IBUFF4)THEN
          WRITE(0,*)'I*4 OVERFLOW ON 2-BODY FINE-STRUCTURE'
          GO TO 995
        ENDIF
        BG2BODY=.TRUE.
        IADJXX=IADJ
        IXRSS=MAX(MXRSS0,MXRSS,IXRSS)             !USE LARGEST PREVIOUS
C        IXRSS=MAX(MXRSS0,MXRSS)                   !RESET
        IAXMI=MAX(MAXMI0,MAXMI,IAXMI)             !USE LARGEST PREVIOUS
C        IAXMI=MAX(MAXMI0,MAXMI)                   !RESET
        IXS2C=MAX(MXS2C0,MXS2C,IXS2C)             !USE LARGEST PREVIOUS
C        IXS2C=MAX(MXS2C0,MXS2C)                   !RESET
        IXS2I=MAX(MXS2I0,MXS2I,IXS2I)             !USE LARGEST PREVIOUS
C        IXS2I=MAX(MXS2I0,MXS2I)                   !RESET
        IXD27=KMAX*KMAX
      ENDIF
      B2BODY=BG2BODY
C
C EX-COMMON/DMQSS3/
C
      ALLOCATE (DSS(IXRSS),MSS(IXRSS),QSS(5,IAXMI),NADR(0:IADJXX)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR  DSS,MSS,QSS,NADR'
        NF=0
        GO TO 999
      ENDIF
      BDMQSS3=.TRUE.
C
C EX-COMMON/DMQSSS/
C
      ALLOCATE (DSSS(IXS2C),MSSS(IXS2C),QSSS(5,IXS2I)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR  DSSS,MSSS,QSSS'
        NF=0
        GO TO 999
      ENDIF
C
C EX-COMMON /NSTS2/
C
      IXXX2=MAX(IXS2I,IAXMI)
      ALLOCATE (NADS2(0:IXD27),NSTJ2(IXS2C),NSTJ2D(IXS2C)
     X         ,IORIG2(IXXX2),JORIG2(IXS2I),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB3: ALLOCATION FAILS FOR NADS2,NSTJ2, ETC'
        NF=0
        GO TO 999
      ENDIF
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.LT.-2)GO TO 999              !EXIT LEVEL DIMENSION CHECK
C
C-----------------------------------------------------------------------
C
C CALCULATE SOME (PRODUCTS OF) CLEBSCH-GORDAN COEFFICIENTS:
C
C VCA=C(L1,L2,L,0,0,0)*C(L1,L2,KT,ML1,ML2,MLK)/(L+1)
C VCB=C(L1,L2,L,0,0,0)*C(L1,L2,KT+2,ML1,ML2,MLK)
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      IF(BDLBD)GO TO 50
C
      MXLL=NXLL
      IF(MXLL.LT.0.OR.KUTSS.EQ.-1)GO TO 50
C
      BVC=MXLL.LE.2*MAXLL
      IF(.NOT.BVC)MXLL=2*MAXLL
C
      M1=0
  46  M2=0
C
  45  MK=ABS(M1-M2)
C
  44  MK2=MK+2
      DVC=VCC(M1,M2,MK,IZERO,IZERO,IZERO,DFS)
      ML1=-M1
C
  42  MB1=MVC(M1,ML1)
      ML2=-M2
C
  43  MB2=MVC(M2,ML2)
      DA=DZERO
      DD=DZERO
      MLK=ML1+ML2
C
      IF(ABS(MLK).LE.MK2)THEN
        DD=VCC(M1,M2,MK2,ML1,ML2,MLK,DFS)*DVC
        IF(ABS(MLK).LE.MK)
     X     DA=(VCC(M1,M2,MK,ML1,ML2,MLK,DFS)/(MK+1))*DVC
      ENDIF
C
      MLK=MK/4+1
      VCA(MB1,MB2,MLK)=DA
      VCB(MB1,MB2,MLK)=DD
C
      ML2=ML2+2
      IF(ML2.LE.M2)GO TO 43
C
      ML1=ML1+2
      IF(ML1.LE.M1)GO TO 42
C
      MK=MK+4
      IF(MK.LE.M1+M2)GO TO 44
C
      M2=M2+2
      IF(M2.LE.MXLL)GO TO 45
C
      M1=M1+2
      IF(M1.LE.MXLL)GO TO 46
C
  50  CONTINUE
C
C-----------------------------------------------------------------------
C
C   PREPARE TO CALCULATE THE ALGEBRA OF THE FINESTRUCTURE INTERACTIONS
C   I.E., THE COEFFICIENTS C,D,AND E.
C   THIS SECTION SHOULD BE STUDIED TOGETHER WITH (COMMENTS IN) SR.SPOR
C   AND SR.RES
C
C-----------------------------------------------------------------------
C
      IF(MPRNT1.LE.0)WRITE(6,3056)
      IF(MCFSS.GE.1)THEN
        WRITE(6,3042)
        DO I=1,KMAX                                      !MAXCF
          IF(KCFSS(I).GE.1)WRITE(6,3043)I
        ENDDO
      ENDIF
C
      WRITE(6,3033)-KUTSO,KUTSS, LIT(QQCUT)
      WRITE(6,3050) MXADJ,MAXLV,MAXLV,IXSOC,IXSOI,
     X              MXADJ,MAXLV,MAXLV,IXRSS,IAXMI
C
C INITIALIZE FOR J-LOOP
C
      NL=0
      IRKP=0
      IRS=0
      IRLP=0
      MXIRKS=0
      MXIRLS=0
      MXIRSS=0
      MXNLS=0
      KPI=0
      KPIS=0
C
      NADP(0)=0
      NADR(0)=0
      NADS1(0)=0
      NADS2(0)=0
      NCJ=0
      NP8=0
      J1=2
      J1P=2
C                                                  !TEST ALTERNATIVE QMJ
      IF(BMOD3)THEN
        JACT=JN(1)
        QMJ=JACT-(JACT/2)*2                             !0 or 1 i.e. min
      ENDIF
C
C******************************
C EXPAND OVER THE NJO JP GROUPS WHERE
C******************************
C NT IS THE NUMBER OF LEVELS IN A JP GROUP
C
      if(btime)then
        time1=dzero
        time2=dzero
      endif
c
      DO 103 K=1,NJO                                     !BEGIN JPI LOOP
C
      JACT=JN(NCJ+1)
      IF(.NOT.BMOD3)QMJ=JACT            !QMJ=TWICE AZIMUTHAL COMPNT OF J
c      qmj=jact/2
C
      IF(KUTDSK.LT.KFBUFF)MTGD1=MTGD+1                          !RESTORE
C
      NCJ0=0
      DO 1150 NGJ1=1,NGSLJ(K)                             !BEGIN SL LOOP
        NC=NSLJ(NGJ1,K)
        N0=NSL(NC)
        LJ=QLI(NC)
        SJ=QSI(NC)
C
        DO KF=KUTDSK+1,KFBUFF                  !PRELOAD NEW SL GROUP VCC
          KSTART(KF,NGJ1)=0
          NGSYM=KGSL(KF,NC)                               !POS WITHIN CF
          IF(NGSYM.GT.0)THEN
            ISTRT=MTGD1
            KSTART(KF,NGJ1)=ISTRT
C
            CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IONE,IZERO)
C
            MTGD1=IFIN+1
            IF(IFIN.LT.0)THEN             !FAILURE TO READ REQUIRED DATA
              NF=-1
              GO TO 999
            ENDIF
          ENDIF
        ENDDO
C
        NCJP0=0
      DO 1140 NGJP1=1,NGJ1                              !BEGIN S'L' LOOP
        ND=NSLJ(NGJP1,K)
        N0P=NSL(ND)
        LJP=QLI(ND)
        SJP=QSI(ND)
C
      if(btime)call cpu_time(timei)
c
        IFLG0=0
        IF(SJP+SJ.EQ.0)GO TO 70
        IF(LJP+LJ.EQ.0)GO TO 70
        IFLG0=1
C
        BEQUGRP=NGJ1.EQ.NGJP1
        if(bequgrp.and.nc.ne.nd)stop 'bequgrp.and.nc.ne.nd'
        if(.not.bequgrp.and.nc.eq.nd)stop '.not.bequgrp.and.nc.eq.nd'
C
        IRKPS=0
        IRLPS=0
        IRSS=0
        NLS=0
C
        KK=0
        KG2=KMAX
        DO KF0=1,KMAX                                     !BEGIN LOOP KF
          kf=kf0                                              !for bswap
C
          IFLG=0
          IF(KGSL(KF,NC).GT.0)IFLG=1            !CF CONTRIBS TO SL GROUP
C
          IF(BEQUGRP)KG2=KF
C
          DO KG0=1,KG2                                    !BEGIN LOOP KG
            kg=kg0                                            !for bswap
            KK=KK+1
            IF(IFLG.EQ.0)GO TO 733                           !JUST INDEX
C
            IF(.NOT.BEQUGRP)THEN
              K0=MIN(KF,KG)
              K1=MAX(KF,KG)
              KB=(K1*(K1-1))/2+K0
            ELSE
              KB=KK
            ENDIF
C
            B1BODY=B1B(KB)
            B2BODY=B2B(KB)
            IF(.NOT.B1BODY.AND..NOT.B2BODY)GO TO 733
C
            IF(KGSL(KG,ND).GT.0)THEN          !CF CONTRIBS TO S'L' GROUP
              IFLGG=1
            ELSE
              IFLGG=0
              GO TO 733                                  !NO, IT DOESN'T
            ENDIF
C
            IF(BFASTSO)THEN
              BEQCFS=KF.EQ.KG
              IF(KUTSO.EQ.-1)THEN
                i1=1
                i2=2
                K2=KF                                        !KF=KG HERE
              ELSE
                if(kf.ge.kg)then
                  i1=1
                  i2=2
                  K2=(KF*(KF-1))/2+KG
                else
                  i1=2
                  i2=1
                  K2=(KG*(KG-1))/2+KF
                endif
              ENDIF
            ENDIF
c
            if(bswap)then                             !test swap bra/ket
              j=kf
              kf=kg
              kg=j
              j=sj
              sj=sjp
              sjp=j
              j=lj
              lj=ljp
              ljp=j
            endif
c
            JA=JYI(KF)
            JB=JYF(KF)
            JAP=JYI(KG)
            JBP=JYF(KG)
C
            IRKPS0=IRKPS+1
            IRLPS0=IRLPS
            IRSS0=IRSS+1
            NLS00=NLS
C
            ICLRR=0
            IF(B2BODY)ICLRR=1
            ICLRS=1
C
C-------------------------------------------------------------
C NOW LOOP-OVER ALL POSSIBLE ML,MS,ML',MS' THAT FORM MJ
C AND PICK-OUT THE CORRESPONDING SLATERSTATES, FOR ALL KF,KG.
C-------------------------------------------------------------
C
            QMS=SJ
 611        QML=QMJ-QMS
            BLX1=QMS.NE.-SJ.AND.QML.NE.LJ
            IF(QML.LT.-LJ)GO TO 616
C
            IF(.NOT.BFASTSO)THEN
C
C MAM(I) IS CONSTRUCTED SO THAT IT CAN BE USED TO SELECT INITIAL STATES
C        HAVING THE CORRECT ML,MS.
C
              J2=1
              DO J=JA,JB
                IF(QBML(J).EQ.QML.AND.QBMS(J).EQ.QMS)THEN
                  J2=J2+1
                  MAM(J2)=J
                ENDIF
              ENDDO
              IF(J2.LT.J1)GO TO 616
            ENDIF
C
            DVCL1=
     X           VCC(LJ,SJ,JACT,INT(QML,SP),INT(QMS,SP),INT(QMJ,SP),DFS)
            IF(ABS(DVCL1).LT.TTYNY)GO TO 616
C
            QMSP=SJP
 622        QMLP=QMJ-QMSP
            BLX2=QMSP.NE.-SJP.AND.QMLP.NE.LJP
            IF(QMLP.LT.-LJP)GO TO 615
C
            J1P=ABS(J1P)
            J2P=1
            IF(ABS(QMSP-QMS).GT.2)THEN                       !NO 1-BODY
              IF(.NOT.B2BODY.OR.ABS(QMSP-QMS).GT.4)GO TO 615 !NO 2-BODY
              GO TO 633                          !AS ABS(QMSP-QMS).EQ.4
            ENDIF
C
C SELECT SLATE STATES/INTERACTIONS
C
            IF(.NOT.BFASTSO)THEN
C
C NAM(I) IS CONSTRUCTED SO THAT IT CAN BE USED TO SELECT FINAL STATES
C        HAVING THE CORRECT MLP,MSP.
C
              DO J=JAP,JBP
                IF(QBML(J).EQ.QMLP.AND.QBMS(J).EQ.QMSP)THEN
                  J2P=J2P+1
                  NAM(J2P)=J
                ENDIF
              ENDDO
C
            ELSE
C
C SET POINTERS THAT SELECT SLATER STATE INTERACTIONS FOR QML & QMLP
C
              if(beqcfs)then
                if(qmlp.ge.qml)then
                  i1=1
                  i2=2
                else
                  i1=2
                  i2=1
                endif
              endif
c
              mej(i1)=qml/2
              mej(i2)=qmlp/2
              k1=kptcfm(mej(2),mej(1),k2)
              mej(2)=mej(2)+1
              k0=kptcfm(mej(2),mej(1),k2)+1
C
C MAM(J2) IS CONSTRUCTED TO SELECT INITIAL & FINAL STATES
C         HAVING THE CORRECT QML, QMS & QMLP,QMSP.
C
c If non-trivial time taken in this search, do a double sweep as in
c   v22.11. The coding below does seem to inhibit compiler optimization.
C
c              write(6,*)qml,qms,' ml ms ',qmlp,qmsp,'   k0 k1  ',k0,k1
c
              J2=1
              do ky=k0,k1
                nej(i1)=kinti(ky)
                nej(i2)=kintf(ky)
                j=nej(1)
                jp=nej(2)
                jjp=jp
                kp=ky
 137            IF(QBMS(J).EQ.QMS.AND.QBMS(JP).EQ.QMSP)THEN
                  J2=J2+1
                  if(j2.gt.nss)then
                    write(6,*)'sr.algeb3: mxst0/nss exceeded...'
                    write(0,*)'sr.algeb3: mxst0/nss exceeded...'
                    go to 999
                  endif
                  if(beqcfs.and.qmlp.lt.qml)kp=-kp
                  MAM(J2)=kp
                ENDIF
                if(beqcfs.and.QML.eq.QMLP.and.j.ne.jjp)then
                  jp=j
                  j=jjp
                  kp=-kp
                  go to 137
                endif
              enddo
              J1P=J1
              J2P=J2
            ENDIF
C
            IF(.NOT.B2BODY.AND.J2P.LT.J1P)GO TO 615
C
  633       DVCL2=
     X       VCC(LJP,SJP,JACT,INT(QMLP,SP),INT(QMSP,SP),INT(QMJ,SP),DFS)
C
            DVC12=DVCL1*DVCL2
            IF(ABS(DVC12).LT.TYNY)GO TO 615
C
            BLX=BLX1.OR.BLX2
C
C-------------------------------------------------------------
C CALCULATE THE SLATER-STATE INTERACTION BETWEEN CFS KF AND KG
C-------------------------------------------------------------
C
   52       IF(B1BODY.AND.J2P.GE.J1P)THEN
C
C
              IF(.NOT.BFASTSO)THEN
                CALL SPOR1(QLMC,MAXEL,MAM,NAM,KPIS)          !<-- 1-BODY
              ELSE
                CALL SPOR1F(QLMC,MAXEL,MAM,KPIS)             !<-- 1-BODY
              ENDIF
C
C
              MXIRKS=MAX(MXIRKS,IRKPS)
              MXIRLS=MAX(MXIRLS,IRLPS)
              IF(KPIS.NE.0)GO TO 619  !DIM MXS1C AND/OR MXS1I EXCEEDED
              IF(NF.LE.0)GO TO 999
C
              IF(ICLRS.EQ.0)THEN
                IF(ICLRR.EQ.0)GO TO 733
                J1P=ABS(J1P)
              ENDIF
C
            ENDIF
C
            IF(.NOT.B2BODY)GO TO 615               !CASE BFASTSO.EQ.TRUE
C
            IF(ABS(QMSP-QMS).EQ.4)THEN               !NOW ADD 2-BODY SS
              DO J=JAP,JBP
                IF(QBML(J).EQ.QMLP.AND.QBMS(J).EQ.QMSP)THEN
                  J2P=J2P+1
                  NAM(J2P)=J
                ENDIF
              ENDDO
            ENDIF
C
  55        IF(J2P.GE.J1P)THEN
C
c       write(6,*)qms,qml,qmsp,qmlp,qmj,irss,j1,j2,j1p,j2p
C
              CALL RES1(QLMC,MAXEL,DFS,MAM,NAM,KPIS)         !<-- 2-BODY
C
C
              MXIRSS=MAX(MXIRSS,IRSS)
              MXNLS=MAX(MXNLS,NLS)
              IF(KPIS.NE.0)GO TO 619    !DIM MXS2C AND/OR MXS2I EXCEEDED
              IF(NF.LE.0)GO TO 999
C
              IF(ICLRR.EQ.0)THEN
                IF(ICLRS.EQ.0)GO TO 733
                GO TO 617
              ENDIF
C
            ENDIF
C
C-------------------------------------------------------------
C IF BLX=.TRUE. THE TRANSFORMATION TO THE J,MJ REPRESENTATION
C              IS NOT YET COMPLETE.
C-------------------------------------------------------------
C
 615        QMSP=QMSP-2
C
            IF(BLX2)GO TO 622
C
 616        QMS=QMS-2
C
            IF(BLX1)GO TO 611
C
C CLEAR ARRAYS, IF NOT ALREADY DONE
C
 617        IF(ICLRS.NE.0)THEN
              ICLRS=-ICLRS
              B1BODY=.TRUE.
              J1P=-ABS(J1P)
              GO TO 52
            ENDIF
C
            IF(ICLRR.NE.0)THEN
              ICLRR=-ICLRR
              J1P=-ABS(J1P)
              GO TO 55
            ENDIF
C
 733        NADS1(KK)=IRKPS
            IF(BG2BODY)NADS2(KK)=IRSS
C
c        write(6,*)'***** kf,kg:',kf,kg,nads2(kk)-nads2(kk-1)
c        do ijk=nads2(kk-1)+1,nads2(kk)
c          jq=msss(ijk)
c          write(6,776)nstj2(ijk),nstj2d(ijk),msss(ijk),dsss(ijk)
c     x              ,(qsss(iq,jq),iq=1,5)
c  776  format(3i5,f12.6,5i5)
c        enddo
c
            if(bswap.and.iflg*iflgg.gt.0)then         !test swap bra/ket
              j=kf
              kf=kg
              kg=j
              j=sj
              sj=sjp
              sjp=j
              j=lj
              lj=ljp
              ljp=j
            endif
c
          ENDDO                                             !END LOOP KG
C
        ENDDO                                               !END LOOP KF
C
C
  70  CONTINUE
C
c
      if(btime)then
        call cpu_time(timef)
        time1=time1+timef-timei
      endif
C
C
C------------------------------------------------------------------
C NOW DETERMINE THE INTERACTION BETWEEN JP LEVELS OF THE LSP GROUPS
C------------------------------------------------------------------
c
      if(btime)call cpu_time(timei)
C
      istrt0=0
      KF0=0
      DO NJ11=1,N0                                       !BEGIN SLJ LOOP
C
        NJ1=NJ11+NCJ0
        NJ=NJ1+NCJ
        IT=NRR(NJ)
        KF=NFK(IT)
c
        if(bcont.or.bkutls)then
          ii=ieq(qcg(nf,kf))
          kcf=0
          if(qn(ii).ge.90)kcf=ii                              !continuum
        endif
C
        IF(IFLG0.EQ.0)GO TO 74
C
        IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
          ISTRT=KSTART(KF,NGJ1)
          IF(ISTRT.EQ.0)THEN                             !BUFFERED BY CF
            NGSYM=KGSL(KF,NC)                             !POS WITHIN CF
            ISTRT=MTGD1
C
            CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
            IF(IEND.LT.0)THEN             !FAILURE TO READ REQUIRED DATA
              NF=-1
              GO TO 999
            ENDIF
          ENDIF
          ISTRT0=ISTRT-MTGD-1                       !I.E. ORIGINAL MTGD1
          KF0=KF
        ENDIF
C
        II=NFI(IT)
        IF(BFAST)THEN
          NJ2=JTGD(II)+ISTRT0              !relative start flagged
        ELSE
          do j=jyi(kf),jyf(kf)
            mam(j)=0
          enddo
          k2=jtgd(ii)                      !absolute end flagged
          if(k2.lt.0)then                  !bdisk first
            k2=-k2
            k1=mtgd
          else
            k1=jtgd(ii-1)                  !start
            k1=abs(k1)                    !case bdisk second
          endif
          k1=k1+1+istrt0
          k2=k2+istrt0
          do k12=k1,k2
            j=idc(k12)
            mam(j)=k12
          enddo
        ENDIF
C
  74    IF(NC.EQ.ND)N0P=NJ11
C
        istrt=0
        KG0=0
        DO NJP11=1,N0P                                 !BEGIN S'L'J LOOP
C
          NJP1=NJP11+NCJP0
          NJG=NJP1+NCJ
          ITP=NRR(NJG)
          KG=NFK(ITP)
c
          if(bcont.or.bkutls)then
            ll=ieq(qcg(nf,kg))
            kcg=0
            if(qn(ll).ge.90)kcg=ll
            if(kcf.ne.kcg.and.kcf*kcg.ne.0)go to 80 !c-c does not contrb
            if(bfastso.and.(kcf+kcg).ne.0.and.kcf*kcg.eq.0)
     x      go to 80                       !no 2-fs and nc.ne.nd and b-c
c single cf mixing (but keeping b-c)
            if(bkutls.and.kf.ne.kg
     x               .and.(kcf+kcg.eq.0.or.kcf*kcg.ne.0))go to 80
          endif
C
          NP8=NP8+1
          IF(IFLG0.EQ.0)GO TO 618                      !NO INTRACTNS 0-0
C
C CALCULATE THE ALGEBRAIC CONTRIBUTION TO THE MATRIX ELEMENT.
C
          IF(BEQUGRP)THEN                !KG.LE.KF HERE
            KK=(KF*(KF-1))/2 + KG
          ELSE
            KK=KMAX*(KF-1)+KG
          ENDIF
C
          B1BODY=NADS1(KK).GT.NADS1(KK-1)
          IF(BG2BODY)B2BODY=NADS2(KK).GT.NADS2(KK-1)
C
          IF(B1BODY.OR.B2BODY)THEN
C
            IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
              ISTRT=KSTART(KG,NGJP1)
              IF(ISTRT.EQ.0)THEN                         !BUFFERED BY CF
                LGSYM=KGSL(KG,ND)                         !POS WITHIN CF
                ISTRT=IEND+1
C
                CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                IF(IFIN.LT.0)THEN         !FAILURE TO READ REQUIRED DATA
                  NF=-1
                  GO TO 999
                ENDIF
              ENDIF
              ISTRT=ISTRT-MTGD-1                    !I.E. ORIGINAL MTGD1
              KG0=KG
            ENDIF
C
            LL=NFI(ITP)
            IF(BFAST)THEN
              NJP2=JTGD(LL)+ISTRT          !relative start flagged
            ELSE
              do j=jyi(kg),jyf(kg)
                nam(j)=0
              enddo
              k2=jtgd(ll)                  !absolute end flagged
              if(k2.lt.0)then              !bdisk first
                k2=-k2
                k1=mtgd
              else
                k1=jtgd(ll-1)              !start
                k1=abs(k1)                !case bdisk second
              endif
              k1=k1+1+istrt
              k2=k2+istrt
              do k12=k1,k2
                j=idc(k12)
                nam(j)=k12
              enddo
            ENDIF
c
            if(bswap)then                             !test swap bra/ket
              j=nj
              nj=njg
              njg=j
              if(bfast)then
                j=nj2
                nj2=njp2
                njp2=j
              else
                if(kf.ne.kg)then
                  do j=jyi(kf),jyf(kf)
                    nam(j)=mam(j)
                  enddo
                  do j=jyi(kg),jyf(kg)
                    mam(j)=nam(j)
                  enddo
                else
                  do j=jyi(kf),jyf(kf)
                    l=mam(j)
                    mam(j)=nam(j)
                    nam(j)=l
                  enddo
                endif
              endif
            endif
C
          ENDIF
C
          IRKP0=IRKP+1
          IF(B1BODY)THEN
C
C
            CALL SPOR2(mam,nam,KK,KPI)                       !<-- 1-BODY
C
C
            IF(KPI.NE.0)GO TO 619
          ENDIF
C
          IRS0=IRS+1
          IF(B2BODY)THEN
C
C
            CALL RES2(mam,nam,KK,KPI)                        !<-- 2-BODY
C
C
            IF(KPI.NE.0)GO TO 619
          ENDIF
C
C
C PRINT THE ALGEBRAIC COEFFICIENTS OF THE SPIN-ORBIT MATRIX ELEMENT
C IF THEY ARE NOT ZERO.
C
          IF(MPRINT.GT.0)THEN
            IF(IRKP.EQ.IRKP0)THEN
              WRITE(6,109)NP8,NJ,NJG,IRKP,IRLP
     X                  ,(NRKP(N),DRKP(N),N=IRKP0,IRKP)
            ELSEIF(IRKP.GT.IRKP0)THEN
              WRITE(6,110)NP8,NJ,NJG,IRKP,IRLP
     X                  ,(NRKP(N),DRKP(N),N=IRKP0,IRKP)
            ELSE
              WRITE(6,109)
            ENDIF
            IF(IRS-IRS0.EQ.2)THEN
              WRITE(6,1201)NP8,NJ,NJG,IRS,NL,(MSS(N),DSS(N),N=IRS0,IRS)
            ELSEIF(IRS.GE.IRS0)THEN
              WRITE(6,1202)NP8,NJ,NJG,IRS,NL,(MSS(N),DSS(N),N=IRS0,IRS)
            ENDIF
          ELSEIF(MPRINT+idw.EQ.0)THEN
            IF(NJG.EQ.NJ)WRITE(6,130)NP8,NJ,NJG,IRKP,IRLP,IRS,NL
          ENDIF
c
          if(bswap)then                               !test swap bra/ket
            j=nj2
            nj2=njp2
            njp2=j
            j=nj
            nj=njg
            njg=j
          endif
C
C NADP IS THE ADDRESS ARRAY WHICH GIVES THE POSITION OF THE LAST
C SPIN-ORBIT PARAMETER ASSOCIATED WITH AN M.E. (J,MJ!F(SO)!JP,MJP)
C NADR SIMILARLY FOR 2-BODY FINE-STRUCTURE. (C.F. NAD FOR LS.)
C
 618      NADP(NP8)=IRKP
          IF(BG2BODY)NADR(NP8)=IRS               !GLOBAL TEST
C
  80    ENDDO                                    !END S'L'J LOOP
C
      ENDDO                                      !END SLJ LOOP
c
      if(btime)then
        call cpu_time(timef)
        time2=time2+timef-timei
      endif
C
      NCJP0=NCJP0+N0P
 1140 ENDDO                                      !END S'L' LOOP
C
      NCJ0=NCJ0+N0
 1150 ENDDO                                      !END SL LOOP
C
      IF(KUTDSK.LT.KFBUFF)THEN
        IFIN=MTGD1-1
        MDCBUF3=MAX(MDCBUF3,IFIN)
      ENDIF
C
      NCJ=NT(K)+NCJ
 103  ENDDO                                      !END JP LOOP
C
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for algeb3:'                 !par
cpar          write(iwp,*)'    spor1+res1 time=',nint(time1),'sec'  !par
cpar          write(iwp,*)'    spor2+res2 time=',nint(time2),'sec'  !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'spor1+res1 time=',nint(time1),'sec'
          write(iw,*)'spor2+res2 time=',nint(time2),'sec'
c          call flush(iw)
cpar        endif                                                   !par
      endif
C
      if(ncj.ne.nlev)stop 'algeb3: nlevels=?'      !temp - to be removed
C
COLD      QBML(1)=NCJ                     !PASS TO ALGEB FOR RESTART I/O
COLD      QBMS(1)=NP8                   !PASS TO ALGEB4, NO LONGER USED?
C
      IF(IADJ8.NE.NP8)THEN
         WRITE(0,*)'SR.ALGEB3 GLOBAL INDEX ERROR:',IADJ8,NP8
         NF=-1
         GO TO 999
      ENDIF
C
      CALL DIMUSE('MXSOC',IRKP)
      CALL DIMUSE('MXSOI',IRLP)
      CALL DIMUSE('MXRSS',IRS)
      CALL DIMUSE('MAXMI',NL)
      CALL DIMUSE('MXS1C',MXIRKS)
      CALL DIMUSE('MXS1I',MXIRLS)
      IF(IRSS.GT.0)THEN
        CALL DIMUSE('MXS2C',MXIRSS)
        CALL DIMUSE('MXS2I',MXNLS)
      ENDIF
      IF(MDCBUF3.GT.0)CALL DIMUSE('MAXDC',MDCBUF3)
C
      IF(MPRNT1.GE.0)THEN
        WRITE(6,122)IXS1C,IXS1I,MXIRKS,MXIRLS,mxstx,kint
        IF(IRSS.GT.0)WRITE(6,123)IXS2C,IXS2I,MXIRSS,MXNLS
        WRITE(6,190)MDCBUF3,MAXDC
      ENDIF
      IF(MPRNT1.EQ.0)GO TO 999                     !RETURN
      IF(MPRNT1.GT.0)GO TO 620
C
      NJG=NCJ
 619  WRITE(6,110)NP8,NJ,NJG,IRKP,IRLP
      WRITE(6,1202)NP8,NJ,NJG,IRS,NL
C
      IF(KPI.LT.0)GO TO 99
      IF(KPI.GT.0)GO TO 991
C
      WRITE(6,122)IXS1C,IXS1I,MXIRKS,MXIRLS,mxstx,kint
      IF(IRSS.GT.0)WRITE(6,123)IXS2C,IXS2I,MXIRSS,MXNLS
      WRITE(6,190)MDCBUF3,MAXDC
      IF(KPIS.LT.0)GO TO 990
      IF(KPIS.GT.0)GO TO 9910
C
      GO TO 999                                    !RETURN
C
 620  IF(IRLP.GT.0)THEN
        WRITE(6,2001)           !NO. S-O BY THEIR ARGUMENTS
        DO L=1,IRLP
          WRITE(6,2002)L,(QRLP(K,L),K=1,2)
        ENDDO
      ENDIF
C
      IF(NL.GT.0)THEN           !TWO-BODY
        WRITE(6,2011)
        DO L=1,NL
          IF(QSS(5,L).GT.197)THEN
            WRITE(6,244)  L,(QSS(K,L),K=1,5)
          ELSE
            WRITE(6,2444)  L,(QSS(K,L),K=1,5)
          ENDIF
        ENDDO
      ENDIF
C
      GO TO 999                                    !RETURN
C
 101  WRITE(6,100)
      GO TO 999                                    !RETURN
C
C PRINT FAILURE DIAGNOSTIC
C
  99  WRITE(6,1210)
      GO TO 90
 990  WRITE(6,1211)
      GO TO 90
 991  WRITE(6,1203)
      GO TO 90
9910  WRITE(6,1204)
      GO TO 90
 995  WRITE(6,1215)
      GO TO 90
 998  WRITE(6,1218)
C
  90  WRITE(6,1377)
      WRITE(0,*) 'DIMENSION FAILURE IN ALGEB3'
      IF(NF.GT.0)NF=-1
COLD  NJO=-1                  !SWITCH-OFF IC, BUT CONTINUE LS RUN
C
 999  CONTINUE
c
      do i=1,mxorb
        if(qn(i).ge.60.and.qn(i).le.i69)qn(i)=mod(INT(qn(i),SP),i60)
      enddo
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MXSOI)/5
      IF(bnom1bp1.and.BCOEFF.AND.IRLP.LT.IXXX)THEN
C
c      WRITE(6,*)'*** ALGEB3: decreasing MXSOI from ',IXSOI,' to: ',IRLP
c      WRITE(0,*)'*** ALGEB3: decreasing MXSOI from ',IXSOI,' to: ',IRLP
C
       CALL RE_ALLOC2(QRLP,IONE,IFOUR,IONE,IXSOI,IFOUR,IRLP,IERR)
C
        IXSOI=IRLP
C
      ENDIF
C
      IXXX=(4*MXSOC)/5
      IF(bnom1bp1.and.BCOEFF.AND.IRKP.LT.IXXX)THEN
C
c      WRITE(6,*)'*** ALGEB3: decreasing MXSOC from ',IXSOC,' to: ',IRKP
c      WRITE(0,*)'*** ALGEB3: decreasing MXSOC from ',IXSOC,' to: ',IRKP
C
        CALL RE_ALLOC(DRKP,IONE,IXSOC,IRKP,IERR)
C
        CALL RE_ALLOC(NRKP,IONE,IXSOC,IRKP,IERR)
C
        IXSOC=IRKP
C
      ENDIF
C
      IXXX=(4*MAXMI)/5
      IF(bnom1bp2.and.BDMQSS3.AND.IAXMI.GT.0.AND.NL.LT.IXXX)THEN
C
c        WRITE(6,*)'*** ALGEB3: decreasing MAXMI from ',IAXMI,' to: ',NL
c        WRITE(0,*)'*** ALGEB3: decreasing MAXMI from ',IAXMI,' to: ',NL
C
        CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,NL,IERR)
C
        IAXMI=NL
C
      ENDIF
C
      IXXX=(4*MXRSS)/5
      IF(bnom1bp2.and.BDMQSS3.AND.IXRSS.GT.0.AND.IRS.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGEB3: decreasing MXRSS from ',IXRSS,' to: ',IRS
c       WRITE(0,*)'*** ALGEB3: decreasing MXRSS from ',IXRSS,' to: ',IRS
C
        CALL RE_ALLOC(DSS,IONE,IXRSS,IRS,IERR)
C
        CALL RE_ALLOC(MSS,IONE,IXRSS,IRS,IERR)
C
        IXRSS=IRS
C
      ENDIF
C
C LOCAL
      IF(ALLOCATED(B1B))THEN
        DEALLOCATE (B1B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR B1B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(B2B))THEN
        DEALLOCATE (B2B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR B2B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(KSTART))DEALLOCATE (KSTART)
C
C EX-COMMON /NSTS2/
      IF(ALLOCATED(NADS2))THEN
        DEALLOCATE (NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR NADS2,NSTJ2...'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/DMQSSS/
      IF(ALLOCATED(DSSS))THEN
        DEALLOCATE (DSSS,MSSS,QSSS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR DSSS,MSSS,QSSS'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON /NSTS1/
      IF(ALLOCATED(NADS1))THEN
        DEALLOCATE (NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR NADS1,NSTJ1...'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/COEFFS/
      IF(ALLOCATED(DRKPS))THEN
        DEALLOCATE (DRKPS,QRLPS,NRKPS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR  DRKPS,QRLPS..'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/NRBFL0/
      IF(ALLOCATED(KINTI))THEN
        DEALLOCATE (KINTI,KINTF,KEN2,KPTCFM,MPOINT,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB3: DE-ALLOCATION FAILS FOR KPTCFM, ETC.'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      RETURN                  !<-------------------RETURN
C
  100 FORMAT( /" NOT ENOUGH VCC'S AVAILABLE FOR CALCULATION OF "
     X,"RELATIVISTIC CORRECTIONS: CHANGE MOD  TO 1,-1 OR 0")
  109 FORMAT(I9,2I6,I9,2I6,F12.6)
  110 FORMAT(I9,2I6,I9,2I6,F12.6/(36X,I6,F12.6))
  122 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXS1C,MXS1I)',I9,I6,
     X10X,'USED:',I9,I6/34X,'(MXSTX)',6X,I9,16X,'USED:',I9)
  123 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXS2C,MXS2I)',I9,I6,
     X10X,'USED:',I9,I6)
  130 FORMAT(I9,2I6,I9,I6,41X,I12,I6)
  131 FORMAT(/73X,'(',I6,')',I11,7X,'MAXDK=',I11)
  132 FORMAT(/83X,I9,7X,'MXAAK=',I11)
  133 FORMAT(' EXPECT ALLOCATION IN SR.DIAGFS TO INCREASE NO. OF ',
     X'MATRIX ELEMENTS MAXJU AS ABOVE, IF RADIATIVE RATES REQUIRED')
  134 FORMAT(/68X,'(',I11,')',I11,7X,'MAXJU=',I11)
  136 FORMAT(/'SR.ALGEB3: INCREASE MXAAK OR MAXDK - SEE ABOVE')
c  140 FORMAT(/'*** SR.ALGEB3: INCREASE MAXDC TO AT LEAST: ',I10,' FOR',
c     X' H-BUFFER')
  180 FORMAT(6I5)
  181 FORMAT(' ',44X,'JGROUP=',I3,4X,'2J=',I2,3X,'PARITY=',I3,4X,'N0=',
     XI6//)
  190 FORMAT(/86X,I10,'=MTGD, MAXDC=',I10,' BUFFER STORAGE USED')
  244 FORMAT(I6,7X,4I5,I7)
  299 FORMAT(/' TOO MANY BOUND-FREE INTERACTIONS, EXPECT '
     X,'ALLOCATION IN ','DIAGFS, TO INCREASE MXAAK TO',I11)
  400 FORMAT(//'   LV  2S+1   L   2J   CF    T',44X
     X,'**** LEVEL TABLE ****')
  670 FORMAT(/' SR.ALGEB3:  TOO MANY LEVELS,',I7,'.GT.MAXLV=',I7,
     X' -  OR TOO MANY (J,P) GROUPS,',I3,'.GT.MAXJG=',I3)
 1777 FORMAT(' NOTE: ALLOCATION IN SR.DIAGFS WILL INCREASE SIZE OF',
     X' SLJ MATRIX MAXDK AS BELOW')
  993 FORMAT(2I2,2X,2I2,2I5,F18.8,3X,A4)
 1111 FORMAT(//1X,136('-')//)
 1112 FORMAT(' *** USER-SUPPLIED LEVEL SYMMETRY RESTRICTIONS:'//)
 1113 FORMAT('   LV  2J   P')
 1114 FORMAT(1X,3I4)
 1115 FORMAT(' MINJT=',I2,3X,'MAXJT=',I2)
 1122 FORMAT(/'*** ALGEB3: YOU HAVE FLAGGED READ OF AN OLD LEVELS'
     X,' FILE, BUT NONE CAN BE FOUND...'/12X,'SWITCH-OFF FLAG AND'
     X,' RE-RUN (FOR ENERGIES ONLY) TO GENERATE ONE (EFFEICIENTLY)')
cw 1123 FORMAT(/'*** IN LARGE CASES IT IS MORE EFFICIENT TO READ A'
cw     X,' "LEVELS" FILE GENERATED BY A PRIOR (ENERGIES ONLY) RUN')
 1201 FORMAT(56X,I12,2I6,I9,I6,3(I5,F9.4))
 1202 FORMAT(56X,I12,2I6,I9,I6,3(I5,F9.4)/(95X,3(I5,F9.4)))
 1203 FORMAT(' STORAGE MAYBE EXCEEDED IN SR.RES2: INCREASE  MXRSS OR'
     X,' MAXMI')
 1204 FORMAT(' STORAGE EXCEEDED IN SR.RES1: INCREASE  MXS2C OR'
     X,' MXS2I')
 1210 FORMAT(' STORAGE EXCEEDED IN SR.SPOR2: AUGMENT  MXSOC OR'
     X,' MXSOI')
 1211 FORMAT(' STORAGE EXCEEDED IN SR.SPOR1: INCREASE  MXS1C OR'
     X,' MXS1I')
 1215 FORMAT('*** SR.ALGEB3: I*4 OVERFLOW ON 2-BODY FINE-STRUCTURE'/
     X'    SET KUTSS=-1 TO SWITCH-OFF, OR REDUCE PROBLEM SIZE')
 1218 FORMAT(//'*** SR.ALGEB3: I*4 WILL OVERFLOW FOR DIAGFS TFU ARRAY'
     X,' INDEX, RECOMPILE FORCING I*8 OR SWITCH-OFF RADIATION/PI'//)
 1377 FORMAT(//' ****DIMENSION FAILURE IN SR.ALGEB3 ***'//)
 2001 FORMAT(/' SPIN-ORBIT PARAMETER REFERENCE LIST'/'  I(Z)',6X,
     X 'ZETA(     A    B)= SPIN-ORBIT PARAMETERS')
 2002 FORMAT(I6,12X,2I5)
 2011 FORMAT(/' REFERENCE LIST OF MAGNETIC INTEGRALS N AND V'
     X        /' INDEX',5X,'N(    A    B    C    D   2LBD+200)',7X,
     X 'INDEX',2X,'V(    A    B    C    D   2LBD+100)')
 2444 FORMAT(51X,I6,4X,4I5,I7)
 3033 FORMAT(//'  ALGEBRA OF THE SPIN-ORBIT INTERACTION ',4X,'KUTSO =',
     XI3,9X,' ALGEBRA OF THE SPIN-SPIN (C), MUTUAL SPIN-ORBIT (A)' /67X
     X,'AND THE SPIN-OTHER-ORBIT (B) INTERACTIONS',10X,'KUTSS =',I3,A1)
 3042 FORMAT(//   ' CONFIGURATIONS FOR WHICH TWO-BODY FINE-STRUCTURE'
     X,' INTERACTIONS ARE EVALUATED; IN ADDITION TO THOSE SPECIFIED'
     X,' BELOW BY KUTSS' /)
 3043 FORMAT(I4)
 3050 FORMAT(4X,'MXADJ MAXLV MAXLV    MXSOC MXSOI',27X,'MXADJ MAXLV '
     X,'MAXLV    MXRSS MAXMI'/I9,2I6,I9,I6,2X,'STORAGE RESTRICTIONS '
     X,I9,2I6,I9,I6/7X,'NP',4X,'LV',3X,'LVP',7X,'CN',3X,'IND',2X,'I(Z)'
     X,6X,'C(A,B)',12X,'NP',4X,'LV',3X,'LVP',7X,'CN',3X,'IND'
     X,3(3X,'I(Y) X(A-D)'))
 3054 FORMAT('SR.ALGEB3: ALLOCATION INCREASES NUMBER OF MATRIX '
     X,' ELEMENTS IADJ =',I10,' .GT. MXADJ=',I10)
 3056 FORMAT(/' *** PRINTOUT OF COEFFICIENTS C, D AND E SUPPRESSED BY'
     X,' MPRINT .LE. 0')
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(MLX,MLY)
C
      MVC=((MLX+2)*MLX/2+MLY)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE ALGEB3
C
C                             *******************
C
      SUBROUTINE ALGEB4(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGEB4 WORKS OUT RADIATIVE MK ALGEBRA, INCLUDING BP CORRECTIONS
C  TO M1 AND E1VEL.
C
C  IT CALLS;
C    SR.DISKDC
C    SR.DIMUSE
C    SR.MKALG1
C    SR.MKALG2
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_COEFF,  ONLY: BCOEFF,DRKP,QRLP,IRLP,NRKP,IWORD1,IXSOC
     X                        ,IXSOI,IPLANT_SOI                   !,NADP
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,IWORD2,IXRSS,IAXMI
     X                        ,IPLANT_MI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
      USE COMMON_NRBMKP, ONLY: BNRBMKP,NMD1,NMD2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXMI0=  1000)
      PARAMETER (MXS2I0=MAXMI0)
      PARAMETER (MXRSS0= 25000)
      PARAMETER (MXS2C0=MXRSS0)
      PARAMETER (MXSOC0= 10000)
      PARAMETER (MXS1C0=MXSOC0)
      PARAMETER (MXSOI0=   500)
      PARAMETER (MXS1I0=MXSOI0)
C
      PARAMETER (MXD05=4*(MAXLL+1))
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      INTEGER(EP) NTMP,MDCF8,MDCFT8
C
      CHARACTER(LEN=1) CQLIT,MP
      CHARACTER(LEN=4) CODE
C
      DIMENSION MAM(*),NAM(*),JYI(*),JYF(*)
     X         ,QLMC(MAXEL,*),QBML(*),QBMS(*)
C
      DIMENSION CQLIT(10),DFS(MXDFS)
C
      ALLOCATABLE :: B1B(:),B2B(:),KSTART(:,:),ITMP(:)
      ALLOCATABLE :: MMD1(:,:,:),MMD2(:,:,:),TMP(:),NTMP(:)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,NLEV,ND1,NDP1,ND2,NDP2
      COMMON /CMKALG1/DVC12,VC1(MXD05),NC0X,MJS1,MJL1,MJS2,MJL2
     X,MJJL,MJJR,NC,ND,ICLR,QLIT(10),BLX1,BLX2,BMSKIP,BOSKIP,BM1BODY
      COMMON /CMKALG2/DVC,MJ1,MJ2,MLAM,BE1CASE
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRLP/IRKP,IRKP0
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      common /nrbtim/iw,iwp,btime,btimex
C
      DATA  MG/-2/,BDEBUG1/.FALSE./
     X ,CQLIT/'0','1','2','3','4','F','S','Q','W','X'/
C
      BLOCAL=.FALSE.
C
      NL=NL000
COLD      NL=NL000-1
C
C HOLD ORIGINAL VALUES
C               N.B. NL000 IS ALREADY ORIG NL (ORDER SWAPPED IN /NXRNL/)
      IRS000=IRS
      IRLP000=IRLP
      IRKP000=IRKP
C
      IF(NJO.LE.0)GO TO 97
C     BECAUSE ALL I.C. CALCULATIONS HAVE BEEN SWITCHED OFF.
C
      IF(MPRINT.EQ.MG)GO TO 97
C     BECAUSE ON INPUT RADIATIVE CALCULATIONS HAVE BEEN SUPPRESSED.
C
      IF(MPRINT.EQ.-1.OR.MPRINT.EQ.-4)GO TO 97
C     BECAUSE ELECTRIC DIPOLE ONLY.
C
      MMAX0=MIN(MPOLE-2,MPOLM)                  !AS MPOLM NOT IN RESTART
      MMIN0=MAX(MPOL0-2,ITWO)
      IF(MMIN0.GT.MMAX0)GO TO 97
C     BECAUSE NO VALID MAGNETIC MULTIPOLE.
C
      IF(MBP1MX.LT.2.AND.MMAX0.LT.4.AND.MEKVMX.LT.2)GO TO 97
C     BECAUSE ONLY ORDINARY M1 - USE TRIVIAL DIAGFS CODING -
C     NOTE: MBP1MX=0 SWTCHES-OFF M1 IN DIAGFS AS WELL.
C
C CHECK WORD LENGTHS
C
      ITEST4=IBUFF4
      ITEST4=ITEST4+1
C
      IF(IWORD1.EQ.4.AND.ITEST4.LT.IBUFF4)THEN                !I.E. SP=4
        IPLANT_SOI=INT(IBUFF4/NLEV)
c          write(0,*)ixsoi,iplant_soi,ibuff4,nlev,kind(iplant_soi)
        IF(IXSOI.GT.IPLANT_SOI)THEN         !NEED TO CHECK REALLOCATIONS
          WRITE(0,*)'ALGEB4: I*4/SP TOO SHORT FOR 1-BODY M_K RAD'
          WRITE(6,*)'ALGEB4: CHANGE TO I*8/EP IN MODULE COMMON_COEFF'
          NF=0
          GO TO 999
        ENDIF
      ELSE
        IPLANT_SOI=IBUFF4                                     !I.E. SP=8
      ENDIF
C
      IF(MBP2MX.GT.0.AND.IWORD2.EQ.4.AND.ITEST4.LT.IBUFF4)THEN
        IPLANT_MI=INT(IBUFF4/NLEV)
        IF(IAXMI.GT.IPLANT_MI)THEN          !NEED TO CHECK REALLOCATIONS
          WRITE(0,*)'ALGEB4: I*4/SP TOO SHORT FOR 2-BODY M_K RAD'
          WRITE(6,*)'ALGEB4: CHANGE TO I*8/EP IN MODULE COMMON_DMQSS3'
          NF=0
          GO TO 999
        ENDIF
      ELSE
        IPLANT_MI=IBUFF4                                      !I.E. SP=8
      ENDIF
C
C EX-COMMON/NRBMKP/
C
      ALLOCATE (NMD1(2,NJO,NLEV),NMD2(2,NJO,NLEV),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR  NMD1,NMD2'
        NF=0
        GO TO 999
      ENDIF
      BNRBMKP=.TRUE.
C
C EX-COMMON/COEFFS/
C
C      IXS1C=MAX(MXS1C0,MXS1C,IXS1C)               !USE LARGEST PREVIOUS
      IXS1C=MAX(MXS1C0,MXS1C)                     !RESET, ELSE ALGEB3
C      IXS1I=MAX(MXS1I0,MXS1I,IXS1I)               !USE LARGEST PREVIOUS
      IXS1I=MAX(MXS1I0,MXS1I)                     !RESET, ELSE ALGEB3
C
      ALLOCATE (DRKPS(IXS1C),QRLPS(4,IXS1I),NRKPS(IXS1C)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR  DRKPS,QRLPS,NRKPS'
        NF=0
        GO TO 999
      ENDIF
C
C EX-COMMON /NSTS1/
C
      IXXX1=MAX(IXS1I,IXSOI)
      IXD27=KMAX*KMAX
C
      ALLOCATE (NADS1(0:IXD27),NSTJ1(IXS1C),NSTJ1D(IXS1C)
     X         ,IORIG1(IXXX1),JORIG1(IXS1I),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR NADS1,NSTJ1, ETC'
        NF=0
        GO TO 999
      ENDIF
C
C TWO-BODY
C
      IF(MBP2MX.LT.2)THEN
        IXS2C=0
        IXS2I=0
        IXXX2=0
C        IXD27=0                                   !NEED NADS2 TO FLAG
      ELSE
        IXS2C=MAX(MXS2C0,MXS2C,IXS2C)             !USE LARGEST PREVIOUS
C        IXS2C=MAX(MXS2C0,MXS2C)                   !RESET
        IXS2I=MAX(MXS2I0,MXS2I,IXS2I)             !USE LARGEST PREVIOUS
C        IXS2I=MAX(MXS2I0,MXS2I)                   !RESET
C
        IXXX2=MAX(IXS2I,IAXMI)
      ENDIF
C
C EX-COMMON/DMQSSS/
C
      ALLOCATE (DSSS(IXS2C),MSSS(IXS2C),QSSS(5,IXS2I)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR  DSSS,MSSS,QSSS'
        NF=0
        GO TO 999
      ENDIF
C
C EX-COMMON /NSTS2/
C
      ALLOCATE (NADS2(0:IXD27),NSTJ2(IXS2C),NSTJ2D(IXS2C)
     X         ,IORIG2(IXXX2),JORIG2(IXS2I),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR NADS2,NSTJ2, ETC'
        NF=0
        GO TO 999
      ENDIF
C
C LOCAL (TBD: USE ACTUAL DIMENSIONS FOR MXD23)
C
      IAXDK=0
      IXD22=0
      DO N=1,NJO
        IAXDK=MAX(IAXDK,NT(N))
        IXD22=MAX(IXD22,NGSLJ(N))
      ENDDO
      IXD23=10*IAXDK+1000
C
      ALLOCATE (MMD1(2,IXD22,IAXDK),MMD2(2,IXD22,IAXDK)
     X         ,TMP(IXD23),NTMP(IXD23),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR  MMDX,TMP'
        NF=0
        GO TO 999
      ENDIF
      BLOCAL=.TRUE.
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
C CHECK KCUT (AND VIA OLD QCUT)
C
      DO I=1,10
        QLIT(I)=ICHAR(CQLIT(I))
      ENDDO
C
      BLPT=MPRINT.GT.0
C
      KUT=KCUT
      DO I=1,7
        IF(QLIT(I).EQ.QCUT)THEN
          IF(I.EQ.6)THEN
            KUT=KMAX
            GO TO 20
          ENDIF
          IF(I.LT.6)THEN
            KUT=I-1
            GO TO 20
          ENDIF
          KUT=KUTSS
        ENDIF
      ENDDO
C
      IF(KUT.LT.0)GO TO 98            !NONE, FLAG AND RETURN
      IF(KUT.EQ.0)KUT=KMAX
      IF(KUTM1.NE.0)KUT=ABS(KUTM1)
C
  20  IF(ABS(MBP2MX).GT.0)THEN       !THERE EXISTS 1/2-BODY BP ALG
        WRITE(6,600)KUT,CHAR(QCUT)
      ELSE                            !JUST 1-BODY NON-BP
        WRITE(6,601)
      ENDIF
C
C-----------------------------------------------------------------------
C
C FLAG EXISTENCE, OR NOT, OF ONE- AND TWO-BODY INTERACTIONS BETWEEN
C CONFIGURATION PAIRS
C
C-----------------------------------------------------------------------
C
C LOCAL
      IXD19=(KMAX*(KMAX+1))/2
C
      ALLOCATE (B1B(IXD19),B2B(IXD19),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB4: ALLOCATION FAILS FOR B1B,B2B'
        NF=0
        GO TO 999
      ENDIF
C
C SMALL
      IF(KUTDSK.LT.KMAX)ALLOCATE (KSTART(KMAX,2))
      ALLOCATE (ITMP(NF))
C
      IFOTMX=0
      IF(BFOT)IFOTMX=1
C
      KK=0
      DO KF=1,KMAX                                        !BEGIN KF LOOP
        II=IEQ(QCG(NF,KF))
        KCF=0
        IF(QN(II).GE.90)KCF=1                                 !CONTINUUM
C
        DO KG=1,KF                                        !BEGIN KG LOOP
          KK=KK+1
C
          B1BODY=.FALSE.
          B2BODY=.FALSE.
C
          II=IEQ(QCG(NF,KG))
          KCG=0
          IF(QN(II).GE.90)KCG=1
          IF(KCF+KCG.GT.IFOTMX)GO TO 173               !DOES NOT CONTRIB
C
          BE1CASE=QCP(KF).NE.QCP(KG)
          BMSKIP=KG.GT.KUT.AND.KF.GT.KUT
          BOSKIP=KF.GT.KUT.OR.KG.GT.KUT
          IF(BE1CASE)BOSKIP=BMSKIP
          BQCUT=QCUT.NE.QLIT(8).AND.QCUT.NE.QLIT(9)
     X                         .AND.KUTM1.GE.0         !SO BMSKIP=BOSKIP
C
C FIND NUMBER MK/2 OF ELECTRON PAIRS IN WHICH KF AND KG DIFFER
C AND THEN SEE IF THIS CF PAIR CONTRIBUTES
C
          DO I=1,NF
            ITMP(I)=QCG(I,KG)
          ENDDO
          MK=0
          DO I=1,NF
            ICG=IEQ(QCG(I,KF))
            DO L=1,NF
              IF(IEQ(ITMP(L)).EQ.ICG)THEN
                ITMP(L)=0
                GO TO 151
              ENDIF
            ENDDO
            MK=MK+2
            IF(MK.EQ.2)LD1=QCG(I,KF)
 151      ENDDO
C
          IF(MK.GT.4)GO TO 173                      !THREE PAIRS OR MORE
          IF(MK.EQ.4.AND.(MBP2MX.LE.0.OR.BE1CASE))GO TO 173 !NO TWO-BODY
C
C SEE IF WE NEED TWO-BODY
C
          IF(.NOT.BOSKIP.AND.NF.GT.1.AND..NOT.BE1CASE)B2BODY=.TRUE.  !M1
          IF(.NOT.B2BODY.AND.MK.EQ.4)GO TO 173
C
C SEE IF ONE-BODY EXISTS
C
          IF(MK.EQ.2)THEN
            DO L=1,NF
              IF(ITMP(L).NE.0)THEN
                LD2=QCG(L,KG)
                GO TO 54
              ENDIF
            ENDDO
  54        LDD=ABS(QL(LD1)-QL(LD2))
            IF(LDD.GT.MPOLE)LDD=-1
          ELSEIF(MK.EQ.4)THEN
            LDD=-1
          ELSE
            LDD=1
          ENDIF
          B1BODY=LDD.GE.0
C
C FLAG WHETHER KF-KG NEEDED
C
 173      B1B(KK)=B1BODY
          B2B(KK)=B2BODY
c
c          write(0,*)kf,kg,b1body,b2body
C
        ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
C
C-----------------------------------------------------------------------
C
C   START CALCULATION OF THE ALGEBRA FOR MAGNETIC MULTIPOLES
C   VIZ. 1-BODY ALL MULTIPOLES AND 2-BODY BP CORRECTIONS TO DIPOLE
C
C-----------------------------------------------------------------------
C
      irlp=-irlp             !flag end of structure integrals for mkalg2
c
COLD      NL=NL000
      ja=2
      jap=2
C
      DFS(1)=1
      DFS(2)=1
      DO J=3,MXDFS,2
        DFS(J)=-DFS(J-2)
        DFS(J+1)=(J-1)*DFS(J-1)/32
      ENDDO
C
ct      mc0x=0
      IF(MBP2MX.LE.0.AND.MEKVMX.LE.0)THEN
        NC0X=0
      ELSE                            !SHOULD ONLY BE LOW-L HERE, BUT...
        NC0X=(NXLL+2)*2                         !m1+bp only *3->*2
        IF(NC0X.GT.MXD05)THEN
          NC0X=NC0X/4
C          NC0X=NC0X+1
          WRITE(6,997)MAXLL,NC0X
          NF=-1
          GO TO 999
        ENDIF
        IF(2*(NC0X+2).GT.MXDFS)THEN
          WRITE(6,998)MXDFS,2*(NC0X+2)
          NF=-1
          GO TO 999
        ENDIF
        DO J=1,NC0X
          LL=(J/2)*2
          LM=LL-2
          IF(LL.NE.J)LM=LL+2
          VC1(J)=VCC(LL,ITWO,LM,IZERO,IZERO,IZERO,DFS)
        ENDDO
      ENDIF
C
      MXIRKS=0
      MXIRLS=0
      MXIRSS=0
      MXNLS=0
C
      DO J=1,NLEV                               !INITIALIZE (FOR SAFETY)
        DO K=1,NJO
          NMD1(1,K,J)=0
          NMD1(2,K,J)=-1
          NMD2(1,K,J)=0
          NMD2(2,K,J)=-1
        ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C CHECK BUFFERS FOR DC ARRAY IF DISKDC IN USE
C
C-----------------------------------------------------------------------
C
      MDCBUF4=0
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
      CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
C
        IF(KUTDSK.LT.KFBUFF)THEN
          DO K=1,NSL0
            MTGD1=MTGD+1                                        !RESTORE
            DO KF=KUTDSK+1,KFBUFF
              NGSYM=KGSL(KF,K)                            !POS WITHIN CF
              IF(NGSYM.GT.0)THEN
c
                do kg=1,kmax
                  k1=max(kf,kg)
                  k2=min(kf,kg)
                  kk=(k1*(k1-1))/2+k2
                  if(b1b(kk).or.b2b(kk))go to 81           !need this kf
                enddo
                go to 82
c
  81            ISTRT=MTGD1
C
                CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IZERO,IZERO)
C
                MTGD1=IFIN+1
              ENDIF
  82        ENDDO
            IFIN=MTGD1-1
            MDCBUF4=MAX(MDCBUF4,IFIN)
          ENDDO
          MDCBUF4=MDCBUF4+MDCBUF4-mtgd
          IF(MDCBUF4.GT.MDCBUF)THEN
c
            if(MDCBUF.ne.IAXDC)stop 'algeb4: buffer index error...'
C
            IXXX=MDCBUF4
C
            WRITE(6,*)'*** ALGEB4: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** ALGEB4: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'ALGEB4: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 999
            ENDIF
C
            IF(.NOT.BFAST)THEN
C
              CALL RE_ALLOC(IDC,IONE,MTGD,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'ALGEB4: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 999
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
            MDCBUF=IAXDC
c            WRITE(6,141)MDCBUF4
          ENDIF
c          write(6,*)'ALGEB4: ',mdcbuf4
c          write(76,*)'ALGEB4'
          MDCBUF4=0
        ELSE
          MDCBUF4=MDCBUF
          DO I=1,2
            DO K=KFBUFF+1,KMAX
              KSTART(K,I)=0
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
      if(btime)then
        time1=dzero
        time2=dzero
      endif
C
C START LOOP STRCUTURE
C
      NCJ=0
      DO 1110 K=1,NJO                  !BEGIN UPPER LOOP OVER JP GROUPS
        MJJL=JN(NCJ+1)
C
        NCJ0=0
      DO 1115 NGJ1=1,NGSLJ(K)          !BEGIN UPPER LOOP OVER SLP GROUPS
C
        NC=NSLJ(NGJ1,K)
        MJL1=QLI(NC)
        MJS1=QSI(NC)
        N0=NSL(NC)
C
        IF(KUTDSK.LT.KFBUFF)THEN
          MTGD1=MTGD+1                                          !RESTORE
          DO KF=KUTDSK+1,KFBUFF                  !LOAD INITIAL GROUP VCC
            KSTART(KF,1)=0
            NGSYM=KGSL(KF,NC)                             !POS WITHIN CF
            IF(NGSYM.GT.0)THEN
c
              do kg=1,kmax
                k1=max(kf,kg)
                k2=min(kf,kg)
                kk=(k1*(k1-1))/2+k2
                if(b1b(kk).or.b2b(kk))go to 71             !need this kf
              enddo
              kstart(kf,1)=mtgd1!dummy, else alternate kf read triggered
              go to 72
c
  71          ISTRT=MTGD1
              KSTART(KF,1)=ISTRT
C
              CALL DISKDC(IUD,ISTRT,IFIN,KF,NGSYM,IONE,IZERO)
C
              MTGD1=IFIN+1
              IF(IFIN.LT.0)THEN           !FAILURE TO READ REQUIRED DATA
                NF=-1
                GO TO 999
              ENDIF
            ENDIF
  72      ENDDO
          MHOLD=MTGD1
          IFIN=MTGD1-1
        ENDIF
C
        NCJP=0
      DO KP=1,K                         !BEGIN LOWER LOOP OVER JP GROUPS
C
        IF(NMETGJ(K)+NMETGJ(KP).GT.1)GO TO 2500
c        IF(K.EQ.KP.AND.NT(K).EQ.1)GO TO 2500            !need for lande
C
        MJJR=JN(NCJP+1)
        ND=NSLJ(1,KP)
        BE1CASE=QPI(ND).NE.QPI(NC)
        MMIN=MAX(MMIN0,ABS(MJJR-MJJL))
        MMAX=MIN(MMAX0,MJJR+MJJL)
        IF(BE1CASE)BE1CASE=MMIN.EQ.2.AND.MEKVMX.GT.0
        IF(.NOT.BE1CASE)THEN
          IF(MOD(QPI(ND)+QPI(NC)+MMIN,IFOUR).EQ.0)MMIN=MMIN+2
          IF(MOD(QPI(ND)+QPI(NC)+MMAX,IFOUR).EQ.0)MMAX=MMAX-2
          BODD=(1-MOD(MMIN,IFOUR)).GT.0.OR.(MMAX-MMIN).GT.0
          BEVEN=(1-MOD(MMIN,IFOUR)).LT.0.OR.(MMAX-MMIN).GT.0
        ELSE
          BODD=.TRUE.
          BEVEN=(MMAX-MMIN).GT.0
        ENDIF
        IF(MMIN.GT.MMAX)GO TO 2500
C
        NCJP0=0
        NGJP1X=NGSLJ(KP)
        IF(NGJP1X.GT.IXD22)GO TO 91
        IF(K.EQ.KP)NGJP1X=NGJ1
      DO NGJP1=1,NGJP1X                !BEGIN LOWER LOOP OVER SLP GROUPS
C
        ND=NSLJ(NGJP1,KP)
        MJL2=QLI(ND)
        MJS2=QSI(ND)
        N0P=NSL(ND)
C
        BEQUGRP=K.EQ.KP.and.nc.eq.nd         !nc.eq.nd missing since v18
        if(bequgrp.and.ngj1.ne.ngjp1)stop 'bequgrp.and.ngj1.ne.ngjp1'
        if(k.eq.kp.and.nc.ne.nd.and.ngj1.eq.ngjp1)
     x                             stop '.not.bequgrp.and.ngj1.eq.ngjp1'
c
        if(btime)call cpu_time(timei)
C
        IRKPS=0
        IRLPS=0
        IRSS=0
        NLS=0
C
        NADS1(0)=0
        NADS2(0)=0
C
        KK=0
        K2=KMAX
        DO KF=1,KMAX                                      !BEGIN KF LOOP
C
          IFLG=0
          IF(KGSL(KF,NC).GT.0)IFLG=1            !CF CONTRIBS TO SL GROUP
C
          IF(BEQUGRP)K2=KF
C
          DO KG=1,K2                                      !BEGIN KG LOOP
            KK=KK+1
            IF(IFLG.EQ.0)GO TO 70                            !JUST INDEX
C
            IF(.NOT.BEQUGRP)THEN
              K0=MIN(KF,KG)
              K1=MAX(KF,KG)
              KB=(K1*(K1-1))/2+K0
            ELSE
              KB=KK
            ENDIF
C
            B1BODY=B1B(KB)
            B2BODY=B2B(KB)
            IF(.NOT.B1BODY.AND..NOT.B2BODY)GO TO 70
            IF(QCP(KG).NE.QPI(ND))GO TO 70
            IF(QCP(KF).EQ.QCP(KG).AND..NOT.BEVEN)GO TO 70
            IF(QCP(KF).NE.QCP(KG).AND..NOT.BODD)GO TO 70
            IF(.NOT.B1BODY.AND.MBP2MX.LT.MMIN)GO TO 70   !NO 2-BODY HERE
C
            IF(KGSL(KG,ND).LE.0)GO TO 70    !CF DOES NOT CONTRIB TO S'L'
C
            BMSKIP=KG.GT.KUT.AND.KF.GT.KUT
            BOSKIP=KF.GT.KUT.OR.KG.GT.KUT
            IF(BE1CASE)BOSKIP=BMSKIP
            IF(BQCUT)BMSKIP=BOSKIP
            IF(B1BODY)THEN
              MK=2
              IF(KF.EQ.KG)MK=0
            ELSE
              MK=4
            ENDIF
C
C NOW DETERMINE INTERACTION BETWEEN KF AND KG FOR THESE CSLJP GROUPS
C
            JL1=JYI(KF)
            JL2=JYF(KF)
            JR1=JYI(KG)
            JR2=JYF(KG)
c      write(6,*)"$",k,ngj1,kf,kp,ngjp1,kg
C
            IRKPS0=IRKPS+1
            IRLPS0=IRLPS
            IRSS0=IRSS+1
            NLS00=NLS
C
C BEGIN LOOP OVER MAGNETIC MULTIPOLES MLAM/2:
C                                       MLAM=MPOL0-2,MPOLE-2,4 AS MPOL E
C
            BE1CASE=QPI(ND).NE.QPI(NC).and..not.boskip    !RE-INITIALIZE
            IF(BE1CASE)BE1CASE=MMIN.EQ.2.AND.MEKVMX.GT.0
C
            MLAM=MMIN
 426        MLAMH=MLAM/2
C
            IF(BDEBUG1)THEN
              MP='M'
              IF(BE1CASE)MP='E'
            ENDIF
C
            BM1BODY=BE1CASE.OR.MLAM.GT.MBP2MX     !SO NO 2-BODY BP TO MK
c
C    IF(MBP1MX+MBP2MX.EQ.0.AND.MLAM.EQ.2.AND.IT.NE.ITP.AND..NOT.BE1CASE)
            IF(MLAM.EQ.2)THEN
              IF(BE1CASE)THEN
C ?????
              ELSE
                IF(MBP1MX+MBP2MX.EQ.0.AND.IT.NE.ITP)
     X                                           GO TO 417  !ORDINARY M1
                IF(BMSKIP.AND.KF.NE.KG)GO TO 417
              ENDIF
            ENDIF
c      write(6,*)ngj1,ngjp1,mjjr,mjjl,nc,nd,mmin,mlam,mmax,be1case
C
C FIND A NONVANISHING MULTIPOLE MATRIX ELEMENT
C
            ICLR=1
            K0=0
            MJ1=MJJL
  21        MJ2=MJJR
  22        MLK=MJ1-MJ2
            ML2=-MJ2
C
            DVC=VCC(MJJL,MJJR,MLAM,MJ1,ML2,MLK,DFS)
C
            IF(DVC.NE.DZERO)THEN
              IF(MODD.LE.0)GO TO 24
              IF(MJ1.LE.1.AND.MJ2.LE.1)GO TO 24
              K0=1
            ENDIF
C
            MJ2=MJ2-2
            IF(MJ2.GE.0)GO TO 22
            MJ1=MJ1-2
            IF(MJ1.GE.0)GO TO 21
            IF(MODD*K0.LE.0)GO TO 417
            WRITE(6,800)
            GO TO 98
C
C---- BEGIN TAKE OUT
C
  24        IRKPS0=IRKPS+1
            IRLPS0=IRLPS
            IRSS0=IRSS+1
            NLS00=NLS
C
            MS1=MJS1
C      IF(DEBUG)WRITE(6,400)IRKP,ND1,NDP1,MJJL,MJJR
  30        ML1=MJ1-MS1
            BLX1=MS1.NE.-MJS1.AND.ML1.NE.MJL1
            IF(ML1.LT.-MJL1)GO TO 40
C
            JB=1
            DO I=JL1,JL2
              IF(QBML(I).EQ.ML1.AND.QBMS(I).EQ.MS1)THEN
                JB=JB+1
                MAM(JB)=I
              ENDIF
            ENDDO
C
            IF(JB.LT.JA)GO TO 40
C
            DVCL1=VCC(MJL1,MJS1,MJJL,ML1,MS1,MJ1,DFS)
C
            MS2=MJS2
  32        ML2=MJ2-MS2
            BLX2=MS2.NE.-MJS2.AND.ML2.NE.MJL2
            IF(ML2.LT.-MJL2)GO TO 39
            IF(ABS(MS2-MS1).GT.2)GO TO 39                   !42
C RDD       IF(ABS(ML2-ML1).GT.4)GO TO 39
C
            IF(MK.EQ.0.AND.ML2.EQ.ML1.AND.MS2.EQ.MS1)THEN
              JBP=JB
              DO I=JAP,JBP
                NAM(I)=MAM(I)
              ENDDO
            ELSE
              JBP=1
              DO I=JR1,JR2
                IF(QBML(I).EQ.ML2.AND.QBMS(I).EQ.MS2)THEN
                  JBP=JBP+1
                  NAM(JBP)=I
                ENDIF
              ENDDO
              IF(JBP.LT.JAP)GO TO 39
            ENDIF
C
            DD2=VCC(MJL2,MJS2,MJJR,ML2,MS2,MJ2,DFS)
C
            DVC12=DVCL1*DD2
            IF(DVC12.EQ.DZERO)GO TO 39
C
            IF(BDEBUG1)WRITE(6,701)MK,MS1,ML1,MS2,ML2,IRKP,DVC,DVCL1,DD2
     X                           ,JAP,JBP,MP,MLAMH
C
C DETERMINE SLATER STATE INTERACTION
C
  42        CALL MKALG1(QLMC,MAXEL,DFS,MAM,NAM)
C
            MXIRKS=MAX(MXIRKS,IRKPS)
            MXIRLS=MAX(MXIRLS,IRLPS)
            MXIRSS=MAX(MXIRSS,IRSS)
            MXNLS=MAX(MXNLS,NLS)
C
            IF(NF.EQ.0)GO TO 99                      !DIMENSION EXCEEDED
            IF(NF.LT.0)GO TO 999                     !INDEX ERROR
C
C IF .T. COMPUTE FOR DIFFERENT (MS,ML) GIVING THE SAME MS+ML=MJ
C
  39        MS2=MS2-2
            IF(BLX2)GO TO 32
C
  40        MS1=MS1-2
            IF(BLX1)GO TO 30
C
            ICLR=-ICLR
            IF(ICLR.NE.0)GO TO 42
C
C----   END TAKE OUT
C
  417       MLAM=MLAM+4
            IF(BE1CASE)THEN
              MLAM=MLAM-2
              BE1CASE=.FALSE.
            ENDIF
            IF(MLAM.LE.MMAX)GO TO 426
C
  70        NADS1(KK)=IRKPS
            NADS2(KK)=IRSS
c          write(6,*)kk,irkps,irss
C
          ENDDO                                           !END LOOP KG
C
        ENDDO                                             !END LOOP KF
C
      if(btime)then
        call cpu_time(timef)
        time1=time1+timef-timei
      endif
C
C NOW DETERMINE THE INTERACTION BETWEEN JP LEVELS OF THE CLSP GROUPS
C
      BE1CASE=QPI(ND).NE.QPI(NC)     !.and..not.boskip    !RE-INITIALIZE
      BM1BODY=BE1CASE.OR.MMIN.GT.MBP2MX           !SO NO 2-BODY BP TO MK
C
      IF(KUTDSK.LT.KFBUFF)THEN
        MTGD1=MHOLD                                             !RESTORE
        DO KG=KUTDSK+1,KFBUFF                      !LOAD FINAL GROUP VCC
          IF(NC.EQ.ND)THEN
            KSTART(KG,2)=KSTART(KG,1)
          ELSE
            KSTART(KG,2)=0
            LGSYM=KGSL(KG,ND)                             !POS WITHIN CF
            IF(LGSYM.GT.0)THEN
c
              k1=1
              if(bequgrp)k1=kg
              do kf=k1,kmax
                if(bequgrp)then
                  kk=(kf*(kf-1))/2 + kg
                else
                  kk=kmax*(kf-1)+kg
                endif
                b1body=nads1(kk).gt.nads1(kk-1)
                b2body=nads2(kk).gt.nads2(kk-1)
                if(b1body.or.b2body)go to 73               !need this kg
              enddo
              go to 74
c
  73          ISTRT=MTGD1
              KSTART(KG,2)=ISTRT
C
              CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
              MTGD1=IFIN+1
              IF(IFIN.LT.0)THEN           !FAILURE TO READ REQUIRED DATA
                NF=-1
                GO TO 999
              ENDIF
            ENDIF
          ENDIF
  74    ENDDO
        IFIN=MTGD1-1
        MDCBUF4=MAX(MDCBUF4,IFIN)
      ENDIF
c
      if(btime)call cpu_time(timei)
C
      istrt0=0
      KF0=0
      DO NJ11=1,N0                         !BEGIN UPPER LOOP OVER LEVELS
C
        NJ1=NCJ0+NJ11
        ND1=NJ1+NCJ
        MMD2(1,NGJP1,NJ11)=IRS+1
        MMD1(1,NGJP1,NJ11)=IRKP+1
C
        IT=NRR(ND1)
        KF=NFK(IT)
C
        IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
          ISTRT=0
          ISTRT=KSTART(KF,1)
          IF(ISTRT.EQ.0)THEN                             !BUFFERED BY CF
            NGSYM=KGSL(KF,NC)                             !POS WITHIN CF
            ISTRT=MTGD1
C
            CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
            IF(IEND.LT.0)THEN             !FAILURE TO READ REQUIRED DATA
              NF=-1
              GO TO 999
            ENDIF
          ENDIF
          ISTRT0=ISTRT-MTGD-1                       !I.E. ORIGINAL MTGD1
          KF0=KF
        ENDIF
C
        II=NFI(IT)
        IF(BFAST)THEN
          ND2=JTGD(II)+ISTRT0              !relative start flagged
        ELSE
          do j=jyi(kf),jyf(kf)
            mam(j)=0
          enddo
          k2=jtgd(ii)                      !absolute end flagged
          if(k2.lt.0)then                  !bdisk first
            k2=-k2
            k1=mtgd
          else
            k1=jtgd(ii-1)                  !start
            k1=abs(k1)                    !case bdisk second
          endif
          k1=k1+1+istrt0
          k2=k2+istrt0
          do k12=k1,k2
            j=idc(k12)
            mam(j)=k12
          enddo
        ENDIF
C
        NJP11X=N0P
        IF(K.EQ.KP.AND.NGJP1.EQ.NGJ1)NJP11X=NJ11
C
        istrt=0
        KG0=0
        DO NJP11=1,NJP11X                !BEGIN LOWER LOOP OVER LEVELS
C
          NJP1=NCJP0+NJP11
          NDP1=NJP1+NCJP
c          write(6,*)'nd1=',nd1,'ndp1=',ndp1
C
          ITP=NRR(NDP1)
          KG=NFK(ITP)
c
c          BMSKIP=KF.GT.KUT.OR.KG.GT.KUT   !.and.mlam.eq.2 !mlam not set
c          IF(ITP.NE.IT.AND.BMSKIP)GO TO 25      !Use test before mkalg1
C
C CALCULATE THE ALGEBRAIC CONTRIBUTION TO THE MATRIX ELEMENT.
C
          IF(BEQUGRP)THEN                !KG.LE.KF HERE
            KK=(KF*(KF-1))/2 + KG
c            if(kf.lt.kg)stop 'algeb4: kf.lt.kg'
          ELSE
            KK=KMAX*(KF-1)+KG
          ENDIF
C
          B1BODY=NADS1(KK).GT.NADS1(KK-1)
          B2BODY=NADS2(KK).GT.NADS2(KK-1)
C
          IF(B1BODY.OR.B2BODY)THEN
C
            IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
              ISTRT=KSTART(KG,2)
              IF(ISTRT.EQ.0)THEN                         !BUFFERED BY CF
                LGSYM=KGSL(KG,ND)                         !POS WITHIN CF
                ISTRT=IEND+1
C
                CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                IF(IFIN.LT.0)THEN         !FAILURE TO READ REQUIRED DATA
                  NF=-1
                  GO TO 999
                ENDIF
              ENDIF
              ISTRT=ISTRT-MTGD-1                    !I.E. ORIGINAL MTGD1
              KG0=KG
            ENDIF
C
            LL=NFI(ITP)
            IF(BFAST)THEN
              NDP2=JTGD(LL)+ISTRT          !relative start flagged
            ELSE
              do j=jyi(kg),jyf(kg)
                nam(j)=0
              enddo
              k2=jtgd(ll)                  !absolute end flagged
              if(k2.lt.0)then              !bdisk first
                k2=-k2
                k1=mtgd
              else
                k1=jtgd(ll-1)              !start
                k1=abs(k1)                !case bdisk second
              endif
              k1=k1+1+istrt
              k2=k2+istrt
              do k12=k1,k2
                j=idc(k12)
                nam(j)=k12
              enddo
            ENDIF
C
            IRKP0=IRKP+1
            IRS0=IRS+1
C
            CALL MKALG2(mam,nam,KK)
C
            IF(NF.EQ.0)GO TO 99                      !DIMENSION EXCEEDED
            IF(NF.LT.0)GO TO 999                     !NOT USED CURRENTLY
C
          ENDIF
C
        ENDDO                     !25        !END LOWER LOOP OVER LEVELS
C
        MMD2(2,NGJP1,NJ11)=IRS
        MMD1(2,NGJP1,NJ11)=IRKP
C
c
c      write(6,*)k,kp,ngjp1,nj11,nd1,mmd2(1,ngjp1,nj11)
c     x,mmd2(2,ngjp1,nj11)
c       do m=mmd1(1,ngjp1,nj11),mmd1(2,ngjp1,nj11)
c         n1=nrkp(m)/mxsoi
c         n2=nrkp(m)-n1*mxsoi
c         write(6,*)m,n1+1,(qrlp(n3,n2),n3=1,4)
c       enddo
C
      ENDDO                                  !END UPPER LOOP OVER LEVELS
c
      if(btime)then
        call cpu_time(timef)
        time2=time2+timef-timei
      endif
C
        NCJP0=NCJP0+N0P
      ENDDO                              !END LOWER LOOP OVER SLP GROUPS
C
C
C SHUFFLE COEFFS SO ALL LOWER LEVELS (WITHIN JP) ARE SEQUENTIAL FOR A
C GIVEN UPPER LEVEL. (CURRENTLY, ONLY TRUE FOR LOWER LEVELS WITHIN SLP.)
C
c      write(6,*)'begin shuffle'
c
      DO NJ11=1,N0            !BEGIN LOOP OVER UPPER LEVELS OF SLP GROUP
C
        NJ1=NCJ0+NJ11
        ND1=NJ1+NCJ
        IF(NJ11.EQ.N0)GO TO 114
C
        DO NGJP1=2,NGJP1X              !BEGIN LOOP OVER LOWER SLP GROUPS
C
C 1-BODY
C
          M1=MMD1(1,NGJP1,NJ11)
          M2=MMD1(2,NGJP1,NJ11)
          MX=M2-M1+1
          IF(MX.GT.IXD23)GO TO 96
C
          L1=MMD1(2,NGJP1-1,NJ11)+1
          L2=L1+MX-1
          IF(MX.EQ.0)GO TO 112
C
          N1=MMD1(1,1,NJ11+1)
          N2=MMD1(2,NGJP1-1,N0)
c
c        write(6,*)'shuffle',nj11,ngjp1-1,m1,m2,n1,n2
C
          IF(N1.LE.N2)THEN
            MM=0
            DO M=M1,M2
              MM=MM+1
              NTMP(MM)=NRKP(M)
              TMP(MM)=DRKP(M)
            ENDDO
            DO N=N2,N1,-1
              NN=MX+N
              NRKP(NN)=NRKP(N)
              DRKP(NN)=DRKP(N)
            ENDDO
            MM=0
            DO L=L1,L2
              MM=MM+1
              NRKP(L)=NTMP(MM)
              DRKP(L)=TMP(MM)
            ENDDO
          ENDIF
C
          DO N=NJ11+1,N0
            DO I=1,NGJP1-1
              MMD1(1,I,N)=MMD1(1,I,N)+MX
              MMD1(2,I,N)=MMD1(2,I,N)+MX
            ENDDO
          ENDDO
C
  112     MMD1(1,NGJP1,NJ11)=L1
          MMD1(2,NGJP1,NJ11)=L2
C
C NOW 2-BODY
C
          IF(.NOT.BM1BODY)THEN
            M1=MMD2(1,NGJP1,NJ11)
            M2=MMD2(2,NGJP1,NJ11)
            MX=M2-M1+1
            IF(MX.GT.IXD23)GO TO 96
C
            L1=MMD2(2,NGJP1-1,NJ11)+1
            L2=L1+MX-1
            IF(MX.EQ.0)GO TO 113
C
            N1=MMD2(1,1,NJ11+1)
            N2=MMD2(2,NGJP1-1,N0)
C
            IF(N1.LE.N2)THEN
              MM=0
              DO M=M1,M2
                MM=MM+1
                NTMP(MM)=MSS(M)
                TMP(MM)=DSS(M)
              ENDDO
              DO N=N2,N1,-1
                NN=MX+N
                MSS(NN)=MSS(N)
                DSS(NN)=DSS(N)
              ENDDO
              MM=0
              DO L=L1,L2
                MM=MM+1
                MSS(L)=NTMP(MM)
                DSS(L)=TMP(MM)
              ENDDO
            ENDIF
C
            DO N=NJ11+1,N0
              DO I=1,NGJP1-1
                MMD2(1,I,N)=MMD2(1,I,N)+MX
                MMD2(2,I,N)=MMD2(2,I,N)+MX
              ENDDO
            ENDDO
  113       MMD2(1,NGJP1,NJ11)=L1
            MMD2(2,NGJP1,NJ11)=L2
          ENDIF
C
        ENDDO                            !END LOOP OVER LOWER SLP GROUPS
C
C NOW SET GLOBAL INDEX FOR DIAGFS
C
  114   DO N=1,NGJP1X
          N1=MMD1(1,N,NJ11)
          N2=MMD1(2,N,NJ11)
          IF(N1.LE.N2)GO TO 116
        ENDDO
        M2=N2
        GO TO 117
  116   DO M=NGJP1X,N,-1
          M1=MMD1(1,M,NJ11)
          M2=MMD1(2,M,NJ11)
          IF(M1.LE.M2)GO TO 117
        ENDDO
  117   NMD1(1,KP,ND1)=N1
        NMD1(2,KP,ND1)=M2
c
c        do n=1,ngjp1x
c          write(6,*)mmd1(1,n,nj11),mmd1(2,n,nj11)
c        enddo
c        write(6,*)"*",n1,m2
c
        IF(.NOT.BM1BODY)THEN
          DO N=1,NGJP1X
            N1=MMD2(1,N,NJ11)
            N2=MMD2(2,N,NJ11)
            IF(N1.LE.N2)GO TO 118
          ENDDO
          M2=N2
          GO TO 119
  118     DO M=NGJP1X,N,-1
            M1=MMD2(1,M,NJ11)
            M2=MMD2(2,M,NJ11)
            IF(M1.LE.M2)GO TO 119
          ENDDO
  119     NMD2(1,KP,ND1)=N1
          NMD2(2,KP,ND1)=M2
c        write(6,*)"**",n1,m2
        ENDIF
c
c      write(6,*)k,kp,ngjp1,nj11,nd1,nmd2(1,kp,nd1),nmd2(2,kp,nd1)
c       do m=nmd1(1,kp,nd1),nmd1(2,kp,nd1)
c         n1=nrkp(m)/mxsoi
c         n2=nrkp(m)-n1*mxsoi
c         write(6,3377)m,n1+1,(qrlp(n3,n2),n3=1,4),drkp(m)
c 3377  format(2i3,4i2,f10.5)
c       enddo
c
      ENDDO            !END LOOP OVER UPPER LEVELS OF SLP GROUP
C
c      write(6,*)'end shuffle'
C
 2500 NCJP=NCJP+NT(KP)
      ENDDO                               !END LOWER LOOP OVER JP GROUPS
C
      NCJ0=NCJ0+N0
 1115 ENDDO                              !END UPPER LOOP OVER SLP GROUPS
C
      NCJ=NCJ+NT(K)
 1110 ENDDO                               !END UPPER LOOP OVER JP GROUPS
C
C
      CALL DIMUSE('MXSOC',IRKP)
      CALL DIMUSE('MXSOI',IRLP)
      CALL DIMUSE('MXRSS',IRS)
      CALL DIMUSE('MAXMI',NL)
      CALL DIMUSE('MXS1C',MXIRKS)
      CALL DIMUSE('MXS1I',MXIRLS)
      CALL DIMUSE('MXS2C',MXIRSS)
      CALL DIMUSE('MXS2I',MXNLS)
      IF(MDCBUF4.GT.0)CALL DIMUSE('MAXDC',MDCBUF4)
C
c      IRLP0=IRLP                        !not used further
      IF(.NOT.BLPT)WRITE(6,704)IRKP,ND1,NDP1,MG,MG,IRLP,ND1,NDP1,IRS,NL
      IF(BLPT.AND.NL.GT.NL000)WRITE(6,300)
     X                                (L,(QSS(I,L),I=1,5),L=NL000+1,NL)
      WRITE(6,122)IXS1C,IXS1I,MXIRKS,MXIRLS
      IF(IRSS.GE.IRSS0)WRITE(6,123)IXS2C,IXS2I,MXIRSS,MXNLS
      WRITE(6,1190)MDCBUF4,MAXDC
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for algeb4:'                 !par
cpar          write(iwp,*)'    mkalg1 time=',nint(time1),'sec'      !par
cpar          write(iwp,*)'    mkalg2 time=',nint(time2),'sec'      !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'mkalg1 time=',nint(time1),'sec'
          write(iw,*)'mkalg2 time=',nint(time2),'sec'
c          call flush(iw)
cpar        endif                                                   !par
      endif
C
  999 CONTINUE
c
      irlp=abs(irlp)  !case no mk, remove flag from structure integrals
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MXSOI)/5
      IF(irlp000.ne.ixsoi.and.BCOEFF.AND.IRLP.LT.IXXX)THEN
C
c      WRITE(6,*)'*** ALGEB4: decreasing MXSOI from ',IXSOI,' to: ',IRLP
c      WRITE(0,*)'*** ALGEB4: decreasing MXSOI from ',IXSOI,' to: ',IRLP
C
       CALL RE_ALLOC2(QRLP,IONE,IFOUR,IONE,IXSOI,IFOUR,IRLP,IERR)
C
        IXSOI=IRLP
C
      ENDIF
C
      IXXX=(4*MXSOC)/5
      IF(irkp000.ne.ixsoc.and.BCOEFF.AND.IRKP.LT.IXXX)THEN
C
c      WRITE(6,*)'*** ALGEB4: decreasing MXSOC from ',IXSOC,' to: ',IRKP
c      WRITE(0,*)'*** ALGEB4: decreasing MXSOC from ',IXSOC,' to: ',IRKP
C
        CALL RE_ALLOC(DRKP,IONE,IXSOC,IRKP,IERR)
C
        CALL RE_ALLOC(NRKP,IONE,IXSOC,IRKP,IERR)
C
        IXSOC=IRKP
C
      ENDIF
C
      IXXX=(4*MAXMI)/5
      IF(nl000.ne.iaxmi.and.BDMQSS3.AND.NL.LT.IXXX)THEN
C
c        WRITE(6,*)'*** ALGEB4: decreasing MAXMI from ',IAXMI,' to: ',NL
c        WRITE(0,*)'*** ALGEB4: decreasing MAXMI from ',IAXMI,' to: ',NL
C
        CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,NL,IERR)
C
        IAXMI=NL
C
      ENDIF
C
      IXXX=(4*MXRSS)/5
      IF(irs000.ne.ixrss.and.BDMQSS3.AND.IRS.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGEB4: decreasing MXRSS from ',IXRSS,' to: ',IRS
c       WRITE(0,*)'*** ALGEB4: decreasing MXRSS from ',IXRSS,' to: ',IRS
C
        CALL RE_ALLOC(DSS,IONE,IXRSS,IRS,IERR)
C
        CALL RE_ALLOC(MSS,IONE,IXRSS,IRS,IERR)
C
        IXRSS=IRS
C
      ENDIF
C
C LOCAL
      IF(ALLOCATED(B1B))THEN
        DEALLOCATE (B1B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR B1B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(B2B))THEN
        DEALLOCATE (B2B,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR B2B'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(KSTART))DEALLOCATE (KSTART)
      IF(ALLOCATED(ITMP))DEALLOCATE (ITMP)
C
C EX-COMMON /NSTS2/
      IF(ALLOCATED(NADS2))THEN
        DEALLOCATE (NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR NADS2,NSTJ2...'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON /NSTS1/
      IF(ALLOCATED(NADS1))THEN
        DEALLOCATE (NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR NADS1,NSTJ1...'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/DMQSSS/
      IF(ALLOCATED(DSSS))THEN
        DEALLOCATE (DSSS,MSSS,QSSS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR DSSS,MSSS,QSSS'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/COEFFS/
      IF(ALLOCATED(DRKPS))THEN
        DEALLOCATE (DRKPS,QRLPS,NRKPS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR  DRKPS,QRLPS..'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BLOCAL)THEN
        DEALLOCATE (MMD1,MMD2,TMP,NTMP,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGEB4: DE-ALLOCATION FAILS FOR MMDX,TMP'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
c      write(0,*)'mc0x,nc0x=',mc0x,nc0x
      RETURN
C
C     E R R O R   M E S S A G E S
C
  91  WRITE(6,991)MAXSL,NGJP1X*2
      GO TO 99
  96  WRITE(6,996)IXD23,MX
C
  99  WRITE(6,990)
      WRITE(6,704)IRKP,ND1,NDP1,MG,MG,IRLP,ND1,NDP1,IRS,NL
C
      WRITE(0,*)'***SR.ALGEB4: STORAGE EXCEEDED ***'
      NF=-1
C
  97  CONTINUE
C
C EX-COMMON/NRBMKP/
      ALLOCATE (NMD1(1,1,1),NMD2(1,1,1),STAT=IERR)
      BNRBMKP=.TRUE.
C
   98 NMD2(1,1,1)=-1
      NMD1(1,1,1)=-1
C
      GO TO 999
C
  122 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXS1C,MXS1I)',I9,I6,
     X10X,'USED:',I9,I6)
  123 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXS2C,MXS2I)',I9,I6,
     X10X,'USED:',I9,I6)
  141 FORMAT(/'*** SR.ALGEB4: MAY NEED TO INCREASE MAXDC TO AT LEAST: ',
     XI10,' FOR',' M_K-BUFFER, WILL PLOUGH ON REGARDLESS...')
  990 FORMAT(' ***SR.ALGEB4: STORAGE EXCEEDED - INCREASE DIMENSION',
     X' INDICATED OR REDUCE/SWITCH-OFF MK OR BP RADIATIVE CORRECTIONS.')
  991 FORMAT(/' SR.ALGEB4:   INCREASE MAXSL FROM',I5,' TO',I5)
  996 FORMAT(/' SR.ALGEB4:   INCREASE MXD23 FROM',I6,' TO',I6)
  997 FORMAT(/' SR.ALGEB4:   INCREASE MAXLL FROM',I5,' TO',I5)
  998 FORMAT(/' SR.ALGEB4:   INCREASE MXDFS FROM',I5,' TO',I5)
  300 FORMAT(/' REFERENCE TABLE FOR RADIATIVE MAGNETIC TWO-BODY TERMS'/
     X (I14,4I3,I5))
C 400 FORMAT(57X,2I6,I9,I6,3(I7,F9.4)/(84X,3(I7,F9.4)))
  600 FORMAT(/'       CN    LV   LVP,    B   D,  IND',6X,'1-BODY',4X
     X,'REL.RAD.ALGEBRA',8X
     X,'2-BODY FOR M1: CONFIGURATIONS INCLUDED UP TO  CF ='
     X,I3,'(',A1,')')
  601 FORMAT(/' MAGNETIC MULTIPOLE ALGEBRA'/
     X'       CN    LV   LVP,    B   D,  IND',3X,
     X'<J||TK||JP> = <J,MJ|TK|JP,MJP> / C(J,JP,K;MJ,MJP)'
     X,7X,'2MJ',1X,'2MJP',2X,'K')
  701 FORMAT(I9,3I6,I4,I6, F13.5,2F19.5, 6X,2I4, 3X,A1,I1,I4)
  704 FORMAT(I9,3I6,I4,I6,31X,2I6,I9,I6)
  800 FORMAT(49X,'NOT ENOUGH SLATER STATES STORED; CHANGE MODE TO'
     X,' -1 IF RADIATIVE DATA REQUIRED')
 1190 FORMAT(/86X,I10,'=MTGD, MAXDC=',I10
     X      ,' BUFFER STORAGE USED')
C
      END SUBROUTINE ALGEB4
C
C                             *******************
C
      SUBROUTINE ALGX
C
C-----------------------------------------------------------------------
C
C  SR.ALGX CALCULATES EIE COLLISION ALGEBRA.
C
C  IT CALLS:
C    SR.ALGX0
C    SR.ALGXLS
C    SR.ALGXFS
C    SR.CALGX
C    SR.CASYM
C    SR.DISKDC
C    SR.SYMLS
C    SR.SYMLSJ
C
C  IT CONTAINS:
C    FN.MVC
C
cparc  and in parallel:                                             !par
cparc    sr.pcasym                                                  !par
cparc    sr.psymls                                                  !par
cparc    sr.psymj                                                   !par
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,nproc,                     !par
cpar     x                           comm_barrier,comm_finalize     !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC,LREC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBBBB, ONLY: BNRBBBB,BXIST0,BXIST1
      USE COMMON_NRBFL0, ONLY: BNRBFL0,KINTI,KINTF,KEN2,KPTCFM
     X                        ,MPOINT
      USE COMMON_NRBGCF, ONLY: BNRBGCF,KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADD,IADJ
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C      PARAMETER (MXD14=100)
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      INTEGER(EP) MDCF8,MDCFT8
C
      CHARACTER(LEN=4) MLIT
C
      ALLOCATABLE :: MAM(:),NAM(:)
     X              ,QBMS(:),QBML(:),QLMC(:)
     X              ,KACT(:,:),KTMP(:)
C
      ALLOCATABLE :: JYI(:),JYF(:)
C
      DIMENSION DFS(MXDFS)
C
      COMMON /BASIC/NF,KX,KG,K1,K2,MGAP(7)
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL0/IRET0,LORIG,LMIN,MPRNT0,MOD0,MSTRT0,BPASS,MLIT(2)
C     COMMON /NRBAL1/MSTAT(MAXCF),MXORB0,NPRINT,MR0,MA00,MB00,KSUBCF
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDUM/MXDC0,MXGR0         !NOT USED ANYWHERE, BUT RESTART
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW3/LSPIB(MAXSL)   !TBD: COMBINE WITH /NRBDW/ IN MODULE
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBJP/JPIP(MAXJG),NASTJP,MINJTP,MAXJTP
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
c
      common /nrbone/ione1,ione0
C
c      MVC(M1,M2)=((M1+2)*M1/2+M2)/2+1 !SEE INTRNL FUNCTN ABVE END ALGX
C
C-----------------------------------------------------------------------
C
      WRITE(6,5000)
C                                              !HISTORIC
      MXMTGD=3*2**26                           !MAX REC LEN FOR DC ARRAY
      MXMTGD=MXMTGD*(8/LREC)
C
C RE-POINT RESTART FILE
C
      MR=10                                           !NO REDEF. ALLOWED
      REWIND(MR)
C
      BMNAM=.FALSE.
      BQXXX=.FALSE.
      BALLDC=.FALSE.
C
      IF(NSL0.LT.0)THEN          !CA, NO RESTART, JUST RECOVER PASS FILE
        READ(MR)MXORB,MA0,MB0
        BDISK=.FALSE.
c        MXORB=MXORB0
c        MA0=MA00
c        MB0=MB00
        INAST=INAST0                                    !AS BYPASS ALGX0
        DO I=1,INAST
          LSPI(I)=LSPIB(I)         !REPOPULATE WITH SCATTERING SYMMTRIES
        ENDDO
        MINLT=MINLTB
        MAXLT=MAXLTB
        GO TO 300
      ENDIF
C
C-----------------------------------------------------------------------
C RECOVER TARGET HEADER INFO FROM ALGEB1
C-----------------------------------------------------------------------
C                                                                  !REC1
      READ(MR)
     X MLIT,MXORB,NW,NF,MODD,KCUTX,KUTDSK,QQKUTX,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRINT,MA0,MB0
C
      BDISK=KUTDSK.LT.KMAX                                   !USE DISKDC
      IF(BDISK)THEN
        IF(MDCBUF.LT.0)THEN
          MDCBUF=-MDCBUF
          MXTGDI=1
        ELSE
          MXTGDI=MDCBUF
        ENDIF
        MXTGD=MDCBUF
      ELSE
        MXTGD=MTGD
        MXTGDI=MTGDI
      ENDIF
C
      NMTGD=MTGD/MXMTGD
      IF(NMTGD.GT.0)THEN
        WRITE(0,*)'DC ARRAY TOO LARGE...'
        WRITE(6,1010)
        GO TO 995
      ENDIF
C
      NESS=MAXEL*NSS
C
      ALLOCATE (DC(0:MXTGD),IDC(MXTGDI),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX: ALLOCATION FAILS FOR DC,IDC'
        GO TO 999
      ENDIF
      BALLDC=.TRUE.
C
      ALLOCATE (QBMS(NSS),QBML(NSS),QLMC(NESS),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX: ALLOCATION FAILS FOR    QXXX'
        GO TO 999
      ENDIF
      BQXXX=.TRUE.
C
      ALLOCATE (MAM(NSS),NAM(NSS),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX: ALLOCATION FAILS FOR MAM,NAM'
        GO TO 999
      ENDIF
      BMNAM=.TRUE.
C
      ALLOCATE (JYI(KMAX),JYF(KMAX))
C
C-----------------------------------------------------------------------
C RECOVER TARGET INFO
C-----------------------------------------------------------------------
C
      CALL ALGX0(QLMC,QBML,QBMS,JYI,JYF)
c                                                      !just conceivable
      if(bdisk.and.dc(0).gt.dzero.and.mxtgdi.ne.mdcbuf)
     x stop 'algx buffer flag error as exactly one VCC in memory mtgd=1'
C
      IF(NF.LE.0.OR.NZION.EQ.0)GO TO 990                        !BAILOUT
C
C-----------------------------------------------------------------------
C (RE-)INITIALIZE
C-----------------------------------------------------------------------
C
 300  CONTINUE                                        !CA RE-ENTRY POINT
C
      IF(KUTOOX.EQ.-999)KUTOOX=-1                              !OR KUTOO
      IF(KUTOOX.EQ.-1)KUTOOX=0                                    !ALIGN
      BKUTOO=KUTOOX.NE.0
      BDLBD=ABS(MODD).LT.2.OR.BKUTOO
C
C-----------------------------------------------------------------------
C COMPUTE CLEBSCH-GORDAN VCC TABLES VCA & VCB
C FOR PRACTICAL PURPOSES, WE GO AS FAR AS DIMENSIONS ALLOW.
C-----------------------------------------------------------------------
C
      NXLL=-1
      DO K=1,MXORB
        IF(DEY(K).NE.DZERO.AND.QL(K).GT.NXLL)NXLL=QL(K)
      ENDDO
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      MXLL=-1
      BSKP=IDW.LT.0.OR.NSL0.LT.0  !NOT USED BY CA (6J-SYMBOL DOOMINATES)
      IF(.NOT.BSKP)THEN
        BVC=.FALSE.
        IF(.NOT.BVC)MXLL=2*MAXLL
C
        M1=0
  46    M2=0
C
  45    MK=ABS(M1-M2)
C
  44    MKT=MK+2
        DVC0=VCC(M1,M2,MK,IZERO,IZERO,IZERO,DFS)
        ML1=-M1
C
  42    MB1=MVC(M1,ML1)
        ML2=-M2
C
  43    MB2=MVC(M2,ML2)
        DA=DZERO
        DD=DZERO
        MLK=ML1+ML2
        IF(ABS(MLK).LE.MKT)THEN
          IF(BDLBD)DD=VCC(M1,M2,MKT,ML1,ML2,MLK,DFS)*DVC0
          IF(ABS(MLK).LE.MK)
     X    DA=(VCC(M1,M2,MK, ML1,ML2,MLK,DFS)/(MK+1))*DVC0
        ENDIF
        MLK=MK/4+1
        VCA(MB1,MB2,MLK)=DA
        VCB(MB1,MB2,MLK)=DD
C
        ML2=ML2+2
        IF(ML2.LE.M2)GO TO 43
C
        ML1=ML1+2
        IF(ML1.LE.M1)GO TO 42
C
        MK=MK+4
        IF(MK.LE.M1+M2)GO TO 44
C
        M2=M2+2
        IF(M2.LE.MXLL)GO TO 45
C
        M1=M1+2
        IF(M1.LE.MXLL)GO TO 46
      ENDIF
C
C-----------------------------------------------------------------------
C COMPARE CONFIGURATION PAIRS:
C IF DIFFER IN MORE THAN ONE ELECTRON PAIR SET
C  BXIST0=.FALSE. (LS/J)
C  KACT=-1 (CA)
C ELSE SET
C  BXIST0=.TRUE. (LS/J)
C  KACT=THE DIFFERING PAIR, OR ZERO IF NONE (CA)
C
C-----------------------------------------------------------------------
C
      BNOTK=NSL0.GE.0                                  !ACTUALLY, NOT CA
C
C EX-COMMON /NRBBBB/
      BNRBBBB=.FALSE.
      IF(BNOTK)THEN
        ALLOCATE (BXIST0(KMAX,KMAX),BXIST1(KMAX),KTMP(NF),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: ALLOCATION FAILS FOR BXIST0,BXIST1'
          GO TO 999
        ENDIF
      ELSE
        MXCF=KMAX
        ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: ALLOCATION FAILS FOR KACT,KTMP'
          GO TO 999
        ENDIF
      ENDIF
      BNRBBBB=.TRUE.
C
      DO KF=1,KMAX
        DO KG=1,KF
          IF(BNOTK)THEN
            BXIST0(KF,KG)=.TRUE.
            BXIST0(KG,KF)=.TRUE.
          ELSE
            KACT(KF,KG)=0
            KACT(KG,KF)=0
          ENDIF
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)THEN
              IF(BNOTK)THEN
                BXIST0(KF,KG)=.FALSE.
                BXIST0(KG,KF)=.FALSE.
              ELSE
                KACT(KF,KG)=-1
                KACT(KG,KF)=-1
              ENDIF
              GO TO 52
            ENDIF
            IF(.NOT.BNOTK)THEN
              KACT(KF,KG)=QCG(I,KF)
              KACT(KG,KF)=KTMP(L0)
            ENDIF
  51      ENDDO
  52    ENDDO
      ENDDO
C               FLAG NF+1 AS CONT.
      NF1=NF+1
      M1=MXORB+1
      DO K=1,KMAX
        QCG(NF1,K)=M1
      ENDDO
C
C-----------------------------------------------------------------------
C DETERMINE CONTINUUM EXPANSION (CA/LS)
C-----------------------------------------------------------------------
C
      IF(NSL0.LT.0)THEN                                          !FOR CA
        QCL0=2*NXLL                                       !4*(MAX ORB L)
        QCL0=MIN(INT(QCL0,SP),NXLL+IFOUR)                  !CASE LARGE-L
        WRITE(6,1000)
      ENDIF
C
      IF(LCONDW.LE.0)THEN
        i1=0
        LCONDW=(QCL0+2)/2            !MAX NO OF CONT-L THAT CAN FORM SLP
      ELSE
        i1=mod(lcondw+1,itwo)
        LCONDW=(LCONDW-1)/2
        IC=QCL0/2
        if(lcondw.lt.ic)then
          WRITE(6,1005)LCONDW,IC
        elseif(lcondw.gt.ic)then
          IF(NSL0.GT.0)LCONDW=IC                  !AS STRICTLY FORBIDDEN
          IF(NSL0.LT.0)LCONDW=MIN(NXLL,LCONDW)    !AS STRICTLY FORBIDDEN
        endif
        LCONDW=LCONDW+1
      ENDIF
      LC=-LCONDW
      LCONDW=2*LCONDW-1                  !ALLOW FOR BOTH TARGET PARITIES
      lcondw=lcondw+i1
C
      IF(MXORB+LCONDW.GT.MAXGR)THEN                   !FOR NON-ALLOCATED
        WRITE(6,*)'*** INCREASE MAXGR TO:',MXORB+LCONDW
        WRITE(0,*)'*** INCREASE MAXGR TO:',MXORB+LCONDW
        GO TO 995
      ENDIF
C
      MPOSC=MXORB
      LW=LCONDW
C
C-----------------------------------------------------------------------
C DETERMINE CONTINUUM EXPANSION (LSJ)
C-----------------------------------------------------------------------
C
      BKUTSS=ABS(MODD).LE.1.AND.KUTSSX.NE.-1.AND.KUTSSX.NE.-999
C
      IF(BKUTSS)THEN
C
        IF(LCONDWJ.LE.0)THEN
          i1=mod(INT(qcs0+1,SP),itwo)
          LCONDWJ=(QCL0+QCS0+3)/2   !MAX NO OF CONT-L THAT CAN FORM SLJP
        ELSE
          LCONDWJ=MAX(LCONDW,LCONDWJ)                   !ELSE INDEX PAIN
          i1=mod(lcondwj+1,itwo)
          LCONDWJ=(LCONDWJ-1)/2
          IC=(QCL0+QCS0+3)/2-1
          if(lcondwj.lt.ic)then
            WRITE(6,2005)LCONDWJ,IC
          elseif(lcondw.gt.ic)then
            LCONDWJ=IC                            !AS STRICTLY FORBIDDEN
          endif
          LCONDWJ=LCONDWJ+1
        ENDIF
        LCJ=-LCONDWJ
        LCONDWJ=2*LCONDWJ-1              !ALLOW FOR BOTH TARGET PARITIES
        lcondwj=lcondwj+i1
C
        IF(MXORB+LCONDWJ.GT.MAXGR)THEN                !FOR NON-ALLOCATED
          WRITE(6,*)'*** INCREASE MAXGR TO:',MXORB+LCONDWJ
          WRITE(0,*)'*** INCREASE MAXGR TO:',MXORB+LCONDWJ
          GO TO 995
        ENDIF
C
        MPOSC=MPOSC+(LCONDWJ-1)/2-(LCONDW-1)/2             !BUFFER SPACE
        LW=LCONDWJ
C
      ELSE
C
        LCONDWJ=LCONDW
C
      ENDIF
c
      if(bkutoo.and.lcondwj.eq.1)then    !note: SET lcondw, not lcondwj!
        write(6,*)'*** buffer space too small, switch-off 2-nfs or'
     x           ,'set lcondw=2'
        write(0,*)'*** increase lcondw to 2'
        go to 995
      endif
C
C-----------------------------------------------------------------------
C INITIALZE CONTINUUM ORBITAL LOCATIONS (LABEL & FLAG EXISTENCE)
C-----------------------------------------------------------------------
C
      IAXGR=MXORB+LW                            !N.B. NEL IS STILL MXORB
C
      CALL RE_ALLOC(QL,IONE,MXORB,IAXGR,IERR)
      CALL RE_ALLOC(QN,IONE,MXORB,IAXGR,IERR)
C
      DO L=1,LW
        I=MXORB+L
        QN(I)=90
        DEY(I)=DONE
      ENDDO

      WRITE(6,1001)
C
      DO L=1,LCONDW
        I=MPOSC+L
        LC=LC+1
        IF(LC.LT.0)WRITE(6,1002)I,ABS(LC)
        IF(LC.EQ.0)WRITE(6,1003)I
        IF(LC.GT.0)WRITE(6,1004)I,LC
      ENDDO
C
C-----------------------------------------------------------------------
C
C INITIALIZE FOR PARALLEL OPERATION.
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      if(nsl0.lt.0)then                                         !par
cpar        call pcasym(iam,nproc)                                  !par
cpar      elseif(abs(MODD).gt.1)then                                !par
cpar        call psymls(iam,nproc)                                  !par
cpar      else                                                      !par
cpar        call psymj(iam,nproc)                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      if(nf.lt.0)then                                           !par
cpar        call comm_finalize()                                    !par
cpar        go to 990                                               !par
cpar      endif                                                     !par
cparc                                                               !par
C
C-----------------------------------------------------------------------
C
C SET-UP CA SYMMETRIES & CHANNEL LIST
C
C-----------------------------------------------------------------------
C
      IF(NSL0.LT.0)THEN
C
        CALL CASYM(KACT,MXCF)
C
        IF(NF.LE.0)GO TO 990
C
C-----------------------------------------------------------------------
C
C FORM 2-BODY CA COLLISION ALGEBRA
C
C-----------------------------------------------------------------------
C
        CALL CALGX(KACT,MXCF,DFS)
C
        IF(NF.LE.0)GO TO 990
C
        GO TO 900
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C SET-UP LSP SYMMETRIES & CHANNEL LIST
C
C-----------------------------------------------------------------------
C
      CALL SYMLS
C
      IF(NF.LE.0)GO TO 990
C
C-----------------------------------------------------------------------
C
C FORM 2-BODY NON-FINE-STRUCTURE COLLISION ALGEBRA IN LS-COUPLING
C
C-----------------------------------------------------------------------
C
      CALL ALGXLS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,DFS,MAXEL)
C
      IF(NF.LE.0)GO TO 990
C
      INASTJ=0
C
      IF(ABS(MODD).GT.1)GO TO 901                    !QUICK RETURN (LS)
C
C-----------------------------------------------------------------------
C
C SET-UP LSJ SYMMETRIES & CHANNEL LIST, INC. SET-UP FOR FINE-STRUCTURE
C
C-----------------------------------------------------------------------
C
      IF(KUTSSX.EQ.-1.AND.MAXJFS.GE.0)THEN
        WRITE(6,1006)KUTSSX,MAXJFS
        WRITE(0,1006)KUTSSX,MAXJFS
        GO TO 995
      ENDIF
      IF(KUTSSX.EQ.-999)KUTSSX=-1                      ! or KUTSS (slow)
      IF(MAXJFS.EQ.-999)MAXJFS=2*MAXLX-QCS0-1
      IF(KUTSSX.EQ.-1)MAXJFS=-2        !not -1, for safety c.f. sr.psymj
C
      CALL SYMLSJ
C
      IF(NF.LE.0)GO TO 990
C
      INASTJ0=0
C
      IF(KUTSSX.EQ.-1)GO TO 903                !NO OPERATORS SET FOR 2FS
      IF(MAXJFS.LT.0)GO TO 902                         !NO J SET FOR 2FS
C
      WRITE(6,2000)MAXJFS
C
      WRITE(6,2001)
C
      LC=LCJ
      DO L=1,LCONDWJ
        I=MXORB+L
        LC=LC+1
        IF(LC.LT.0)WRITE(6,2002)I,ABS(LC)
        IF(LC.EQ.0)WRITE(6,2003)I
        IF(LC.GT.0)WRITE(6,2004)I,LC
      ENDDO
C
C-----------------------------------------------------------------------
C
C FORM 2-BODY FINE-STRUCTURE COLLISION ALGEBRA IN LSJ-COUPLING
C
C-----------------------------------------------------------------------
C
      CALL ALGXFS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,DFS,MAXEL)
C
      IF(NF.LE.0)GO TO 990
C
C-----------------------------------------------------------------------
C
 900  IF(IDW.LT.0)THEN
        WRITE(6,190)IDW
        NF=0
      ENDIF
C
 990  CONTINUE
C
C FINALIZE (CLOSE) WRITE/READ DC ARRAY TO/FROM DISK.
C
      IF(BDISK)
     X   CALL DISKDC(IUD,IZERO,IZERO,IZERO,IZERO,IZERO,IZERO)
C
C DEALLOCATE
C
      IF(ALLOCATED(JYI))DEALLOCATE (JYI,JYF)
C
      IF(BALLDC)THEN
        DEALLOCATE (DC,IDC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR DC,IDC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BQXXX)THEN
        DEALLOCATE (QBMS,QBML,QLMC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR QXXX'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(BMNAM)THEN
        DEALLOCATE (MAM,NAM,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR MAM,NAM'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON /NRBBBB/
      IF(BNRBBBB)THEN
        IF(BNOTK)THEN
          DEALLOCATE (BXIST0,BXIST1,KTMP,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR BXIST0,BXIST1'
            IF(NF.GT.0)NF=0
          ENDIF
        ELSE
          DEALLOCATE (KACT,KTMP,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'ALGX: DEALLOCATION FAILS FOR KACT,KTMP'
            IF(NF.GT.0)NF=0
          ENDIF
        ENDIF
        BNRBBBB=.FALSE.
      ENDIF
C
C EX-COMMON/NRBFL0/
      IF(BNRBFL0)THEN
        DEALLOCATE (KINTI,KINTF,KEN2,KPTCFM,MPOINT,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR KPTCFM ETC.'
          IF(NF.GT.0)NF=0
        ENDIF
        BNRBFL0=.FALSE.
      ENDIF
C
C EX-COMMON/NRBGCF/
      IF(BNRBGCF)THEN
        DEALLOCATE (KGCF,NKSL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR KGCF,NKSL'
          IF(NF.GT.0)NF=0
        ENDIF
        BNRBGCF=.FALSE.
      ENDIF
C
      IF(ALLOCATED(KGSL))THEN
        DEALLOCATE (KGSL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGX: DE-ALLOCATION FAILS FOR KGSL'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
      RETURN
C
 901  WRITE(6,100)
      KUTSSX=-1
      GO TO 900
C
 902  WRITE(6,102)
C      KUTSSX=-1                                 !ALLOW BKUTSS FOR DWXBP
      GO TO 900
C
 903  WRITE(6,103)
      GO TO 900
C
 995  NF=-1
      GO TO 990
C
 999  NF=0
      GO TO 990
C
C
  100 FORMAT( /" NOT ENOUGH VCC'S AVAILABLE FOR CALCULATION OF"
     X," RELATIVISTIC CORRECTIONS: CHANGE MOD  TO 1,-1 OR 0")
  102 FORMAT(/' *** NO TWO-BODY FINE-STRUCTURE POSSIBLE: SET MAXJFS NON'
     X,'-NEGATIVE')
  103 FORMAT(/' *** NO TWO-BODY FINE-STRUCTURE POSSIBLE: SET KUTSSX TO '
     X,'1 OR -9 ETC.')
  190 FORMAT(/' THIS WAS NO MORE THAN A DIMENSION CHECK -- IDW=',I2/)
 1000 FORMAT(///1X,136('-')//52X,'*** COLLISION ALGEBRA (CA) ***'
     X       //1X,136('-')//)
 1001 FORMAT(/' CONTINUUM ORBITAL INDEXING FOR TOTAL L:'/
     X        60X,' GAM',2X,'SMALL L')
 1002 FORMAT(60X,I4,3X,'L-',I2)
 1003 FORMAT(60X,I4,3X,'L ',I2)
 1004 FORMAT(60X,I4,3X,'L+',I2)
 1005 FORMAT(/' WARNING SR.ALGX: YOU HAVE RESTRICTED THE CONTINUUM'
     X       ,' EXPANSION TO:     L +/-',I2/29X,'WHILE THE FULL'
     X       ,' EXPANSION EXTENDS TO:     L +/-',I2/)
 1006 FORMAT('*** ERROR, SR.ALGX: YOU HAVE SPECIFIED CONFLICTING',
     X' OPTIONS FOR FINE-STRUCTURE COLLISION ALGEBRA; KUTSSX, MAXJFS='
     X,2I4)
 1010 FORMAT(/' DC ARRAY TOO LARGE TO READ (NEED NMTGD SET-UP) - TBD')
 2000 FORMAT(//1X,136('-')//52X,'*** COLLISION ALGEBRA (LSJ) ***'
     X       //1X,136('-')///61X,'MAXJFS=',I3/61X,10('-')/)
 2001 FORMAT(/' CONTINUUM ORBITAL INDEXING FOR TOTAL J:'/
     X        57X,' GAM',4X,'SMALL L')
 2002 FORMAT(57X,I4,3X,'INT(J)-',I2)
 2003 FORMAT(57X,I4,3X,'INT(J) ',I2)
 2004 FORMAT(57X,I4,3X,'INT(J)+',I2)
 2005 FORMAT(/' WARNING SR.ALGX: YOU HAVE RESTRICTED THE LSJ CONTINUUM'
     X       ,' EXPANSION TO:     INT(J) +/-',I2/33X,'WHILE THE FULL'
     X       ,' EXPANSION EXTENDS TO:     INT(J) +/-',I2/)
 5000 FORMAT(///1X,136('-')//50X,'*** ELECTRON-IMPACT EXCITATION ***'
     X       //1X,136('-')//)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(M1,M2)
C
      MVC=((M1+2)*M1/2+M2)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE ALGX
C
C                             *******************
C
      SUBROUTINE ALGX0(QLMC,QBML,QBMS,JYI,JYF)
C
C-----------------------------------------------------------------------
C
C  SR.ALGX0 RECOVERS TARGET INFO, ALGEBRA AND ENERGIES.
C
C  IT CALLS:
C    SR.NUMSYM
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL,IAXCL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: BNRBGCF,KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADD,IADJ
C      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
C     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C      PARAMETER (MXD14=100)
C
      INTEGER(SP) SJ
C
      INTEGER(EP) MDCF8,MDCFT8
C
      CHARACTER(LEN=4) MLIT
C
      DIMENSION QLMC(*),QBML(*),JYI(*),QBMS(*),JYF(*)
C
      COMMON /BASIC/NF,KX,KG,K1,K2,MGAP(7)
C      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL0/IRET0,LORIG,LMIN,MPRNT0,MOD0,MSTRT0,BPASS,MLIT(2)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDUM/MXDC0,MXGR0         !NOT USED ANYWHERE, BUT RESTART
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW3/LSPIB(MAXSL)   !TBD: COMBINE WITH /NRBDW/ IN MODULE
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBJP/JPIP(MAXJG),NASTJP,MINJTP,MAXJTP
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
c
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
      BPRNT0=JPRINT.NE.-3
      BTEST=BPRNT0          !.TRUE.                   !DETAILED PRINTOUT
C
C RE-POINT RESTART FILE
C
      MR=10                                           !NO REDEF. ALLOWED
      REWIND(MR)
C
C-----------------------------------------------------------------------
C RECOVER TARGET HEADER INFO FROM ALGEB1 (NOTE: DEY IS JUST ON/OFF HERE)
C-----------------------------------------------------------------------
C                                                                  !REC1
      READ(MR)
     X MLIT,MXORB,NW,NF,MODD,KCUTX,KUTDSK,QQKUTX,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRINT,MA0,MB0,MAXNV,IRLX,ITANAL
      BACKSPACE(MR)
C
      ALLOCATE (NEL(MXORB,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX0: ALLOCATION FAILS FOR NEL'
        GO TO 999
      ENDIF
C
      IAXCL=MAX(IONE,NW)
      ALLOCATE (NNL(IAXCL,3),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX0: ALLOCATION FAILS FOR NNL'
        GO TO 999
      ENDIF
C
      ALLOCATE (QCG(MAXEL,KMAX),QL(MXORB),QN(MXORB),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX0: ALLOCATION FAILS FOR QCG,QL,QN'
        NF=0
        GO TO 999
      ENDIF
C
      ALLOCATE (KGCF(0:KMAX),NKSL(MAXSL,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX0: ALLOCATION FAILS FOR KGCF,NKSL'
        GO TO 999
      ENDIF
      BNRBGCF=.TRUE.
C                                                                  !REC1
      READ(MR)
     X MLIT,MXORB,NW,NF,MODD,KCUTX,KUTDSK,QQCUTX,QCL0,QCS0,MDCBUF
     X,MTGD,MTGDI,NTT,NSS,MAXEL,KMAX,NPRINT,MA0,MB0,MAXNV,IRLX,ITANAL
     X,((NEL(I,J),I=1,MXORB),J=1,KMAX),((NNL(I,J),I=1,NW),J=1,3)
     X,((QCG(I,J),I=1,MAXEL),J=1,KMAX),(QL(I),I=1,MXORB)
     X,(QN(I),I=1,MXORB),(DEY,I=1,MXORB),(MSTAT,I=1,KMAX)
     X,(IEQ(I),I=0,MXORB),(IGRCF(I),I=1,MXORB),(BANAL(I),I=1,KMAX)
     X,(KGCF(I),I=0,KMAX),((NKSL(I,J),I=1,KGCF(J)-KGCF(J-1)),J=1,KMAX)
     X,(NTG(I),I=0,KMAX),(QCP(I),I=1,KMAX)
C
      KCUT=ABS(KCUTX)
      BREL=NPRINT.LT.-4                            !INCASE BYPASS ALGEB0
      IF(BREL)NPRINT=MOD(NPRINT,IFIVE)
C
      NESS=MAXEL*NSS
C
C-----------------------------------------------------------------------
C RECOVER SOME TARGET ALGEBRA FROM ALGEB1, AFTER CALL TO ALGEB3
C-----------------------------------------------------------------------
C
      READ(MR)(DC(I),I=0,MTGD)                                     !REC3
      READ(MR)(IDC(I),I=1,MTGDI)                                   !REC3
      READ(MR)(JYI(I),I=1,KMAX),(JYF(I),I=1,KMAX)
     X       ,(QBML(I),I=1,NSS),(QBMS(I),I=1,NSS),(QLMC(I),I=1,NESS)
     X       ,(JTGD(I),I=0,NTT)
     X       ,(QTGS(I),I=1,NTT),(QTGL(I),I=1,NTT),(QTGD(I),I=1,NTT)
C
C-----------------------------------------------------------------------
C RECOVER SOME TARGET ALGEBRA FROM ALGEB2 (LIKELY NOT ALL NECESSARY)
C-----------------------------------------------------------------------
C                                                                  !REC2
      READ(MR)IADD,IRK,IRKO,IRL,MTGD,MPOL00,MPOLE,IOS,NXLL
     X        ,KUTLS,NSL0,NMETA,MXORBR
C
      ALLOCATE (KGSL(KMAX,NSL0),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGX0: ALLOCATION FAILS FOR KGSL'
        GO TO 999
      ENDIF
C                                                                  !REC3
      READ(MR)(NSL(I),I=1,NSL0),(QSI(I),I=1,NSL0)
     X      ,(QLI(I),I=1,NSL0),(QPI(I),I=1,NSL0),(NMETAG(I),I=1,NSL0)
     X      ,((KGSL(I,J),I=1,KMAX),J=1,NSL0),(NADG(I),I=1,NSL0)
     X      ,(NFI(I),I=1,NTT),(NFK(I),I=1,NTT),(NFQ(I),I=1,NTT)
C
C-----------------------------------------------------------------------
C RECOVER SOME TARGET ALGEBRA FROM ALGEB3 (LIKELY NOT ALL NECESSARY)
C-----------------------------------------------------------------------
C
      READ(MR)NJO,IRS,NL,IADJ8,IADJ0,IRKP,IRLP,NCJ,NMETAJ          !REC4
C
      IF(NJO.EQ.0)THEN                          !LS
        READ(MR)NJO                                                !REC5
      ELSE                                                         !REC5
        READ(MR)NJO,(NRR(I),I=1,NCJ),(NT(I),I=1,NJO)
     X         ,(JN(I),I=1,NCJ),(NGR(I),I=1,NCJ),(NMETGJ(I),I=1,NJO)
     X         ,((NSLJ(J,I),J=1,NSL0),I=1,NJO),(NGSLJ(I),I=1,NJO)
C     X         ,(NTJ(I),I=1,KMAX),(NFJ(I),I=1,NCJ)
      ENDIF
C
C-----------------------------------------------------------------------
C RECOVER TARGET DIAGON SO WE CAN SET METASTABLE AND CORRELATION ALGEBRA
C-----------------------------------------------------------------------
C
      READ(MR,END=10)NMETA                         !NDUM IF WANT NMETA=0
      READ(MR)(NMETAG(I),I=1,NSL0)
c      NENERG=0
      READ(MR)N,KCUT
      BECOR=N.LT.0
      IF(BECOR)N=-N
      NENERG=N
      READ(MR)(INDEX(I),I=1,NENERG)
      READ(MR)(DSPECE(I),I=1,NENERG)                   !RYD NOW !
C
C REDUCE NENERG ENERGIES TO THE NSPECE NON-CORRELATION.
C THIS MAKES IT EASY TO HANDLE INTERSPERSED SPEC/CORR.
C
C ALSO, SET REVERSE INDEX(I), JNDEX(J):
C INDEX MAPS SPEC E.O. I=1,2,3  TO S.O.
C JNDEX MAPS *ALL S.O. I=1,2,3  TO SPEC E.O.
C   FOR CORR S.O. THE FULL E.O. POSITION IS SET. SUBSEQUENTLY, WE ONLY
C   CARE THAT IT HAS BEEN FLAGGED NEGATIVE FOR CORR. THE ACTUAL VALUE
C   IS NOT NEEDED/USED.
C
      NSPECE=0
      DO J=1,NENERG
        I=INDEX(J)
        if(i.lt.0)then
          jndex(-i)=-j
        else
          NSPECE=NSPECE+1
          JNDEX(I)=NSPECE                               !=J IN ORIG E.O.
          INDEX(NSPECE)=I
          DSPECE(NSPECE)=DSPECE(J)
        endif
      ENDDO
C
  10  IF(NENERG.EQ.0)THEN
        IF(NZION.NE.0)THEN                             !SHOULDN'T HAPPEN
          WRITE(6,*)'*** SR.ALGX0: MISSING LS TARGET INFO'
          WRITE(0,*)'*** SR.ALGX0: MISSING LS TARGET INFO'
          GO TO 995
        ENDIF
C ELSE JUST AN ALGEBRA RUN
      ENDIF
C
C RE-RETABULATE THE NCI=NTG(KMAX) TERMS CASL OF THE KMAX CONFIGURATIONS
C ACCORDING TO TOTAL S,L,KPC(=PARITY  0,2 FOR EVEN,ODD); ONE OBTAINS
C NSL0 BLOCKS OF LENGTH NSL(N), WITH QSI(N)=2S,QLI(N)=2L,QPI(N)=KP;
C NGRPI(ND): GROUP ND STARTS AT NCI=NGRPI(ND)+1 IN TERM LIST
C
      WRITE(6,400)NMETA
C
      NCTOT=0
      NCI=0
      NSL0=0
      NN=0
      NAST=INAST        !PASS NAST TARGETS, THEN -> INAST N+1 (USE BOTH)
C
      QCL=QCL0         !2L
C
 151  QCS=QCS0         !2S
C
 152  KCP=0            !2P
C
 153  NC=0
C
      DO K=1,KMAX
        IF(QCP(K).EQ.KCP)THEN
          NG0=NTG(K-1)+1
          NT0=NTG(K)
          QCS00=QTGS(NG0)
          QCL00=QTGL(NG0)
          K0=1
          ND0=0
          DO I=NG0,NT0
            IF(QTGL(I).NE.QCL00.OR.QTGS(I).NE.QCS00)THEN
              QCS00=QTGS(I)
              QCL00=QTGL(I)
              K0=K0+1
            ENDIF
            IF(QTGL(I).EQ.QCL.AND.QTGS(I).EQ.QCS)THEN
              NC=NC+1
              NCI=NCI+1
              ND=NSL0+1
              ND0=K0
              IF(BTEST)WRITE(6,180)NCI,QCS+1,QCL/2,KCP/2,K,I,ND
              NFQ(NCI)=ND
              NFK(NCI)=K
              NFI(NCI)=I
            ELSE
              IF(QTGL(I).LT.QCL)GO TO 155                      !BAIL OUT
            ENDIF
          ENDDO
 155      IF(ND0.GT.0)KGSL(K,ND)=ND0                !GROUP NO. WITHIN CF
        ENDIF
      ENDDO
C
      IF(NC.GT.0)THEN
        NCTOT=NCTOT+NC*NC
c        if(btest)write(6,182)nc
        NN=((NC+1)*NC)/2+NN
        NSL0=ND
        QLI(ND)=QCL
        QSI(ND)=QCS
        QPI(ND)=KCP
        NSL(ND)=NC
        NGRPI(ND)=NCI-NC
      ENDIF
C
      KCP=KCP+2
      IF(KCP.LE.2)GO TO 153           !LOOP UP TO NEXT PARITY
C
      QCS=QCS-2
      IF(QCS.GE.0)GO TO 152           !LOOP UP FOR NEXT SPIN
C
      QCL=QCL-2
      IF(QCL.GE.0)GO TO 151           !LOOP UP FOR NEXT ORB A.M.
C
      IADD=NN
C
      IF(NCI.NE.NENERG.AND.NZION.NE.0)THEN
        WRITE(6,170)NCI,NENERG
        WRITE(0,170)NCI,NENERG
        GO TO 995
      ENDIF
c
c      if(btest)write(6,198)nctot,maxuc
C
C LOWEST (ENERGY) NMETA INITIAL TERMS TO ALL EXCITED STATES ONLY,
C SO FLAG GROUPS FOR OMISSION WHICH ONLY INTERACT VIA EXCITED STATES
C DEFAULT (NMETA=0) IS "ALL".
C (IF USER SETS NMETA.LT.0 THEN THEY COULD SPECIFY NMETAG DIRECTLY VIA
C  SALGEB NAMELIST... NOT CURRENTLY ALLOWED, BUT BP RUN SETS NMETAG
C  IN ALGX AND THEN RESETS .LT.0 TO SKIP HERE.)
C
      IF(ABS(MODD).GT.1)THEN
C
        NMETA=ABS(NMETA)
        NMETA=MIN(NMETA,NSPECE)
C
        DO N=1,NSL0                          !OR BGLS=IUNIT(14).LT.0
          IF(NMETAG(N).NE.0)THEN             !WAS SET IN STRUCTURE RUN
            BGLS=.TRUE.
            GO TO 15
          ENDIF
        ENDDO
        BGLS=.FALSE.                         !WAS NOT
  15    IF(NMETA.GT.0)THEN
          IF(.NOT.BGLS)THEN                  !SET NOW
            DO N=1,NSL0
              NMETAG(N)=1
            ENDDO
          ENDIF
          DO N=1,NMETA
            I=INDEX(N)
c            if(i.gt.0)then                          !else correlation
              ND=NFQ(I)
              IF(BGLS)THEN
                IF(NMETAG(ND).NE.0)THEN      !ABORT
                  WRITE(0,114)
                  WRITE(6,114)
                  GO TO 995
                ENDIF
              ELSE
                NMETAG(ND)=0
              ENDIF
c              write(0,*)i,nd
c            endif
          ENDDO
        elseif(nmeta.eq.0.and.nzion.ne.0)then    !shouldn't get here now
          stop 'algx0 error: nmeta.eq.0...'
        ENDIF
c
c        write(6,*)'lsp groups'
c        do k=1,nsl0
c          write(6,*)k,nmetag(k)
c        enddo
C
        GO TO 20
C
      ENDIF
C
C-----------------------------------------------------------------------
C RECOVER TARGET DIAGFS SO WE CAN SET METASTABLE AND CORRELATION ALGEBRA
C-----------------------------------------------------------------------
C
      READ(MR,END=50)  !NCTOT            !SKIP LS, AS NOT USED CURRENTLY
      READ(MR)  !(TFU(I),I=1,NCTOT)      !SKIP LS, AS NOT USED CURRENTLY
C
      READ(MR)NMETAJ                     !NDUM IF WANT NMETAJ=0
      READ(MR)(NMETGJ(I),I=1,NJO)
c      NENERJ=0
      READ(MR)N,KCUT
      BECOR=N.LT.0
      IF(BECOR)N=-N
      NENERJ=N
      READ(MR)(INDXJ(I),I=1,NENERJ)
      READ(MR)(DSPECJ(I),I=1,NENERJ)                   !RYD NOW !
C
C REDUCE NENERJ ENERGIES TO THE NSPECJ NON-CORRELATION.
C THIS MAKES IT EASY TO HANDLE INTERSPERSED SPEC/CORR.
C
C ALSO, SET REVERSE INDXJ(I), JNDXJ(J):
C  INDXJ MAPS SPEC E.O. I=1,2,3  TO S.O.
C  JNDXJ MAPS *ALL S.O. I=1,2,3  TO SPEC E.O.
C   FOR CORR S.O. THE FULL E.O. POSITION IS SET. SUBSEQUENTLY, WE ONLY
C   CARE THAT IT HAS BEEN FLAGGED NEGATIVE FOR CORR. THE ACTUAL VALUE
C   IS NOT NEEDED/USED.
C
      NSPECJ=0
      DO J=1,NENERJ
        I=INDXJ(J)
        if(i.lt.0)then
          jndxj(-i)=-j
        else
          NSPECJ=NSPECJ+1
          JNDXJ(I)=NSPECJ                               !=J IN ORIG E.O.
          INDXJ(NSPECJ)=I
          DSPECJ(NSPECJ)=DSPECJ(J)
        endif
      ENDDO
C
  50  IF(NENERJ.EQ.0)THEN
        IF(NZION.NE.0)THEN                             !SHOULDN'T HAPPEN
          WRITE(6,*)'*** SR.ALGX0: MISSING IC TARGET INFO'
          WRITE(0,*)'*** SR.ALGX0: MISSING IC TARGET INFO'
          GO TO 995
        ENDIF
C ELSE JUST AN ALGEBRA RUN
      ENDIF
C
C THE FOLLOWING SECTION SETS UP THE STATES ACCORDING TO THEIR
C J-VALUES: J=TOTAL ANGULAR MOMENTUM.
C
      bcutfs=nmetag(0).ne.0              !may use other values in future
      im=-1
      if(bcutfs)im=1
c
      WRITE(6,401)NMETAJ*im
C
      NJO=0
      NJ=0
      NP=0
      NCTOT=0
      NASTJ=INASTJ    !PASS NASTJ TARGETS, THEN -> INASTJ N+1 (USE BOTH)
C
      JACT=QCL0+QCS0
C
  60  KPI=0
C
  61  IF(NASTJ.GT.0)THEN                                  !SELECT BY JPI
        JT=10*JACT+KPI/2
        DO  I=1,NASTJ
          IF(JT.EQ.JPI(I))GO TO 62                                 !WANT
        ENDDO
        GO TO 64                                             !DON'T WANT
      ELSEIF(NASTJ.LT.0)THEN                      !SELECT BY MINJT,MAXJT
        IF(JACT.LT.MINJT.OR.JACT.GT.MAXJT)GO TO 64           !DON'T WANT
      ENDIF
C
  62  N0=0
      NDJ=NJO+1                                  !NDJ IS JP GROUP NUMBER
      NGSLJ(NDJ)=0
C
C DO LOOP TO FIND NUMBER OF LEVELS WHICH CAN RESULT IN GIVEN J
C
      IT=0
      DO I=1,NSL0
        NC=NSL(I)
        IT=IT+NC
        IF(QPI(I).NE.KPI)GO TO 63
C
        LJ=QLI(I)
        SJ=QSI(I)
        IF(ABS(LJ-SJ).GT.JACT.OR.(LJ+SJ).LT.JACT)GO TO 63
C
        IT=IT-NC
        NGSLJ(NDJ)=NGSLJ(NDJ)+1
        NSLJ(NGSLJ(NDJ),NDJ)=I
        DO N=1,NC
          IT=IT+1
          NJ=NJ+1
          N0=N0+1
          IF(BTEST)THEN
            KG=NFK(IT)
            WRITE(6,181)NJ,SJ+1,LJ/2,JACT,KG,IT
          ENDIF
          NRR(NJ)=IT
          JN(NJ)=JACT
          NGR(NJ)=NDJ
        ENDDO
C
  63  ENDDO
C
      IF(N0.GT.0)THEN
        NJO=NDJ
        NP=((N0+1)*N0)/2+NP
        NCTOT=NCTOT+N0*N0
c        if(btest)write(6,181)ndj,jact,kpi/2,n0
        NT(NDJ)=N0
      ENDIF
C
  64  KPI=KPI+2
      IF(KPI.EQ.2)GO TO 61               !LOOP BACK UP FOR SECOND PARITY
C
      JACT=JACT-2
      IF(JACT.GE.0)GO TO 60                    !LOOP BACK UP FOR NEXT 2J
C
      IADJ=NP
C
      IF(NJ.NE.NENERJ.AND.NZION.NE.0)THEN
        WRITE(6,175)NJ,NENERJ
        WRITE(0,175)NJ,NENERJ
        GO TO 995
      ENDIF
C
c      if(btest)write(6,134)nctot,maxju
C
C NOW SET NMETAG, WHICH DEFINES THE LS(J) GROUP INTERACTIONS WE NEED,
C BASED UPON NMETAJ.
C PROBABLY DON'T WANT TO LET USER JOE OVERRIDE, I.E. RE-SET NMETA.GT.0.
c
c Default nmetaj.gt.0 will neglect 2fs between excited levels that at
c most spin-orbit mix with the metastable levels. (Passed via nmetag(0))
c User input nmetaj.lt.0 includes all allowed by a.m. selection.
c
c     bcutfs=nmetag(0).ne.0              !may use other values in future
C
C NMETGJ IS NOT CURRENTLY USED IN THE ALGX BRANCH (USED BY TARGET MK)
C RATHER, THE CONSTITUENT NMETAG GROUPS ARE USED/FLAGGED
C *THIS*, NMETGJ USE, MAY CHANGE AND SO WE SET IT UP CORRECTLY.
C
      NMETAJ=ABS(NMETAJ)
      NMETAJ=MIN(NMETAJ,NSPECJ)
c
c see if fully unitarized approximation ii, and set space for all phases
c (n.b. quietly switch-off maxjfs here if user has kutssx=-1, i.e
c  do not flag input conflict if maxjfs.ge.0...)
c
      bunit2=nmetaj.eq.nspecj.and.ione1.eq.0
      if(bunit2.and.(kutssx.eq.-1.or.kutssx.eq.-999))then
        kutssx=0
        maxjfs=-2                                  !not -1, for sr.psymj
      elseif(maxjfs.eq.-1)then                   !not a wise user choice
        maxjfs=-2
      endif
c
      i0=0
      if(bcutfs)i0=-1
C
      DO N=1,NJO                           !OR BGLS=IUNIT(15).LT.0
        IF(NMETGJ(N).NE.0)THEN             !WAS SET IN STRUCTURE RUN
          BGIC=.TRUE.
          GO TO 16
        ENDIF
      ENDDO
      BGIC=.FALSE.                         !WAS NOT
  16  IF(NMETAJ.GT.0)THEN
        IF(.NOT.BGIC)THEN                  !SET NOW
          DO N=1,NJO
            NMETGJ(N)=1
          ENDDO
        ENDIF
        DO N=1,NMETAJ
          I=INDXJ(N)
c          if(i.gt.0)then                          !else correlation
            NDJ=NGR(I)                        !J-GROUP
            IF(BGIC)THEN
              IF(NMETGJ(NDJ).NE.0)THEN        !ABORT
                WRITE(0,115)
                WRITE(6,115)
                GO TO 995
              ENDIF
            ELSE
              NMETGJ(NDJ)=0
            ENDIF
c          write(0,*)i,ndj
c        endif
        ENDDO
        IF(.NOT.BGIC)THEN                  !SINCE CONTROLLED BY NMETAJ
          DO K=1,NSL0
            NMETAG(K)=1
          ENDDO
        ENDIF
        DO N=1,NJO
          IF(NMETGJ(N).EQ.0)THEN
            NCN0=NGSLJ(N)
            DO NC0=1,NCN0
              ND=NSLJ(NC0,N)
              IF(BGIC)THEN
                IF(NMETAG(ND).gt.0)THEN      !ABORT
                  WRITE(0,115)
                  WRITE(6,115)
                  GO TO 995
                else
                  nmetag(nd)=i0
                ENDIF
              ELSE
                NMETAG(ND)=i0
              ENDIF
            ENDDO
          ENDIF
        ENDDO
        if(bcutfs)then
          do n=1,nmetaj
            i=indxj(n)
            it=nrr(i)
            nd=nfq(it)
            nmetag(nd)=0
c            write(0,*)n,i,it,nd
          enddo
        endif
c        do n=1,nsl0
c          write(0,*)n,nmetag(n)
c        enddo
      elseif(nmetaj.eq.0.and.nzion.ne.0)then     !shouldn't get here now
        stop 'algx0 error: nmetaj.eq.0...'
      ENDIF
c
c      write(6,*)'jp groups'
c      do k=1,njo
c        write(6,*)k,nmetgj(k)
c      enddo
c      write(6,*)'lsp groups'
c      do k=1,nsl0
c        write(6,*)k,nmetag(k)
c      enddo
C
C-----------------------------------------------------------------------
C RE-INSTATE LS-SYMMETRY SELECTION
C-----------------------------------------------------------------------
C
  20  INAST=INAST0
C      NASTP=NAST
C      MX=MAX(NASTP,INAST)
      DO I=1,INAST                !MX
C        II=LSPI(I)
        LSPI(I)=LSPIB(I)
C        LSPIB(I)=II              !UNUSED
      ENDDO
C      MINLTP=MINLT               !UNUSED
C      MAXLTP=MAXLT               !UNUSED
C      MINSTP=MINSP               !UNUSED
C      MAXSTP=MAXSP               !UNUSED
      MINLT=MINLTB
      MAXLT=MAXLTB
      MINSP=MINSTB
      MAXSP=MAXSTB
C      MINLTB=MINLTP              !UNUSED
C      MAXLTB=MAXLTP              !UNUSED
C      MINSTB=MINSTP              !UNUSED
C      MAXSTB=MAXSTP              !UNUSED
C
      WRITE(6,1000)
C
      IF(ABS(MODD).GT.1)GO TO 990
C
C-----------------------------------------------------------------------
C RE-INSTATE J-SYMMETRY SELECTION
C-----------------------------------------------------------------------
C
      INASTJ=INASTJ0
C      NASTJP=NASTJ
C      MX=MAX(NASTJP,INASTJ)
      DO I=1,INASTJ               !MX
C        II=JPI(I)
        JPI(I)=JPIP(I)
C        JPIP(I)=II               !UNUSED
      ENDDO
C      MINJTP=MINJT               !UNUSED
C      MAXJTP=MAXJT               !UNUSED
      MINJT=MINJTB
      MAXJT=MAXJTB
C      MINJTB=MINJTP              !UNUSED
C      MAXJTB=MAXJTP              !UNUSED
C
C-----------------------------------------------------------------------
C PERFORM CONSISTENCY CHECKS ON LS & J, I.E. THAT WE HAVE REQUIRED SLP
C FOR JP AND THAT MAXLX IS SET APPROPRIATELY FOR MAXJFS.
C-----------------------------------------------------------------------
C
      IF(INAST0.LE.0)THEN
C
        IF(INASTJ0.LE.0)THEN
C
          M01=QCS0+1-2*((QCS0+1)/2)
          IF(MOD(MINJT,ITWO).EQ.MOD(INT(QCS0,SP),ITWO))THEN
            MINJT=MINJT-1
            MINJT=MAX(M01,MINJT)
          ENDIF
          IF(MAXJT.LT.200.AND.MOD(MAXJT,ITWO).EQ.MOD(INT(QCS0,SP),ITWO))
     X                                                     MAXJT=MAXJT+1
          IF(LVMAX.GE.0)THEN     !BTHRSH: CHECK BY CHANNEL LV (FOR BBGP)
C
            MAXJ=2*LVMAX+QCL0+QCS0+1
            IF(MAXJT.EQ.2000)MAXJT=MAXJ
            IF(MAXJT.GT.MAXJ)THEN
              WRITE(6,1007)
              WRITE(6,1015)MAXJ,LVMAX
              WRITE(6,1007)
              MAXJT=MAXJ
            ELSEIF(MAXJT.LT.MAXJ)THEN
              WRITE(6,1007)
              WRITE(6,1016)MAXJT,LVMAX,MAXJ
              WRITE(6,1007)
C              MAXJT=MAXJ                   !ALLOW USER TO RESTRICT BY J
            ENDIF
            MAXLT=(MAXJT+QCS0+1)/2   !DO NOT ALLOW USER TO RESTRICT BY L
C
            MINJ=2*LVMIN-QCL0-QCS0-1
            MINJ=MAX(M01,MINJ)
            IF(MINJT.GT.MINJ)THEN
              WRITE(6,1007)
              WRITE(6,1017)MINJT,LVMIN,MINJ
              WRITE(6,1007)
C              MINJT=MINJ                   !ALLOW USER TO RESTRICT BY J
            ELSEIF(MINJT.LT.MINJ)THEN
              WRITE(6,1007)
              WRITE(6,1018)MINJ,LVMIN
              WRITE(6,1007)
              MINJT=MINJ
            ENDIF
            MINLT=(MINJT-QCS0-1)/2   !DO NOT ALLOW USER TO RESTRICT BY L
            MINLT=MAX(IZERO,MINLT)
C
          ELSE                                !CHECK BY TOTAL L (FOR DW)
C
            IF(MAXLT.EQ.1000)MAXLT=30+(QCS0+1)/2
            IF(MAXLT.GT.100)THEN
              MAXLT=100
              WRITE(0,*)'*** SR.ALGX0: REDUCING MAXLT TO',MAXLT
              MINLT=MIN(MINLT,MAXLT)
            ENDIF
            IF(MAXJT.GT.200)THEN
              IF(MAXJT.NE.2000)WRITE(0,*)'*** SR.ALGX0: REDUCING MAXJT'
              MAXJT=2*MAXLT-QCS0-1
              MINJT=MIN(MINJT,MAXJT)
            ELSE
              MAXL=(MAXJT+QCS0+1)/2
              IF(MAXLT.GT.MAXL)THEN
                WRITE(6,1007)
                WRITE(6,1008)MAXL,MAXJT
                WRITE(6,1007)
                MAXLT=MAXL
              ELSEIF(MAXLT.LT.MAXL)THEN
                WRITE(6,1007)
                WRITE(6,1009)MAXL,MAXJT
                WRITE(6,1007)
                MAXLT=MAXL           !DO NOT ALLOW USER TO RESTRICT BY L
              ENDIF
            ENDIF
C
            MINL=(MINJT-QCS0-1)/2
            MINL=MAX(IZERO,MINL)
            IF(MINLT.GT.MINL)THEN
              WRITE(6,1007)
              WRITE(6,1011)MINL,MINJT
              WRITE(6,1007)
              MINLT=MINL             !DO NOT ALLOW USER TO RESTRICT BY L
            ELSEIF(MINLT.LT.MINL)THEN
              WRITE(6,1007)
              WRITE(6,1012)MINL,MINJT
              WRITE(6,1007)
              MINLT=MINL
            ENDIF
C
          ENDIF
C
        ELSE                         !INASTJ0.GT.0
C
          MTEST=MOD(INT(QCS0,SP),ITWO)
          IFLAGJ=0
          JCOUNT=-1
          INAST=0
          DO I=1,INASTJ0
            IJ=JPI(I)/10
            IPJ=JPI(I)-IJ*10
            IF(MOD(IJ,ITWO).EQ.MTEST)THEN
              IF(IFLAGJ.EQ.0)WRITE(6,1113)
              IFLAGJ=IFLAGJ+1
              WRITE(6,1114)I,IJ,IPJ
            ELSE
              CALL NUMSYM(IJ,IPJ,JCOUNT)
            ENDIF
          ENDDO
          IF(IFLAGJ.GT.0)THEN
            WRITE(6,1120)
            WRITE(0,*)
     X      '***SR.ALGX0 ERROR:',IFLAGJ,' ILLEGAL TOTAL 2J REQUESTED'
            NF=-1
            GO TO 990
          ENDIF
          INAST0=INAST                                 !RE-SYNC.
C
        ENDIF
C
        IF(MAXJFS.GE.0)THEN
C          MLAM0=MXLAMX
          IF(MXLAMX.EQ.1000)THEN                 !MAX EXCHANGE MULTIPOLE
            IF(MAXLX.GE.100)THEN
              MXLAMX=NXLL+3                  !TWICE MAX ORB L+3 (was +1)
c              mxlamx=max(mxlamx,3)
            ELSE
C              MXLAMX=(MAXLX+1)/2
              MXLAMX=MAXLX-NXLL/2
            ENDIF
          ENDIF
C          IF(MAXLX.GE.100)MAXLX=2*MXLAMX            !MAX L FOR EXCHANGE
          IF(MAXLX.GE.100)MAXLX=MXLAMX+NXLL/2        !MAX L FOR EXCHANGE
          JTEST=MAXJFS
          IF(INASTJ.LE.0)JTEST=MIN(MAXJT,MAXJFS)
          IL=(JTEST+QCS0+1)/2
          IF(IL.GT.MAXLX)THEN
            WRITE(6,1119)IL
            WRITE(0,*)
     X     'NOTE: MAXLX IS INCREASED FOR 2-BODY FINE-STRUCTURE'
            MAXLX=IL
          ENDIF
        ENDIF
C
      ENDIF
C
 990  RETURN
C
 995  NF=-1
      GO TO 990
C
 999  NF=0
      GO TO 990
C
C
  114 FORMAT('*** SR.ALGX: NMETA INCONSISTANCY, EITHER CREATE A NEW'
     X,' "TERMS" FILE (BEST) OR DO NOT FLAG TO READ OLD FILE.')
  115 FORMAT('*** SR.ALGX: NMETAJ INCONSISTANCY, EITHER CREATE A NEW'
     X,' "LEVELS" FILE (BEST) OR DO NOT FLAG TO READ OLD FILE.')
c  134 FORMAT(/82X,I9,5X,'MAXJU=',I9)
  170 FORMAT(/' SR.ALGX: MIS-MATCH BETWEEN ALGEB/DIAGON TARGET TERMS:'
     X,2I5)
  175 FORMAT(/' SR.ALGX: MIS-MATCH BETWEEN ALGEB/DIAGFS TARGET LEVELS:'
     X,2I5)
  180 FORMAT(I5,3I4,25X,I3,I6,I3)
  181 FORMAT(6I5)
c  198 FORMAT(/56X,I9,5X,'MAXUC=',I9)
  400 FORMAT(//'    T 2S+1  L  (P-0/1 FOR EVEN/ODD)',8X,'CF    NT GR',
     X 15X,'**** TARGET TERMS ****',15X,'NMETA=',I4)
  401 FORMAT(//'   LV  2S+1   L   2J   CF    T',39X
     X,'**** TARGET LEVELS ****',14X,'NMETAJ=',I5)
 1000 FORMAT(///1X,136('-')//52X,'*** COLLISION ALGEBRA (LS) ***'
     X       //1X,136('-')//)
 1007 FORMAT(//1X,136('-')//)
 1008 FORMAT(/' NOTE: REDUCING MAXLT TO',I3,', THAT NEEDED BY MAXJT='
     X,I4,' (=2J)')
 1009 FORMAT(/' NOTE: INCREASING MAXLT TO',I3,', THAT NEEDED BY MAXJT='
     X,I4,' (=2J)')
 1011 FORMAT(/' NOTE: REDUCING MINLT TO',I3,', THAT NEEDED BY MINJT='
     X,I3,' (=2J)')
 1012 FORMAT(/' NOTE: INCREASING MINLT TO',I3,', THAT NEEDED BY MINJT='
     X,I3,' (=2J)')
 1113 FORMAT('  SYJ  2J   P')
 1114 FORMAT(1X,3I4)
 1015 FORMAT(/' NOTE: REDUCING MAXJT TO',I4,' (=2J)'
     X,', THAT NEEDED BY LVMAX=',I3)
 1016 FORMAT(/' ***WARNING: YOU HAVE SET MAXJT=',I4,' (=2J)'
     X,', LESS THAN THAT FORMALLY NEEDED BY LVMAX=',I3/22X
     X,'SET MAXJT=',I4,7X,' TO SATISFY TRIANGLE RELATION')
 1017 FORMAT(/' ***WARNING: YOU HAVE SET MINJT=',I3,' (=2J)'
     X,', GREATER THAT FORMALLY NEEDED BY LVMIN=',I3/22X
     X,'SET MINJT=',I3,7X,' TO SATISFY TRIANGLE RELATION')
 1018 FORMAT(/' NOTE: INCREASING MINJT TO',I3,' (=2J)'
     X,', THAT NEEDED BY LVMIN=',I3)
 1119 FORMAT(/'NOTE: MAX EXCHANGE L HAS BEEN INCREASED FOR 2-BODY'
     X      ,' FINE-STRUCTURE TO MAXLX=',I3)
 1120 FORMAT('***SR.ALGX ERROR: REQUESTED TOTAL 2J NOT POSSIBLE FOR '
     X      ,'THIS ATOMIC TARGET - ADD/SUBTRACT 1 TO/FROM 2J')
C
      END SUBROUTINE ALGX0
C
C                             *******************
C
      SUBROUTINE ALGXFS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,DFS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGXFS CALCULATES 2-BODY FS EIE COLLISION ALGEBRA IN LSJ-COUPLING.
C
C  IT CALLS:
C    SR.DIMUSE
C    SR.DISKDC
C    FN.QPTLSJ
C    SR.RESX1
C    SR.RESX2
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C    FN.VCC
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR,IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
      USE COMMON_NRBBBB, ONLY: BNRBBBB,BXIST0,BXIST1
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KPTCFM
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADJ
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXMI0=  1000)
      PARAMETER (MXS2I0=MAXMI0)
      PARAMETER (MXRSS0= 25000)
      PARAMETER (MXS2C0=MXRSS0)
C
      PARAMETER (TYNY=1.0D-5)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      INTEGER(SP) QPTLSJ                       !DO NOT USE SHORT INTEGER
C
      INTEGER(SP) SA,SAP
C
      CHARACTER(LEN=1) LIT
C
      INTEGER(EP) MDCF8,MDCFT8
C
      DIMENSION MAM(*),NAM(*)
      DIMENSION QLMC(MAXEL,*),QBML(*),QBMS(*),JYI(*),JYF(*),DFS(*)
C
      DIMENSION LIT(8),nej(2),mej(2)
C
      ALLOCATABLE :: BXIST2(:,:),qnf1(:)
C
      COMMON /BASIC/NF,KF,KG,J1,J2,J1P,J2P,ND1,NDP1,LL(2),NGAP
      COMMON /CMDVC/DVC12,ICLRR,BLX,BEQUALM
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL,NL000
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
C      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)     !target
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
C      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
C
      POINTER :: LI,LF
      TARGET :: LL
C
      LI=>LL(1)
      LF=>LL(2)
C
c      EQUIVALENCE (LI,LL(1)),(LF,LL(2))
C
      DATA LIT(1),LIT(2),LIT(3),LIT(4)/' ','A','B','C'/
      DATA LIT(5),LIT(6),LIT(7),LIT(8)/'*','a','b','c'/
C
C SUPPRESS COMPILER WARNINGS (SIGH...)
C
      QDUM=QBML(1)
C
C-----------------------------------------------------------------------
C
c some test set-up switches that user joe should not need to touch.
c
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                   !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
c      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NADJ(NCORJ)
c
c      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
c
      if(btimex)then
        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algxfs'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algxfs'
cpar        endif                                                   !par
        endif
        call cpu_time(timei)
        time0=timei
      endif
C
C INITIALIZATIONS
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C***
      QQCUTX=1                          !TBD (OR COULD USE TARGET QQCUT)
C***
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
CTEST CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
      ENDIF
C
      MXX=KF                               !SYMLSJ TRANSFER
      NCHMX=KG                             !  "       "
C
      NF1=NF+1
C
      NSS=JYF(KMAX)
C
      IF(KUTSSX.NE.-9)THEN                         !RESET BXIST0 FOR 2FS
        WRITE(6,102)KUTSSX                                      !WARNING
        MKT=KUTSSX
        IF((MKT+3)/2.EQ.1)MKT=1+MKT      !ALIGNS DEFAULT KUTSSX=0 AND -1
        DO KF=1,KMAX
          DO KG=1,KF
            B2BODY=.FALSE.
            IF(MKT.GE.0.AND.KF.NE.KG)GO TO 15
c            IF(KCFSSX(KF)*KCFSSX(KG).LE.0)THEN !TBD or could use target
              IF(KF.GT.ABS(MKT))GO TO 15
              IF(KG.GT.ABS(MKT))GO TO 15
c            ENDIF
            B2BODY=BXIST0(KG,KF)
   15       BXIST0(KG,KF)=B2BODY
            BXIST0(KF,KG)=B2BODY
          ENDDO
        ENDDO
      ENDIF
C
C  INASTJ0 WAS THE NUMBER OF USER INPUT SYMMETRIES, NOW RE-SET TO
C  LAST SYMMETRY THAT CONTRIBS TO MAXJFS - THUS USER INPUT SHOULD BE
C  IN ASCENDING J. DEFAULT USAGE IS MINJT,MAXJT I.E. INAST0.LE. INPUT.
C  INASTJ IS THE TOTAL NUMBER OF JP SYMMS TO BE USED.
C
      DO J=1,INASTJ
        IJ=JPI(J)/10
        IF(IJ.LE.MAXJFS)INASTJ0=J
      ENDDO
C
C EX-COMMON/DMQSS3/
C
C     IXRSS=MAX(MXRSS0,MXRSS,IXRSS)                !USE LARGEST PREVIOUS
      IXRSS=MAX(MXRSS0,MXRSS)                     !RESET
C      IAXMI=MAX(MAXMI0,MAXMI,IAXMI)               !USE LARGEST PREVIOUS
      IAXMI=MAX(MAXMI0,MAXMI)                     !RESET
C
      ALLOCATE (DSS(IXRSS),MSS(IXRSS),QSS(5,IAXMI),NADR(0:IADJ)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXFS: ALLOCATION FAILS FOR  DSS,MSS,QSS,NADR'
        NF=0
        RETURN
      ENDIF
      BDMQSS3=.TRUE.
C
C EX-COMMON/DMQSSS/
C
C        IXS2C=MAX(MXS2C0,MXS2C,IXS2C)             !USE LARGEST PREVIOUS
        IXS2C=MAX(MXS2C0,MXS2C)                   !RESET
C        IXS2I=MAX(MXS2I0,MXS2I,IXS2I)             !USE LARGEST PREVIOUS
        IXS2I=MAX(MXS2I0,MXS2I)                   !RESET
C
      ALLOCATE (DSSS(IXS2C),MSSS(IXS2C),QSSS(5,IXS2I)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXFS: ALLOCATION FAILS FOR  DSSS,MSSS,QSSS'
        NF=0
        GO TO 900
      ENDIF
C
C EX-COMMON /NSTS2/
C
      IXXX2=MAX(IXS2I,IAXMI)
      IXD27=KMAX*KMAX
      ALLOCATE (NADS2(0:IXD27),NSTJ2(IXS2C),NSTJ2D(IXS2C)
     X         ,IORIG2(IXXX2),JORIG2(IXS2I),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXFS: ALLOCATION FAILS FOR NADS2,NSTJ2, ETC'
        NF=0
        GO TO 900
      ENDIF
C
C LOCAL
C
      ALLOCATE (BXIST2(KMAX,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXFS: ALLOCATION FAILS FOR BXIST2'
        NF=0
        GO TO 900
      ENDIF
C
      ALLOCATE (qnf1(nss),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXFS: ALLOCATION FAILS FOR qnf1'
        NF=0
        GO TO 900
      ENDIF
C
c      ALLOCATE (IGRGR(MXORB))
cC
c      DO I=1,MB                                !MAXGR
c        IGRGR(I)=I                             !FOR BASIS='RLX', UNUSED
c      ENDDO
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C NOW GENERATE LSJ PARTIAL WAVE ALGEBRA, LOOPING OVER INITIAL AND FINAL
C LS CHANNELS RESOLVED BY CONTINUUM L,S=1/2 COUPLED TO TARGET SYMMETRY
C GROUPS, THEN RESOLVE BY INDIVIDUAL LEVELS.
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C
      WRITE(6,3033) KUTSSX,LIT(QQCUTX)
      WRITE(6,3050) MXADJ,MAXJG,MXSYJ,MXSYJ,MAXDK,MAXDK,IXRSS,IAXMI
C
      IF(IADJ.GT.MXADJ)THEN
        IF(MXADJ.GT.0)WRITE(6,3054)IADJ,MXADJ
      ENDIF
C
C
      KPI=0
      NL=0
      IRS=0
      MXIRSS=0
      MXNLS=0
      KPI=1
      KPIS=1
C
      NADS2(0)=0
      NADR(0)=0
      NCORJ=0
C
C-----------------------------------------------------------------------
C LOOP OVER TOTAL SYMMETRIES
C-----------------------------------------------------------------------
C
      DO KX=1,INASTJ0
C
        MTJ=JPI(KX)/10
        MTP=JPI(KX)-MTJ*10
        MTP=MTP+MTP
c
        if(mtj.gt.maxjfs)go to 99                   !case non-sequential
C
        MTMJ=MTJ
ct        if(mtj.ne.0)mtmj=mtj-2
C
c        write(0,*)kx,nadgj(kx),ncorj
        if(ncorj.ne.nadgj(kx))stop 'ncorj.ne.nadgj(kx)'!shouldn't happen
c
        INASTX=NCHGJ(KX)
C
C-----------------------------------------------------------------------
C
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'Starting proc',iam                       !par
cpar     x              ,'symmetry',kx,':',mtj,mtp/2                !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'Starting symmetry',kx,' :',mtj,mtp/2
cpar        endif                                                   !par
cparc                                                               !par
          time1=dzero
          time2=dzero
          call cpu_time(timei)
          times=timei
        endif
C
C-----------------------------------------------------------------------
C
      DO IXX=1,INASTX                  !BEGIN LOOP OVER INITIAL LS SYMMS
C
        IX=JSYMM(IXX,KX)
C
        NCN=NCHG(IX)
C
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
C                                                                 !ALIGN
        IF(MTP.NE.IP+IP)STOP 'IXX ERROR'
        MTS=IS-1
        MTL=IL+IL
C
      DO JXX=1,IXX                       !BEGIN LOOP OVER FINAL LS SYMMS
C
        JX=JSYMM(JXX,KX)
C
        NCNP=NCHG(JX)
C
        ISP=LSPI(JX)/10000
        IPP=LSPI(JX)-ISP*10000
        ILP=IPP/10
        IPP=IPP-ILP*10
C
        IF(MTP.NE.IPP+IPP)STOP 'JXX ERROR'
        MTSP=ISP-1
        MTLP=ILP+ILP
C                                                                 !ALIGN
        IF(MTSP+MTS.EQ.0)GO TO 70      !will need same test on forming H
        IF(MTLP+MTL.EQ.0)GO TO 70      !   ditto
C
        NCH=0
        NCHI=0
        NCHI0=0
c
c          write(0,*)'start algxfs',kx,ixx,jxx,ncorj
C
        DO NC0=1,NCN                     !BEGIN LOOP OVER INITIAL GROUPS
          L1=LLCH(1,NC0,IX)
          L2=LLCH(2,NC0,IX)
          NC=ITARG(NC0,IX)
          MC=NSL(NC)
          SA=QSI(NC)
          LA=QLI(NC)
          MCI=NGRPI(NC)
          ND1=NC
C                                                    !PRE-SELECT CONFIGS
          DO KK=1,KMAX
            BXIST1(KK)=KGSL(KK,NC).GT.0             !CF DOES/NOT CONTRIB
          ENDDO
C
          NCHP=0
          NCHIP=0
          NCHIP0=0
c
          if(ix.eq.jx)ncnp=nc0                             !sync with ls
C
          DO ND0=1,NCNP                    !BEGIN LOOP OVER FINAL GROUPS
            L1P=LLCH(1,ND0,JX)
            L2P=LLCH(2,ND0,JX)
            ND=ITARG(ND0,JX)
            MCP=NSL(ND)
            SAP=QSI(ND)
            IF(abs(NMETAG(NC))+abs(NMETAG(ND)).EQ.2)GO TO 69 !LS SELEC
            LAP=QLI(ND)
            MCIP=NGRPI(ND)
            NDP1=ND
C
            BEQGRP=IX.EQ.JX.AND.NC.EQ.ND                 !WITHIN A GROUP
C
            DO KF=1,KMAX                                     !INITIALIZE
              IF(BXIST1(KF))THEN
                DO KG=1,KMAX
                  BXIST2(KG,KF)=BXIST0(KG,KF)
                ENDDO
              ELSE
                DO KG=1,KMAX
                  BXIST2(KG,KF)=.FALSE.
                ENDDO
              ENDIF
            ENDDO
C                                                    !PRE-SELECT CONFIGS
            DO KG=1,KMAX
              IF(KGSL(KG,ND).LE.0)THEN              !CF DOES NOT CONTRIB
                DO KF=1,KMAX
                  BXIST2(KG,KF)=.FALSE.
                ENDDO
              ENDIF
            ENDDO
C
C------------------------------------------------------------
C  DETERMINE SLATER STATE INTERACTIONS BETWEEN GROUP CHANNELS
C------------------------------------------------------------
C
            NCHI=NCHI0
            DO LI=L1,L2,4                   !LOOP OVER INITIAL CHANNEL L
C
              lf2=l2p
              if(beqgrp)lf2=li
c
              NCHIP=NCHIP0
              DO LF=L1P,lf2,4                 !LOOP OVER FINAL CHANNEL L
C
                IRSS=0
                NLS=0
                J1=2
                beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
c
                ncorjt=qptlsj(kx,ixx,jxx,nc0,nd0,li,lf)
                if(ncorjt.ne.ncorj)then
                  write(0,*)kx,ixx,jxx,nc0,nd0,li,lf,ncorj,ncorjt
                  stop 'ncorj mis-match'
                endif
C
                KK=0
                KG2=KMAX
                DO KF=1,KMAX             !BEGIN LOOP OVER INITIAL CONFGS
C
                  IF(beqgrpl)KG2=KF
                  DO KG=1,KG2              !BEGIN LOOP OVER FINAL CONFGS
                    KK=KK+1
C
                    IF(.NOT.BXIST2(KG,KF))GO TO 733
C
                    BEQCFS=KF.EQ.KG
                    BEQUAL=BEQGRPL.AND.BEQCFS
ctest                    bequal=.false.
                    BEQUALM=BEQUAL
C
                    if(kf.ge.kg)then
                      i1=1
                      i2=2
                      K2=(KF*(KF-1))/2+KG
                    else
                      i1=2
                      i2=1
                      K2=(KG*(KG-1))/2+KF
                    endif
C
C FOR BASIS='RLX' - NOT USED SINCE NO ONE-BODY HERE...
C
c                    DO I=MB+1,MXORB
c                      IGRGR(I)=0
c                    ENDDO
cC
c                    DO I=NF,1,-1
c                      II=QCG(I,KF)
c                      DO L=NF,1,-1
c                        J=QCG(L,KG)
c                        IF(IEQ(J).EQ.IEQ(II))THEN
c                          IF(IGRGR(II).EQ.0)IGRGR(II)=J
c                        ENDIF
c                      ENDDO
c                    ENDDO
C
                    IRSS0=IRSS+1
                    NLS00=NLS
C
                    ICLRR=1
C
C-----------------------------------------------------------------------
C LOOP-OVER ALL POSSIBLE ML,MS, ML',MS' THAT FORM MTML,MTMS, MTML',MTMS'
C AND PICK-OUT THE CORRESPONDING SLATERSTATES, FOR THE KF,KG.
C-----------------------------------------------------------------------
C
                    MTMS=MTS
 611                MTML=MTMJ-MTMS
                    BLX1=MTMS.NE.-MTS.AND.MTML.NE.MTL
                    IF(MTML.LT.-MTL)GO TO 616
C
                    DVCJ1=VCC(MTL,MTS,MTJ,MTML,MTMS,MTMJ,DFS)
C
                    MTMSP=MTSP
 622                MTMLP=MTMJ-MTMSP
                    BLX2=MTMSP.NE.-MTSP.AND.MTMLP.NE.MTLP
                    IF(MTMLP.LT.-MTLP)GO TO 615
                    if(abs(mtmsp-mtms).gt.4)go to 615
C
                    DVCJ2=VCC(MTLP,MTSP,MTJ,MTMLP,MTMSP,MTMJ,DFS)
c
c                   write(6,*)mtms,mtml,mtmsp,mtmlp,mtmj,irss
C
                    QML=LA
 600                BLXL1=QML.NE.-LA
                    ML=MTML-QML
                    IF(ML.GT.LI)GO TO 615
                    IF(-ML.GT.LI)GO TO 604
                    DVCL1=VCC(LA,LI,MTL,INT(QML,SP),ML,MTML,DFS)
C
                    QMS=SA
 601                BLXS1=QMS.NE.-SA
                    MS=MTMS-QMS
                    IF(MS.GT.1)GO TO 604
                    IF(-MS.GT.1)GO TO 605
c
c                   write(6,*)sa,'1',mts,qms,ms,mtms,' x  '
c     x                      ,la,li,mtl,qml,ml,mtml
C
                    DVCS1=VCC(SA,IONE,MTS,INT(QMS,SP),MS,MTMS,DFS)
                    DVC1=DVCL1*DVCS1*DVCJ1
                    IF(ABS(DVC1).LT.TTYNY)GO TO 605
c
c                    write(6,*)sa,'1',mts,qms,ms,mtms,' xx '
c     x                       ,la,li,mtl,qml,ml,mtml
c                    write(6,*)dvcs1,dvcl1
C
                    QMLP=LAP
cls                    IF(BEQUAL)QMLP=QML
 602                BLXL2=QMLP.NE.-LAP
                    MLP=MTMLP-QMLP
                    IF(MLP.GT.LF)GO TO 605
                    IF(-MLP.GT.LF)GO TO 607
                    DVCL2=VCC(LAP,LF,MTLP,INT(QMLP,SP),MLP,MTMLP,DFS)
C
                    QMSP=SAP
cls                    IF(BEQUAL)QMSP=QMS
 603                BLXS2=QMSP.NE.-SAP
                    MSP=MTMSP-QMSP
                    IF(MSP.GT.1)GO TO 606
                    IF(-MSP.GT.1)GO TO 607
c
c                    write(6,*)sap,'1',mtsp,qmsp,msp,mtmsp,' y  '
c     x                       ,lap,lf,mtlp,qmlp,mlp,mtmlp
C
C SET POINTERS THAT SELECT SLATER STATE INTERACTIONS FOR QML & QMLP
C
                    if(beqcfs)then
                      if(qmlp.ge.qml)then
                        i1=1
                        i2=2
                      else
                        i1=2
                        i2=1
                      endif
                    endif
c
                    mej(i1)=qml/2
                    mej(i2)=qmlp/2
                    k1=kptcfm(mej(2),mej(1),k2)
                    mej(2)=mej(2)+1
                    k0=kptcfm(mej(2),mej(1),k2)+1
C
C NAM(J2) IS CONSTRUCTED TO SELECT INITIAL & FINAL STATES
C         HAVING THE CORRECT QML, QMS & QMLP,QMSP.
C
c If non-trivial time taken in this search, do a double sweep as in
c   v22.11. The coding below does seem to inhibit compiler optimization.
C
                    J2=1
                    do k=k0,k1
                      nej(i1)=kinti(k)
                      nej(i2)=kintf(k)
                      j=nej(1)
                      jp=nej(2)
                      jp0=jp
                      kp=k
 137                  IF(QBMS(J).EQ.QMS.AND.QBMS(JP).EQ.QMSP)THEN
                        J2=J2+1
                        if(j2.gt.nss)then
                          write(6,*)'sr.algxfs: mxst0/nss exceeded...'
                          write(0,*)'sr.algxfs: mxst0/nss exceeded...'
                          go to 999
                        endif
                        if(beqcfs.and.qmlp.lt.qml)kp=-kp
                        MAM(J2)=kp
                        QLMC(NF1,J)=(MS+1)/2+ML
                        if(j.ne.jp)then
                          QLMC(NF1,JP)=(MSP+1)/2+MLP
                        else
                          qnf1(jp)=(msp+1)/2+mlp
                        endif
                      ENDIF
                      if(beqcfs.and.QML.eq.QMLP.and.j.ne.jp0)then
                        jp=j
                        j=jp0
                        kp=-kp
                        go to 137
                      endif
                    enddo
c
                    IF(J2.LT.J1)GO TO 607
C
                    DVCS2=VCC(SAP,IONE,MTSP,INT(QMSP,SP),MSP,MTMSP,DFS)
                    DVC2=DVCL2*DVCS2*DVCJ2
C
                    DVC12=DVC1*DVC2
                    IF(ABS(DVC12).LT.TYNY)GO TO 607
                    IF(BEQUAL)THEN
cls                      IF(QMS.NE.QMSP)DVC12=DVC12+DVC12
cls                      IF(QML.NE.QMLP)DVC12=DVC12+DVC12
                      BEQUALM=QMS.EQ.QMSP.AND.QML.EQ.QMLP
                    ENDIF
c
c                    write(6,*)sap,'1',mtsp,qmsp,msp,mtmsp,' yy '
c     x                       ,lap,lf,mtlp,qmlp,mlp,mtmlp
c                    write(6,*)dvcs2,dvcl2
c                    write(6,*)dvc12
C
                    BLX=BLXL1.OR.BLXL2.OR.BLXS1.OR.BLXS2.OR.BLX1.OR.BLX2
C
C-------------------------------------------------------------
C CALCULATE THE SLATER-STATE INTERACTION BETWEEN CFS KF AND KG
C-------------------------------------------------------------
C
          if(btimex)call cpu_time(timei)
c
  55                CALL RESX1(QLMC,MAM,qnf1,DFS,MAXEL)
c
          if(btimex)then
            call cpu_time(timef)
            time1=time1+timef-timei
          endif
C
                    MXIRSS=MAX(MXIRSS,IRSS)
                    MXNLS=MAX(MXNLS,NLS)
                    IF(IRSS.GT.IXS2C)KPIS=0
                    IF(NLS.GT.IXS2I)KPIS=-1
                    IF(KPIS.LE.0)GO TO 619
                    IF(NF.LT.0)GO TO 999
C
                    IF(ICLRR.EQ.0)GO TO 617
C
C---------------------------------------------------------------------
C IF BLXL,S,1,2=.TRUE. THE TRANSFORMATION TO THE LS,L'S' REPRESENTATION
C                     IS NOT YET COMPLETE.
C---------------------------------------------------------------------
C
 607                QMSP=QMSP-2
                    IF(BLXS2)GO TO 603
C
 606                QMLP=QMLP-2
                    IF(BLXL2)GO TO 602
C
 605                QMS=QMS-2
                    IF(BLXS1)GO TO 601
C
 604                QML=QML-2
                    IF(BLXL1)GO TO 600
C
C--------------------------------------------------------------
C IF BLX1,2=.TRUE. THE TRANSFORMATION TO THE J,MJ REPRESENTATION
C                 IS NOT YET COMPLETE.
C--------------------------------------------------------------
C
 615                MTMSP=MTMSP-2
C
                    IF(BLX2)GO TO 622
C
 616                MTMS=MTMS-2
C
                    IF(BLX1)GO TO 611
C
C CLEAR ARRAYS, IF NOT ALREADY DONE
C
 617                IF(ICLRR.NE.0)THEN
                      ICLRR=-ICLRR
                      GO TO 55
                    ENDIF
C
 733                NADS2(KK)=IRSS
C
c        nkk=nads2(kk)-nads2(kk-1)
c        write(6,*)'***** kf,kg:',kf,kg,nkk
c        if(nkk.eq.xxx)then      !select particular value for breakpoint
c          write(0,*)'we are here'
c        endif
c        do ijk=nads2(kk-1)+1,nads2(kk)
c          write(6,777)nstj2(ijk),nstj2d(ijk),msss(ijk),dsss(ijk)
c  777  format(3i5,f12.6)
c        enddo
c        do ijk=nls00+1,nls
c          write(6,778)ijk,(qsss(lll,ijk),lll=1,5)
c  778   format(i4,2x,5i4)
c        enddo
c
                  ENDDO                                     !END LOOP KG
C
                ENDDO                                       !END LOOP KF
C
C------------------------------------------------------------------
C NOW DETERMINE THE INTERACTION BETWEEN TERMS OF THE LSP GROUPS
C------------------------------------------------------------------
C
          if(btimex)call cpu_time(timei)
c
                istrt0=0
                KF0=0
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
                  J1=MD1+MCI
          j=jndex(j1)
          if(kcutx.lt.0)j=abs(j)                      !keep corr.-corr.
                  KF=NFK(J1)
C
                  IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
                    NGSYM=KGSL(KF,NC)                     !POS WITHIN CF
                    ISTRT=MTGD1
C
                  CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
                    ISTRT0=ISTRT-MTGD1          !ALLOW FOR RE-DEFINITION
                    IF(IEND.LT.0)GO TO 999   !FAIL TO READ REQUIRED DATA
                    KF0=KF
                  ENDIF
C
                  II=NFI(J1)
                  IF(BFAST)THEN
                    J2=JTGD(II)+ISTRT0           !relative start flagged
                    do jj=jyi(kf),jyf(kf)
                      jy=j2+jj
                      if(abs(dc(jy)).lt.tyny)then
                        mam(jj)=0
                      else
                        mam(jj)=jy
                      endif
                    enddo
                  ELSE
                    do jj=jyi(kf),jyf(kf)
                      mam(jj)=0
                    enddo
                    k2=jtgd(ii)                    !absolute end flagged
                    if(k2.lt.0)then                !bdisk first
                      k2=-k2
                      k1=mtgd
                    else
                      k1=jtgd(ii-1)                !start
                      k1=abs(k1)                  !case bdisk second
                    endif
                    k1=k1+1+istrt0
                    k2=k2+istrt0
                    do k12=k1,k2
                      jj=idc(k12)
                      mam(jj)=k12
                    enddo
                  ENDIF
C
                  istrt=0
                  KG0=0
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
                    J1P=MDP1+MCIP
                    IF(beqgrpl.and.J1P.GT.J1-ione0)GO TO 11
c
          if(becor)ncorj=ncorj+1          !need for dwxbp reversed symms
c
          jp=jndex(j1p)
          if(j.lt.0.and.jp.lt.0)go to 10 !neglect corr-corr, alg or ener
C
                    KG=NFK(J1P)
C
                    IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
                      LGSYM=KGSL(KG,ND)                   !POS WITHIN CF
                      ISTRT=IEND+1
C
                  CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                      ISTRT=ISTRT-MTGD1         !ALLOW FOR RE-DEFINITION
                      IF(IFIN.LT.0)GO TO 999 !FAIL TO READ REQUIRED DATA
                      KG0=KG
                    ENDIF
C
                    II=NFI(J1P)
                    IF(BFAST)THEN                !nam not used, only mam
                      J2P=JTGD(II)+ISTRT         !relative start flagged
                    ELSE
                      do jj=jyi(kg),jyf(kg)
                        nam(jj)=0
                      enddo
                      k2=jtgd(ii)                  !absolute end flagged
                      if(k2.lt.0)then              !bdisk first
                        k2=-k2
                        k1=mtgd
                      else
                        k1=jtgd(ii-1)              !start
                        k1=abs(k1)                !case bdisk second
                      endif
                      k1=k1+1+istrt
                      k2=k2+istrt
                      do k12=k1,k2
                        jj=idc(k12)
                        nam(jj)=k12
                      enddo
                    ENDIF
C
                    IF(beqgrpl)THEN                !KG.LE.KF HERE
                      KK=(KF*(KF-1))/2 + KG
                      if(kf.lt.kg)stop 'algxfs: kf.lt.kg?'
                    ELSE
                      KK=KMAX*(KF-1)+KG
                    ENDIF
C
                    CALL RESX2(mam,nam,KK)
C
          if(.not.becor)NCORJ=NCORJ+1                  !reverse of above
C
                    IF(IRS.GT.IXRSS)KPI=0
                    IF(NL.GT.IAXMI)KPI=-1
                    IF(KPI.LE.0)GO TO 619
                    IF(NF.LT.0)GO TO 999
C
                    IF(MPRINT.GT.0)THEN
                      NCH=NCHI+MD1
                      NCHP=NCHIP+MDP1
                      IF(IRS-IRS0.EQ.5)THEN
                        WRITE(6,1201)NCORJ,KX,IX,JX,NCH,NCHP,IRS,NL,
     X                              (MSS(N),DSS(N),N=IRS0,IRS)
                      ELSEIF(IRS.GE.IRS0)THEN
                        WRITE(6,1202)NCORJ,KX,IX,JX,NCH,NCHP,IRS,NL,
     X                              (MSS(N),DSS(N),N=IRS0,IRS)
                      ENDIF
                      WRITE(6,1201)
                    ELSEIF(MPRINT.EQ.0)THEN
                      IF(NCHP.EQ.NCH)WRITE(6,130)NCORJ,KX,IX,JX,
     X                                           NCH,NCHP,IRS,NL
                    ENDIF
C
  10                NADR(NCORJ)=IRS                     !MUST BE ALLOWED
C
                  ENDDO                       !END LOOP OVER FINAL TERMS
C
  11            ENDDO                       !END LOOP OVER INITIAL TERMS
c
          if(btimex)then
            call cpu_time(timef)
            time2=time2+timef-timei
          endif
C
                NCHIP=NCHIP+MCP
              ENDDO                               !END LOOP OVER FINAL L
C
              NCHI=NCHI+MC
            ENDDO                               !END LOOP OVER INITIAL L
C
  69        NCHIP0=NCHIP0+((L2P-L1P)/4+1)*MCP   !=NCHIP
          ENDDO                              !END LOOP OVER FINAL GROUPS
C
          NCHI0=NCHI0+((L2-L1)/4+1)*MC        !=NCHI
        ENDDO                              !END LOOP OVER INITIAL GROUPS
C
  70  ENDDO                                !END LOOP OVER FINAL LS SYMMS
C
      ENDDO                              !END LOOP OVER INITIAL LS SYMMS
C
C-----------------------------------------------------------------------
C
      if(btimex)then
        call cpu_time(timef)
        times=timef-times
c
cpar        if(iam.ge.0)then                                        !par
c
c
cparc          write(iwp,*)'resx1',time1                            !par
cparc          write(iwp,*)'resx2',time2                            !par
c
cpar          write(iwp,*)'Ending proc',iam,'symmetry',kx,':'       !par
cpar     x             ,'time=',nint(times),'sec'                   !par
cpar        else                                                    !par
c
c        write(iw,*)'resx1',time1
c        write(iw,*)'resx2',time2
c
        write(iw,*)'Ending symmetry',kx,' :'
     x           ,'time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C-----------------------------------------------------------------------
C
  99  ENDDO                                 !END LOOP OVER JP SYMMETRIES
C
      IF(IADJ.NE.NCORJ)THEN
         WRITE(6,*)'GLOBAL INDEX ERROR:',IADJ,NCORJ       !remove evntly
         GO TO 999
      ENDIF
C      IADJ=NCORJ
C
      CALL DIMUSE('MXRSS',IRS)
      CALL DIMUSE('MAXMI',NL)
      CALL DIMUSE('MXS2C',MXIRSS)
      CALL DIMUSE('MXS2I',MXNLS)
C
C RESULTS
C
      IF(MPRINT.GE.0)WRITE(6,123)IXS2C,IXS2I,MXIRSS,MXNLS
      IF(MPRINT.EQ.0)GO TO 900                                   !RETURN
      IF(MPRINT.GT.0)GO TO 620
C
 619  WRITE(6,1202)NCORJ,INASTJ0,MXX,MXX,NCHMX,NCHMX,IRS,NL
      IF(KPI.LE.0)GO TO 991
C
      WRITE(6,123)IXS2C,IXS2I,MXIRSS,MXNLS
      IF(KPIS.LE.0)GO TO 9910
C
      GO TO 900                                                  !RETURN
C
 620  WRITE(6,2011)
      M197=197-LCONDWJ-3
      DO L=1,NL
        IF(QSS(5,L).GT.M197)THEN
          WRITE(6,244)L,(QSS(K,L),K=1,5)
        ELSE
          WRITE(6,2444)L,(QSS(K,L),K=1,5)
          if(qss(5,l).gt.150)stop 'N&V Index error...'
        ENDIF
      ENDDO
C
      GO TO 900                                    !RETURN
C
C PRINT FAILURE DIAGNOSTIC (DIMENSION FAILURE NOT SEPARATE)
C
 991  IF(KPI.EQ.0)WRITE(6,1203)
      IF(KPI.LT.0)WRITE(6,1204)
      GO TO 999
9910  IF(KPIS.EQ.0)WRITE(6,1205)
      IF(KPIS.LT.0)WRITE(6,1206)
C
 999  WRITE(6,190)
      NF=-1                       !<-------------------- ABNORMAL RETURN
C
 900  CONTINUE
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MAXMI)/5
      IF(BDMQSS3.AND.NL.LT.IXXX)THEN
C
c        WRITE(6,*)'*** ALGXFS: decreasing MAXMI from ',IAXMI,' to: ',NL
c        WRITE(0,*)'*** ALGXFS: decreasing MAXMI from ',IAXMI,' to: ',NL
C
        CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,NL,IERR)
C
        IAXMI=NL
C
      ENDIF
C
      IXXX=(4*MXRSS)/5
      IF(BDMQSS3.AND.IRS.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGXFS: decreasing MXRSS from ',IXRSS,' to: ',IRS
c       WRITE(0,*)'*** ALGXFS: decreasing MXRSS from ',IXRSS,' to: ',IRS
C
        CALL RE_ALLOC(DSS,IONE,IXRSS,IRS,IERR)
C
        CALL RE_ALLOC(MSS,IONE,IXRSS,IRS,IERR)
C
        IXRSS=IRS
C
      ENDIF
C
C LOCAL
      IF(ALLOCATED(BXIST2))THEN
        DEALLOCATE (BXIST2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXFS: DE-ALLOCATION FAILS FOR BXIST2'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C LOCAL
      IF(ALLOCATED(qnf1))THEN
        DEALLOCATE (qnf1,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXFS: DE-ALLOCATION FAILS FOR qnf1'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON /NSTS2/
      IF(ALLOCATED(NADS2))THEN
        DEALLOCATE (NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXFS: DE-ALLOCATION FAILS FOR NADS2,NSTJ2...'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/DMQSSS/
      IF(ALLOCATED(DSSS))THEN
        DEALLOCATE (DSSS,MSSS,QSSS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXFS: DE-ALLOCATION FAILS FOR DSSS,MSSS,QSSS'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
      if(btimex)then
        call cpu_time(timef)
        times=timef-time0
c
c        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algxfs:'           !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algxfs: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
c        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN                      !<-------------------           RETURN
C
  102 FORMAT(/' ATTENTION: FINE-STRUCTURE COLLISION ALGEBRA IS ',
     X       'RESTRICTED BETWEEN TARGET CFS AS SPECIFIED BY KUTSSX=',I4)
  123 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXS2C,MXS2I) ',I8,I6,
     X10X,'USED: ',I8,I6)
  130 FORMAT(I9,I5,2I4,2I5,I9,I6)
  190 FORMAT( ' SR.ALGXFS: FAILURE - CASE SKIPPED')
  244 FORMAT(I6,7X,4I5,I7)
 1201 FORMAT(I9,I5,2I4,2I5,I9,I6,6(I6,F9.4))
 1202 FORMAT(I9,I5,2I4,2I5,I9,I6,6(I6,F9.4)/(47X,6(I6,F9.4)))
 1203 FORMAT(' *** STORAGE MAYBE EXCEEDED IN SR.RESX2: INCREASE  MXRSS')
 1204 FORMAT(' *** STORAGE MAYBE EXCEEDED IN SR.RESX2: INCREASE  MAXMI')
 1205 FORMAT(' *** STORAGE EXCEEDED IN SR.RESX1: INCREASE  MXS2C')
 1206 FORMAT(' *** STORAGE EXCEEDED IN SR.RESX1: INCREASE  MXS2I')
 2011 FORMAT(/' REFERENCE LIST OF MAGNETIC INTEGRALS N AND V',
     X'  (EXCHANGE LAMBDA = LBD + INT(J))'
     X        /' INDEX',5X,'N(    A    B    C    D   2LBD+200)',7X,
     X 'INDEX',2X,'V(    A    B    C    D   2LBD+100)')
 2444 FORMAT(51X,I6,4X,4I5,I7)
 3033 FORMAT(//'  ALGEBRA OF THE MUTUAL SPIN-ORBIT (A), SPIN-OTHER-'
     X,'ORBIT (B) AND SPIN-SPIN (C) INTERACTIONS:',10X,'KUTSSX =',I3,A1)
 3050 FORMAT(I9,I5,2I4,2I5,I9,I6,'  STORAGE RESTRICTIONS FOR ',
     X'(MXADJ,MAXJG,MXSYJ,MXSYJ,MAXDK,MAXDK,MXRSS,MAXMI)'
     X/7X,'NP',2X,'SYJ',2X,'SY',1X,'SYP',3X,'CH',2X,'CHP',7X,
     X'CN',3X,'IND',6(3X,'I(Y)  X(A-D)'))
 3054 FORMAT('SR.ALGXFS: ALLOCATION INCREASES NUMBER OF FS MATRIX'
     X,' ELEMENTS IADJ =',I10,' .GT. MXAJS=',I10)
C
      END SUBROUTINE ALGXFS
C
C                             *******************
C
      SUBROUTINE ALGXLS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,DFS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.ALGXLS CALCULATES EIE 2-BODY NFS COLLISION ALGEBRA IN LS-COUPLING.
C    IT HAS SIMILARITIES WITH WE'S COLALG (OF COURSE).
C
C  IT CALLS:
C    SR.DIMUSE
C    SR.DISKDC
C    SR.FLGLX0
C    SR.FLGLX1
C    SR.FLGLX2
C    SR.FLGLX3
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C    FN.VCC
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DC,     ONLY: BFAST,DC,IDC
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IRLAST
     X                        ,IWORD,IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBBBB, ONLY: BNRBBBB,BXIST0,BXIST1
      USE COMMON_NRBFL0, ONLY: BNRBFL0,KINTI,KINTF,KEN2,KPTCFM,KINT
     X                        ,MPOINT,IXSTX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NRBIAD, ONLY: IADD
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXRK0=100000)
      PARAMETER (MXRKS0=MAXRK0)
      PARAMETER (MAXRL0=  2500)
      PARAMETER (MXRLS0=MAXRL0)
      PARAMETER (MXSTX0= 50000)
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-5)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      INTEGER(SP) SA,SAP
C
      INTEGER(EP) MDCF8,MDCFT8
C
      DIMENSION MAM(*),NAM(*)
      DIMENSION QLMC(MAXEL,*),QBML(*),JYI(*),QBMS(*),JYF(*),DFS(*)
     X         ,nej(2),mej(2)
C
      ALLOCATABLE :: BXIST2(:,:)
C
      COMMON /BASIC/NF,KF,KG,J1,J2,J1P,J2P,ND1,NDP1,LL(2),NGAP
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
c      COMMON /CHARY/DEY(MAXGR)
      COMMON /CMDVC/DVC12,ICLRR,BLX,BEQUALM
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /XSSADR/IRKS0,IRLS0
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MTS,MTSP,MTL,MTLP,MTP,LCONDWJ,MTJ
     X              ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
C      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
C
      POINTER :: LI,LF
      TARGET :: LL
C
      LI=>LL(1)
      LF=>LL(2)
C
c      EQUIVALENCE (LI,LL(1)),(LF,LL(2))
C
C-----------------------------------------------------------------------
C
c some test set-up switches that user joe should not need to touch.
c
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                    !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
c      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD(NCOR)
c
c      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
c
      if(btimex)then
c        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for algxls'          !par
cpar        else                                                    !par
          write(iw,*)'Starting algxls'
cpar        endif                                                   !par
c        endif
        call cpu_time(timei)
        time0=timei
      endif
C
C INITIALIZATIONS
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
      IF(KUTDSK.LT.KMAX)THEN
        IEND=MTGD                                            !FOR DISKDC
        MTGD1=MTGD+1
CTEST CALL DISKDC(IUD,IONE,IZERO,IZERO,IZERO,IZERO,IZERO)!REPOINT
      ENDIF
C
      KOLDOO=KUTOOX
      BKUTOO=KUTOOX.NE.0
      BDLBD=ABS(MODD).LT.2.OR.BKUTOO
C
      BLP=MPRINT.GT.0
C
      NSS=JYF(KMAX)
C
      NF1=NF+1
c      KSP=NF1-(NF1/2)*2                    !TEST ONLY
C
      INASTX=KF                                          !SYMLS TRANSFER
      NCHMX=KG                                           !  "       "
C
      IF(MAXLT.LT.0)THEN
        MTLO1=-1
        MTLO2=-1
      ELSE
        MTLO1=MAX(MAXLX,IONE,MINLT-1)
        MTLO1=2*MTLO1+2                         !SCALE FROM ONE L PER PI
        MTLO2=MTLO1+2
      ENDIF
C
C SET POINTERS TO ML BOUNDARIES
C
C
C EX-COMMON/NRBFL0/
C
      IXD02=QCL0/2
      IXD03=IXD02+1
      IXD19=(KMAX*(KMAX+1))/2
C
      IXSTX=MAX(MXSTX0,MXSTX)                      !RESET
      ALLOCATE (KINTI(IXSTX),KINTF(IXSTX),KEN2(IXSTX)
     X         ,KPTCFM(-IXD02:IXD03,-IXD02:IXD03,0:IXD19)
     X         ,MPOINT(-IXD02:IXD03,KMAX)
     X         ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR KPTCFM,MPOINT ETC.'
        NF=0
        GO TO 99
      ENDIF
      BNRBFL0=.TRUE.
C
      DO K=1,KMAX
        J=JYI(K)
        ML0=QBML(J)
        ML=ML0/2
        J=J-1
        DO M=IXD03,ML,-1
          MPOINT(M,K)=J
        ENDDO
        DO J=JYI(K),JYF(K)
          ML=QBML(J)
          IF(ML.LT.ML0)THEN
            ML0=ML0/2
            ML1=1+ML/2
            DO M=ML0,ML1,-1
              MPOINT(M,K)=J-1
            ENDDO
            ML0=ML
          ENDIF
        ENDDO
        ML=ML/2
        MPOINT(ML,K)=JYF(K)
        ML=ML-1
        DO M=ML,-IXD02,-1
          MPOINT(M,K)=JYF(K)
        ENDDO
      ENDDO
C
C SET-UP POINTERS TO SLATER-STATE INTERACTIONS
C
      KK=0
      KINT=0
      KPTCFM(IXD03,IXD02,1)=0
C
      DO KF=1,KMAX
        DO KG=1,KF
          KK=KK+1
C
          IF(BXIST0(KG,KF))THEN
            CALL FLGLX0(KK,QLMC,MAXEL)
            IF(NF.LE.0)GO TO 99
          ELSE
            DO M=IXD02,-IXD02,-1
              DO MP=IXD02,-IXD02,-1
                KPTCFM(MP,M,KK)=KINT
               ENDDO
            ENDDO
          ENDIF
c
c          write(0,*)'*** kg, kf, kint:',kg,kf,kint
c
          IF(KK.GT.1)KPTCFM(IXD03,IXD02,KK)=KPTCFM(-IXD02,-IXD02,KK-1)
C
          MPP=-IXD02
          DO M=IXD02-1,-IXD02,-1
            IF(KF.EQ.KG)MPP=M+1
            KPTCFM(IXD03,M,KK)=KPTCFM(MPP,M+1,KK)
c            kptcfm(ixd03,m,kk)=kptcfm(m,ixd03,kk)
          ENDDO
c
c checks and debug print (remove/comment-out eventually)
c
c          do m=ixd02,-ixd02,-1
c            if(kf.eq.kg)mpp=m
c            do mp=ixd02,mpp,-1
c              do k=kptcfm(mp+1,m,kk)+1,kptcfm(mp,m,kk)
c                if(k.gt.mxstx)stop 'increase mxstx'
c                j=kinti(k)
c                jd=kintf(k)
c                if(qbml(jd).ne.2*mp.or.qbml(j).ne.2*m)then
c                  write(6,*)kg,jd,mp,qbml(jd)/2,' cf j ml qbml',
c     x                      kf,j,m,qbml(j)/2,'    kint=',k
c                  stop 'algxls: ml-mismatch'
c               endif
c              enddo
c            enddo
c          enddo
C
        ENDDO
      ENDDO
C
      CALL DIMUSE('MXSTX',KINT)
C
      IF(KINT.GT.IXSTX)THEN                        !SHOULDN'T HAPPEN NOW
        WRITE(6,*)'SR:ALGXLS: INCREASE MXSTX TO:',KINT
        WRITE(0,*)'INCREASE MXSTX TO:',KINT
        GO TO 999
      ENDIF
C
C EX-COMMON/DXRL/
C
C      IAXRK=MAX(MAXRK0,MAXRK,IAXRK)               !USE LARGEST PREVIOUS
      IAXRK=MAX(MAXRK0,MAXRK)                     !RESET
C      IAXRL=MAX(MAXRL0,MAXRL,IAXRL)               !USE LARGEST PREVIOUS
      IAXRL=MAX(MAXRL0,MAXRL)                     !RESET
      IL=ABS(MAXLT)
C
      ALLOCATE (DRK(IAXRK),QRL(5,IAXRL),NRK(IAXRK),NAD(0:IADD)
     X         ,IRLAST(0:IL),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR  DRK,QRL,NRK,NAD'
        NF=0
        RETURN
      ENDIF
      BDXRL=.TRUE.
C
C EX-COMMON/NRBNF1/
      IRKO=1
      IF(BKUTOO)IRKO=IAXRK                                        !MXRKO
      ALLOCATE (DEK(IRKO),BFALL(IRKO),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR  DEK, BFALL'
        NF=0
        RETURN
      ENDIF
      BNRBNF1=.TRUE.
C
C EX-COMMON/DXRLS/
C
C      IXRKS=MAX(MXRKS0,MXRKS,IXRKS)               !USE LARGEST PREVIOUS
      IXRKS=MAX(MXRKS0,MXRKS)                     !RESET
C      IXRLS=MAX(MXRLS0,MXRLS,IXRLS)               !USE LARGEST PREVIOUS
      IXRLS=MAX(MXRLS0,MXRLS)                     !RESET
C
      IXROS=1
      IF(BKUTOO)IXROS=IXRKS                                       !MXROS
      ALLOCATE (DRKS(IXRKS),DEKS(IXROS),QRLS(5,IXRLS),NRKS(IXRKS)
     X         ,BFALLS(IXROS),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR  DRKS,DEKS,QRLS ETC'
        NF=0
        GO TO 99
      ENDIF
C
C EX-COMMON /NSTS/
C
      IXXXX=MAX(IXRLS,IAXRL)
      IXD27=KMAX*KMAX
      ALLOCATE (NADS(-1:IXD27),NSTJ(IXRKS),NSTJD(IXRKS)
     X         ,IORIG(IXXXX),JORIG(IXRLS),JPLANT(IXRLS),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR NADS,NSTJ,IORIG ETC'
        NF=0
        GO TO 99
      ENDIF
C
C LOCAL
      ALLOCATE (BXIST2(KMAX,KMAX),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGXLS: ALLOCATION FAILS FOR BXIST2'
        NF=0
        GO TO 99
      ENDIF
C
c      ALLOCATE (IGRGR(MXORB))
cC
c      DO I=1,MB                                !MAXGR
c        IGRGR(I)=I                             !FOR BASIS='RLX', UNUSED
c      ENDDO
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C NOW GENERATE PARTIAL WAVE ALGEBRA, LOOPING OVER INITIAL AND FINAL
C CHANNELS RESOLVED BY CONTINUUM L,S=1/2 COUPLED TO TARGET SYMMETRY
C GROUPS, THEN RESOLVE BY INDIVIDUAL TERMS.
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
      IF(.NOT.BKUTOO)
     XWRITE(6,150)MAXAD,MAXSL,MAXDI,MAXDI,IAXRK,IAXRL,MXDFS
      IF(BKUTOO)
     XWRITE(6,151)MAXAD,MAXSL,MAXDI,MAXDI,IAXRK,IAXRL,MXDFS,KUTOOX
C
      JOS=0
      J=IADD                 !NNN
      IF(IADD.GT.MAXAD)THEN
        IF(MAXAD.GT.0)WRITE(6,133)IADD,MAXAD
      ENDIF
C
      JOS=1
      IRK=0
      IRL=0
      NAD(0)=0
      NCOR=0
C
      MXIRKS=0
      MXIRLS=0
      JOSS=1
      NADS(0)=0
C
C-----------------------------------------------------------------------
C LOOP OVER TOTAL SYMMETRIES
C-----------------------------------------------------------------------
C
      DO IX=1,INASTX
C
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
c
        nwt=is
        if(il.gt.maxlx)nwt=-2*is+2
C
C-----------------------------------------------------------------------
C
        if(btimex)then
cpar          if(abs(modd).gt.1)then                                !par
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                  ,'algxls symmetry',ix,':',nwt,il,ip     !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'Starting algxls symmetry',ix,':',nwt,il,ip
cpar            endif                                               !par
cpar          endif                                                 !par
          time1=dzero
          time2=dzero
          call cpu_time(timei)
          times=timei
        endif
C
C-----------------------------------------------------------------------
C
C                                                                 !ALIGN
        MTS=IS-1
        MTL=IL+IL
        MTP=IP+IP
C
        MTML=MTL               !0                     !TEST ONLY, SLOW!!
        MTMS=MTS               !KSP          !*MUST* ADJUST VCG MS.ge.-1
C
        IF(BKUTOO.AND.IL.GT.MAXLOO)THEN
          KUTOOX=0
          BKUTOO=.FALSE.
        ENDIF
C
c        write(0,*)ix,nadg(ix),ncor
        if(ncor.ne.nadg(ix))stop 'ncor.ne.nadg(ix)'    !shouldn't happen
c
        NCN=NCHG(IX)
C
        NCHI=0
        NCHI0=0
C
        DO NC0=1,NCN                     !BEGIN LOOP OVER INITIAL GROUPS
          L1=LLCH(1,NC0,IX)
          L2=LLCH(2,NC0,IX)
          NC=ITARG(NC0,IX)
          MC=NSL(NC)
          SA=QSI(NC)
          LA=QLI(NC)
          MCI=NGRPI(NC)
          ND1=NC
C                                                    !PRE-SELECT CONFIGS
          DO KK=1,KMAX
            BXIST1(KK)=KGSL(KK,NC).GT.0             !CF DOES/NOT CONTRIB
          ENDDO
C
          NCHIP=0
          NCHIP0=0
C
          DO ND0=1,NC0                     !BEGIN LOOP OVER FINAL GROUPS
            L1P=LLCH(1,ND0,IX)
            L2P=LLCH(2,ND0,IX)
            ND=ITARG(ND0,IX)
            MCP=NSL(ND)
            SAP=QSI(ND)
            IF(ABS(SA-SAP).GT.2)GO TO 69                 !unnecessary...
            IF(NMETAG(NC)+NMETAG(ND).EQ.2)GO TO 69
            LAP=QLI(ND)
            MCIP=NGRPI(ND)
            NDP1=ND
C
            BEQGRP=NC.EQ.ND                              !WITHIN A GROUP
C
            DO KF=1,KMAX                                     !INITIALIZE
              IF(BXIST1(KF))THEN
                DO KG=1,KMAX
                  BXIST2(KG,KF)=BXIST0(KG,KF)
                ENDDO
              ELSE
                DO KG=1,KMAX
                  BXIST2(KG,KF)=.FALSE.
                ENDDO
              ENDIF
            ENDDO
C                                                    !PRE-SELECT CONFIGS
            DO KG=1,KMAX
              IF(KGSL(KG,ND).LE.0)THEN              !CF DOES NOT CONTRIB
                DO KF=1,KMAX
                  BXIST2(KG,KF)=.FALSE.
                ENDDO
              ENDIF
            ENDDO
C
C------------------------------------------------------------
C  DETERMINE SLATER STATE INTERACTIONS BETWEEN GROUP CHANNELS
C------------------------------------------------------------
C
            NCHI=NCHI0
            DO LI=L1,L2,4                   !LOOP OVER INITIAL CHANNEL L
C
              lf2=l2p
              if(beqgrp)lf2=li
c
              NCHIP=NCHIP0
              DO LF=L1P,lf2,4                 !LOOP OVER FINAL CHANNEL L
C
                IRKS=0
                IRLS=0
                JPLANT(1)=0
                J1=2
                beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
C
                KK=0
                KG2=KMAX
                DO KF=1,KMAX             !BEGIN LOOP OVER INITIAL CONFGS
C
                  IF(beqgrpl)KG2=KF
                  DO KG=1,KG2              !BEGIN LOOP OVER FINAL CONFGS
                    KK=KK+1
C
                    IF(.NOT.BXIST2(KG,KF))GO TO 733
C
                    BEQCFS=KF.EQ.KG
                    BEQUAL=BEQGRPL.AND.BEQCFS
ctest                   bequal=.false.
                    BEQUALM=BEQUAL
C
                    if(kf.ge.kg)then
                      i1=1
                      i2=2
                      K2=(KF*(KF-1))/2+KG
                    else
                      i1=2
                      i2=1
                      K2=(KG*(KG-1))/2+KF
                    endif
C
C FOR BASIS='RLX' - NOT USED SINCE NO ONE-BODY HERE...
C
c                    DO I=MB+1,MXORB
c                      IGRGR(I)=0
c                    ENDDO
cC
c                    DO I=NF,1,-1
c                      II=QCG(I,KF)
c                      DO L=NF,1,-1
c                        JJ=QCG(L,KG)
c                        IF(IEQ(JJ).EQ.IEQ(II))THEN
c                          IF(IGRGR(II).EQ.0)IGRGR(II)=JJ
c                        ENDIF
c                      ENDDO
c                    ENDDO
C
                    IRKS0=IRKS+1
                    IRLS0=IRLS
C
                    ICLRR=1
C
C-------------------------------------------------------------
C NOW LOOP-OVER ALL POSSIBLE ML,MS,ML',MS' THAT FORM MTML,MTMS
C AND PICK-OUT THE CORRESPONDING SLATERSTATES, FOR THE KF,KG.
C-------------------------------------------------------------
C
                    QML=LA
 600                BLXL1=QML.NE.-LA
                    ML=MTML-QML
                    IF(ML.GT.LI)GO TO 617
                    IF(-ML.GT.LI)GO TO 604
                    DVCL1=VCC(LA,LI,MTL,INT(QML,SP),ML,MTML,DFS)
C
                    QMS=SA
 601                BLXS1=QMS.NE.-SA
                    MS=MTMS-QMS
                    IF(MS.GT.1)GO TO 604
                    IF(-MS.GT.1)GO TO 605
c
c                   write(6,*)sa,'1',mts,qms,ms,mtms,' x  '
c     x                      ,la,li,mtl,qml,ml,mtml
C
                    DVCS1=VCC(SA,IONE,MTS,INT(QMS,SP),MS,MTMS,DFS)
                    DVC1=DVCL1*DVCS1
                    IF(ABS(DVC1).LT.TTYNY)GO TO 605
c
c                    write(6,*)sa,'1',mts,qms,ms,mtms,' xx '
c     x                       ,la,li,mtl,qml,ml,mtml
c                    write(6,*)dvcs1,dvcl1
C
                    QMLP=LAP
                    IF(BEQUAL)QMLP=QML
 602                BLXL2=QMLP.NE.-LAP
                    MLP=MTML-QMLP
                    IF(MLP.GT.LF)GO TO 605
                    IF(-MLP.GT.LF)GO TO 607
                    DVCL2=VCC(LAP,LF,MTL,INT(QMLP,SP),MLP,MTML,DFS)
C
                    QMSP=SAP
                    IF(BEQUAL)QMSP=QMS
 603                BLXS2=QMSP.NE.-SAP
                    MSP=MTMS-QMSP
                    IF(MSP.GT.1)GO TO 606
                    IF(-MSP.GT.1)GO TO 607
c
c                    write(6,*)sap,'1',mts,qmsp,msp,mtms,' y  '
c     x                       ,lap,lf,mtl,qmlp,mlp,mtml
C
C SET POINTERS THAT SELECT SLATER STATE INTERACTIONS FOR QML & QMLP
C
                    if(beqcfs)then
                      if(qmlp.ge.qml)then
                        i1=1
                        i2=2
                      else
                        i1=2
                        i2=1
                      endif
                    endif
c
                    mej(i1)=qml/2
                    mej(i2)=qmlp/2
                    k1=kptcfm(mej(2),mej(1),k2)
                    mej(2)=mej(2)+1
                    k0=kptcfm(mej(2),mej(1),k2)+1
C
C MAM(J2) IS CONSTRUCTED TO SELECT INITIAL & FINAL STATES
C         HAVING THE CORRECT QML, QMS & QMLP,QMSP.
C
c If non-trivial time taken in this search, do a double sweep as in
c   v22.11. The coding below does seem to inhibit compiler optimization.
C
c              write(6,*)qml,qms,' ml ms ',qmlp,qmsp,'   k0 k1  ',k0,k1
c
                    J2=1
                    do k=k0,k1
                      nej(i1)=kinti(k)
                      nej(i2)=kintf(k)
                      j=nej(1)
                      jp=nej(2)
                      jj=jp
                      kp=k
 137                  IF(QBMS(J).EQ.QMS.AND.QBMS(JP).EQ.QMSP)THEN
                        J2=J2+1
                        if(j2.gt.nss)then
                          write(6,*)'sr.algxls: mxst0/nss exceeded...'
                          write(0,*)'sr.algxls: mxst0/nss exceeded...'
                          go to 999
                        endif
                        if(beqcfs.and.qmlp.lt.qml)kp=-kp
                        MAM(J2)=kp
                        QLMC(NF1,J)=(MS+1)/2+ML
                        QLMC(NF1,JP)=(MSP+1)/2+MLP
                      ENDIF
                      if(beqcfs.and.QML.eq.QMLP.and.j.ne.jj)then
                        jp=j
                        j=jj
                        kp=-kp
                        go to 137
                      endif
                    enddo
c
                    IF(J2.LT.J1)GO TO 607
C
                    DVCS2=VCC(SAP,IONE,MTS,INT(QMSP,SP),MSP,MTMS,DFS)
                    DVC2=DVCL2*DVCS2
C
                    DVC12=DVC1*DVC2
                    IF(ABS(DVC12).LT.TYNY)GO TO 607
                    IF(BEQUAL)THEN
                      IF(QMS.NE.QMSP)DVC12=DVC12+DVC12
                      IF(QML.NE.QMLP)DVC12=DVC12+DVC12
                      BEQUALM=QMS.EQ.QMSP.AND.QML.EQ.QMLP
                    ENDIF
c
c                    write(6,*)sap,'1',mts,qmsp,msp,mtms,' yy '
c     x       x               ,lap,lf,mtl,qmlp,mlp,mtml
c                    write(6,*)dvcs2,dvcl2
c                    write(6,*)dvc12
C
                    BLX=BLXL1.OR.BLXL2.OR.BLXS1.OR.BLXS2
C
C-------------------------------------------------------------
C CALCULATE THE SLATER-STATE INTERACTION BETWEEN CFS KF AND KG
C-------------------------------------------------------------
C
          if(btimex)call cpu_time(timei)
c
  55                CALL FLGLX1(QLMC,MAM,DFS,MAXEL)
c
          if(btimex)then
            call cpu_time(timef)
            time1=time1+timef-timei
          endif
C
                    MXIRKS=MAX(MXIRKS,IRKS)
                    MXIRLS=MAX(MXIRLS,IRLS)
                    IF(IRLS.GT.IXRLS)JOSS=-1
                    IF(IRKS.GT.IXRKS)JOSS=0
                    IF(JOSS.LE.0)GO TO 67      !DIMENSION EXCEEDED
                    IF(NF.LE.0)GO TO 999
C
                    IF(ICLRR.EQ.0)GO TO 617
C
C---------------------------------------------------------------
C IF BLX=.TRUE. THE TRANSFORMATION TO THE LS,L'S' REPRESENTATION
C              IS NOT YET COMPLETE.
C---------------------------------------------------------------
C
 607                QMSP=QMSP-2
                    IF(BLXS2)GO TO 603
C
 606                QMLP=QMLP-2
                    IF(BLXL2)GO TO 602
C
 605                QMS=QMS-2
                    IF(BLXS1)GO TO 601
C
 604                QML=QML-2
                    IF(BLXL1)GO TO 600
C
C CLEAR ARRAYS, IF NOT ALREADY DONE
C
 617                IF(ICLRR.NE.0)THEN
                      ICLRR=-ICLRR
                      GO TO 55
                    ENDIF
C
 733                NADS(KK)=IRKS
C
c        write(6,*)'***** kf,kg:',kf,kg,nads(kk)-nads(kk-1)
c        do ijk=nads(kk-1)+1,nads(kk)
c          write(6,777)nstj(ijk),nstjd(ijk),nrks(ijk),drks(ijk)
c  777  format(3i5,f12.6)
c        enddo
c        do ijk=1,irls
c          write(6,778)ijk,(qrls(lll,ijk),lll=1,5)
c  778   format(i4,2x,5i4)
c        enddo
                  ENDDO                                     !END LOOP KG
C
                ENDDO                                       !END LOOP KF
C
C------------------------------------------------------------------
C NOW DETERMINE THE INTERACTION BETWEEN TERMS OF THE LSP GROUPS
C------------------------------------------------------------------
C
          if(btimex)call cpu_time(timei)
c
                istrt0=0
                KF0=0
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(kcutx.lt.0)j=abs(j)              !keep corr.-corr.
                  KF=NFK(J1)
C
                  IF(KF.GT.KUTDSK.AND.KF.NE.KF0)THEN
                    NGSYM=KGSL(KF,NC)                     !POS WITHIN CF
                    ISTRT=MTGD1
C
                  CALL DISKDC(IUD,ISTRT,IEND,KF,NGSYM,IONE,IZERO)
C
                    ISTRT0=ISTRT-MTGD1          !ALLOW FOR RE-DEFINITION
                    IF(IEND.LT.0)GO TO 999   !FAIL TO READ REQUIRED DATA
                    KF0=KF
                  ENDIF
C
                  II=NFI(J1)
                  IF(BFAST)THEN
                    J2=JTGD(II)+ISTRT0           !relative start flagged
                    do jj=jyi(kf),jyf(kf)
                      jx=j2+jj
                      if(abs(dc(jx)).lt.tyny)then
                        mam(jj)=0
                      else
                        mam(jj)=jx
                      endif
                    enddo
                  ELSE
                    do jj=jyi(kf),jyf(kf)
                      mam(jj)=0
                    enddo
                    k2=jtgd(ii)                    !absolute end flagged
                    if(k2.lt.0)then                !bdisk first
                      k2=-k2
                      k1=mtgd
                    else
                      k1=jtgd(ii-1)                !start
                      k1=abs(k1)                  !case bdisk second
                    endif
                    k1=k1+1+istrt0
                    k2=k2+istrt0
                    do k12=k1,k2
                      jj=idc(k12)
                      mam(jj)=k12
                    enddo
                  ENDIF
C
                  istrt=0
                  KG0=0
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
                    J1P=MDP1+MCIP
                    IF(beqgrpl.and.J1P.GT.J1-ione0)GO TO 11
c
                    jp=jndex(j1p)
                    if(j.lt.0.and.jp.lt.0)then      !neglect corr.-corr.
                      if(becor)then
                        ncor=ncor+1  !needed for bp, but not strictly ls
                        go to 10
                      endif
                      go to 11
                    endif
C
                    KG=NFK(J1P)
C
                    IF(KG.GT.KUTDSK.AND.KG.NE.KG0)THEN
                      LGSYM=KGSL(KG,ND)                   !POS WITHIN CF
                      ISTRT=IEND+1
C
                  CALL DISKDC(IUD,ISTRT,IFIN,KG,LGSYM,IONE,IZERO)
C
                      ISTRT=ISTRT-MTGD1         !ALLOW FOR RE-DEFINITION
                      IF(IFIN.LT.0)GO TO 999 !FAIL TO READ REQUIRED DATA
                      KG0=KG
                    ENDIF
C
                    II=NFI(J1P)
                    IF(BFAST)THEN
                      J2P=JTGD(II)+ISTRT         !relative start flagged
c                      do jj=jyi(kg),jyf(kg)  !slower, no gain in flglx2
c                        if(abs(dc(j2p+jj)).lt.tyny)then
c                          nam(jj)=0
c                        else
c                          nam(jj)=j2p+jj
c                        endif
c                      enddo
                    ELSE
                      do jj=jyi(kg),jyf(kg)
                        nam(jj)=0
                      enddo
                      k2=jtgd(ii)                  !absolute end flagged
                      if(k2.lt.0)then              !bdisk first
                        k2=-k2
                        k1=mtgd
                      else
                        k1=jtgd(ii-1)              !start
                        k1=abs(k1)                !case bdisk second
                      endif
                      k1=k1+1+istrt
                      k2=k2+istrt
                      do k12=k1,k2
                        jj=idc(k12)
                        nam(jj)=k12
                      enddo
                    ENDIF
C
                    IF(beqgrpl)THEN                       !KG.LE.KF HERE
                      KK=(KF*(KF-1))/2 + KG
                      if(kf.lt.kg)stop 'algxls: kf.lt.kg?'
                    ELSE
                      KK=KMAX*(KF-1)+KG
                    ENDIF
C
                    CALL FLGLX2(mam,nam,KK)
C
                    NCOR=NCOR+1                        !reverse of above
C
                    IF(IRL.GT.IAXRL)JOS=-1
                    IF(IRK.GT.IAXRK)JOS=0
                    IF(JOS.LE.0)GO TO 67             !DIMENSION EXCEEDED
                    IF(NF.LE.0)GO TO 999
C
                    IF(BLP)THEN                        !.AND.IRK.GE.IRK0
                      NCH=NCHI+MD1
                      NCHP=NCHIP+MDP1
                      IF(IRK-IRK0.NE.5)THEN
                        WRITE(6,120)NCOR,IX,NCH,NCHP,IRK,IRL
     X                            ,(NRK(I),DRK(I),I=IRK0,IRK)
                      ELSE
                        WRITE(6,119)NCOR,IX,NCH,NCHP,IRK,IRL
     X                            ,(NRK(I),DRK(I),I=IRK0,IRK)
                      ENDIF
                      IF(BKUTOO)WRITE(6,121)(NRK(I),DEK(I),I=IRK0,IRK)
                      WRITE(6,120)
                    ENDIF
C
c                  write(72,*)ix,md1,mdp1,j,jp,ncor,irk
  10                NAD(NCOR)=IRK
C
                ENDDO                       !END LOOP OVER FINAL TERMS
C
  11            ENDDO                       !END LOOP OVER INITIAL TERMS
c
          if(btimex)then
            call cpu_time(timef)
            time2=time2+timef-timei
          endif
C
                NCHIP=NCHIP+MCP
              ENDDO                               !END LOOP OVER FINAL L
C
              NCHI=NCHI+MC
            ENDDO                               !END LOOP OVER INITIAL L
C
  69        NCHIP0=NCHIP0+((L2P-L1P)/4+1)*MCP   !=NCHIP
          ENDDO                              !END LOOP OVER FINAL GROUPS
C
          NCHI0=NCHI0+((L2-L1)/4+1)*MC        !=NCHI
        ENDDO                              !END LOOP OVER INITIAL GROUPS
C
        IRLAST(IL)=IRL                         !POINT TO END FOR THIS IL
C
        IF(MTL.LT.MTLO1)NCOR1=NCOR
        IF(MTL.LT.MTLO2)NCOR2=NCOR
C
        KUTOOX=KOLDOO
        BKUTOO=KUTOOX.NE.0
C
C-----------------------------------------------------------------------
C
        if(btimex)then
          call cpu_time(timef)
          times=timef-times
c
cpar          if(abs(modd).gt.1)then                                !par
c
cpar            if(iam.ge.0)then                                    !par
c
cparc              write(iwp,*)'flglx1',time1                       !par
cparc              write(iwp,*)'flglx2',time2                       !par
c
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                 ,'algxls symmetry',ix,':',' nchan=',nchi !par
cpar     x                 ,'time=',nint(times),'sec'               !par
cpar            else                                                !par
c
c              write(iw,*)'flglx1',time1
c              write(iw,*)'flglx2',time2
c
            write(iw,*)'Ending algxls symmetry ',ix,':',' nchan=',nchi
     x               ,'time=',nint(times),'sec'
cpar            endif                                               !par
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C
      ENDDO                                    !END LOOP OVER SYMMETRIES
C
C
C-------------------------------------------------------------------
C
C NOW EXCHANGE CAN BE NEGLECTED, ADD-IN HIGHER-L DIRECT VIA SYMMETRY
C RELATION.
C
C-------------------------------------------------------------------
C
      MTLN=0
      IFLAG1=0
      IFLAG2=0
C
      DO IX=INASTX+1,INAST
C
        if(btimex.and.ix.eq.inastx+1)then
c
cpar        if(abs(modd).gt.1)then                                  !par
cpar          if(iam.ge.0)then                                      !par
cpar            write(iw,*)'Proc',iam                               !par
cpar     x                ,'Scaling loop:',mtlo1/2,mtlo2/2          !par
cpar          else                                                  !par
c
          write(iw,*)'Scaling loop:',mtlo1/2,mtlo2/2
cpar          endif                                                 !par
cpar        endif                                                   !par
        endif
C
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
c
        if(btimex)then
cpar        if(abs(modd).gt.1)then                                  !par
          write(iw,*)'Symmetry ',ix,':',-2*is+2,il,ip
cpar        endif                                                   !par
        endif
C                                                                 !ALIGN
        MTS=IS-1
        MTL=IL+IL
        MTP=IP+IP
C
        IF(BKUTOO.AND.IL.GT.MAXLOO)THEN
          KUTOOX=0
          BKUTOO=.FALSE.
          CALL DIMUSE('MXRKO',IRK)
          CALL DIMUSE('MXRLO',IRL)
          CALL DIMUSE('MXROS',MXIRKS)
        ENDIF
C
        IF(MTL.GT.MTLN)THEN
          MTLN=MTL
          IF(MOD(MTLO1,IFOUR).EQ.MOD(MTL,IFOUR))THEN
            IFLAG1=ABS(IFLAG1)+1
            IFLAG2=-ABS(IFLAG2)
            NCORX=NCOR1
            MTLO=MTLO1
          ELSEif(mod(mtlo2,ifour).eq.mod(mtl,ifour))then
            IFLAG2=ABS(IFLAG2)+1
            IFLAG1=-ABS(IFLAG1)
            NCORX=NCOR2
            MTLO=MTLO2
          else
            stop 'algxls: index error on flgl symmetry set-up'
          ENDIF
        ENDIF
C
c        write(0,*)ix,nadg(ix),ncor
        if(ncor.ne.nadg(ix))stop 'nx ncor.ne.nadg(ix)' !shouldn't happen
c
        NCN=NCHG(IX)
C
        NCHI=0
        NCHI0=0
C
        DO NC0=1,NCN                     !BEGIN LOOP OVER INITIAL GROUPS
          L1=LLCH(1,NC0,IX)
          L2=LLCH(2,NC0,IX)
          NC=ITARG(NC0,IX)
          MC=NSL(NC)
          SA=QSI(NC)
          LA=QLI(NC)
          MCI=NGRPI(NC)
C
          NCHIP=0
          NCHIP0=0
C
          DO ND0=1,NC0                     !BEGIN LOOP OVER FINAL GROUPS
            L1P=LLCH(1,ND0,IX)
            L2P=LLCH(2,ND0,IX)
            ND=ITARG(ND0,IX)
            MCP=NSL(ND)
            SAP=QSI(ND)
            IF(ABS(SA-SAP).GT.2)GO TO 68   !unnecessary...
            IF(NMETAG(NC)+NMETAG(ND).EQ.2)GO TO 68
            LAP=QLI(ND)
            MCIP=NGRPI(ND)
            BEQGRP=NC.EQ.ND                             !WITHIN A GROUP
C
            NCHI=NCHI0
            DO LI=L1,L2,4                   !LOOP OVER INITIAL CHANNEL L
C
              lf2=l2p
              if(beqgrp)lf2=li
c
              NCHIP=NCHIP0
              DO LF=L1P,Lf2,4                 !LOOP OVER FINAL CHANNEL L
c
                beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(kcutx.lt.0)j=abs(j)              !keep corr.-corr.
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
                    J1P=MDP1+MCIP
                    IF(beqgrpl.and.J1P.GT.J1-ione0)GO TO 13
c
                    jp=jndex(j1p)
                    if(j.lt.0.and.jp.lt.0)then      !neglect corr.-corr.
                      if(becor)then
                        ncor=ncor+1
                        ncorx=ncorx+1
                        go to 12
                      endif
                      go to 13
                    endif
C
                    NCORX=NCORX+1
                    if(ncor+1.eq.iadd)ncorx=-ncorx            !flag last
C
                    CALL FLGLX3(IFLAG1,IFLAG2,LA,LAP,LI,LF,MTL,MTLO
     X                         ,NCORX,DFS)
C
                    NCOR=NCOR+1
C
                    IF(IRL.GT.IAXRL)JOS=-1
                    IF(IRK.GT.IAXRK.OR.NCORX.EQ.0)JOS=0
                    IF(JOS.LE.0)GO TO 67             !DIMENSION EXCEEDED
                    IF(NF.LE.0)GO TO 999
C
                    IF(BLP)THEN                        !.AND.IRK.GE.IRK0
                      NCH=NCHI+MD1
                      NCHP=NCHIP+MDP1
                      IF(IRK-IRK0.NE.5)THEN
                        WRITE(6,120)NCOR,IX,NCH,NCHP,IRK,IRL
     X                            ,(NRK(I),DRK(I),I=IRK0,IRK)
                      ELSE
                        WRITE(6,119)NCOR,IX,NCH,NCHP,IRK,IRL
     X                            ,(NRK(I),DRK(I),I=IRK0,IRK)
                      ENDIF
                      IF(BKUTOO)WRITE(6,121)(NRK(I),DEK(I),I=IRK0,IRK)
                      WRITE(6,120)
                    ENDIF
C
c                                   write(72,*)ix,md1,mdp1,j,jp,ncor,irk
  12                NAD(NCOR)=IRK
C
                  ENDDO                       !END LOOP OVER FINAL TERMS
C
  13            ENDDO                       !END LOOP OVER INITIAL TERMS
C
                NCHIP=NCHIP+MCP
              ENDDO                               !END LOOP OVER FINAL L
C
              NCHI=NCHI+MC
            ENDDO                               !END LOOP OVER INITIAL L
C
  68        NCHIP0=NCHIP0+((L2P-L1P)/4+1)*MCP   !=NCHIP
          ENDDO                              !END LOOP OVER FINAL GROUPS
C
          NCHI0=NCHI0+((L2-L1)/4+1)*MC        !=NCHI
        ENDDO                              !END LOOP OVER INITIAL GROUPS
C
        IRLAST(IL)=IRL                         !POINT TO END FOR THIS IL
C
        KUTOOX=KOLDOO
        BKUTOO=KUTOOX.NE.0
C
      ENDDO                                 !END LOOP OVER NX SYMMETRIES
C
C RESULTS
C
      IF(IADD.NE.NCOR)THEN
        WRITE(6,*)'SR.ALGXLS: GLOBAL INDEX ERROR:',IADD,NCOR       !test
        GO TO 999
      ENDIF
c      write(0,*)iadd
C      IADD=NCOR
C
C
      CALL DIMUSE('MAXRK',IRK)
      CALL DIMUSE('MAXRL',IRL)
      CALL DIMUSE('MXRKS',MXIRKS)
      CALL DIMUSE('MXRLS',MXIRLS)
C
      IF(BKUTOO)THEN
        CALL DIMUSE('MXRKO',IRK)
        CALL DIMUSE('MXRLO',IRL)
        CALL DIMUSE('MXROS',MXIRKS)
      ENDIF
C
  67  IF(.NOT.BLP.OR.JOS.LE.0.OR.JOSS.LE.0)THEN
        WRITE(6,120)NCOR,INAST,NCHMX,NCHMX,IRK,IRL
        IF(JOS.LT.0)GO TO 92
        IF(JOS.EQ.0)GO TO 95
        WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS,mxstx,kint
        IF(JOSS.LT.0)GO TO 93
        IF(JOSS.EQ.0)GO TO 89
        WRITE(6,900)MPRINT
      ELSE
C
C PRINT SLATER INTEGRAL (ADRESS REFERENCE) LIST
C
        WRITE(6,122)IXRKS,IXRLS,MXIRKS,MXIRLS,mxstx,kint
        IF(IRL.GT.0)THEN
          IF(BKUTOO)WRITE(6,301)KUTOOX
          IF(.NOT.BKUTOO)WRITE(6,300)
          DO  L=1,IRL
            WRITE(6,700)L,(QRL(I,L), I=1,5)
          ENDDO
        ENDIF
      ENDIF
C
      GO TO 99                                                   !RETURN
C
C     E R R O R   M E S S A G E S
C
  95  WRITE(6,188)
      IF(IRL.LE.IAXRL)GO TO 999
  92  WRITE(6,192)
  93  WRITE(6,193)
      GO TO 999
  89  WRITE(6,189)
C
 999  WRITE(6,190)
      NF=-1                                                       !ABORT
C
  99  CONTINUE
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MAXRL)/5
      IF(BDXRL.AND.IRL.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGXLS: decreasing MAXRL from ',IAXRL,' to: ',IRL
c       WRITE(0,*)'*** ALGXLS: decreasing MAXRL from ',IAXRL,' to: ',IRL
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IRL,IERR)
C
        IAXRL=IRL
C
      ENDIF
C
      IXXX=(4*MAXRK)/5
      IF(BDXRL.AND.IRK.LT.IXXX)THEN
C
c       WRITE(6,*)'*** ALGXLS: decreasing MAXRK from ',IAXRK,' to: ',IRK
c       WRITE(0,*)'*** ALGXLS: decreasing MAXRK from ',IAXRK,' to: ',IRK
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IRK,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEK,IONE,IAXRK,IRK,IERR)           !KEEP IN SYNC
          CALL RE_ALLOC(BFALL,IONE,IAXRK,IRK,IERR)         !KEEP IN SYNC
        ENDIF
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IRK,IERR)
C
        IAXRK=IRK
C
      ENDIF
C
C LOCAL
      IF(ALLOCATED(BXIST2))THEN
        DEALLOCATE (BXIST2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXLS: DE-ALLOCATION FAILS FOR BXIST2'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(NADS))THEN
        DEALLOCATE (NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXLS: DE-ALLOCATION FAILS FOR NADS,NSTJ, ETC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(DRKS))THEN
        DEALLOCATE (DRKS,DEKS,QRLS,NRKS,BFALLS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'ALGXLS: DE-ALLOCATION FAILS FOR DRKS,DEKS, ETC'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
      if(btimex)then
        call cpu_time(timef)
        times=timef-time0
c
C        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for algxls:'           !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending algxls: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
C        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
  119 FORMAT(I8,I3, 2I5, I8,I5, 6(I6,F11.6))
  120 FORMAT(I8,I3, 2I5, I8,I5, 6(I6,F11.6)/(34X,6(I6,F11.6)))
  121 FORMAT((34X,6(I6,F11.6)))
  122 FORMAT(/' SLATER STATE INTERACTION STORAGE (MXRKS,MXRLS) ',I8,I6,
     X10X,'USED: ',I8,I6/34X,'(MXSTX)',7X,I8,16X,'USED: ',I8)
  133 FORMAT('SR.ALGXLS: ALLOCATION INCREASES NUMBER OF LS MATRIX'
     X,' ELEMENTS IADD =',I10,' .GT. MAXAD =',I10)
  150 FORMAT(//'  SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING  '
     X,'( CH !  H  ! CHP ) = SUM( F(A,...) * R(A,...) )'
     X/I8,I3,2I5,I8,I5,' STORAGE RESTRICTIONS FOR '
     X,'(MAXAD,MAXSL,MAXDI,MAXDI,MAXRK,MAXRL), MXDFS=',I3/
     X '    NCYC SY   CH  CHP     MNF  MNR',6(3X,'I(R)  F(A,...)'))
  151 FORMAT(//'  SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING  '
     X,'( CH !  H  ! CHP ) = SUM( F(A,...) * R(A,...) )'
     X/I8,I3,2I5,I8,I5,' STORAGE RESTRICTIONS FOR '
     X,'(MAXAD,MAXSL,MAXDI,MAXDI,MAXRK,MAXRL), MXDFS=',I3,
     X5X,'***** KUTOOX=',I2,' *****'
     X/ '    NCYC SY   CH  CHP     MNF  MNR',6(3X,'I(R)  F(A,...)'))
  188 FORMAT(/' SR.ALGXLS: *MAXRK TOO SMALL, ARRAYS DRK AND NRK ')
  189 FORMAT(/' SR.ALGXLS: *MXRKS TOO SMALL, ARRAYS DRKS AND NRKS ')
  190 FORMAT( ' SR.ALGXLS: FAILURE - CASE SKIPPED')
  192 FORMAT(/' SR.ALGXLS: *MAXRL TOO SMALL, ARRAYS DRL AND QRL')
  193 FORMAT(/' SR.ALGXLS: *MXRLS TOO SMALL, ARRAYS DRLS AND QRLS')
  300 FORMAT(/ ' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS '
     X,' REFERENCE LIST  (EXCHANGE LAMBDA = LBD + LTOT)')
  301 FORMAT(//' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS'
     X,' AND ETA( A, B, C, D, 2LBD) REFERENCE LIST (LBDX=LBD+LTOT),'
     X,' KUTOOX=',I2)
  700 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,2F19.5, 6X,2I4, 5X,'E',I1,I6)
  900 FORMAT(/ ' *** PRINTOUT OF COEFFICIENTS SUPPRESSED - MPRINT'
     X,'(MODULO 5)=',I2/)
C
      END SUBROUTINE ALGXLS
C
C                             *******************
C
      FUNCTION ARGAM(EL,A)
C
C-----------------------------------------------------------------------
C
C  BADNELL & BURGESS D.A.M.T.P. CAMBRIDGE
C
C  FN.ARGAM CALCULATES ARGGAMMA(EL+1+I*A),
C  WHERE EL+1 IS NOT LESS THAN ZERO
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D21=DSEVEN*DTHREE)
      PARAMETER (D210=D21*DTEN)
      PARAMETER (D250=DFIVE*DFIVE*DTEN)
      PARAMETER (D2520=D250*DTEN+D20)
      PARAMETER (D35=DSEVEN*DFIVE)
      PARAMETER (D45=DNINE*DFIVE)
      PARAMETER (D63=DNINE*DSEVEN)
      PARAMETER (D105=D100+DFIVE)
      PARAMETER (D315=DTHREE*D105)
C
      F=ABS(A)
      F=D250*F**DQUART-A*A
      J1=0
      C=EL+DONE
      D=C*C
      Z=DZERO
C
      IF(D.LT.F)THEN
        F=SQRT(F)
        J1=INT(F-C+DONE)
C
        DO J=1,J1
          D=J-1
          D=C+D
          D=A/D
          D1=ABS(D)
          IF(D1.LT.D1M1)THEN
            D1=D*D
            D2=-D35*D1+D45
            D2=-D1*D2+D63
            D2=-D1*D2+D105
            D1=D-D*D1*D2/D315
          ELSE
            D1=ATAN (D)
          ENDIF
          Z=Z+D1
        ENDDO
      ENDIF
C
      D=J1
      D=C+D
      D0=D*D
      U=A*A
      D1=DONE/(D0+U)
      D2=D1*D1
      D3=DTEN*D0*D0-D20*D0*U+DTWO*U*U
      D3=D3*D2-D21*D0+DSEVEN*U
      D3=D3*D2+D210
      D1=A*D3*D1/D2520
C
      ARGAM=-Z+DHALF*A*LOG(D0+U)+(D-DHALF)*ATAN(A/D)-A-D1
C
      RETURN
C
      END FUNCTION ARGAM
C
C                   ***********ASYMPTOPIA***********
C
      SUBROUTINE ASS2PX(X1,H,X,F0,F1,P0,P1,G0,G1,EI0,EJ0,CI0,CJ0,QI,QJ
     X,UI,UJ,Z0,NI,REM)
C
C-----------------------------------------------------------------------
C
C  BADNELL AND BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.ASS2PX CALCS LONG RANGE INTEGRAL OUT TO POINT WHERE CAN USE AMP.-
C  PHASE METHOD IN SR.ASSX. MODIFIED VERSION OF A. BURGESS'S SR.ASS2.
C  THIS VERSION EVALUATES INTEGRAL G*P WHERE P IS THE DERIVATIVE OF F.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) QI,QJ
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D5M4=DFIVE*D1M4)
C
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      TKIJ=ABS(SQRT(EI0)-SQRT(EJ0))
      TEST=(DONE-Z0)*D5M4
      T=DONE
      IF(NI.LE.-1)T=D100
      IF(TKIJ.LT.TEST/T)TKIJ=D1P6
COLD      TEST=TEST*DTEN
      IF(TKIJ.LT.TEST)TKIJ=TEST
c
      if(-z0.lt.d5m4)then
        eztst=d100
      elseif(ei0/z0**2.lt.d5m4)then
        eztst=-d5m4*z0
      else
        eztst=-ei0/z0
      endif
C
      HH=H*H
      H1=HH/DTWELV
      REM=DZERO
      X=X1
      A3=P1*G1*X**NI
C
      IF(BREL)THEN
        EI=EI0+DQUART*DALF*EI0*EI0
        EJ=EJ0+DQUART*DALF*EJ0*EJ0
        ZI=Z0+DHALF*DALF*Z0*EI0
        ZJ=Z0+DHALF*DALF*Z0*EJ0
        CI=CI0-DALF*Z0*Z0
        CJ=CJ0-DALF*Z0*Z0
C CHANGE NORM BACK TO THAT OF ORIGINAL EQUATION/SOLUTION: 1+(E+V)*D4
C (LIKELY OVER-KILL SINCE UNAFFECTED BY A CONSTANT FACTOR, ONLY ANY
C  REMAINING ASYMPTOTIC R-DEPENDENCE - SET BNORM=.TRUE. TO TEST.)
        BNORM=.FALSE.                           !.TRUE.        !TEST
        IF(BNORM)THEN
          D4=DQUART*DALF
          Z2=Z0+Z0
          T0=DONE/(X-H)
          TF0=DONE+D4*(EI0-Z2*T0)
          TG0=DONE+D4*(EJ0-Z2*T0)
          TF0=SQRT(TF0)
          TG0=SQRT(TG0)
          F0=F0/TF0
          P0=P0/TF0                                  !NEGLECT F0
          G0=G0/TG0
          T1=DONE/X
          TF1=DONE+D4*(EI0-Z2*T1)
          TG1=DONE+D4*(EJ0-Z2*T1)
          TF1=SQRT(TF1)
          TG1=SQRT(TG1)
          F1=F1/TF1
          P1=P1/TF1
          G1=G1/TG1
        ENDIF
      ELSE
        EI=EI0
        EJ=EJ0
        ZI=Z0
        ZJ=Z0
        CI=CI0
        CJ=CJ0
        BNORM=.FALSE.
      ENDIF
C
      ZI2=ZI+ZI
      ZJ2=ZJ+ZJ
      CI2=CI+CI
      CJ2=CJ+CJ
C
      T=DONE/(X-H)
      VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
      V0=VI
      U0=-F0*(ZI2+CI2*T)*T*T
      VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
      TI=F0*(DONE+VI*H1)
      TJ=G0*(DONE+VJ*H1)
      T=DONE/X
      VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
      VP=VI
      UP=-F1*(ZI2+CI2*T)*T*T
      VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
      TI=(DONE+H1*VI)*F1-TI
      TJ=(DONE+H1*VJ)*G1-TJ
      AI=F1*(DONE+H1*VI)
      AJ=G1*(DONE+H1*VJ)
C
   1  DO I=1,2
        TI=TI-HH*VI*F1
        TJ=TJ-HH*VJ*G1
        AI=AI+TI
        AJ=AJ+TJ
        X=X+H
        T=DONE/X
        VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
        VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
        VM=V0
        V0=VP
        VP=VI
        PM=P0
        F0=F1
        P0=P1
        G0=G1
        F1=AI/(DONE+H1*VI)
        UM=U0
        U0=UP
        UP=-F1*(ZI2+CI2*T)*T*T
        TT=(DTWO-DTEN*H1*V0)*P0-(DONE+H1*VM)*PM
        P1=(TT+(UP+DTEN*U0+UM)*H1)/(DONE+H1*VI)
C        AP=P1*(DONE+H1*VI)
        G1=AJ/(DONE+H1*VJ)
      ENDDO
C
      A1=A3
      A2=P0*G0*(X-H)**NI
      A3=P1*G1*X**NI
C
      IF(BNORM)THEN
        T0=DONE/(X-H)
        TF0=DONE+D4*(EI0-Z2*T0)
        TG0=DONE+D4*(EJ0-Z2*T0)
        T1=T
        TF1=DONE+D4*(EI0-Z2*T1)
        TG1=DONE+D4*(EJ0-Z2*T1)
        A2=A2*SQRT(TF0*TG0)
        A3=A3*SQRT(TF1*TG1)
      ENDIF
C
      REM=REM+A1+DFOUR*A2+A3
C                                      CHECK CONVERGENCE
      IF(TKIJ*X.LT.D20)GO TO 1
      IF((VJ*X*X-CJ2).LT.D60)GO TO 1
      IF((VI*X*X-CI2).LT.D60)GO TO 1
      if(eztst*x.lt.dten)go to 1
C
      IF(BNORM)THEN                !CONVERT TO FINAL NORM
        F0=F0*SQRT(TF0)
        P0=P0*SQRT(TF0)
        G0=G0*SQRT(TG0)
        F1=F1*SQRT(TF1)
        P1=P1*SQRT(TF1)
        G1=G1*SQRT(TG1)
      ENDIF
C
      REM=H*REM/DTHREE
C
      RETURN
C
      END SUBROUTINE ASS2PX
C
C                   ***********ASYMPTOPIA***********
C
      SUBROUTINE ASS2X(X1,H,X,F0,F1,G0,G1,EI0,EJ0,CI0,CJ0,QI,QJ,UI,UJ,Z0
     X,NI,REM)
C
C-----------------------------------------------------------------------
C
C  BADNELL AND BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.ASS2X CALCS LONG RANGE INTEGRAL OUT TO POINT WHERE CAN USE AMP-
C  PHASE METHOD IN ASSX. MODIFIED VERSION OF A. BURGESS'S SR.ASS2.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) QI,QJ
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D5M4=DFIVE*D1M4)
C
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      TKIJ=ABS(SQRT(EI0)-SQRT(EJ0))
      TEST=(DONE-Z0)*D5M4
      T=DONE
      IF(NI.LE.-1)T=D100
      IF(TKIJ.LT.TEST/T)TKIJ=D1P6
COLD      TEST=TEST*DTEN
      IF(TKIJ.LT.TEST)TKIJ=TEST
C
      HH=H*H
      H1=HH/DTWELV
      REM=DZERO
      X=X1
      A3=F1*G1*X**NI
C
      IF(BREL)THEN
        EI=EI0+DQUART*DALF*EI0*EI0
        EJ=EJ0+DQUART*DALF*EJ0*EJ0
        ZI=Z0+DHALF*DALF*Z0*EI0
        ZJ=Z0+DHALF*DALF*Z0*EJ0
        CI=CI0-DALF*Z0*Z0
        CJ=CJ0-DALF*Z0*Z0
C CHANGE NORM BACK TO THAT OF ORIGINAL EQUATION/SOLUTION: 1+(E+V)*D4
C (LIKELY OVER-KILL SINCE UNAFFECTED BY A CONSTANT FACTOR, ONLY ANY
C  REMAINING ASYMPTOTIC R-DEPENDENCE - SET BNORM=.TRUE. TO TEST.)
        BNORM=.FALSE.                           !.TRUE.        !TEST
        IF(BNORM)THEN
          D4=DQUART*DALF
          Z2=Z0+Z0
          T0=DONE/(X-H)
          TF0=DONE+D4*(EI0-Z2*T0)
          TG0=DONE+D4*(EJ0-Z2*T0)
          TF0=SQRT(TF0)
          TG0=SQRT(TG0)
          F0=F0/TF0
          G0=G0/TG0
          T1=DONE/X
          TF1=DONE+D4*(EI0-Z2*T1)
          TG1=DONE+D4*(EJ0-Z2*T1)
          TF1=SQRT(TF1)
          TG1=SQRT(TG1)
          F1=F1/TF1
          G1=G1/TG1
        ENDIF
      ELSE
        EI=EI0
        EJ=EJ0
        ZI=Z0
        ZJ=Z0
        CI=CI0
        CJ=CJ0
        BNORM=.FALSE.
      ENDIF
C
      ZI2=ZI+ZI
      ZJ2=ZJ+ZJ
      CI2=CI+CI
      CJ2=CJ+CJ
C
      T=DONE/(X-H)
      VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
      VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
      TI=F0*(DONE+VI*H1)
      TJ=G0*(DONE+VJ*H1)
      T=DONE/X
      VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
      VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
      TI=(DONE+H1*VI)*F1-TI
      TJ=(DONE+H1*VJ)*G1-TJ
      AI=F1*(DONE+H1*VI)
      AJ=G1*(DONE+H1*VJ)
C
   1  DO I=1,2
        TI=TI-HH*VI*F1
        TJ=TJ-HH*VJ*G1
        AI=AI+TI
        AJ=AJ+TJ
        X=X+H
        T=DONE/X
        VI=EI-(ZI2+(CI+(QI+UI*T)*T)*T)*T
        VJ=EJ-(ZJ2+(CJ+(QJ+UJ*T)*T)*T)*T
        F0=F1
        G0=G1
        F1=AI/(DONE+H1*VI)
        G1=AJ/(DONE+H1*VJ)
      ENDDO
C
      A1=A3
      A2=F0*G0*(X-H)**NI
      A3=F1*G1*X**NI
C
      IF(BNORM)THEN
        T0=DONE/(X-H)
        TF0=DONE+D4*(EI0-Z2*T0)
        TG0=DONE+D4*(EJ0-Z2*T0)
        T1=T
        TF1=DONE+D4*(EI0-Z2*T1)
        TG1=DONE+D4*(EJ0-Z2*T1)
        A2=A2*SQRT(TF0*TG0)
        A3=A3*SQRT(TF1*TG1)
      ENDIF
C
      REM=REM+A1+DFOUR*A2+A3
C                                      CHECK CONVERGENCE
      IF(TKIJ*X.LT.D20)GO TO 1
      IF((VJ*X*X-CJ2).LT.D60)GO TO 1
      IF((VI*X*X-CI2).LT.D60)GO TO 1
C
      IF(BNORM)THEN                !CONVERT TO FINAL NORM
        F0=F0*SQRT(TF0)
        G0=G0*SQRT(TG0)
        F1=F1*SQRT(TF1)
        G1=G1*SQRT(TG1)
      ENDIF
C
      REM=H*REM/DTHREE
C
      RETURN
C
      END SUBROUTINE ASS2X
C
C                                 ************
C
      SUBROUTINE ASSX(X,N,TI,TJ,EI0,EJ0,Z0,LI0,LJ0,ci,cj,QI,QJ,UI,UJ
     X               ,REM)
C
C-----------------------------------------------------------------------
C
C  BADNELL & BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.ASSX CALCS LONG-RANGE INTEGRAL FROM X TO INFINITY, N=-(LAMBDA+1).
C
C  CASE EI .NE. EJ AMP. PHASE METHOD.
C  CASE EI=EJ PHI+ AMP. PHASE METHOD, PHI- SUBSTITUTION & SIMPSONS RULE.
C  BASED ON A. BURGESS'S SR.ASS, MODIFIED AND EXTENDED TO TREAT EI=EJ.
C
C  IT CALLS:
C    SR.DNAMP
C    SR.DNAQ
C    SR.DNPROD
C    FN.PHASEX
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) QI,QJ
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (NMAX=10)
      PARAMETER (N2MX=2*NMAX)
      PARAMETER (MAXNST=65)
C
      PARAMETER (D5M4=5.0D-4)
      PARAMETER (D32M6=3.2D-6)
C
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
c      common /nrbnfg/fnorm,gnorm
C
      DIMENSION AI(N2MX),AJ(N2MX),Y(N2MX),C(N2MX),D(N2MX),E(N2MX)
     X,F(N2MX),G(N2MX),H(N2MX),R(MAXNST),P(N2MX),V(N2MX),W(N2MX)
C
      IF(LI0+LJ0.EQ.0.OR.LI0.LT.0.OR.LJ0.LT.0)THEN!NO LONG RANGE CONTRIB
        REM=DZERO                                 !BAIL OUT
        RETURN
      ENDIF
C
      ELI=LI0
      ELJ=LJ0
C
      TEST=D32M6
      TKIJ=ABS(SQRT(EI0)-SQRT(EJ0))
      PI=ACOS(-DONE)
C
c  for SUN S11 bug: if sub argument is ci0,cj0; ci,cj re-instated at end
c
      ci0=ci
      cj0=cj
c
      IF(BREL)THEN
        EI=EI0+DQUART*DALF*EI0*EI0
        EJ=EJ0+DQUART*DALF*EJ0*EJ0
        ZI=Z0+DHALF*DALF*Z0*EI0
        ZJ=Z0+DHALF*DALF*Z0*EJ0
        CI=CI0-DALF*Z0*Z0
        CJ=CJ0-DALF*Z0*Z0
        LI=-LI0-1
        LJ=-LJ0-1
      ELSE
        EI=EI0
        EJ=EJ0
        ZI=Z0
        ZJ=Z0
        CI=CI0
        CJ=CJ0
        LI=LI0
        LJ=LJ0
      ENDIF
C
      PHI=PHASEX(EI,CI,QI,UI,LI,ZI,X)+TI*PI
      PHJ=PHASEX(EJ,CJ,QJ,UJ,LJ,ZJ,X)+TJ*PI
C
      CALL DNAMP(AI0,AI,EI,CI,QI,UI,ZI,X,NMAX,IFIVE)
      CALL DNAMP(AJ0,AJ,EJ,CJ,QJ,UJ,ZJ,X,NMAX,IFIVE)
C
c      fnorm=ai0*sin(phi)
c      gnorm=aj0*sin(phj)
c
      ETIJ=(TI-TJ)*PI
C
      CALL DNAQ(AI0,AI,Y0,Y,-DTWO,NMAX,ITWO)
      CALL DNAQ(AJ0,AJ,C0,C,-DTWO,NMAX,ITWO)
C
      D0=Y0+C0
      DO I=1,NMAX
        D(I)=Y(I)+C(I)
      ENDDO
C
      CALL DNAQ(D0,D,V0,V,-DONE,NMAX,ITHREE)
      CALL DNPROD(AI0,AI,AJ0,AJ,D0,D,NMAX)
C
      E0=X**N
      DEN=N
      E(1)=DEN*E0/X
      DO I=2,NMAX
        DEN=DEN-DONE
        E(I)=DEN*E(I-1)/X
      ENDDO
C
      CALL DNPROD(D0,D,E0,E,F0,F,NMAX)
      CALL DNPROD(V0,V,F0,F,E0,E,NMAX)
C
      H0=E0
      IMAX=NMAX-1
C
      DO I=1,IMAX
        E0=E(1)
        JMAX=NMAX-I
        DO J=1,JMAX
          E(J)=E(J+1)
        ENDDO
C
        CALL DNPROD(V0,V,E0,E,W0,W,JMAX)
C
        E0=W0
        DO J=1,JMAX
          E(J)=W(J)
        ENDDO
        H(I)=E0
      ENDDO
C
      H(NMAX)=V0*E(1)
      S=-DONE
      U=H0
      R3=U
      T1=ABS(R3)
      I=0
C
  16  I=I+2
      IF(I.GT.NMAX)GO TO 19
      T2=ABS(H(I))
      IF(T2.GT.T1)GO TO 19
      U=S*H(I)
      R3=R3+U
      S=-S
      T1=T2
      GO TO 16
C
  19  R3=R3-DHALF*U
      S=-DONE
      U=H(1)
      R4=U
      T1=ABS(R4)
      I=1
C
  21  I=I+2
      IF(I.GT.NMAX)GO TO 24
      T2=ABS(H(I))
      IF(T2.GT.T1)GO TO 24
      U=S*H(I)
      R4=R4+U
      S=-S
      T1=T2
      GO TO 21
C
  24  R4=R4-DHALF*U
      S2=SIN(PHI+PHJ)
      C2=COS(PHI+PHJ)
      RP=R3*S2+R4*C2
C
      TEZT=D5M4*(DONE-Z0)
      IF(TKIJ.LT.TEZT)GO TO 25
      IF(TKIJ.GT.DTEN*TEZT)GO TO 20
      IF(N.LE.-1)GO TO 25
C
C SLOW CONVERGENCE IN CASE EI-EJ SMALL BUT NON-ZERO, RM BETTER EVALUATED
C IN ASS2. CASE ONLY ARISES IF ONE OF THE INTERPOLATION ENERGIES
C IS CLOSE TO ZERO (=ZERO IS NO PROBLEM). CHOOSING INTERPOLATION
C ENERGY=ZERO OR .GT. 4.E-4*(ASYMPTOTIC CHARGE +1)**2
C IS MUCH MORE FASTER AND ACCURATE.
C
      REM=RP/DTWO
      GO TO 999                                                  !RETURN
C
  20  C0=Y0-C0
      DO I=1,NMAX
        C(I)=Y(I)-C(I)
      ENDDO
C
      CALL DNAQ(C0,C,Y0,Y,-DONE,NMAX,ITHREE)
C
      CALL DNPROD(Y0,Y,F0,F,D0,D,NMAX)
C
      G0=D0
      IMAX=NMAX-1
C
      DO I=1,IMAX
        D0=D(1)
        JMAX=NMAX-I
        DO J=1,JMAX
          D(J)=D(J+1)
        ENDDO
C
        CALL DNPROD(Y0,Y,D0,D,P0,P,JMAX)
C
        D0=P0
        DO J=1,JMAX
          D(J)=P(J)
        ENDDO
        G(I)=D0
      ENDDO
C
      G(NMAX)=Y0*D(1)
      S=DONE
      U=-G0
      R1=U
      T1=ABS(R1)
      I=0
C
   6  I=I+2
      IF(I.GT.NMAX)GO TO 9
      T2=ABS(G(I))
      IF(T2.GT.T1)GO TO 9
      U=S*G(I)
      R1=R1+U
      S=-S
      T1=T2
      GO TO 6
C
   9  R1=R1-DHALF*U
      S=DONE
      U=-G(1)
      R2=U
      T1=ABS(R2)
      I=1
C
  11  I=I+2
      IF(I.GT.NMAX)GO TO 14
      T2=ABS(G(I))
      IF(T2.GT.T1)GO TO 14
      U=S*G(I)
      R2=R2+U
      S=-S
      T1=T2
      GO TO 11
C
  14  R2=R2-DHALF*U
      S1=SIN(PHI-PHJ)
      C1=COS(PHI-PHJ)
      RM=R1*S1+R2*C1
      REM=(RM+RP)/DTWO
C
      GO TO 999                                                  !RETURN
C
C CALCS INTEGRAL [X,INFINITY) OF:
C AMP1(R)*AMP2(R)*COS(PH2-PH1)/(2*R**(LAM+1)
C FOR EI=EJ WITH SUB:
C U=(DARSIN((DTWO/R-Z2L)/DEL)+SI)/DTL (AS DEFINED BELOW.)
C
  25  TL=(CI+CJ)/DTWO
      DTL=SQRT(TL)
      PH0=(ELJ-ELI)*PI
      Z2=-ZI-ZI
      Z2L=Z2/TL
      DEL=SQRT(DFOUR*EI/TL+Z2L*Z2L)
      SI=PI/DTWO
      IF(EI.GT.DZERO)SI=ASIN(Z2L/DEL)
      N2=N+2
      AM=DZERO
      IF(N2.EQ.0)AM=DONE
C
      IF(EI.GT.D1M10)THEN
        DEI=SQRT(EI)
        ZE=ZI/DEI
        AGI=ARGAM(ELI,ZE)
        AGJ=ARGAM(ELJ,ZE)
        PH0=PH0/DTWO+AGI-AGJ
      ENDIF
C
      RM=DZERO
      R(1)=AM*COS(PH0+ETIJ)
      CU=EI+Z2/X-TL/(X*X)
      IF(CU.LT.DZERO)GO TO 99                    !ABORT
C
      CU=SQRT(CU)
      R(3)=AI0*AJ0*COS(PHI-PHJ)*CU*X**N2
      NST=1
      HT=(ASIN((DTWO/X-Z2L)/DEL)+SI)/DTL
C
  31  RM0=RM
      NST=NST+NST
      HT=HT/DTWO
      NS2=NST+2
      RM=R(1)
      UH=HT
C
      DO K=4,NS2,2
        XH=DTWO/(Z2L+DEL*SIN(UH*DTL-SI))
        CU=EI+Z2/XH-TL/(XH*XH)
        IF(CU.LT.DZERO)GO TO 99                  !ABORT
        CU=SQRT(CU)
C
        CALL DNAMP(AI1,AI,EI,CI,QI,UI,ZI,XH,NMAX,IFIVE)
        CALL DNAMP(AJ1,AJ,EJ,CJ,QJ,UJ,ZJ,XH,NMAX,IFIVE)    !EI=EJ, ZI=ZJ
C
        PI1=PHASEX(EI,CI,QI,UI,LI,ZI,XH)
        PJ1=PHASEX(EJ,CJ,QJ,UJ,LJ,ZJ,XH)
C
        R(K-2)=AI1*AJ1*COS(PI1-PJ1+ETIJ)*CU*XH**N2
        UH=UH+HT+HT
      ENDDO
C
      DO K=4,NST,2
        RM=RM+DFOUR*R(K-2)+DTWO*R(K-1)
      ENDDO
C
      RM=(RM+DFOUR*R(NST)+R(NST+1))*HT/DTHREE
C
      IF(ABS(RM-RM0).GT.TEST)THEN                !NOT YET CONVERGED
        NSN=NST+NST
        IF(NSN.LT.MAXNST)THEN
          NSN=NSN+3
          DO K=1,NST
            R(NSN-K-K)=R(NS2-K)
          ENDDO
          GO TO 31                               !NEXT ITERATION
        ENDIF
        IF(ABS(RM).GT.DONE)WRITE(6,100)TEST,RM0,RM !FAILURE
      ENDIF
C
      REM=(RM+RP)/DTWO                           !CONVERGED RESULT
C
 999  CONTINUE
C
      IF(BREL)THEN                               !CORRECT NORMALIZATION
        TF=DONE+DQUART*DALF*EI0   !       -2*z0/x)
        TG=DONE+DQUART*DALF*EJ0   !       -2*z0/x)
        TF=SQRT(TF)
        TG=SQRT(TG)
        REM=REM*TF*TG
c        fnorm=fnorm*tf
c        gnorm=gnorm*tg
      ENDIF
c                                            !re-instate for SUN S11 bug
      ci=ci0
      cj=cj0
C
      RETURN
C
  99  REM=RP/DTWO                                !RM NOT CONVERGED
      GO TO 999                                                  !RETURN
C
 100  FORMAT('*****WARNING IN SR.ASSX, LONG-RANGE INTEGRALS HAVE FAILED'
     X,'TO CONVERGE TO WITHIN',1PE8.1/ ' FOR EI=EJ, CHECK WHETHER '
     X,'ACCURACY IS SUFFICIENT, RM0=',E14.7,3X,'RM=',E14.7)
C
      END SUBROUTINE ASSX
C
C                                 ************
C
      SUBROUTINE BDCF3(F,E,N,L,Z,J0,J1,X)
C
C-----------------------------------------------------------------------
C
C     ALAN BURGESS, D.A.M.T.P. CAMBRIDGE
C
C  SR.BDCF3 EVALUATES A BOUND COULOMB FUNCTION FROM SERIES.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TOL=1400.0D0)
      PARAMETER (SUPFCT=55.0D0)
C
      DIMENSION F(J1),X(J1)
C
C
      EL=L
      GNU=-Z/SQRT(-E)
C
      T1=GNU+EL+DONE
      IF(T1.GT.SUPFCT)THEN
        WRITE(6,*)'****ERROR: BDCF3, N+L TOO LARGE FOR GAMA7'
        WRITE(0,*)'****ERROR: BDCF3, N+L TOO LARGE FOR GAMA7'
        L=-1
        J=J0
        GO TO 6
      ENDIF
C
      T2=GNU-EL
      IF(T2.LT.DHALF)T2=DONE                        !SAFE LOWER BOUND
C
      T3=GAMA7(T1)*GAMA7(T2)
      TB=SQRT(-Z/T3)/GNU
      ISGN=1-2*mod(abs(N-L+1),ITWO)        !(-1)**(N-L+1)
      TB=TB*ISGN
C
      DO J=J0,J1
C
        R=-Z*X(J)
        T=DTWO*R/GNU
        T3=DONE/T
        S=DONE
        A=DONE
        K0=INT(GNU+GNU+D3HALF+T)
        TH=K0
        TH=GNU+GNU+DONE+T-TH
C
        DO K=1,K0
          TK=K
          A=A*(TK-GNU+EL)*(GNU-TK+EL+DONE)*T3/TK
          T1=ABS(A)
          T2=ABS(S)*T3/TK
          IF(T2.GT.T1*D1P12)GO TO 2
          S=S+A
        ENDDO
C
        T1=(GNU-EL)*(GNU+EL+DONE)
        T2=-DTWO*GNU*T1
        C=-DHALF+D8TH*T3*((DTWO*TH-DONE)+(TH*TH-D3HALF*TH+DQUART
     X    -DTWO*T1)*T3)
        S=S+C*A
    2   IF(T.GT.TOL)GO TO 6
        F(J)=(T**GNU)*S*EXP(-DHALF*T)*TB
C
      ENDDO
C
      IF(F(1).LT.DZERO)THEN
        WRITE(6,*)'****ERROR: BDCF3, EXPANSION FAILED TO CONVERGE'
        WRITE(0,*)'****ERROR: BDCF3, EXPANSION FAILED TO CONVERGE'
        L=-1
        J=J0
        GO TO 6
      ENDIF
C
      RETURN
C
    6 DO I=J,J1
        F(I)=DZERO
      ENDDO
C
      RETURN
C
      END SUBROUTINE BDCF3
C
C                             *******************
C
      FUNCTION SBESS(L,X,JSWITCH)
C
C-----------------------------------------------------------------------
C
C  FN.SBESS EVALUATES A SPHERICAL BESSEL FUNCTION OF KIND DEFINED BY:
C
C  JSWITCH= 1 FOR FIRST KIND
C         = 2 FOR SECOND KIND
C         =-1 FOR MODIFIED FIRST KIND
C         =-2 FOR MODIFIED SECOND KIND
C         =-3 FOR MODIFIED THIRD KIND
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESS=_L(X) SAID BESSEL.
C
C  IT CALLS:
C    FN.SBESSJ
C    FN.SBESSY
C    FN.SBESSI
C    FN.SBESSN
C    FN.SBESSK
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      IF(JSWITCH.EQ.1)THEN
        SBESS=SBESSJ(L,X)
      ELSEIF(JSWITCH.EQ.2)THEN
        SBESS=SBESSY(L,X)
      ELSEIF(JSWITCH.EQ.-1)THEN
        SBESS=SBESSI(L,X)
      ELSEIF(JSWITCH.EQ.-2)THEN
        SBESS=SBESSN(L,X)
      ELSEIF(JSWITCH.EQ.-3)THEN
        SBESS=SBESSK(L,X)
      ELSE
        STOP 'BESSEL FUNCTION KIND NOT FOUND'
      ENDIF
C
      RETURN
C
      END FUNCTION SBESS
C
C                             *******************
C
      FUNCTION SBESSP(L,X,JSWITCH)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSP EVALUATES THE DERIVATIVE OF SPHERICAL BESSEL FUNCTION,
C  USING ABRAMOWITZ & STEGUN 10.1.20 & 10.2.19, DEFINED BY:
C
C  JSWITCH= 1 FOR FIRST KIND
C         = 2 FOR SECOND KIND
C         =-1 FOR MODIFIED FIRST KIND
C         =-2 FOR MODIFIED SECOND KIND
C         =-3 FOR MODIFIED THIRD KIND
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSP='_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      SBESSP=-SIGN(IONE,MOD(JSWITCH,ITHREE))*SBESS(L+1,X,JSWITCH)
C
      IF(L.EQ.0)RETURN
C
      SBESSP=(L*SBESS(L-1,X,JSWITCH)+(L+1)*SBESSP)/(2*L+1)
C
      RETURN
C
      END FUNCTION SBESSP
C
C                             *******************
C
      FUNCTION SBESSJ(L,X)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSJ EVALUATES A SPHERICAL BESSEL FUNCTION OF THE FIRST KIND,
C  AS DEFINED BY ABRAMOWITZ & STEGUN 10.1.1
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSJ=J_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (JMAX=6)
C
      parameter (iacc=40)
      parameter (sbigno=1.d10)
      parameter (sbigni=1.d-10)
C
      IF(L.LT.0)THEN
        LP=-L-1
        SBESSJ=SBESSY(LP,X)*(1-2*mod(-L,ITWO))
        GO TO 500
      ENDIF
C
C START WITH POWER SERIES
C
      SBJ=DONE
      SBJ0=DONE
      L2=L+L
      T2=-X*X/2
      DO J=1,JMAX
        SBJ0=SBJ0*T2/(J*(2*(L+J)+1))
        SBJ=SBJ+SBJ0
        IF(ABS(SBJ0).LT.ABS(SBJ)*D1M5)THEN
          IF(L.GT.0)SBJ=SBJ*X**L
          DO I=2,L2,2
            SBJ=SBJ/(I+1)
          ENDDO
          SBESSJ=SBJ
          GO TO 500   !CONVERGED
        ENDIF
c      write(6,*)'L=',l,' X=',x
      ENDDO
C
C NOT CONVERGED, LOOK FOR QUICK RETURN (SAFE TO DO SO NOW)
C
      SBESSJ=SIN(X)/X
      IF(L.EQ.0)GO TO 500
C
      SBESSJ0=SBESSJ
      SBESSJ=(SBESSJ0-COS(X))/X
      IF(L.EQ.1)GO TO 500
C
      SBESSJ1=SBESSJ
C
C ELSE USE RECURRENCE RELATION
C
      N=ABS(X)
      N=N+1
C
      IF(N.GT.L)THEN                !RECUR UPWARDS FROM J0 AND J1
C
        DO I=2,L
          SBESSJ2=(2*I-1)*SBESSJ1/X-SBESSJ0
          SBESSJ0=SBESSJ1
          SBESSJ1=SBESSJ2
        ENDDO
C
        SBESSJ=SBESSJ2
C
      ELSE                          !RECUR DOWNWARDS FROM ASYMTOPIA (JM)
C
        m=2*((l+int(sqrt(float(iacc*l))))/2)
C
        SBNORM0=SBESSJ0
        SBESSJ=DZERO
        SBESSJ2=DZERO
        SBESSJ1=sbigni                !DONE
C
        DO I=m,0,-1
          SBESSJ0=(2*I+3)*SBESSJ1/X-SBESSJ2
          IF(ABS(SBESSJ0).GT.sbigno)THEN
            SBESSJ0=SBESSJ0*sbigni
            SBESSJ1=SBESSJ1*sbigni
            SBESSJ=SBESSJ*sbigni
          ENDIF
          IF(I.EQ.L)SBESSJ=SBESSJ0
          SBESSJ2=SBESSJ1
          SBESSJ1=SBESSJ0
        ENDDO
        SBESSJ=SBESSJ*SBNORM0/SBESSJ0   !NORMALIZE
C
      ENDIF
C
 500  RETURN
C
      END FUNCTION SBESSJ
C
C                             *******************
C
      FUNCTION SBESSY(L,X)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSY EVALUATES SPHERICAL BESSEL FUNCTION OF THE SECOND KIND,
C  AS DEFINED BY ABRAMOWITZ & STEGUN 10.1.1
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSY=Y_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (XMIN=1.D-300)
      PARAMETER (TYMAX=1.D300)
C
      PARAMETER (NMAX=6)
C
      IF(L.LT.0)THEN
        LP=-L-1
        SBESSY=SBESSJ(LP,X)*(1-2*mod(LP,ITWO))
        GO TO 500
      ENDIF
C
C CHECK X NOT TOO SMALL
C
      IF(ABS(X)**(L+1).LT.XMIN)THEN
        SBESSY=TYMAX
        GO TO 500
      ENDIF
C
C START WITH POWER SERIES
C
      SBY=DONE
      SBY0=DONE
      L2=L+L
      T2=-X*X/2
      DO N=1,NMAX
        SBY0=-SBY0*T2/(N*(2*(L-N)+1))
        SBY=SBY+SBY0
        IF(ABS(SBY0).LT.ABS(SBY)*D1M5)THEN
          SBY=-SBY/X**(L+1)
          DO I=2,L2,2
            SBY=SBY*(I-1)
          ENDDO
          SBESSY=SBY
          GO TO 500   !CONVERGED
        ENDIF
      ENDDO
C
C NOT CONVERGED, LOOK FOR QUICK RETURN (SAFE TO DO SO NOW)
C
      SBESSY=-COS(X)/X
      IF(L.EQ.0)RETURN
C
      SBESSY0=SBESSY
      SBESSY=(SBESSY0-SIN(X))/X
      IF(L.EQ.1)RETURN
C
C ELSE USE RECURRENCE RELATION
C
      SBESSY1=SBESSY
      DO I=2,L
        SBESSY2=(2*I-1)*SBESSY1/X-SBESSY0
        SBESSY0=SBESSY1
        SBESSY1=SBESSY2
      ENDDO
C
      SBESSY=SBESSY2
C
 500  RETURN
C
      END FUNCTION SBESSY
C
C                             *******************
C
      FUNCTION SBESSI(L,X)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSI EVALUATES MODIFIED SPHERICAL BESSEL FUNCTION OF FIRST KIND,
C  AS DEFINED BY ABRAMOWITZ & STEGUN 10.2.2
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSI=I_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (XMAX=700)
      PARAMETER (TIMAX=1.D300)
C
      PARAMETER (JMAX=6)
C
      parameter (iacc=40)
      parameter (sbigni=1.d-10)
C
      IF(L.LT.0)THEN
        LP=-L-1
        SBESSI=SBESSN(LP,X)
        GO TO 500
      ENDIF
C
C CHECK X NOT TOO LARGE
C
      IF(ABS(X).GT.XMAX)THEN
        SBESSI=TIMAX
        GO TO 500
      ENDIF
C
C START WITH POWER SERIES
C
      SBI=DONE
      SBI0=DONE
      L2=L+L
      T2=X*X/2
      DO J=1,JMAX
        SBI0=SBI0*T2/(J*(2*(L+J)+1))
        SBI=SBI+SBI0
        IF(ABS(SBI0).LT.ABS(SBI)*D1M5)THEN
          IF(L.GT.0)SBI=SBI*X**L
          DO I=2,L2,2
            SBI=SBI/(I+1)
          ENDDO
          SBESSI=SBI
          GO TO 500   !CONVERGED
        ENDIF
c      write(6,*)'L=',l,' X=',x
      ENDDO
C
C NOT CONVERGED, LOOK FOR QUICK RETURN (SAFE TO DO SO NOW)
C
      SBESSI=SINH(X)/X
      IF(L.EQ.0)GO TO 500
C
      SBESSI0=SBESSI
      SBESSI=(-SBESSI0+COSH(X))/X
      IF(L.EQ.1)GO TO 500
C
      SBESSI1=SBESSI
C
C ELSE USE RECURRENCE RELATION
C
      N=ABS(X)
      N=N+1
C
      IF(N.GT.L)THEN                !RECUR UPWARDS FROM I0 AND I1
C
        DO I=2,L
          SBESSI2=-(2*I-1)*SBESSI1/X+SBESSI0
          SBESSI0=SBESSI1
          SBESSI1=SBESSI2
        ENDDO
C
        SBESSI=SBESSI2
C
      ELSE                          !RECUR DOWNWARDS FROM ASYMTOPIA (IM)
C
        m=2*((l+int(sqrt(float(iacc*l))))/2)
C
        SBNORM0=SBESSI0
        SBESSI=DZERO
        SBESSI2=DZERO
        SBESSI1=sbigni                !DONE
C
        DO I=m,0,-1
          SBESSI0=(2*I+3)*SBESSI1/X+SBESSI2
          IF(I.EQ.L)SBESSI=SBESSI0
          SBESSI2=SBESSI1
          SBESSI1=SBESSI0
        ENDDO
        SBESSI=SBESSI*SBNORM0/SBESSI0   !NORMALIZE
C
      ENDIF
C
 500  RETURN
C
      END FUNCTION SBESSI
C
C                             *******************
C
      FUNCTION SBESSN(L,X)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSN EVALUATES MODIFIED SPHERICAL BESSEL FUNCTION OF SECOND KIND
C  AS DEFINED BY ABRAMOWITZ & STEGUN 10.2.3
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSN=N_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (XMAX=700)
      PARAMETER (XMIN=1.D-300)
      PARAMETER (TNMAX=1.D300)
C
      PARAMETER (NMAX=6)
C
      IF(L.LT.0)THEN
        LP=-L-1
        SBESSN=SBESSI(LP,X)
        GO TO 500
      ENDIF
C
C CHECK X NOT TOO SMALL
C
      IF(ABS(X)**(L+1).LT.XMIN)THEN
        SBESSN=TNMAX
        GO TO 500
      ENDIF
C
C CHECK X NOT TOO LARGE
C
      IF(ABS(X).GT.XMAX)THEN
        SBESSN=TNMAX
        GO TO 500
      ENDIF
C
C START WITH POWER SERIES
C
      SBN=DONE
      SBN0=DONE
      L2=L+L
      T2=X*X/2
      DO N=1,NMAX
        SBN0=-SBN0*T2/(N*(2*(L-N)+1))
        SBN=SBN+SBN0
        IF(ABS(SBN0).LT.ABS(SBN)*D1M5)THEN
          SBN=SBN/X**(L+1)*(1-2*mod(L,ITWO))
          DO I=2,L2,2
            SBN=SBN*(I-1)
          ENDDO
          SBESSN=SBN
          GO TO 500   !CONVERGED
        ENDIF
      ENDDO
C
C NOT CONVERGED, LOOK FOR QUICK RETURN (SAFE TO DO SO NOW)
C
      SBESSN=COSH(X)/X
      IF(L.EQ.0)RETURN
C
      SBESSN0=SBESSN
      SBESSN=(-SBESSN0+SINH(X))/X
      IF(L.EQ.1)RETURN
C
C ELSE USE RECURRENCE RELATION
C
      SBESSN1=SBESSN
      DO I=2,L
        SBESSN2=-(2*I-1)*SBESSN1/X+SBESSN0
        SBESSN0=SBESSN1
        SBESSN1=SBESSN2
      ENDDO
C
      SBESSN=SBESSN2
C
 500  RETURN
C
      END FUNCTION SBESSN
C
C                             *******************
C
      FUNCTION SBESSK(L,X)
C
C-----------------------------------------------------------------------
C
C  FN.SBESSK EVALUATES MODIFIED SPHERICAL BESSEL FUNCTION OF THIRD KIND,
C  AS DEFINED BY ABRAMOWITZ & STEGUN 10.2.4 - OTHERS DIFFER BY 2/PI.
C
C  L=ORDER
C  X=ARGUEMENT
C  SBESSK=K_L(X) SAID BESSEL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (XMIN=1.D-60)
      PARAMETER (TKMAX=1.D300)
C
C CHECK X NOT TOO SMALL
C
      IF(ABS(X).LT.XMIN)THEN
        SBESSK=TKMAX
        GO TO 500
      ENDIF
C
C LOOK FOR QUICK RETURN
C
      SBESSK=DHALF*XPI*EXP(-X)/X
      IF(L.EQ.0)RETURN
C
      LP=ABS(L)
C
      SBESSK0=SBESSK
      SBESSK=SBESSK0*(DONE+DONE/X)
      IF(LP.EQ.1)RETURN
C
C ELSE USE RECURRENCE RELATION
C
      SBESSK1=SBESSK
      DO I=2,LP
        SBESSK2=(2*I-1)*SBESSK1/X+SBESSK0
        IF(ABS(SBESSK2).GT.TKMAX)THEN
          SBESSK=TKMAX
          GO TO 500
        ENDIF
        SBESSK0=SBESSK1
        SBESSK1=SBESSK2
      ENDDO
C
      SBESSK=SBESSK2
C
 500  RETURN
C
      END FUNCTION SBESSK
C
C                             *******************
C
      SUBROUTINE BORN(LAM,K1,K2,K3,K4,LL,LIMR,MENGB,MV0,MV1,V0,V1
     X               ,XBINT,XOINT,TM2)
c
C-----------------------------------------------------------------------
C
C  ADAPTED SR.BORN FROM ALAN BURGESS, DAMTP CAMBRIDGE:
C
C  COMPUTES THE BORN INTEGRALS SPECIFIED IN THE APPENDIX TO
C  BURGESS, CHIDICHIMO AND TULLY (J.PHYS.B,30,33-57,1997).
C  N.B. ID SETS THE MAXIMUM NUMBER OF POINTS USED FOR TABULATION OF
C  RADIAL FUNCTIONS, AND FOR THE INTEGRATIONS OVER R AND OVER K.
C  THE VALUE OF ID MUST BE A POWER OF 2, AND BE AT LEAST 2**M0
C  WHERE M0 IS THE NUMBER OF ROMBERG ITERATIONS.
C
C  IT CALLS;
C    SR.NORMS
C    SR.PNL
C    SR.ROMB
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (ID=1024)      !N.B. MAXB1 LARGE
C
      PARAMETER (D1PT5=1.5D0)
      PARAMETER (D5M4=5.0D-4)
C
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
C
      DIMENSION F1(0:ID),F2(0:ID),F12(0:ID),F34(0:ID)
      DIMENSION P1(0:ID),P2(0:ID),S3(0:ID)
      DIMENSION LIMR(*),LL(*),XBINT(*),V0(*),V1(*)
C
      IPS=0
      IF(KCUT.GT.0)THEN
        IF(DADJUS(K1).LT.DZERO)IPS=IPS+1
        IF(DADJUS(K2).LT.DZERO)IPS=IPS+1
        IF(DADJUS(K3).LT.DZERO)IPS=IPS+1
        IF(DADJUS(K4).LT.DZERO)IPS=IPS+1
      ENDIF
C
      IF((IPS.LE.0.OR.IPS.LE.2.AND.LAM.LE.2).AND.
     X   (MENGB.EQ.1.OR.LAM.EQ.0))THEN  !INFINITE ENERGY / OMG TO 4 S.F.
        TOLR=D1M5
        M0=6
      ELSE                              !FINITE ENERGY / OMG TO 3 S.F.
        IF(IPS.LE.2.OR.IPS.LE.4.AND.LAM.EQ.0)THEN
          TOLR=D5M4
          M0=5
        ELSE
          TOLR=D1M3
          M0=4
        ENDIF
      ENDIF
C
c      TOLR=1.D-7           !HIGH PRECISION CHECK OF BORN INTEGRALS
c      M0=8
C
      BCF=K3.NE.K1.OR.K4.NE.K2
      IF(2**M0.GT.ID)THEN
        WRITE(6,*)'BORN ERROR: 2**M0 .GT. ID'
        WRITE(0,*)'BORN ERROR: 2**M0 .GT. ID'
        LAM=-1
        RETURN
      ENDIF
C
      I1=ID
      M=MAX(LIMR(K1),LIMR(K2))
      IF(DX(LIMR(K1)+LIMR(K2)-M)*D1PT5.GT.DX(M))I1=I1/2
      R1=DX(M)
      H1=R1/I1
C
      CALL PNL(I1,H1,LL(K1),DX,DPNL(1,K1),LIMR(K1),F1)
      CALL PNL(I1,H1,LL(K2),DX,DPNL(1,K2),LIMR(K2),F2)
C
      CALL NORMS(I1,H1,LAM,F1,F2,F12,XB11,XB22,XB12,TM12,VM12)
C
      TM2=DZERO
      IF(LAM.EQ.1)TM2=TM12*TM12/DNINE
      IF(BCF)THEN
        I2=ID
        M=MAX(LIMR(K3),LIMR(K4))
        IF(DX(LIMR(K3)+LIMR(K4)-M)*D1PT5.GT.DX(M))I2=I2/2
        R2=DX(M)
        H2=R2/I2
C
        CALL PNL(I2,H2,LL(K3),DX,DPNL(1,K3),LIMR(K3),F1)
        CALL PNL(I2,H2,LL(K4),DX,DPNL(1,K4),LIMR(K4),F2)
C
        CALL NORMS(I2,H2,LAM,F1,F2,F34,XB33,XB44,XB34,TM34,VM34)
C
        IF(LAM.EQ.1)TM2=SQRT(TM2*TM34*TM34/DNINE)
      ELSE
        R2=R1
        I2=I1
        DO I=1,I1
          F34(I)=F12(I)
        ENDDO
        VM34=VM12
      ENDIF
C
      VM=(VM12+VM34)*DHALF
      IF(MENGB.GT.1)THEN                  !FINITE ENERGY CASE
        IE=0
        DO J0=1,MV0
          J11=J0+1
          DO J1=J11,MV1
            IE=IE+1
C
            CALL ROMB(ID,BCF,LAM,R1,I1,F12,R2,I2,F34,VM,V0(J0),V1(J1)
     X               ,M0,F1,F2,S3,P1,P2,XBINT(IE),XOINT,EB,EO,TOLR,TM2)
C
            IF(LAM.EQ.1)XBINT(IE)=
     X      XBINT(IE)+TM2*LOG((V0(J0)+VM)/(V1(J1)+VM)) !OMIT LOG(V1/V0)
c     X      XBINT(IE)+TM2*LOG(V1(J1)*(V0(J0)+VM)/(V0(J0)*(V1(J1)+VM)))
          ENDDO
        ENDDO
      ELSE                              !INFINITE ENERGY CASE
C
        CALL ROMB(ID,BCF,LAM,R1,I1,F12,R2,I2,F34,VM,V0(1),V1(1)
     X           ,M0,F1,F2,S3,P1,P2,XBINT(1),XOINT,EB,EO,TOLR,TM2)
C
      ENDIF
C
      RETURN
C
      END SUBROUTINE BORN
C
C                             *******************
C
      SUBROUTINE BRNINT(BPRNT0,NLAGB,MXNXB,MV0,MV1,DRY,V0,V1,XB,XS
     X                 ,DB0,DB1,OMG1,OBO,OMEGA)
C
C-----------------------------------------------------------------------
C
C SR.BRNINT INTERPOLATES BORN OMEGAS.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D1PT2=1.2D0)
C
      DIMENSION V0(*),V1(*),XB(*),XS(0:*),DB0(*),DB1(*),OMEGA(0:*)
     X         ,OBO(*)
C
      DATA BFLAG/.TRUE./
C
      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      NPB=NLAGB/2
      MV11=MV1-1
C
        DO NX=1,MXNXB
          XE=SQRT(XB(NX)*DRY)
          TKMIN=XE*(DONE-XS(NX))
          TKMAX=XE*(DONE+XS(NX))
C
c find tkmin interp. points
C
          IF(TKMIN.LT.V0(1))THEN
c            write(0,*)'tkmin out of bounds (lower)',tkmin,v0(1)
ctest            stop 'tkmin out of bounds (lower)'
            NB01=1
            NB02=NLAGB
            GO TO 272
          ENDIF
          IF(TKMIN.GT.D1PT2*V0(MV0))THEN
            IF(BPRNT0)THEN
              write(6,*)'tkmin out of bounds (upper)',tkmin,v0(mv0)
              write(6,*)
     X             'Upper-state above the ionization limit? SET KCUT !!'
              IF(BFLAG)THEN
                write(0,*)
     X             'Upper-state above the ionization limit? SET KCUT !!'
                BFLAG=.FALSE.
              ENDIF
            ENDIF
cold             nlagb=-1
cold             return
ctest            stop 'tkmin out of bounds (upper)'
            NB02=MV0
            NB01=NB02-NLAGB+1
            GO TO 272
          ENDIF
C
          DO L=1,MV0
            IF(V0(L).GT.TKMIN)THEN
              NB02=L+NPB-1
              NB01=L-NPB
              IF(NB01.LE.0)THEN
                NB02=NLAGB
                NB01=1
              ELSEIF(NB02.GT.MV0)THEN
                NB02=MV0
                NB01=NB02-NLAGB+1
              ENDIF
              GO TO 272
            ENDIF
          ENDDO
          NB02=MV0
          NB01=NB02-NLAGB+1
C WEIGHTS
  272     DO L=NB01,NB02
            DD0=DONE
            DO M=NB01,NB02
              IF(L.NE.M)THEN
                DD0=DD0*(TKMIN-V0(M))
                DD0=DD0/(V0(L)-V0(M))
              ENDIF
            ENDDO
            DB0(L)=DD0
          ENDDO
C
c find tkmax interp. points
C
          IF(TKMAX.LT.V1(1))THEN
c            write(0,*)'tkmax out of bounds (lower)',tkmax,v1(1)
ctest            stop 'tkmax out of bounds (lower)'
            NB11=1
            NB12=NLAGB
            GO TO 273
          ENDIF
          DO L=1,MV11
            IF(V1(L).GT.TKMAX)THEN
              NB12=L+NPB-1
              NB11=L-NPB
              IF(NB11.LE.0)THEN
                NB11=1
                NB12=NLAGB
              ELSEIF(NB12.GT.MV11)THEN
                NB12=MV11
                NB11=NB12-(NLAGB-1)+1
              ENDIF
              GO TO 273
            ENDIF
          ENDDO
          IF(TKMAX.GT.D1PT2*V1(MV11))THEN
            IF(BPRNT0)THEN
              write(6,*)'tkmax out of bounds (upper)',tkmax,v1(mv11)
              write(6,*)'Is this a K-shell excitation?'
            ENDIF
ctest            stop 'tkmax out of bounds (upper)'
            NB12=MV1
            NB11=NB12-1
          ELSE
            NB12=MV1
            NB11=NB12-(NLAGB-1)+1
          ENDIF
C WEIGHTS
  273     DO L=NB11,NB12
            DD0=DONE
            DO M=NB11,NB12
              IF(L.NE.M)THEN
                DD0=DD0*(TKMAX-V1(M))
                DD0=DD0/(V1(L)-V1(M))
              ENDIF
            ENDDO
            DB1(L)=DD0
          ENDDO
C
C INTERPOLATE BORN INTEGRAL OVER K_MIN AND K_MAX MOM. TRANSFER LIMITS.
C
          XOBO=DZERO
          DO I0=NB01,NB02
            DO I1=NB11,NB12
              IF(I1.GT.I0)THEN
                IE=IROW(I0,I1,IONE,MV1)
                XOBO=XOBO+DB0(I0)*DB1(I1)*OBO(IE)
              ELSEIF(I1.LT.I0)THEN
                IE=IROW(I1,I0,IONE,MV1)
                XOBO=XOBO-DB0(I0)*DB1(I1)*OBO(IE)
              ENDIF
            ENDDO
          ENDDO
          XOBO=XOBO+OMG1*LOG(TKMAX/TKMIN) !IF(NGROUP.EQ.1)
          OMEGA(NX)=XOBO        !INTERPOLATED BORN INTGRAL
        ENDDO
C
      RETURN
      END SUBROUTINE BRNINT
C***********************************************************************
C***********************************************************************
C
C J. BURNS BOX FUNCTION GENERATOR
C
C***********************************************************************
C***********************************************************************
C
      SUBROUTINE BXCUNT(IN_INT,IANSTEPS,DTF,DARFUNC,ISIZE,INODES)
C
C-----------------------------------------------------------------------
C
C  SR.BXCUNT COUNTS THE NUMBER OF NODES TO SEE IF WE HAVE THE REQUIRED
C  ORBITAL.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DARFUNC(*)
C
C
      IINDEX=2
      INODES=0
C
      DO II=1,IN_INT
        DO IN=2,IANSTEPS(II)
          IF(IINDEX.GE.(ISIZE-10))THEN
            IF(ABS(DARFUNC(IINDEX)).LT.DTF)THEN
              DF1=DZERO
            ELSE
              DF1=DARFUNC(IINDEX)
            ENDIF
C
            IF(ABS(DARFUNC(IINDEX-1)).LT.DTF)THEN
              DF2=DZERO
            ELSE
              DF2=DARFUNC(IINDEX-1)
            ENDIF
            DM=DF1*DF2
          ELSE
            DM=DARFUNC(IINDEX)*DARFUNC(IINDEX-1)
          ENDIF
C
          IF(DM.LT.DZERO)THEN        !WE FLIPPED SIGN
            INODES=INODES+1
          ENDIF
          IINDEX=IINDEX+1
          IF(IINDEX.GE.ISIZE)GO TO 1
        ENDDO
      ENDDO
C
  1   CONTINUE
C
      RETURN
C
      END SUBROUTINE BXCUNT
C
C                             *******************
C
      SUBROUTINE BXDFKK(DZ,DL,DE,DR,DFFK)
C
C-----------------------------------------------------------------------
C
C  SR.BXDFKK DETERMINES THE KINETIC-PLUS-NUCLEAR OPERATOR (FOR BOX USE).
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DFKK=(-(DL*(DL+DONE)/(DR*DR)))+(DTWO*DZ/DR)+DE
C
      RETURN
C
      END SUBROUTINE BXDFKK
C
C                             *******************
C
      SUBROUTINE BXINFL(IN_INT,IANSTEPS,DZ,DL,DE,DR1,DR2,DAR,IRN)
C
C-----------------------------------------------------------------------
C
C  SR.BXINFL DETERMINES THE INNER POINT OF INFLECTION.
C  IRN IS USED TO RETURN THE INDEX OF THE R VALUE CLOSEST TO BUT
C  NOT GREATER THAN THE POSITION OF THE INNER POINT OF INFLECTION
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DAR(*)
C
      DR1=(-DZ+SQRT( DZ**2+DE*DL*(DL+DONE)))/DE
      DR2=(-DZ-SQRT( DZ**2+DE*DL*(DL+DONE)))/DE
C
      IF(DR1.LT.DZERO)THEN
        DPT_INFL=DR2
      ELSE IF(DR2.LT.DZERO)THEN
        DPT_INFL=DR1
      ELSE
        IF(DR1.LT.DR2)THEN
          DPT_INFL=DR1
        ELSE
          DPT_INFL=DR2
        ENDIF
      ENDIF
      IF(DPT_INFL.LT.0)THEN
        DPT_INFL=0
        IN=0
        RETURN
      ENDIF
C
      DPT_INFL=DPT_INFL/DFOUR
      IINDEX=1
C
      DO II=1,IN_INT
        DO IN=1,IANSTEPS(II)
          IF(DAR(IINDEX).GT.DPT_INFL)THEN
            IRN=IINDEX-1
            GO TO 1
          ENDIF
          IINDEX=IINDEX+1
        ENDDO
      ENDDO
C
   1  CONTINUE
C
C      PRINT *,RN,R1,R2,R(RN)
C   2  IF(R(INDEX).LT.PT_INFL)THEN
C        INDEX=INDEX+1
C        GO TO 2
C      ENDIF
C      RN=INDEX-1
C      PRINT *,"RN=",RN
C
      RETURN
C
      END SUBROUTINE BXINFL
C
C                             *******************
C
      SUBROUTINE BXINT(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DAF1,DAF2,DSUM)
C
C-----------------------------------------------------------------------
C
C  SR.BXINT USES SIMSPONS RULE TO INTEGRATE THE PRODUCT OF TWO FUNCTIONS
C  ON A RADIAL MESH OF INCREASING STEPSIZE.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DASTEPSIZE(*),DAF1(*),DAF2(*)
C
      IINDEX=0
      DSUM=DZERO
      D_TSUM=DZERO
      DFAC=DONE
      IU=2
C
      DO II=1,IN_INT
C                                     PRINT *,"INTEGRATING INTERVAL ",II
        IF(II.NE.1)THEN
          IU=1
          DT=DAF1(IINDEX)*DAF2(IINDEX)
          D_TSUM= DT
        ELSE
          D_TSUM=DZERO
          IU=1
        ENDIF
C           PRINT *,IINDEX,") DAF1=",DAF1(IINDEX),"DFAC=",DFAC," DT=",DT
        DFAC=DTWO
C
        DO IN=IU,(IANSTEPS(II)-1)
          IINDEX=IINDEX+1
          IF(DFAC.EQ.DTWO)THEN
            DFAC=DFOUR
          ELSE
            DFAC=DTWO
          ENDIF
C
          DT=DFAC*DAF1(IINDEX)*DAF2(IINDEX)
          D_TSUM=D_TSUM+DT
C            PRINT *,IINDEX,") DAF1=",DAF1(IINDEX),"DFAC=",DFAC,"DT=",DT
          IF(IINDEX.EQ.(IR0-1))GO TO 1
        ENDDO
C
  1     DFAC=1
        IINDEX=IINDEX+1
        DT=DAF1(IINDEX)*DAF2(IINDEX)
        D_TSUM=D_TSUM+DT
C            PRINT *,IINDEX,") DAF1=",DAF1(IINDEX),"DFAC=",DFAC,"DT=",DT
        D_TSUM=D_TSUM*DASTEPSIZE(II)/DTHREE

        DSUM=DSUM+D_TSUM
        IF(IINDEX.EQ.IR0)GO TO 2              !WE ARE DONE
      ENDDO
C                                        PRINT *,"INTEGRAL RESULT ",DSUM
C
  2   RETURN
C
      END SUBROUTINE BXINT
C
C                             *******************
C
      SUBROUTINE BXNORM(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DARFUNC)
C
C-----------------------------------------------------------------------
C
C  SR.BXNORM NORMALIZES BOX FUNCTIONS, TO UNITY.
C
C  IT CALLS:
C    SR.BXINT
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
      DIMENSION DASTEPSIZE(*),DARFUNC(*)
C
      CALL BXINT(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DARFUNC,DARFUNC,DA)
C
      DA=SQRT(DA)
C
      IINDEX=1
      DO II=1,IN_INT
        DO IN=1,IANSTEPS(II)
          DARFUNC(IINDEX)=DARFUNC(IINDEX)/DA
          IINDEX=IINDEX+1
        ENDDO
      ENDDO
C
      RETURN
C
      END SUBROUTINE BXNORM
C
C                             *******************
C
      SUBROUTINE BXNUMV(IN_INT,IANSTEPS,DASTEPSIZE,ISTOP,DZ,DL,
     X                  DE,DARFUNC,DAR)
C
C-----------------------------------------------------------------------
C
C  SR.BXNUMV CARRIES-OUT A NUMEROV INTEGRATION TO DETERMINE BOX ORBITALS
C
C  IT CALLS:
C    SR.BXDFKK
C    SR.BXINFL
C    SR.BXPWRS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DASTEPSIZE(*),DARFUNC(*),DAR(*)
C
      CALL BXINFL(IN_INT,IANSTEPS,DZ,DL,DE,DR1,DR2,DAR,IRN)
C
C                                         PRINT *,"DR1=",DR1,",DR2=",DR2
C                                  PRINT *,"POWER SERIES TO IINDEX ",IRN
C
      IF((IRN.LE.0).OR.(NINT(DL).EQ.0))IRN=50    !RSET IRN TO SOMETHING
C                                                !SENSIBLE
C
C ***************************
C      FORCE IRN
C                                 PRINT *,IRN
C      IRN=8
C ***************************
C                                PRINT  *,"POSITION OF PT. OF INFL=",IRN
C
C      DARFUNC(0)=DZERO
      DO IN=1,IRN                   !FILL OUT DARFUNC USING POWER SERIES
        CALL BXPWRS(DZ,DL,DE,DAR(IN),I100,DPWRS)
        DARFUNC(IN)=DPWRS
      ENDDO
C
      ISTART_INT=1                         !INITIALISE STARTING INTERVAL
C
      II=1                               !KEEP TRACK OF CURRENT INTERVAL
      ISTART_PT=IRN          !START POINT IS WHERE THE POWER SERIES ENDS
C
C                          THIS LOOP FINDS THE INTERVAL AND THE POSITION
C                       WITHIN IT AT WHICH THE PT OF INFLECTION OCCURS -
C                        THIS WILL BE THE STARTING PT OF THE INTEGRATION
   1  IF(ISTART_PT.GT.IANSTEPS(II))THEN
        ISTART_PT=ISTART_PT-IANSTEPS(II)
        II=II+1
        GO TO 1
      ENDIF
C
      ISTART_INT=II                         !STORE THE STARTING INTERVAL
      IINDEX=IRN                                  !STORE STARTING IINDEX
C
C !-------------------------------------------------------------
C
C                      PRINT *,"BEGINNING INTEGRATION AT IINDEX=",IINDEX
C                                           PRINT *,"START INTERVAL=",II
C                                         PRINT *,"ISTART_PT=",ISTART_PT
C
      DO II=ISTART_INT,IN_INT           !WE START INTEGRATION FROM WHERE
C
        DHH=DASTEPSIZE(II)**2              !THE POWER SERIES WAS STOPPED
C
C                          PRINT *,"CONTINUING INTEGRATION FROM ",IINDEX
        DO IN=ISTART_PT,(IANSTEPS(II)-1)       !CONTINUE THE INTEGRATION
C                                        ! FOR THE REST OF THIS INTERVAL
C                                       !PRINT *,DHH
          IF(IN.EQ.0)THEN
            IM=IINDEX-2
          ELSE
            IM=IINDEX-1
          ENDIF
          IC=IINDEX
          IP=IINDEX+1
C                                         !PRINT *,"IM,IC,IP ",IM,IC,IP
          CALL BXDFKK(DZ,DL,DE,DAR(IP),DKK_P)
          CALL BXDFKK(DZ,DL,DE,DAR(IC),DKK_C)
          CALL BXDFKK(DZ,DL,DE,DAR(IM),DKK_M)
C
          DARFUNC(IP)=DTWO*(DONE-((DFIVE*DHH)/DTWELV)*DKK_C)*DARFUNC(IC)
          DARFUNC(IP)=DARFUNC(IP)-DARFUNC(IM)*(DONE+(DHH/DTWELV)*DKK_M)
          DARFUNC(IP)=DARFUNC(IP)/(DONE+((DHH/DTWELV)*DKK_P))
C
C     !!PRINT *,"    ----> ",DKK_C
C     !!PRINT *,IINDEX,"    ",DARFUNC(IP)
C
          IINDEX=IINDEX +1
          IF(IINDEX.GE.ISTOP)GO TO 108
        ENDDO
C
        ISTART_PT=0                   !FOR ALL INTERVALS AFTER THE FIRST
C                                          !(NOT NESSECARILY INTERVAL 1)
C                               !WE SET I3START_PT=0 SO TWO NEW STARTING
C                                  !POINTS ARE TAKING FROM PREV INTERVAL
C
C                !PRINT *,"FINISHED INTERVAL ",II,",LAST IINDEX=",IINDEX
C                !PRINT *,"."
      ENDDO
C
 108  RETURN
C
      END SUBROUTINE BXNUMV
C
C                             *******************
C
      SUBROUTINE BXPWRS(DZ,DL,DE,DR,II,DSUM)
C
C-----------------------------------------------------------------------
C
C  SR.BXPWRS DETERMINES A POWER SERIES OF A FUNCTION OF FORM SUM(CN*R^N)
C  NOTE: SET BB TO TRUE IF YOU WANT THE INTEGRATION TO ASSUME
C  THE INTIAL VALUE AT THE ORIGIN IS ZERO
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DT=D1M40
C
      DC0=DONE
      DC1=-DZ*DC0/(DL+DONE)
C
      DFIRST_R=DR**(NINT(DL)+1)
      DSUM=DC0*DFIRST_R+DC1*DFIRST_R*DR
C
      DCUR_R=DFIRST_R*DR
C
      DCM1=DC1
      DCM2=DC0
C
      DN=DTWO
      BB=.TRUE.
C
   1  CONTINUE
C
      DC=-(DTWO*DZ*DCM1+DE*DCM2)
C                         !DC=DC/((DN+2.0D00)*(DN+(2.0D00*DL)+3.0D00))
      DC=DC/(DN*(DN+DTWO*DL+DONE))
C
      DCUR_R=DCUR_R*DR
      DCUR_TERM=DC*DCUR_R
C
C                                       PRINT *,CUR_TERM
      DSUM=DSUM+DCUR_TERM
C
      DCM2=DCM1
      DCM1=DC
C
      DN=DN+DONE
C                                       PRINT *,DCUR_TERM
      IF(DN.GT.II)THEN
C                                  PRINT *,DSUM,DCUR_TERM
        BB=.FALSE.
C        DNTERMS=DN
      ELSE
        IF(ABS(DCUR_TERM).LT.ABS(DT*DSUM))THEN
          IF(DC.NE.DZERO)THEN
            BB=.FALSE.
C            DNTERMS=DN
          ENDIF
        ENDIF
      ENDIF
C
      IF(BB)GO TO 1              !ELSE WE ARE DONE - DSUM
C
C                                PRINT *,"MAX NO.OF TERMS=",I
C                                PRINT *,"TERMS USED=",DNTERMS
C
      RETURN
C
      END SUBROUTINE BXPWRS
C
C                             *******************

      SUBROUTINE BXSCHN(IN_INT,IANSTEPS,DASTEPSIZE,DZ,
     X                  IN,IL,DE,DARFUNC,DR,IR0,IM0)
C
C-----------------------------------------------------------------------
C
C  SR.BXSCHN IS THE *** MAIN DRIVER FOR BOX ORBITAL GENERATION: ***
C
C  IT SEARCHES FOR THE BOXED STATE WITH Q. NO N,L,Z,E ETC...
C  ADDED DR0 (29_09_04),CAN BE ANYWHERE IN MESH
C
C  IT CALLS:
C    SR.BXCUNT
C    SR.BXNORM
C    SR.BXSRCH
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D99=99.0D0)
      PARAMETER (DPI=3.14D0)
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DASTEPSIZE(*),DARFUNC(*),DR(*)
C
C                       PRINT *,"CALL BXSCHN()"
C                       PRINT *,"IN=",IN,",IL=",IL,",DE=",DE,",IR0=",IR0
C
      IF(DE.GT.DZERO)THEN                                   !CHECK MESH
        DT=SQRT(DE)
        DT=DPI/DT
        DT=DT/(DR(IR0)-DR(IR0-1))
        IF(DT.LT.DTWELV)THEN
          WRITE(6,*)'*** BXSCHN: INCREASE MSTEP TO:',IM0+1
          WRITE(0,*)'*** BXSCHN: RADIAL MESH TOO COARSE'
          IL=-999
          RETURN
        ENDIF
      ENDIF
C
      DT=D1M6                                   !CONVERGE E-ENERGY TO DT
      DTF=D1M9                               !CONVERGE E-FUNCTION TO DTF

      DL=IL
      DN=IN
      INODES=IN-IL-1
C
C*****************************************
C
      DR0=DR(IR0)
C                                                             !ISIZE=IR0
C
      IF(DE.GT.-D99*DZ**2)THEN
C                      FIND THE FIRST BOXED STATE NEAR THE INITIAL GUESS
C                      PRINT *,"USING SUPPLIED INITIAL GUESS"
        DE0=DE
      ELSE
C                                                  MAKE AN INITIAL GUESS
        IF(IN.GT.2) THEN
          DE0=(DPI*DZ*DN**2)/(2*2*DR0)
        ELSE
          DE0=-(DZ**2)/(DN**2)
        ENDIF
C                                                         DE0=DE0/2.0D00
C
      ENDIF
C
      DDE=ABS(DE0)/D1P2
C
C                                       PRINT *,"INITIAL GUESS=",DE0,DDE
      D_DE_COARSE=DE0/DTEN
C
C                IF(DE0.LT.1.0D0)D_DE_COARSE=1.0D0
C     *****************************************
C                PRINT *,"N=",IN,",L=",IL
C                PRINT *,"LOOKING FOR ",INODES," INODES"
C
C      *****************************************
C
C
      CALL BXSRCH(IN_INT,IANSTEPS,DASTEPSIZE,DZ,DL,DE0,
     X            DE,DDE,DT,DTF,DARFUNC,DR,IR0)
C
      CALL BXCUNT(IN_INT,IANSTEPS,DTF,DARFUNC,IR0,ICNODES)
C
C*****************************************
C
C                PRINT *,"E=",DE0," DE=",D_DE_COARSE," ICNODES=",ICNODES
C
C*********************************************
C
C  DETERMINE WHICH DIRECTION IN ENERGY IT NEEDS TO GO
C  TO FIND THE CORRECT FUNCTION
C
      IF(ICNODES.LT.INODES)THEN      !NEED TO GO UP
        D_DE_COARSE=ABS(D_DE_COARSE)
        DDE=ABS(DDE)
        IDIR=1
      ELSEIF(ICNODES.GT.INODES)THEN  !NEED TO GO DOWN
        D_DE_COARSE=-ABS(D_DE_COARSE)
        DDE=-ABS(DDE)
        IDIR=-1
      ELSE                           !WE ARE DONE
        GO TO 2                      !NORMALIZE
      ENDIF
C
   1  CONTINUE
C
      DE0=DE0+D_DE_COARSE
C
C      PRINT *,"E=",DE0," DE=",D_DE_COARSE," ICNODES=",ICNODES
C
      CALL BXSRCH(IN_INT,IANSTEPS,DASTEPSIZE,DZ,DL,
     X            DE0,DE,DDE,DT,DTF,DARFUNC,DR,IR0)
C
      CALL BXCUNT(IN_INT,IANSTEPS,DTF,DARFUNC,IR0,ICNODES)
C
C FINDHAT DIRECTION WE NEED TO GO IN NOW
C
      IF(ICNODES.LT.INODES)THEN
        IF(IDIR.EQ.-1)THEN
          DE0=DE0+ABS(D_DE_COARSE)
          D_DE_COARSE=D_DE_COARSE/DTWO
        ENDIF
        GO TO 1
      ELSEIF(ICNODES.GT.INODES)THEN
        IF(IDIR.EQ.1)THEN
          DE0=DE0-ABS(D_DE_COARSE)
          D_DE_COARSE=D_DE_COARSE/DTWO
        ENDIF
        GO TO 1
C      ELSE
C        WE ARE DONE
      ENDIF
C
C      IL=NINT(DL)
C      PRINT *,"FOUND:"
C      PRINT *,"      N=",ICNODES+IL+1,"  INODES=",ICNODES
C      PRINT *,"      L=",IL
C      PRINT *,"      Z=",DZ
C      PRINT *,"      E=",DE
C
   2  CALL BXNORM(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DARFUNC)
C
      RETURN
C
      END SUBROUTINE BXSCHN
C
C                             *******************
C
      SUBROUTINE BXSRCH(IN_INT,IANSTEPS,DASTEPSIZE,DZ,DL,DE0,
     X                  DE,DDE,DT,DTF,DARFUNC,DR,IR0)
C
C-----------------------------------------------------------------------
C
C  SR.BXSRCH SEARCHES FOR A FUNCTION WHICH IS 0 AT R0.
C
C   E0 IS INTIAL ENERGY
C   DE IS THE ENERGY STEPSIZE
C   T IS THE THRESHOLD VALUE FOR DE
C   ISIZE IS THE ISIZE OF THE R AND RFUNC ARRAY
C
C  IT CALLS:
C    SR.BXNUMV
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION IANSTEPS(*)
C
      DIMENSION DARFUNC(*),DR(*),DASTEPSIZE(*)
C
C
      DE=DE0
      CALL BXNUMV(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DZ,DL,DE,DARFUNC,DR)
C
      D_DE=DDE
      DS=1
      IF(DARFUNC(IR0).LT.0)DS=-1
C
c      ICNT=0
      ICNT_TOT=0
C
    1 CONTINUE
C
c      ICNT=ICNT+1
      ICNT_TOT=ICNT_TOT+1
C
c      IF(ICNT.GE.1000) THEN
c        ICNT=0
C               PRINT *,"SEARCHING...",ICNT_TOT," : E=",DE," DE=",D_DE
C
c      ENDIF
C
      IF(ICNT_TOT.GE.10000) THEN
         WRITE(6,*)"SR.BXSRHC: FAIL TO CONVERGE ENERGY... ITERATIONS="
     X           ,ICNT_TOT," : E=",DE," DE=",D_DE
         STOP "SR.BXSRHC: FAILURE TO CONVERGE ENERGY..."
c        NF=-1                            !SHOULD FOLLOW NORNAL EXIT:TBD
C
      ENDIF
C
      DE=DE+D_DE
C                               PRINT *,"("
C                               PRINT *,D_E
C
      CALL BXNUMV(IN_INT,IANSTEPS,DASTEPSIZE,IR0,DZ,DL,DE,DARFUNC,DR)
C
C                               PRINT *,")"
C                               PRINT *," "
      IF((DARFUNC(IR0)*DS).LT.0) THEN               !WE FLIPPED SIGN
         DE=DE-D_DE
         D_DE=D_DE/DTWO
      ENDIF
C
C       CONVERGE ON E    AND   CONVERGE ON F AS WELL
      IF((ABS(D_DE).GT.DT) .OR. (ABS(DARFUNC(IR0)).GT.DTF))GO TO 1
C
C                         PRINT *,"ABS(DARFUNC(IR0))=",ABS(DARFUNC(IR0))
C                                 PRINT *,"ABS(D_DE)=",ABS(D_DE)
C
      RETURN
C
      END SUBROUTINE BXSRCH
C
C                             *******************
C
      SUBROUTINE CADWX(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5)

C
C-----------------------------------------------------------------------
C
C  SR.CADWX CALCULATES EIE 2-BODY NR COLLISION STRENGTHS IN CA-COUPLING
C
C  IT CALLS:
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.PQ
C    SR.PQLAP
C    FN.QBINOM
C    SR.RADCNX
C    SR.SLATRX
C    SR.TOP1
C    SR.TOP2
C    FN.XINT
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,comm_barrier               !par
cpar      use mpi, only : mpi_real4,mpi_real8,mpi_integer           !par
cpar     x               ,mpi_sum,mpi_comm_world                    !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD,IPLANT_RL,n8
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
C
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXD14=100)
C
      PARAMETER (MXNXB=10)    !NO. OF BPW X-VALUES PRE-EXISTING IN ADF04
C
      PARAMETER (D0PT8=0.8D0)
cparc                                                               !par
cpar      integer(kind(mpi_integer))itmp4,ier4,izero_mpi,my_mpi_real!par
cpar      parameter (izero_mpi=0)                                   !par
cparc                                                               !par
cpar      real(rp) omsend,omrecv                                    !par
C
      REAL(RP) OMEGA,E1M30
      PARAMETER (E1M30=1.E-30)
      PARAMETER (XBTEST=DFIVE)          !APPLY btop ONLY FOR X.GT.XBTEST
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      CHARACTER(LEN=3) IEXP,IEXP0,IEXP1
      CHARACTER(LEN=4) CARD4
      CHARACTER(LEN=5) XMANT,XMANT0,XMANT1
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=15) F767
      CHARACTER(LEN=35) F762
      CHARACTER(LEN=44) F761
      CHARACTER(LEN=MXLEN) CARD
C
C
      ALLOCATABLE :: OMEGA(:,:),OMGINF(:),KACT(:,:),KTMP(:)
cpar      allocatable :: omsend(:),omrecv(:)                        !par
C
      ALLOCATABLE :: IEXP(:),XMANT(:)
      ALLOCATABLE :: OMP(:),RHO1(:) ,TMP1(:,:),TMP2(:,:)
      ALLOCATABLE :: DWRK(:),IWRK3(:),IWRK4(:)
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3),PSHFT0(0:20)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
      DIMENSION DZLX(1),DXTWOX(1),DETAX(1)   !DUMMY, SUPPRESS COMP WARNS
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
c      COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C      COMMON /WORKLS/DWRK(MAXTM),IWRK3(MAXTM),IWRK4(MAXTM)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
c      common /nrbrel/irel,kappa,igagr,irtard,ibreit,brel,bjumpr,bmvd !x
c
      common /hps/badas
C
      DATA LOLD/-1/,IU/23/,IUU/25/
c                 omginfls adf04ls
C
      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
C-----------------------------------------------------------------------
C
c some cross section units options: need to uncomment code above and  !x
c below labeled "!x"                                                  !x
c                                                                     !x
c      xconv=done                   !pi*a_0^2                         !x
c      xconv=xconv*acos(-done)      !a_0^2                            !x
c      xconv=xconv*28.003d0         !Mbarns                           !x
c      xconv=xconv*1.d6             !barns                            !x
c
c flag write of "OMEGA" file - this is by final scattered energy and so
c *not* directly usable by R-matrix utility codes such as xtrct/adasexj.
c this is somewhat historic as adasexj *does* read/process dw adf04 file
c
      bomega=.false.
c
c some test set-up switches that user joe should not need to touch.
c
      bht=.false.                  !.true. for bht(1970) test comparison
c
c set (approx) unitarity switch
c
      bunit=.true.
      if(bht)bunit=.false.
c
cparc                                                               !par
cpar      if(rp.eq.4)then                                           !par
cpar        my_mpi_real=mpi_real4                                   !par
cpar      elseif(rp.eq.8)then                                       !par
cpar        my_mpi_real=mpi_real8                                   !par
cpar      else                                                      !par
cpar        if(iam.eq.0)write(iw,*)'error rp precsion =',rp         !par
cpar        go to 999                                               !par
cpar      endif                                                     !par
C
C-----------------------------------------------------------------------
c
      btimep=btimex                                        !for iam.ne.0
      if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for cadwx'           !par
cpar        else                                                    !par
          write(iw,*)'Starting cadwx'
cpar        endif                                                   !par
        call cpu_time(timei)
        time0=timei
      endif
C
C INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TPI=DTWO*PI
C
      BPRNT2=JPRINT.GE.2                    !FOR DETAILED OMEGA PRINTOUT
      BPRNT3=JPRINT.GE.3                      !FOR DETAILED RHO PRINTOUT
      BPRNT0=JPRINT.NE.-3
      BPRNT1=JPRINT.EQ.1       !PRINT CHANNEL INFO AGAIN
C
      IF(NZION.EQ.MION)THEN
        NZA=0
        DZ2=DONE
      ELSE
        NZA=NZION-MION
        DZ2=NZA*NZA
      ENDIF
C
      LSTORE=0                                 !TRIVIAL INTEGRAL STORAGE
C
      IF(MAXLT.GE.0)THEN
        IF(LRGLAM.GT.MAXLT)THEN
          WRITE(0,*)'*** SR.CADWX: LRGLAM.GT.MAXLT, SO NO TOP-UP'
          LRGLAM=-1
        ELSE
          IF(LRGLAM.EQ.-999)LRGLAM=MAXLT
        ENDIF
        IF(LRGLAM.EQ.0)LRGLAM=-1
      ENDIF
C
      IF(LRGLAM.GE.0)THEN        !SET L WHERE DIPOLE TOP-UP NEEDS CHECKS
        LRGLMN=LRGLAM-QCL0                    !QCL0=2*NXLL - SET IN ALGX
      ELSE
        LRGLMN=1000
      ENDIF
c
      btop=btop.and.lrglam.ge.0
C
C SMALL LOCAL MEMORY
C
      MXD4=MAX(MENG,10_SP)+3
      ALLOCATE (IEXP(0:MXD4),XMANT(0:MXD4))
      ALLOCATE (OMP(MENG),RHO1(MENG),TMP1(MENG,MENG),TMP2(MENG,MENG))
C
C LOOK FOR LAST SPECTROSCOPIC ENERGY
C
c      NSPECL=0
c      DO N=1,NENERG
c        NSPECL=MAX(NSPECL,JNDEX(N))
c      ENDDO
C
C USE ROWWISE TO SIMPLY REDUCE NDIM2 IF NMETA.LT.NSPECE
C
      nmin=min(NMETA,NSPECE)
      NOMWRT=IROW(nmin,NSPECE,ione1,NSPECE)                     !ROWWISE
      NOMWR0=NOMWRT
ctest    if(ione1.eq.1)nomwr0=nomwr0+nmin      !incase ione1=0 in carate
C
C
      BTHRSH=LVMAX.GE.0
      IF(BTHRSH)THEN
        MOGGY=LVMAX+1-LVMIN
      ELSE
        MOGGY=MENG0
      ENDIF
C
      ALLOCATE (OMGINF(NOMWR0),OMEGA(MOGGY,NOMWRT),STAT=IERR)
cparc                                                               !par
cpar      allocate (omsend(nomwrt),omrecv(nomwrt),stat=ierr)        !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CADWX: ALLOCATION FAILS FOR OMEGA'
        NF=0
        GO TO 900
      ENDIF
C
      DO N=1,NOMWRT
        OMGINF(N)=DZERO
        DO M=1,MOGGY
          OMEGA(M,N)=0
        ENDDO
      ENDDO
C
C RECOVER INFINITE ENERGY INFO (ROWWISE)
C
      IF(IUNIT(IU).EQ.0)THEN                   !ADF04 WILL BE INCOMPLETE
        WRITE(6,*)'NO INFINITE ENERGY FILE="OMGINFCA"...'
        WRITE(0,*)'NO INFINITE ENERGY FILE ON UNIT=',IU
        IF(LRGLAM.GE.0)THEN
          WRITE(6,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          WRITE(0,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          NF=-1
          GO TO 700
        ELSE
          GO TO 110
        ENDIF
      ELSEIF(IUNIT(IU).LT.0)THEN
        OPEN(IU,FILE='OMGINFCA',STATUS='OLD',ERR=110)
        IUNIT(IU)=1
      ELSE                               !SERIAL SHOULD NOT BE HERE
        REWIND(IU)                       !BUT PAR ALREADY OPEN
cpar        if(iam.eq.0)then                                        !par
        stop 'cadwx: omginfca confusion'
cpar        endif                                                   !par
      ENDIF
C
      READ(IU,*)NZDUM,MDUM
      READ(IU,*)NSPEC0,MENGB,NOMWR0
C
      IF(NSPEC0.NE.NSPECE)THEN                   !SHOULD NOT HAPPEN, NOW
        WRITE(6,*)'CADWX: INFINITE ENERGY TARGET MISMATCH',NSPEC0,NSPECE
        WRITE(0,*)'CADWX: INFINITE ENERGY TARGET MISMATCH'
        NF=-1
        GO TO 700
      ENDIF
C
      ALLOCATE (DWRK(NSPEC0),IWRK3(NSPEC0),IWRK4(NSPEC0))
C
      READ(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPEC0)
      READ(IU,711)(DWRK(I),I=1,NSPEC0)
C
c optionally recover spec energy subset from omginf,
c and retain full-set in denerg back in algx.
c
c      do i=1,nspec0
c        dwrk(i)=dwrk(i)*dz2
c      enddo
c
      iflag=0
      if(nomwrt.ne.nomwr0)then       !should not happen in non-test mode
        if(ione1.eq.0)then                             !elastic in cadwx
          if(nomwrt-nmin.ne.nomwr0)then
            write(6,*)'cadwx: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'cadwx: infinite energy omega mismatch'
            nf=-1
            go to 700
          else                                   !case ione1=1 in carate
            iflag=1
          endif
        else                                         !inelastic in cadwx
          if(nomwrt+nmin.ne.nomwr0)then
            write(6,*)'cadwx: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'cadwx: infinite energy omega mismatch'
            nf=-1
            go to 700
          else                                   !case ione1=0 in carate
            iflag=2
          endif
        endif
      endif
C
      READ(IU,713)EINF,(OMGINF(I),I=1,NOMWR0)
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        IUNIT(IU)=-1                                            !par
cpar        CLOSE(IU)                                               !par
cpar      endif                                                     !par
c
      if(iflag.eq.1)then                          !make room for elastic
        n=nomwrt+1
        nshft=nmin
        do i=nmin,1,-1
          do j=nspec0,i+1,-1
            n=n-1
            omginf(n)=omginf(n-nshft)
          enddo
          n=n-1
          omginf(n)=done                             !flag poss. allowed
          nshft=nshft-1
        enddo
        if(n.ne.1)stop 'iflag=1 nshft error'
      elseif(iflag.eq.2)then                               !drop elastic
        n=0
        nshft=1
        do i=1,nmin
          do j=i+1,nspec0
            n=n+1
            omginf(n)=omginf(n+nshft)
          enddo
          nshft=nshft+1
        enddo
        if(n.ne.nomwrt)stop 'iflag=2 nshft error'
      endif
C
  110 CONTINUE
C
C WRITE-OUT SPEC. TARGET ENERGIES
C
      WRITE(6,1110)
      WRITE(6,996)NMETA
C
      DO J=1,NSPECE
        I=INDEX(J)
        WRITE(6,995)J,I,DSPECE(J)
      ENDDO
C
      WRITE(6,1111)
C
C RE-FLAG ACTIVE ORBITAL PAIR IN INTERACTING CONFIGS,
C SINCE WE DE-ALLOCATED IT IN SR.ALGX...
C
      ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CADWX: ALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 800
      ENDIF
C
      DO KF=1,KMAX
        DO KG=1,KF
          KACT(KF,KG)=0
          KACT(KG,KF)=0
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)THEN
              KACT(KF,KG)=-1
              KACT(KG,KF)=-1
              GO TO 52
            ENDIF
            KACT(KF,KG)=QCG(I,KF)
            KACT(KG,KF)=KTMP(L0)
  51      ENDDO
  52    ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C BEGIN LOOP OVER SCATTERING SYMMETRIES
C
C-----------------------------------------------------------------------
C
      NCOR=0
c
      iwait=0
      wait=done
C
      DO IX=1,INAST
C
        IL=LSPI(IX)
C
        LNEW=IL
C
C SEE IF WE NEED TO UPDATE INTEGRALS & CONTINUUM BASIS
C
        IF(LNEW.NE.LOLD)THEN
C
C-----------------------------------------------------------------------
C
          if(btimex)then
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                  ,'updating continuum for l=',il         !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)
     x         'Begin update of continuum basis & integrals for L=',lnew
cpar            endif                                               !par
c
            call cpu_time(timei)
            times=timei
          endif
C
C-----------------------------------------------------------------------
C
          lstep=lnew-lold
          if(lstep.gt.1.and.lfact.gt.100.and.lold.gt.0)then
            if(iwait.eq.4)then
              iwait=2
            else
              iwait=4
            endif
            wait=iwait*lstep
            wait=wait/dthree
          endif
C
C UPDATE CONTINUUM BASIS
C
          IF(BTHRSH)LCONDW=-LCONDW                            !FLAG
C
          CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3,LNEW,LOLD
     X               ,LCONDW,MXORB)
C
          IF(NF.LE.0)GO TO 700
C
C UPDATE EXCHANGE MULTIPOLE
C
          LDIFF=LNEW
          IF(LOLD.GE.0)LDIFF=LDIFF-LOLD
          LDIFF=LDIFF+LDIFF
C
          DO I=1,IRL
            IF(QRL(2,I).GT.MXORB)QRL(5,I)=QRL(5,I)+LDIFF  !EXCHANGE
          ENDDO
C
C UPDATE SLATER INTEGRALS
C
          IF(BPRNT0)WRITE(6,1996)LNEW
C
          DO M=1,MTRAN
            M1=MNDEX(M,1)
            M2=MNDEX(M,2)
            CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                 ,DRLX(1,M,LSTORE)
     X                 ,DZLX(1)
     X                 ,DXTWOX(1)
     X                 ,DETAX(1)
     X           ,M1,M2,LNEW,MAXLX,MXORB)
          ENDDO
C
          LOLD=LNEW
C
C-----------------------------------------------------------------------
C
          if(btimex)then
            call cpu_time(timef)
            times=timef-times
c
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                  ,'updating continuum'                   !par
cpar     x                 ,' time=',nint(times),'sec'              !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'End update of continuum basis & integrals'
     x               ,', time=',nint(times),'sec'
cpar            endif                                               !par
          endif
C
C-----------------------------------------------------------------------
C
        ENDIF
C
C
C INITIALIZE FOR L-LOOP
C
        IF(BPRNT1)THEN
          WRITE(6,1135)IX
        ELSEIF(BPRNT0)THEN
          WRITE(6,1130)IX
        ENDIF
C
        IF(BPRNT2)WRITE(6,1116)
C
C-----------------------------------------------------------------------
C
        if(btimex)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'Starting proc',iam                     !par
cpar     x                ,'cadwx symmetry',ix,':',il               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Starting cadwx symmetry',ix,': L=',il
cpar          endif                                                 !par
c
          call cpu_time(timei)
          times=timei
        endif
C
C-----------------------------------------------------------------------
C
C
C NOW FORM CA INTERACTION
C************************
C
C
        MTL=IL+IL
        LI=MTL                                        !INITIAL CHANNEL L
C
c set position of phase shift for this li.
c only required by elastic case, for diagonal rho.
c n.b. recall, elastic yet not coded for CA.
c
        if(ione1.eq.0)then
          L=LCONDW/2+1-LNEW+LI/2
          L0=ABS(QPOS(L))
        endif
c        lcon0=4*((nmulte-1)/2)                                   !local
C
        DO KF=1+ione1,KMAX                                !BEGIN KF LOOP
C
          DO KG=1,KF-ione1                                !BEGIN KG LOOP
C
            IF(KACT(KG,KF).LT.0)GO TO 73
C
            N1=KACT(KF,KG)
            L1=QL(N1)
            N2=KACT(KG,KF)
            L2=QL(N2)
C
            L12M=ABS(L1-L2)
            L12=L1+L2
C
            LCON=L12
   57       LMIN=MTL-LCON
            IF(LMIN.LT.0)THEN                  !EFFECTIVE MULTIPOLE LOOP
              LCON=LCON-IFOUR
              IF(LCON.GE.L12M)GO TO 57
              LMIN=ABS(MTL-L12M)
            ENDIF
C
            LCON=MIN(L12,LCONDW-1)                               !GLOBAL
c            lcon0=3*abs(l1-l2)                                  !local
c            if(l12m.eq.2)lcon=min(lcon,14)                      !dipole
C
            MT=MTL-LCON
            IF(LMIN.LT.MT)THEN
              LMIN=MT
              IF(MOD(L12/2,ITWO).NE.MOD(LCON/2,ITWO))LMIN=LMIN+2  !ALIGN
            ENDIF
C
            LMAX=MTL+L12
            MT=MTL
C            MT=MAX(MT,LMIN)   !NEED MEMORY REPOINTED AS ACCESSES>LCONDW
            MT=MT+LCON
            IF(LMAX.GT.MT)THEN
              LMAX=MT
              IF(MOD(LMIN/2,ITWO).NE.MOD(LMAX/2,ITWO))LMAX=LMAX-2 !ALIGN
            ENDIF
C
            IF(LMAX.LT.LMIN)GO TO 73
C
            J=JNDEX(KF)
            JP=JNDEX(KG)
C
C OMIT CORRELATION BY ENERGY/NON-METASTABLE
C
            if(j.lt.0.or.jp.lt.0
     x               .or.min(j,jp).gt.nmeta)then         !non-metastable
              ncor=ncor+(lmax-lmin)/4+1
              go to 73
            endif
C
            IF(BPRNT1)WRITE(6,1125)J,JP,LMIN/2,LMAX/2
C
            NWTF=NEL(N1,KF)
            NWTG=NEL(N2,KG)
            L11=2*(L1+1)
            L22=2*(L2+1)
            NWT=NWTF*NWTG*QBINOM(L11,NWTF)*QBINOM(L22,NWTG)
C
            litlam=abs(l1-l2)/2                       !top-up multipole
C
C ALLOW FOR ANY INITIAL ALGEBRAIC TERMS NOT BEING LOWEST IN ENERGY.
C
            IF(J.LE.JP)THEN           !INITIAL ALGEBRAIC IS LOWER ENERGY
C
              JL=J                     !EO
              JH=JP                    !EO
c              KLOW=KF                 !SO
c              KUP=KG                  !SO
              LLOW=LI
              I1=1
              I2=2
C
            ELSE                        !FINAL ALGEBRAIC IS LOWER ENERGY
C
              JL=JP                    !EO
              JH=J                     !EO
c              KLOW=KG                 !SO
c              KUP=KF                  !SO
              LUP=LI
              I1=2
              I2=1
C
            ENDIF
C
            NOMT=IROW(JL,JH,ione1,NSPECE)                       !ROWWISE
            DE=DSPECE(JH)-DSPECE(JL)
c
            if(nomt.gt.nomwrt)then                !shouldn't happen, now
              write(0,*)jl,jh,nmeta,nspece,nomt,nomwrt
              stop 'omega prob.'
            endif

            DO LF=LMIN,LMAX,4                 !LOOP OVER FINAL CHANNEL L
C
              N1=NAD(NCOR)+1
              NCOR=NCOR+1
              N2=NAD(NCOR)
              IF(N1.GT.N2)GO TO 1                       !SHOULDN'T BE SO
c
c                     write(6,*)ncor,li/2,lf/2,kf,kg,n1,n2,nrk(n2)
c
c need to find if Slater integral initial and final states are swapped
c because of falling order. (algebraic are not swapped in CA.)
c
              do n=n1,n2
                bswap=.false.
                n8=nrk(n)
                if(n8.gt.0)then                      !direct or exchange
                  n0=int(n8)
                  m0=qrl(1,n0)
                  if(li.eq.ql(m0))then
                    if(li.eq.lf.and.kf.ne.kg)then
                      m0=qrl(3,n0)
                      if(m0.le.mxorb)then                      !exchange
                        if(m0.ne.kact(kg,kf))then                  !swap
                          bswap=.true.
                        endif
                        go to 60
c                      else                !direct, continue to exchange
                      endif
                    else               !distinct or kf=kg, so they can't
                      go to 60
                    endif
                  else                             !trivially, they were
                    bswap=.true.
                    go to 60
                  endif
                else                                       !interference
                  stop 'interference position wrong...?'    !tbd: remove
                endif
              enddo
c
  60          continue
c         write(6,*)bswap
C
C-----------------------------------------------------------------------
C
C FORM RHO-REACTANCE MATRIX (SQUARED)
C
              DO M0=1,MENG0
                RHO1(M0)=DZERO
              ENDDO
C
              DO N=N1,N2            !BEGIN LOOP OVER SLATER INTERACTIONS
C
                n8=NRK(N)
                IF(n8.GT.0)THEN                      !DIRECT & EXCHANGE
                  N0=INT(n8)
                ELSE                                 !INTERFERENCE
                  K1=-INT(n8/IPLANT_RL)              !DIRECT      !MAXRL
                  K2=-INT(n8+K1*IPLANT_RL)           !EXCHANGE    !MAXRL
                ENDIF
C
                DO M=1,MTRAN                   !INTERACTING ENERGY PAIRS
C
                  if(bswap)then           !swap because of falling order
                    mm=mrndx(m)
                  else
                    mm=m
                  endif
C
                  M1=MNDEX(M,I1)
                  M2=MNDEX(M,I2)
C
                  IF(n8.GT.0)THEN                    !DIRECT OR EXCHANGE
                    TMP1(M1,M2)=DRLX(N0,mm,LSTORE)
                  ELSE                               !INTERFERENCE
                    TMP1(M1,M2)=DRLX(K1,mm,LSTORE)   !DIRECT
                    TMP2(M1,M2)=DRLX(K2,mm,LSTORE)   !EXCHANGE
                  ENDIF
C
                ENDDO
C
C INTERPOLATE SLATER INTEGRAL AND UPDATE RHO^2.
C
                DO M0=1,MENG0                       !SCATTERING ENERGIES
C
                  M=IYY0(M0)
                  ml=mlim(m,1)
                  mu=mlim(m,2)
c
                  if(omginf(nomt).lt.dzero)mu=-mu           !flag dipole
C
                  T1=XINT(DE,DYY,NLAG,TMP1(1,M),M,ml,mu)         !INTERP
C
                  IF(N8.GT.0)THEN                    !DIRECT OR EXCHANGE
                    DD=T1*T1
                  ELSE       !could recover from respective dir & exc...
                    T2=XINT(DE,DYY,NLAG,TMP2(1,M),M,ML,MU)       !INTERP
                    DD=T1*T2
                  ENDIF
C
                  RHO1(M0)=RHO1(M0)+DD*DRK(N)
C
                ENDDO
c
c                    write(6,777)kf,kg,(rho1(m0),m0=1,meng0)
c  777               format(2i5,1p,10d12.3/(10x,10d12.3))
C
              ENDDO                   !END LOOP OVER SLATER INTERACTIONS
C
C-----------------------------------------------------------------------
C
C CONVERT TO TMX^2 AND ADD TO OMEGA
C
              IF(J.LE.JP)THEN
                LUP=LF
              ELSE
                LLOW=LF
              ENDIF
C
              DO M0=1,MENG0                         !SCATTERING ENERGIES
C
                M=IYY0(M0)
C
                RHOSQ=4*RHO1(M0)                                !AS A.U.
c
                if(rhosq.lt.dzero)rhosq=dzero              !interp error
C
                IF(KF.eq.KG.and.LI.eq.LF)THEN               !DIAGONAL MX
C
                  IF(BPRNT3)WRITE(6,202)LLOW/2,LUP/2,JL,JH
     X                                    ,PSHFTX(M,L0),M0,'PHASE SHIFT'
                  T=TPI*PSHFTX(M,L0)
                  C2T=COS(T)
                  S2T=SIN(T)
C
                  rho=sqrt(rhosq)                           !approx
                  if(bunit)then                             !2x2 UNITARY
                    TSQ=DONE+(C2T*(RHOSQ-DONE)+DTWO*S2T*RHO)
     X                      /(RHOSQ+DONE)
                  else                                      !non-unitary
                    tsq=done+(dtwo*s2t*rho-c2t)
                  endif
c
                  TSQ=TSQ+TSQ              !  T^R=1+EXP(2I*TAU)(T^RHO-1)
C
                ELSE                                       !OFF DIAGONAL
C
                  TSQ=4*RHOSQ              !   |T^R(V,V')|=|T^RHO(V,V')|
C
                  if(bunit)TSQ=TSQ/(DONE+RHOSQ)**2 !APPROX UNITRTY
C
C TBD             IF(KF.EQ.KG)TSQ=TSQ+TSQ         !FOR ELASTIC LI.NE.LF
C
                ENDIF
C
                IF(BPRNT3)WRITE(6,202)LLOW/2,LUP/2,JL,JH
     X                               ,RHOSQ,M0,'RHO^2-MATRIX'
C
                OMPW=wait*TSQ*NWT/DTWO
C
                if(bht)ompw=ompw/2             !for BHT(1970) comparison
C
C LOOK AT TOP-UP ISSUES, IF L LARGE ENOUGH TO WARRANT IT (OFF IF BTHRSH)
C
                IF(LNEW.GE.LRGLMN)THEN
C                                                            !NON-DIPOLE
                  IF(OMGINF(NOMT).GT.DZERO.and.litlam.gt.0)THEN
C
                    IF(LNEW.EQ.LRGLAM)THEN                 !APPLY TOP-UP
                      EJ=DYY0(M0)
                      EI=EJ+DE
c
                      ompw0=ompw
                      ompw=ompw/wait
                      IF(BPRNT3)OMPW=-OMPW                   !FLAG PRINT
C
                      CALL TOP2(LITLAM,LRGLAM,EI,EJ,OMPW)
C
                      ompw=ompw+ompw0*(wait-done)/wait           !adjust
c
                    ELSEIF(LNEW.GT.LRGLAM)THEN
                      OMPW=DZERO
                    ENDIF
C                                                  !DIPOLE:LITLAM=LRGLAM
                  ELSEIF(OMGINF(NOMT).LT.DZERO)THEN       !POSS ZERO-OUT
C                                                        !INC. IN TOP-UP
                    IF(MAX(LI,LF)/2.GT.LRGLAM)OMPW=DZERO
C
                  ENDIF
C
                ENDIF
C
C ARCHIVE PARTIAL/TOTAL COLLISION STRENGTHS
C
                IF(BTHRSH)THEN
                  M00=LUP/2+1-LVMIN
                  IF(M00.LT.1.OR.M00.GT.MOGGY)GO TO 1
                ELSE                          !CASE NOT XCLUDED BY CALGX
                  M00=M0
                ENDIF
C
                OMP(M0)=OMPW
C                                                    !UPDATE TOTAL OMEGA
                OMEGA(M00,NOMT)=OMEGA(M00,NOMT)+REAL(OMPW,RP)
C
              ENDDO                              !END LOOP OVER ENERGIES
C                                                         !PARTIAL OMEGA
              IF(BPRNT2)
     X        WRITE(6,201)LLOW/2,LUP/2,JL,JH,(OMP(M0),M0=1,MENG0)
C
    1       ENDDO                                 !END LOOP OVER FINAL L
C
  73        CONTINUE
C
          ENDDO                                   !END LOOP KG
C
        ENDDO                                     !END LOOP KF
C
C-----------------------------------------------------------------------
c
        if(btimex)then
          call cpu_time(timef)
          times=timef-times
c
cpar          if(iam.ge.0)then                                      !par
cpar            write(6,*)'Ending proc',iam                         !par
cpar     x               ,'cadwx symmetry',ix                       !par
cpar     x               ,'  time=',nint(times),'sec'               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Ending cadwx symmetry ',ix
     x             ,'  time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C                                             --------------------------
      ENDDO                                   !END LOOP OVER TOTAL SYMMS
C                                             --------------------------
C
      IF(IADD.NE.NCOR)THEN
        WRITE(6,*)'SR.CADWX: GLOBAL INDEX ERROR:',IADD,NCOR        !test
        GO TO 999
      ENDIF
C
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        if(btimex)then                                          !par
cpar          btimep=.false.                                        !par
cpar          call cpu_time(timef)                                  !par
cpar          times=timef-time0                                     !par
cparc                                                               !par
cpar          write(iw,*)'Ending proc',iam,' for cadwx:'            !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar        endif                                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      ns=0                                                      !par
cpar      nr=0                                                      !par
cpar      itmp4=int(nomwrt)                                         !par
cparc                                                               !par
cpar      do m0=1,moggy                                             !par
cparc                                                               !par
cpar        call pomsend(ns,omega(1,1),nomwrt,omsend)               !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        call mpi_reduce(omsend,omrecv,itmp4,my_mpi_real,        !par
cpar     x                  mpi_sum,izero_mpi,mpi_comm_world,ier4)  !par
cparc                                                               !par
cpar        if(ier4.ne.0)write(0,*)'mpi_reduce: iam, ier=',iam,ier4 !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        if(iam.eq.0)call pomrecv(nomwrt,omrecv,nr,omega(1,1))   !par
cparc                                                               !par
cpar      enddo                                                     !par
cparc                                                               !par
cpar      if(iam.ne.0)go to 700                                     !par
cparc                                                               !par
C
C APPLY (DIPOLE) TOP-UP (OFF IF BTHRSH)
C
      IF(LRGLAM.GT.0)THEN
C
        WRITE(6,1002)LRGLAM
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,                                !par
cpar     x       'Top-up has been applied: lrglam=',lrglam          !par
cpar        else                                                    !par
          write(iw,*)'Top-up has been applied: lrglam=',lrglam
cpar        endif                                                   !par
        endif
        IF(BPRNT2)WRITE(6,716)
C
        LITLAM=LRGLAM                             !USE GLOBAL VALUE LA=0
        CO2S=D3QRT/LOG(EINF*DZ2)
C
        NOMT=0
        DO I=1,NMETA                                        !,NSPECL
c          IF(INDEX(I).GT.0)THEN                               !NON-CORR
C
          DO J=I+ione1,NSPECE                                !,NSPECL
c            IF(INDEX(J).GT.0)THEN                             !NON-CORR
C
              NOMT=NOMT+1
              SS=OMGINF(NOMT)
C
              IF(SS.LT.DZERO)THEN                                !DIPOLE
                SS=SS*CO2S                     !CONVERT TO LINE STRENGTH
                DE=DSPECE(J)-DSPECE(I)
                DE=DE/DZ2
                DO M0=1,MENG0
                  EJ=DYY0(M0)/DZ2
                  EI=EJ+DE
C
                  CALL TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
                  if(bht)omt=omt/2             !for BHT(1970) comparison
c
                  OM=REAL(OMEGA(M0,NOMT),WP)
                  OMEGA(M0,NOMT)=OMEGA(M0,NOMT)+REAL(OMT,RP)
C
                  IF(BPRNT2)WRITE(6,717)I,J,SS,EI,EJ,DE,OM,OMT,OM+OMT
                ENDDO
              ENDIF
C
c              IF(NOMT.EQ.NOMWRT)GO TO 113                  !WE ARE DONE
c            ENDIF
          ENDDO
C
c          ENDIF
        ENDDO
C
      ELSE
C
        WRITE(6,1003)
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,'Top-up has *NOT* been applied!'!par
cpar        else                                                    !par
          write(iw,*)'Top-up has *NOT* been applied!'
cpar        endif                                                   !par
        endif
C
      ENDIF
C
c 113  CONTINUE
c
c fix top-up failure on high-e near-degenerate Born allowed transitions
c
      if(btop)then
        NOMT=0
        DO I=1,NMETA
          DO J=I+ione1,NSPECE
            NOMT=NOMT+1
            OMB=OMGINF(NOMT)
            IF(OMB.GT.DZERO)THEN                                   !born
              DE=DSPECE(J)-DSPECE(I)
              DE=MAX(DE,D1M30)
              OM=REAL(OMEGA(2,NOMT),WP)
              DO M0=3,MENG0                        !skip threshold point
                RAT=DYY0(M0)/DE
                OM1=OM
                OM=REAL(OMEGA(M0,NOMT),WP)
                IF(RAT.GT.XBTEST.AND.OM.LT.D0PT8*OM1.AND.OM1.LT.OMB)THEN
                  MM=M0-1              !max(2,m0-1) if no threshold skip
                  GO TO 196
                ENDIF
              ENDDO
              M0=MENG0
              MM=M0+1
              IF(OM1.GE.OMB)THEN
                IF(OM.LT.OMB)MM=MENG0
              ELSE
                IF(OM.LT.OM1)MM=MENG0
              ENDIF
  196         IF(BPRNT2.AND.MM.LE.MENG0)THEN
                WRITE(6,762)I,J,DYY0(M0),DE,RAT,
     X                        (OMEGA(M,NOMT),M=1,MENG0),OMB
              ENDIF
              DO M0=MM,MENG0
                OMEGA(M0,NOMT)=REAL(OMB,RP)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      endif
c                                                                     !x
c test convert to cross section                                       !x
c                                                                     !x
c      nomt=0                                                         !x
c      do i=1,nmeta                                                   !x
c        j=index(i)                                                   !x
c        do ip=i+ione1,nspece                                         !x
c          nomt=nomt+1                                                !x
c          de=dspece(ip)-dspece(i)                                    !x
c          jp=index(ip)                                               !x
c          kf=max(j,jp)                                               !x
c          kg=min(j,jp)                                               !x
c          n1=kact(kf,kg)                                             !x
c          l1=ql(n1)                                                  !x
c          n2=kact(kg,kf)                                             !x
c          l2=ql(n2)                                                  !x
c          n1=nel(n1,kf)                                              !x
c          n2=nel(n2,kg)                                              !x
c          if(kf.eq.j)then                                            !x
c            wi=qbinom(2*(l1+1),n1-1)*qbinom(2*(l2+1),n2)             !x
c          else                                                       !x
c            wi=qbinom(2*(l1+1),n1)*qbinom(2*(l2+1),n2-1)             !x
c          endif                                                      !x
c          do m0=1,moggy                                              !x
c            ej=dyy0(m0)                                              !x
c            ei=ej+de                                                 !x
c            if(brel)ei=ei+dalf4*ei*ei          !wavenumber           !x
c            om=real(omega(m0,nomt),wp)                               !x
c            om=xconv*om/(ei*wi)                                      !x
c            omega(m0,nomt)=real(om,rp)                               !x
c          enddo                                                      !x
c        enddo                                                        !x
c      enddo                                                          !x
C
C-----------------------------------------------------------------------
C
C WRITE TOTALS
C
      IF(BTHRSH)THEN
        WRITE(6,1001)
        IF(BPRNT0)THEN
          WRITE(6,1118)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MOGGY
            WRITE(6,200)REAL(M0-1+LVMIN),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ELSE
        WRITE(6,1000)
        IF(BPRNT0)THEN
          WRITE(6,1117)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MENG0                                         !=MOGGY
            WRITE(6,200)DYY0(M0),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ENDIF
C
      IF(IUNIT(IU).GT.0)THEN
        CLOSE(IU,STATUS='DELETE')
        IF(BTHRSH.or..not.bomega)THEN
          IUNIT(IU)=-1
        ELSE
          OPEN(IU,FILE='OMEGACA',STATUS='REPLACE')  !OPEN UNDER NEW NAME
CTBD        OPEN(IU,FILE='OMEGAUCA',STATUS='REPLACE',FORM='UNFORMATTED')
          WRITE(IU,*)NZION,MION
          WRITE(IU,*)NSPECE,-(MENG0+1),NOMWRT       !FLAG NO E'S .LT.0
          WRITE(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
          WRITE(IU,711)(DWRK(I),I=1,NSPECE)
          DO M0=1,MENG0                                          !=MOGGY
            WRITE(IU,713)DYY0(M0)/DZ2,(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
          WRITE(IU,713)EINF,(OMGINF(N),N=1,NOMWRT)
          IUNIT(IU)=-1
          CLOSE(IU)
        ENDIF
      ENDIF
C
C OVERWRITE PWB ADF04 WITH DW, TAKING ACCOUNT OF THE FACT THAT THE PWB
C DOES NOT CONTAIN (SPIN) FORBIDDEN TRANSITIONS
C
      IF(IUNIT(IUU).GE.0)THEN           !NO ADF04, LIKELY SINCE RAD='NO'
        WRITE(6,*)'NO ADF04 FILE="adf04ca"...'
        WRITE(0,*)'NO ADF04 FILE ON UNIT=',IUU
C        NF=-1
        GO TO 700
      ELSEIF(IUNIT(IUU).LT.0)THEN
        IUNIT(IUU)=1
        OPEN(IUU,FILE='adf04ca',STATUS='OLD',ERR=700)
      ENDIF
C
      BEXP=.FALSE.                              !*MUST* SYNC WITH CARATE
      IF(NSPECE.LT.1000)THEN
        i1=0
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
            F767='(18X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
            F767='(16X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2)/(18X,20(1PE10.2)))'
            F762='(2I4,21(1PE10.2)/(18X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3)/(16X, 20(A5, A3)))'
            F762='(2I4, 21(A5, A3)/(16X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ELSE
        i1=1
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
            F767='(20X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
            F767='(18X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2)/(20X,20(1PE10.2)))'
            F762='(2I5,21(1PE10.2)/(20X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3)/(18X, 20(A5, A3)))'
            F762='(2I5, 21(A5, A3)/(18X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ENDIF
C
      MSC0=80
      OPEN(MSC0,STATUS='SCRATCH',FORM='FORMATTED')
      IF(.NOT.BEXP)THEN
        MSCP=81
        OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
      ENDIF
C
      DO N=1,NSPECE+2
        READ(IUU,760)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
      NNN=max(NOMWRT,nomwr0)
C
      DO N=1,NNN+2
        READ(IUU,760,END=115)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
 115  REWIND(IUU)
      REWIND(MSC0)
C
      DO N=1,NSPECE+2
        READ(MSC0,760)CARD
        WRITE(IUU,760)CARD
      ENDDO
C
      IF(BTHRSH)THEN
        ITYPE=6
        WRITE(IUU,F767)(PSHFT0(M-1+LVMIN),M=1,MOGGY)
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(REAL(M-1+LVMIN),M=1,MOGGY)
        ELSE
          WRITE(MSCP,764)(REAL(M-1+LVMIN),M=1,MOGGY)
        ENDIF
      ELSE
        ITYPE=5
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(DYY0(M),M=1,MENG0)   !=MOGGY
        ELSE
          WRITE(MSCP,764)(DYY0(M),M=1,MENG0)                     !=MOGGY
        ENDIF
      ENDIF
C
      IF(BEXP)THEN
        READ(MSC0,F761)
      ELSE
        BACKSPACE(MSCP)
        READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
        iexp(0)='   '
        READ(MSC0,F761)XMANT(0)                                !,IEXP(0)
        WRITE(IUU,F761)XMANT(0),IEXP(0),ITYPE
     X               ,(XMANT(M),IEXP(M),M=1,MOGGY)
      ENDIF
C
      MENG1=MOGGY+1
      IB0=1
      JB0=IB0+IONE1
c
      nt=0
C
      DO N=1,NNN+1
C
        IF(BEXP)THEN
          READ(MSC0,F762)JB,IB,XB0,(DUM,I=1,MXNXB),XB1
        ELSE
          READ(MSC0,F762)JB,IB,XMANT0,IEXP0,
     X             (XMANT(I),IEXP(I),I=1,MXNXB),XMANT1,IEXP1
        ENDIF
C
        JB1=JB
        IF(JB.LT.0)THEN
          JB1=NSPECE
          IB=MIN(JB1-IONE1,NMETA)
          IF(BEXP)THEN
            XB0=D1M30
            XB1=DZERO
          ELSE
            XMANT0=' 1.00'
            IEXP0='-30'
            XMANT1=' 0.00'
            IEXP1='+00'
          ENDIF
        ENDIF
C
        IF(BEXP)THEN
          X0=D1M30
          X1=DZERO
        ELSE
          XMANT(0)=' 1.00'
          IEXP(0)='-30'
          XMANT(MENG1)=' 0.00'
          IEXP(MENG1)='+00'
        ENDIF
C
        DO JT=JB0,JB1
          IF(JT.EQ.JB1)THEN
            IB1=IB
          ELSE
            IB1=MIN(JT-IONE1,NMETA)
          ENDIF
          DO IT=IB0,IB1
C
ctest        if(ione1.eq.0.or.it.ne.jt)then   !catch ione1=0 carate only
            nt=nt+1
c
            NOMT=IROW(IT,JT,IONE1,NSPECE)
C                                            !TEST MENG0 STILL IF BTHRSH
            IF(OMEGA(MENG0,NOMT).GT.E1M30)THEN           !NO SKIP FOR CA
c
c              if(omginf(nomt).lt.dzero)then  !test write reduced dipole
c                do m=1,moggy
c                  de=log(dyy0(m)+2.7183)
c                  omega(m,nomt)=omega(m,nomt)/de
c                enddo
c              endif
C
              IF(BEXP)THEN
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  X0=XB0
                  X1=XB1
                ENDIF
                WRITE(IUU,F762)JT,IT,X0,(OMEGA(M,NOMT),M=1,MOGGY),X1
              ELSE
                BACKSPACE(MSCP)
                WRITE(MSCP,764)(OMEGA(M,NOMT),M=1,MOGGY)
                BACKSPACE(MSCP)
                READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  XMANT(0)=XMANT0
                  IEXP(0)=IEXP0
                  XMANT(MENG1)=XMANT1
                  IEXP(MENG1)=IEXP1
                ENDIF
                WRITE(IUU,F762)JT,IT,(XMANT(M),IEXP(M),M=0,MENG1)
              ENDIF
C
            ENDIF
ctest        endif
          ENDDO
          IB0=1
        ENDDO
C
        IF(JB.LT.0)then
          if(nt.ne.nomwrt)then                                 !checksum
            write(6,*)'adf04 no. of transitions mis-match: nt,nomwrt='
     x                ,nt,nomwrt
            write(0,*)'adf04 no. of transitions mis-match'
            nf=-1
            go to 700
          endif
          GO TO 120
        endif
C
        JB0=JB
        IB0=IB+1
C
      ENDDO
C
      WRITE(0,*)'SR.CADWX: HAVE NOT REACHED END OF adf04ca...'
      WRITE(6,*)'SR.CADWX: HAVE NOT REACHED END OF adf04ca...'
      NF=-1
      GO TO 700
C
  120 WRITE(IUU,F762)-1
      WRITE(IUU,F762)-1,-1
c
        if(.not.badas)then                           !adas skip comments
      WRITE(IUU,758)
C
      NREC=1
  121 NREC=NREC+1
      BACKSPACE(5)
      BACKSPACE(5)
      READ(5,766)CARD4
      IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
      REWIND(5)
C
      DO N=1,NREC
        READ(5,760)CARD
        WRITE(IUU,759)CARD
      ENDDO
      DATE='        '
      CALL DATE_AND_TIME(DATE)
      WRITE(IUU,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X             ,DATE(3:3),DATE(4:4)
        endif
C
      IUNIT(IUU)=-1
      CLOSE(IUU)
C
      CLOSE(MSC0)
      IF(.NOT.BEXP)CLOSE(MSCP)
C
C-----------------------------------------------------------------------
C
  700 CONTINUE
C
      DEALLOCATE (KACT,KTMP,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CADWX: DEALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 999
      ENDIF
C
  800 DEALLOCATE (OMGINF,OMEGA,STAT=IERR)
cparc                                                               !par
cpar      deallocate (omsend,omrecv,stat=ierr)                      !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CADWX: DEALLOCATION FAILS FOR OMEGA'
        NF=0
        GO TO 999
      ENDIF
C
  900 CONTINUE
C
      DEALLOCATE (OMP,RHO1,TMP1,TMP2)
      DEALLOCATE (IEXP,XMANT)
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
  999 CONTINUE
C
C-----------------------------------------------------------------------
C
      if(btimep)then
        call cpu_time(timef)
        times=timef-time0
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for cadwx:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending cadwx: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C
  200 FORMAT(F21.3,2X,1P,10(E11.3)/(23X,10(E11.3)))
  201 FORMAT(2I5,3X,2I4,2X,1P,10(E11.3)/(23X,10(E11.3)))
  202 FORMAT(2I5,3X,2I4,2X,1PE11.3,10X,'E(',I2,')   ',A13)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  716 FORMAT(3X,'CH',2X,'CHP',9X,'S',14X,'EI',10X,'EJ',10X,'DE',
     X9X,'OMEGA(PAR)',2X,'OMEGA(TOP)',4X,'OMEGA(TOT)')
  717 FORMAT(2I5,3X,1PE11.3,2X,0P,3F12.4,5X,2F12.4,2X,F12.4)
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  762 FORMAT(2I5,22(1PE10.2))
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE DISTORTED-WAVE'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  995 FORMAT(2I10,13X,F18.6)
  996 FORMAT(9X,'I',8X,' C',21X,'(EI-E1)/RY'
     X      ,15X,'NMETA=',I5)
 1000 FORMAT(///1X,136('-')//51X,
     X       '*** TOTAL COLLISION STRENGTHS (CA) ***'//1X,136('-')//)
 1001 FORMAT(///1X,136('-')//45X,
     X       '*** THRESHOLD PARTIAL COLLISION STRENGTHS (CA) ***'//
     X      1X,136('-')//)
 1002 FORMAT(//' *** TOP-UP HAS BEEN APPLIED: LRGLAM=',I5//)
 1003 FORMAT(//' *** TOP-UP HAS *NOT* BEEN APPLIED ***'//)
 1110 FORMAT(//1X,136('-')///
     X   49X,'*** TARGET ENERGIES (CA) ***'/)
 1111 FORMAT(//1X,136('-')/)
 1116 FORMAT(/3X,' L',3X,'LP',5X,' I',2X,'IP',4X,'OMEGA(IE=1,MENG):')
 1117 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/2X,'*FINAL* ENERGY(RYD)'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1118 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/1X,'*FINAL* RYDBERG A.M.'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1125 FORMAT(20X,2I5,2X,2I4)
 1130 FORMAT(' SY=',I3/1X,6('-'))
 1135 FORMAT(' SY=',I3,13X,'    I','   IP',3X,'LP=...,+2')
 1996 FORMAT(//' *** UPDATING SLATER INTEGRALS FOR LTOT=',
     X       I3/1X,42('-')/)
C
      END SUBROUTINE CADWX
C
C                             *******************
C
      SUBROUTINE CALCFX(N,DX,DF)
C
C-----------------------------------------------------------------------
C
C  SR.CALCFX HAS BEEN WRITTEN ACCORDING TO THE REQUIREMENTS OF SR.VA04A.
C  THE ROUTINE RETURNS THE VARIATIONAL FUNCTIONAL DF; DF DEPENDS UPON
C  N.LE.MXVAR SCALING PARAMETERS DX, SOME OF WHICH MAYBE VARIATIONAL.
C
C  IT CALLS:
C    SR.CARATE
C    SR.CAVE0
C    SR.DIAGFS
C    SR.DIAGON
C    SR.RADIAL
C    SR.SOCC
C
C-----------------------------------------------------------------------
C
      USE COMMON_TRANS,  ONLY: TFU
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DX(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CADJ/DAJNEW(MXVAR),DF0,IEQUAL(MXVAR),ICOUNT
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /CALAN/DALAN(MXVAR),BALAN
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV0
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
C
C
C ASSIGN VALUES DX TO SCALING FACTORS DAJNEW(I)
C
      NP0=0
      IF(IPOLFN.LT.0)NP0=-IPOLFN
      NPARM3=(NP0+1)*NPARAM              !MXVAR
C
      DO I=1,NPARM3      !=SIZE OF PARAMETER ARRAYS, DEFINED IN SR.MINIM
        J=IEQUAL(I)
        IF(J.GT.0)THEN
c          write(6,*)i,j,dx(j)
C          IF(J.LE.N)THEN                          !CONTROLLED BY IEQUAL
            DAJNEW(I)=DX(J)
            IF(BALAN)DALAN(I)=DX(J)
C          ENDIF
        ENDIF
      ENDDO
C
      IF(ISCALR.GT.0)SCALER=DAJNEW(ISCALR)     !SLATER SCALING PARAMETER
C
C UPDATE RADIAL FUNCTIONS & CA ENERGIES
C
      CALL RADIAL(DAJNEW)
C
      IF(ICAV0.NE.0)THEN                       !UNIQUE
        ICAV=-ABS(ICAV0)
C
        CALL CAVE0(ICAV)
C
      ENDIF
C
      IF(NF.LE.0)GO TO 20
C
      IF(NSL0.LT.0)THEN                        !CA
C
        CALL CARATE(DECORE,DESUM)
C
        GO TO 300
      ENDIF
C
C DIAGONALIZE ENERGY MATRIX;  DESUM+DECORE=DF+DF0
C DESUM IS THE ENERGY SUM, WITHOUT THE CORE CONTRIBUTION DECORE;
C IN THE ALTERNATIVE CASE JPRINT=-2 DIAGON RETURNS DESUM=G, DECORE=0
C
      CALL DIAGON(DECORE,DESUM)                !H(LS)
C
      IF(NF.LE.0)GO TO 200
C
      IF(NJO.GT.0)THEN                         !COMPUTE FINE-STRUCTURE
C
        CALL SOCC                              !BLUME & WATSON
C
        IF(NF.LE.0)GO TO 200
C
        CALL DIAGFS(DECORE,DESUM)              !H(IC)
C
      ENDIF
C
C
 200  CONTINUE
C
      DEALLOCATE (TFU,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CALCFX: DE-ALLOCATION FAILS FOR TFU'
        NF=0
      ENDIF
C
 300  IF(NF.LE.0)GO TO 20
C
      IF(IOPTIM.EQ.0)THEN
        IF(DF0.EQ.DZERO)DF0=DECORE
        DF=(DECORE-DF0)+DESUM
        DECORE=-DF0
        DESUM=DF-DECORE
      ELSE
        DF=DESUM
        DECORE=DZERO
      ENDIF
C
C PRINT THE COMPUTED VALUE OF THE FUNCTIONAL
C
      WRITE(6,799)DF,DESUM,DECORE,ICOUNT
C
      ICOUNT=ICOUNT-1
      IF(ICOUNT.NE.0)RETURN
C
      WRITE(6,798)
C
  20  N=0
C
      RETURN
C
  799 FORMAT(/' CALCFX-FUNCTIONAL FX=',E15.8,', =(E-ECORE0)/2RY=',
     X2E16.9,24X, 'COUNTDOWN INDEX =',I4)
  798 FORMAT(' SR.CALCFX: PARAMETERS IMAXIT AND NEXTRE ALLOW NO MORE'
     X,' ITERATIVE STEPS -- IT MAY NOT BE SENSIBLE TO RESUME ITERATING')
C
      END SUBROUTINE CALCFX
C
C                             *******************
C
      SUBROUTINE CAEKAL(MMIN,MMAX,DFS,JOS)
C
C-----------------------------------------------------------------------
C
C  SR.CAEKAL EXPANDS THE ELECTRIC MULTIPOLE MATRIX ELEMENT <CA|R^K|CA'>
C  IN TERMS OF RADIAL INTEGRALS AND ANGULAR COEFFICIENTS.
C  IT CALCULATES THE AVERAGE SQUARE ALGEBRAIC COEFFICIENT * NWT
C  WHERE NWT IS THE NUMBER OF TRANSITIONS. THIS IS JUST
C  NWT * 0.5*(L1 K L2 0 0 0)**2 WHERE (...) IS THE WIGNER 3J-SYMBOL.
C
C  N.B. WE COULD DIVIDE BY THE STAT WEIGHT OF ALGEBRAIC "UPPER" STATE,
C  SAY, AND CANCEL BINOMIALS ANALYTICALLY BUT SINCE WE SUBSEQUENTLY WANT
C  THE LINE STRENGTH ANYWAY, WE CURRENTLY GENERATE A SYMMETRIC QUANTITY.
C
C  IT CALLS:
C    FN.QBINOM
C    FN.VCC
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IWORD,IAXRK
     X                        ,IAXRL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB
CB     X,MENGB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
CC      CHARACTER(LEN=4) CODE
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      DIMENSION DFS(*)
C
      COMMON /BASIC/NF,KF,KG,NEN(2,2),MGAP(5)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
CC      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
CC      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      MXORB2=MXORB*MXORB      !MXORB -> MXORBR UNNECESS. FOR CA   !FLAGX
c
      i1=1
cc      i1=mb+1                                                   !FLAGX
      i2=i1
C
      IOS0=IOS+1
      K=IOS
C
      NG=NEN(1,1)
      NT=NEN(2,1)
      M1=QL(NG)
      M2=QL(NT)
      MN=MIN(NT,NG)
      MX=MAX(NT,NG)
      IN=ICOL(MN,MX,IZERO)
C
      NUX=NEL(NG,KF)
      NLX=NEL(NT,KG)
      NWT=NUX*NLX*QBINOM(2*M1+2,NUX)*QBINOM(2*M2+2,NLX)
C
      DO MK=MMIN,MMAX,4
C
        MM=MK/2
        BINDB(IN,MM/2)=.TRUE.
C
        DD=VCC(M1,M2,MK,IZERO,IZERO,IZERO,DFS)
        DD=DD*DD/REAL(MK+1,WP)                                 !W3J NORM
        DD=NWT*DD/2
C
C STORE COEFFICIENT
C
        K=K+1
        IF(K.GT.IAXRK)THEN                                    !GO TO 999
          IXXX=7*(IAXRK/5+1)
          WRITE(6,*)'*** CAEKAL: increasing MAXRK from ',IAXRK,' to: '
     X              ,IXXX
          WRITE(0,*)'*** CAEKAL: increasing MAXRK from ',IAXRK,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'CAEKAL: REALLOCATION FAILS FOR DRK'
            NF=0
            GO TO 999
          ENDIF
C
          CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'CAEKAL: REALLOCATION FAILS FOR NRK'
            NF=0
            GO TO 999
          ENDIF
          IAXRK=IXXX
        ENDIF
C
        MX=MK
CC        MX=MX-MPOL0                                             !FLAGX
cc        if(irlx.lt.0)then
cc          i1=icfgp(kf)*mb+1
cc          i2=icfgp(kg)*mb+1
cc        endif
        IPLANT=(MX/2)*MXORB2+(NG-I1)*MXORB+NT-I2
C
        NRK(K)=IPLANT
        DRK(K)=DD
C
        IF(MPRINT.GT.0)THEN
          IF(MM.LT.10)THEN
            WRITE(6,700)JOS,KF,KG,NG,NT,K,DRK(K)/NWT,MM
          ELSE
            WRITE(6,701)JOS,KF,KG,NG,NT,K,DRK(K)/NWT,MM
          ENDIF
        ENDIF
C
      ENDDO
C
 999  IOS=K
      IF(IOS.GE.IOS0)JOS=JOS+1
C
      RETURN
C
  700 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,5X,'E',I1)
  701 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,5X,'E',I2)
C
      END SUBROUTINE CAEKAL
C
C                             *******************
C
      SUBROUTINE CAFLGL0(DFS)
C
C-----------------------------------------------------------------------
C
C  SR.CAFLGL0 EXPANDS THE DIAGONAL ENERGY MATRIX ELEMENT <CA! H !CA>
C  IN TERMS OF 2-BODY RADIAL INTEGRALS AND CALCULATES THE COEFFICIENTS.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IWORD,IAXRK
     X                        ,IAXRL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DFS(*),MRL(5)
C
      COMMON /BASIC/NF,KF,KG,MGAP(9)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      POINTER :: ML
      TARGET :: MRL
C
      ML=>MRL(5)
C
c      EQUIVALENCE (ML,MRL(5))
C
      MXLAM=ABS(MAXLAM)
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      IRL00=IRL
C
      IDIR=0                                               !ALLOW DIRECT
      IXCH=0                                              !ALLOW ECHANGE
ct      idir=1
ct      ixch=1
C
C RESTRICT RANGE OF ORBITALS
C
      NGRP0=0
      MB0=MB
C
      IF(IEQ(0).LT.0)THEN
        MXBORB=-IEQ(0)
      ELSEIF(IEQ(0).GT.0)THEN
        IF(IRLX.LT.0)THEN                                  !QUICK UNPACK
          NGRP=-IRLX/100000
          MXBORB=-IRLX-100000*NGRP
          IF(NF.EQ.0)NGRP0=NGRP
          MB0=0
        ELSEIF(NF.GT.0)THEN
          ID=IEQ(0)-MXORB
          NGRP=ID/100000
          ID=ID-100000*NGRP
          MXFORB=ID/10000
          ID=ID-10000*MXFORB
          MXVORB=ID/1000
          ID=ID-1000*MXVORB
          MXBORB=ID
        ENDIF
      ENDIF
C
      J1=1
      K00=MB+1
C
      IF(NF.EQ.0)THEN                                 !CLOSED SHELL CORE
        MXB=MB
      ELSEIF(IEQ(0).EQ.0)THEN
        MXB=0
        DO J=1,MXORB
          IF(QN(J).LT.90)MXB=J
        ENDDO
      ELSE
        N=ICFGP(KF)
        N1=(N-1)*MXBORB
        IF(IRLX.LT.0)J1=J1+N1
        K00=K00+N1
        MXB=N1+MXBORB+MB0
      ENDIF
C
C FORM CONFIGURATION AVERAGE
C
      G0=DONE/DTWO
C
      DO J=J1,MXB                              !LOOP OVER FIRST ELECTRON
C
       IF(NEL(J,KF).NE.0)THEN
C
        IF(IDIR.EQ.0)THEN
C
          MI=QL(J)+2
          F0=REAL((MI-1),WP)/REAL((2*MI-3),WP)
          MJX=MIN(INT(QL(J),SP),MXLAM)                       !MAX LAMBDA
          MJX=MIN(MJX,ITWO*NMULT)                             !LIMIT NO.
C
        ENDIF
C
        IF(NF.EQ.0)THEN
          K0=J
        ELSE                                    !EXCLUDE ANY CLOSED CORE
          K0=MAX(J,K00)
        ENDIF
C
        DO K=MXB,K0,-1                        !LOOP OVER SECOND ELECTRON
C
          BEQNL=J.EQ.K
C
          C=ABS(NEL(K,KF))
          IF(BEQNL)C=(C-DONE)/DTWO
C
          IF(C.NE.DZERO)THEN
C
            C=C*ABS(NEL(J,KF))
C
C STATIC
C
            MRL(1)=K
            MRL(3)=K
            MRL(2)=J
            MRL(4)=J
            MRL(5)=0
C
            IRL=IRL+1
            IF(IRL.GT.IAXRL)THEN                              !GO TO 999
              IXXX=7*(IAXRL/5+1)
              WRITE(6,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                  ,' to: ',IXXX
              WRITE(0,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                  ,' to: ',IXXX
C
              CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR QRL'
                NF=0
                GO TO 999
              ENDIF
              IAXRL=IXXX
            ENDIF
C
            IRK=IRK+1
            IF(IRK.GT.IAXRK)THEN                              !GO TO 999
              IXXX=7*(IAXRK/5+1)
              WRITE(6,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                  ,' to: ',IXXX
              WRITE(0,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                  ,' to: ',IXXX
C
              CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR DRK'
                NF=0
                GO TO 999
              ENDIF
C
              CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR NRK'
                NF=0
                GO TO 999
              ENDIF
              IAXRK=IXXX
            ENDIF
C
            DRK(IRK)=C
            NRK(IRK)=IRL
C
            DO M=1,5
              QRL(M,IRL)=MRL(M)
            ENDDO
C
            IF(NGRP0.NE.0)THEN            !DUPLICATE CORE FOR EACH GROUP
              DO N=1,NGRP-1
                IRL=IRL+1         !ASSUME INITIAL ALLOC O.K. FOR CORE...
                DO M=1,4
                  QRL(M,IRL)=MRL(M)+N*MXBORB
                ENDDO
                QRL(5,IRL)=MRL(5)
              ENDDO
            ENDIF
C
C DIRECT
C
            IF(BEQNL.AND.IDIR.EQ.0)THEN
C
              DO MJ=2,MJX,2
C
                ML=2*MJ
                DC1=
     X         VCC(INT(QL(J),SP),ML,INT(QL(J),SP),IZERO,IZERO,IZERO,DFS)
                F=-F0*DC1*DC1/(QL(J)+1)
c                write(6,*)ql(j),2*mj,ql(j),'  f=',f
C
                IRL=IRL+1
                IF(IRL.GT.IAXRL)THEN                          !GO TO 999
                  IXXX=7*(IAXRL/5+1)
                  WRITE(6,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                      ,' to: ',IXXX
                  WRITE(0,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                      ,' to: ',IXXX
C
                  CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL
     X                          ,IFIVE,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR QRL'
                    NF=0
                    GO TO 999
                  ENDIF
                  IAXRL=IXXX
                ENDIF
C
                IRK=IRK+1
                IF(IRK.GT.IAXRK)THEN                          !GO TO 999
                  IXXX=7*(IAXRK/5+1)
                  WRITE(6,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                      ,' to: ',IXXX
                  WRITE(0,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                      ,' to: ',IXXX
C
                  CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR DRK'
                    NF=0
                    GO TO 999
                  ENDIF
C
                  CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR NRK'
                    NF=0
                    GO TO 999
                  ENDIF
                  IAXRK=IXXX
                ENDIF
C
                DRK(IRK)=C*F
                NRK(IRK)=IRL
C
                DO M=1,5
                  QRL(M,IRL)=MRL(M)
                ENDDO
C
                IF(NGRP0.NE.0)THEN        !DUPLICATE CORE FOR EACH GROUP
                  DO N=1,NGRP-1
                    IRL=IRL+1     !ASSUME INITIAL ALLOC O.K. FOR CORE...
                    DO M=1,4
                      QRL(M,IRL)=MRL(M)+N*MXBORB
                    ENDDO
                    QRL(5,IRL)=MRL(5)
                  ENDDO
                ENDIF
C
              ENDDO
C
            ENDIF
C
C EXCHANGE
C
            IF(.NOT.BEQNL.AND.IXCH.EQ.0)THEN
C
              MRL(2)=K
              MRL(3)=J
C
              ME1=ABS(QL(J)-QL(K))/2                         !MIN LAMBDA
              ME2=(QL(J)+QL(K))/2
              ME2=MIN(ME2,MXLAM)                             !MAX LAMBDA
              ME2=MIN(ME2,ME1+2*NMULT)                        !LIMIT NO.
C
              DO MJ=ME1,ME2,2
C
                ML=2*MJ
                DC1=
     X         VCC(INT(QL(J),SP),ML,INT(QL(K),SP),IZERO,IZERO,IZERO,DFS)
                G=-G0*DC1*DC1/(QL(K)+1)
c                write(6,*)ql(j),2*mj,ql(k),'  g=',g
C
                IRL=IRL+1
                IF(IRL.GT.IAXRL)THEN                          !GO TO 999
                  IXXX=7*(IAXRL/5+1)
                  WRITE(6,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                      ,' to: ',IXXX
                  WRITE(0,*)'*** CAFLGL0: increasing MAXRL from ',IAXRL
     X                      ,' to: ',IXXX
C
                  CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL
     X                          ,IFIVE,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR QRL'
                    NF=0
                    GO TO 999
                  ENDIF
                  IAXRL=IXXX
                ENDIF
C
                IRK=IRK+1
                IF(IRK.GT.IAXRK)THEN                          !GO TO 999
                  IXXX=7*(IAXRK/5+1)
                  WRITE(6,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                      ,' to: ',IXXX
                  WRITE(0,*)'*** CAFLGL0: increasing MAXRK from ',IAXRK
     X                      ,' to: ',IXXX
C
                  CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR DRK'
                    NF=0
                    GO TO 999
                  ENDIF
C
                  CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
                  IF(IERR.NE.0)THEN
                    WRITE(0,*)'CAFLGL0: REALLOCATION FAILS FOR NRK'
                    NF=0
                    GO TO 999
                  ENDIF
                  IAXRK=IXXX
                ENDIF
C
                DRK(IRK)=C*G
                NRK(IRK)=IRL
C
                DO M=1,5
                  QRL(M,IRL)=MRL(M)
                ENDDO
C
                IF(NGRP0.NE.0)THEN        !DUPLICATE CORE FOR EACH GROUP
                  DO N=1,NGRP-1
                    IRL=IRL+1     !ASSUME INITIAL ALLOC O.K. FOR CORE...
                    DO M=1,4
                      QRL(M,IRL)=MRL(M)+N*MXBORB
                    ENDDO
                    QRL(5,IRL)=MRL(5)
                  ENDDO
                ENDIF
C
              ENDDO
C
            ENDIF
C
          ENDIF
C
        ENDDO
C
       ENDIF
C
      ENDDO
C
C
C ELIMINATE ARGUMENTS OF QRL THAT HAVE BEEN LISTED BEFORE
C IN THE REFERENCE LIST
C
      KP=0
      DO K=IRK0,IRK
C
       JD=INT(NRK(K))
       LP=JD
       IF(JD.GT.IRL00)THEN
         LP=JD-KP
         DO L=1,IRL00
           DO J=1,5
             IF(QRL(J,JD).NE.QRL(J,L))GO TO 95
           ENDDO
           KP=KP+1
           LP=L
           GO TO 92
  95     ENDDO
         DO J=1,5
           QRL(J,LP)=QRL(J,JD)
         ENDDO
       ENDIF
C
  92   NRK(K)=LP
C
      ENDDO
C
      IRL=IRL-KP
C
 999  RETURN
C
      END SUBROUTINE CAFLGL0
C
C                             *******************
C
      SUBROUTINE CAFLGL(DFS)
C
C-----------------------------------------------------------------------
C
C  SR.CAFLGL EXPANDS THE ENERGY MATRIX ELEMENT <CA! H !CA'>
C  IN TERMS OF 2-BODY RADIAL INTEGRALS AND ANGULAR COEFFICIENTS.
C  IT CALCULATES THE AVERAGE SQUARE ALGEBRAIC COEFFICIENT * NWT/G
C  WHERE NWT IS THE NUMBER OF TRANSITIONS AND G THE STAT WEIGHT
C  OF THE INITIAL QUASI-BOUND STATE.
C  IT IS SPECIFIC FOR BOUND-CONTINUUM INTERACTIONS ONLY.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  INPUT: NEN(L,K) ORBITAL NUMBERS FOR L=1,2 AND K=1,2 WHERE K IS THE
C         INTERACTION PAIR AND L IS THE CONFIGURATION, KF, KG.
C
C  OUTPUT: COEFFICIENTS DRK(J) AND ARGUMENT-ADRESSES L=NRK(J) STORED
C  SEQUENTIALLY FROM IRK0 ONWARDS; ARGUMENTS QRL(1...5,L)=A,B,C,D,LD
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IWORD,IAXRK
     X                        ,IAXRL,IPLANT_RL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-8)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      DIMENSION DFS(*),Q1(2,2),MM(2,2),MRL(5)
C
      COMMON /BASIC/NF,KF,KG,NEN(2,2),MGAP(5)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
C
      POINTER :: MJ11,MJ12,ML
      TARGET :: MM,MRL
C
      MJ11=>MM(1,1)
      MJ12=>MM(1,2)
      ML=>MRL(5)
C
c      EQUIVALENCE (MJ11,MM(1,1)),(MJ12,MM(1,2)),(ML,MRL(5))
C
      ITEST4=IBUFF4
      ITEST4=ITEST4+1
      IF(IWORD.EQ.4.AND.ITEST4.LT.IBUFF4)THEN
        T=IBUFF4
        IPLANT_RL=SQRT(T)
        IF(IAXRL.GT.IPLANT_RL)THEN          !NEED TO CHECK REALLOCATIONS
          WRITE(0,*)'CAFLGL: I*4/SP TOO SHORT FOR PLANTS'
          WRITE(6,*)'CAFLGL: CHANGE TO I*8/EP IN MODULE COMMON_DXRL'
          IRL=-IAXRL
          NF=0
          GO TO 999
        ENDIF
      ELSE
        IPLANT_RL=IBUFF4
      ENDIF
C
      MXLAM=ABS(MAXLAM)
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      IRL00=IRL
C
      IDIR=0                                               !ALLOW DIRECT
      IXCH=0                                              !ALLOW ECHANGE
ct      idir=1
ct      ixch=1
C
      II=QCG(NF,KF)
      IF(QN(II).GE.90)THEN
        KC=1
        KCC=KF
        KB=2
        KBB=KG
      ELSE
        II=QCG(NF,KG)
        KC=2
        KCC=KG
        KB=1
        KBB=KF
      ENDIF
      JJ=NEN(KC,1)
      IF(JJ.EQ.II)JJ=NEN(KC,2)
C
      BEQNL=NEN(1,1).EQ.NEN(1,2).OR.NEN(2,1).EQ.NEN(2,2)
C
C DETERMINE (RESIDUAL) NWT/G, HAVING CANCELLED BINOMIALS ANALYTICALLY.
C
      IF(BEQNL)THEN
        IXCH=1
        L2=NEN(KB,1)
        L3=NEN(KB,2)
        if(l2.ne.l3)stop 'equiv error'
        N2=NEL(L2,KBB)
        L2=QL(L2)
        L1=QL(JJ)
        L4=QL(II)
        N1=NEL(JJ,KCC)-1
C       N4=1                                              !THE CONTINUUM
        MQ=N2*(N2-1)*(2*L1+2-N1)*2*(L2+1)*2*(L4+1)
        TQ=REAL(MQ,WP)
        TQ=TQ/REAL(2*L2+1,WP)
      ELSE
        L2=NEN(KB,1)
        L3=NEN(KB,2)
        N2=NEL(L2,KBB)
        N3=NEL(L3,KBB)
        L1=QL(JJ)
        L4=QL(II)
        N1=NEL(JJ,KCC)-1
C       N4=1                                              !THE CONTINUUM
        MQ=N2*N3*(2*L1+2-N1)*2*(L4+1)
        TQ=REAL(MQ,WP)
      ENDIF
C
      TQ=TQ/DFOUR                                         !RYD TO A.U.
C
      DO L=1,2              ! KF=1, KG=2
        DO K=1,2            ! PAIR 1, PAIR 2
          LP=NEN(L,K)
          MM(L,K)=QL(LP)
          Q1(L,K)=LP
        ENDDO
      ENDDO
C
C DIRECT
C
      KP=0
C
C EQU  MJ11=Q2(1,1)
C EQU  MJ12=Q2(1,2)
C
      ID2=IRK
      ID1=ID2+1
C
      IF(IDIR.EQ.1)GO TO 76                                   !NO DIRECT
C
C EXCHANGE RE-ENTRY POINT
C
  77  CONTINUE
C
      MJ21=MM(2,KP+1)
      MJ22=MM(2,2-KP)
C
C MU=MAX LAM
      MU=MIN(MJ11+MJ21,MJ12+MJ22,ITWO*MXLAM)
C
C ML=MIN LAM
      ML=MAX(ABS(MJ11-MJ21),ABS(MJ12-MJ22))
C
C LIMIT NUMBER
      MU=MIN(MU,ML+IFOUR*NMULT)
C
      IF(ML.GT.MU)GO TO 76
C
C REORDER A,B,C,D IN AS MUCH FALLING ORDER AS SYMMETRY ALLOWS FOR
C
      L=0
      K=0
      IF(Q1(2,2-KP).GT.Q1(1,2))K=2                       !FO
      I=0
      IF(Q1(2,1+KP).GT.Q1(1,1))I=2                       !FO
      IF(KP.EQ.0)THEN
        I0=I
        K0=K
      ELSE
        I0=0
        K0=0
      ENDIF
C
  62  MRL(1+I+L)=Q1(1,1)*(1-I0)
      MRL(3-I+L)=Q1(2,1+KP)
      MRL(2+K-L)=Q1(1,2)*(1-K0)
      MRL(4-K-L)=Q1(2,2-KP)
      L=1
      IF(MRL(2).GT.MRL(1))GO TO 62                       !FO
C
C LAMBDA RE-ENTRY POINT
C
  78  CONTINUE
C
      DVC=VCC(MJ11,MJ21,ML,IZERO,IZERO,IZERO,DFS)
      DDA=DVC*VCC(MJ22,MJ12,ML,IZERO,IZERO,IZERO,DFS)
      DDA=DDA/REAL(ML+1,WP)                                    !W3J NORM
C
C STORE COEFFICIENT
C
      LP=IRL+1
      IF(LP.GT.IAXRL)THEN                                     !GO TO 999
        IXXX=7*(IAXRL/5+1)
        WRITE(6,*)'*** CAFLGL: increasing MAXRL from ',IAXRL,' to: '
     X            ,IXXX
        WRITE(0,*)'*** CAFLGL: increasing MAXRL from ',IAXRL,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGL: REALLOCATION FAILS FOR QRL'
          NF=0
          GO TO 999
        ENDIF
        IAXRL=IXXX
        IF(IAXRL.GT.IPLANT_RL)THEN
          WRITE(0,*)'CAFLGL: I*4/SP TOO SHORT FOR PLANTS'
          WRITE(6,*)'CAFLGL: CHANGE TO I*8/EP IN MODULE COMMON_DXRL'
          IRL=-IAXRL
          NF=0
          GO TO 999
        ENDIF
      ENDIF
C
      IRL=LP
      DO K=1,5
        QRL(K,LP)=MRL(K)
      ENDDO
C
      IRK=IRK+1
      IF(IRK.GT.IAXRK)THEN                                    !GO TO 999
        IXXX=7*(IAXRK/5+1)
        WRITE(6,*)'*** CAFLGL: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
        WRITE(0,*)'*** CAFLGL: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGL: REALLOCATION FAILS FOR DRK'
          NF=0
          GO TO 999
        ENDIF
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGL: REALLOCATION FAILS FOR NRK'
          NF=0
          GO TO 999
        ENDIF
        IAXRK=IXXX
      ENDIF
C
      NRK(IRK)=LP
      DRK(IRK)=DDA
C
C MOVE TO NEXT CONTRIBUTION
C
      ML=ML+4
      IF(ML.LE.MU)GO TO 78                           !NEXT LAMBDA
C
      IF(KP.EQ.0)ID2=IRK
C
  76  KP=KP+1+IXCH
      IF(KP.EQ.1)GO TO 77                            !EXCHANGE
C
C ELIMINATE ARGUMENTS OF QRL THAT HAVE BEEN LISTED BEFORE
C IN THE REFERENCE LIST
C
      KP=0
      DO K=IRK0,IRK
C
       JD=INT(NRK(K))
       LP=JD
       IF(JD.GT.IRL00)THEN
         LP=JD-KP
         DO L=1,IRL00
           DO J=1,5
             IF(abs(QRL(J,JD)).NE.abs(QRL(J,L)))GO TO 95
           ENDDO
           KP=KP+1
           LP=L
           QRL(3,LP)=QRL(3,JD)
           QRL(4,LP)=QRL(4,JD)
           GO TO 92
  95     ENDDO
         DO J=1,5
           QRL(J,LP)=QRL(J,JD)
         ENDDO
       ENDIF
C
  92   NRK(K)=LP
C
      ENDDO
C
      IRL=IRL-KP
C
C SUM INTERFERENCE
C
      IF(BEQNL)THEN
        IH=2
        IE2=ID2
      ELSE
        IH=1
        IE1=ID2+1
        IE2=IRK
      ENDIF
C
      DO K=ID1,ID2
C
        DDA=DRK(K)
C
        L=INT(NRK(K))
        ML=QRL(5,L)
C
        I0=QRL(3,L)
        IF(I0.LT.0)THEN
          I=2
          QRL(3,L)=-QRL(3,L)
        ELSE
          I=0
        ENDIF
        I1=QRL(1+I,L)
        MRL(1)=QL(I1)
        I3=QRL(3-I,L)
        MRL(3)=QL(I3)
C
        I0=QRL(4,L)
        IF(I0.LT.0)THEN
          I=2
          QRL(4,L)=-QRL(4,L)
        ELSE
          I=0
        ENDIF
        I2=QRL(2+I,L)
        MRL(2)=QL(I2)
        I4=QRL(4-I,L)
        MRL(4)=QL(I4)
C
        IF(BEQNL)IE1=K
        DO KP=IE1,IE2
C
          DDB=DRK(KP)
          LP=INT(NRK(KP))
          MLP=QRL(5,LP)
C
          SJ6=SJS(MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP,DFS)
C
          IF(ABS(SJ6).GT.TYNY)THEN
            IRK=IRK+1
            IF(IRK.GT.IAXRK)THEN                              !GO TO 999
              IXXX=7*(IAXRK/5+1)
              WRITE(6,*)'*** CAFLGL: increasing MAXRK from ',IAXRK
     X                 ,' to: ',IXXX
              WRITE(0,*)'*** CAFLGL: increasing MAXRK from ',IAXRK
     X                 ,' to: ',IXXX
C
              CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGL: REALLOCATION FAILS FOR DRK'
                NF=0
                GO TO 999
              ENDIF
C
              CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGL: REALLOCATION FAILS FOR NRK'
                NF=0
                GO TO 999
              ENDIF
              IAXRK=IXXX
            ENDIF
C
            NRK(IRK)=-(IPLANT_RL*L+LP)                            !MAXRL
C
            IF(K.EQ.KP)SJ6=SJ6/REAL(IH,WP)
            DRK(IRK)=-DDA*DDB*SJ6*TQ*(1-MOD(ABS((ML-MLP)),IFOUR))
c
            if(beqnl)then
              isgn=1-2*mod(abs((ml-mlp)/2),itwo)   !(-1)**((ml-mlp)/2)
              if(isgn.lt.0)write(0,*)'multipole mixup?',k,kp
            endif
c
          else
            if(sj6.eq.dzero)then !cancellation error, since triangles ok
              write(6,*)"sjs=zero: ",MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP
c now just drop
c              nf=-1
c              go to 999
            else
              write(6,*)"sjs=",sj6,MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP
c drop
            endif
          ENDIF
C
        ENDDO
      ENDDO
C
C FINALIZE DIRECT & EXCHANGE
C
      DO K=ID1,ID2
        DDA=DRK(K)
        L=INT(NRK(K))
        ML=QRL(5,L)
        DRK(K)=TQ*DDA*DDA/REAL(ML+1,WP)
      ENDDO
C
      IF(IXCH.EQ.0)THEN
        DO KP=IE1,IE2
          DDB=DRK(KP)
          LP=INT(NRK(KP))
          MLP=QRL(5,LP)
          DRK(KP)=TQ*DDB*DDB/REAL(MLP+1,WP)
        ENDDO
      ENDIF
C
 999  RETURN
C
      END SUBROUTINE CAFLGL
C
C                             *******************
C
      SUBROUTINE CAFLGLX(DFS)
C
C-----------------------------------------------------------------------
C
C  SR.CAFLGLX EXPANDS THE HAMILTONIAN MATRIX ELEMENT <CA! H !CA'>
C  IN TERMS OF 2-BODY RADIAL INTEGRALS AND ANGULAR COEFFICIENTS.
C  IT CALCULATES THE AVERAGE SQUARE ALGEBRAIC COEFFICIENT.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  INPUT: NEN(L,K) ORBITAL NUMBERS FOR L=1,2 AND K=1,2 WHERE K IS THE
C         INTERACTION PAIR AND L IS THE CONFIGURATION, KF, KG.
C
C  OUTPUT: COEFFICIENTS DRK(J) AND ARGUMENT-ADRESSES L=NRK(J) STORED
C  SEQUENTIALLY FROM IRK0 ONWARDS; ARGUMENTS QRL(1...5,L)=A,B,C,D,LD
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IWORD,IAXRK
     X                        ,IAXRL,IPLANT_RL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-8)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      INTEGER(SP) Q1(2,2),Q2(2,2)
C
      DIMENSION DFS(*),MRL(5)
C
      COMMON /BASIC/NF,KF,KG,NEN(2,2),MGAP(2),LLCH(2),MAXLX
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
C
      POINTER :: MJ11,MJ12,ML
      TARGET :: Q2,MRL
C
      MJ11=>Q2(1,1)
      MJ12=>Q2(1,2)
      ML=>MRL(5)
C
c      EQUIVALENCE (MJ11,Q2(1,1)),(MJ12,Q2(1,2)),(ML,MRL(5))
C
      ITEST4=IBUFF4
      ITEST4=ITEST4+1
      IF(IWORD.EQ.4.AND.ITEST4.LT.IBUFF4)THEN
        T=IBUFF4
        IPLANT_RL=SQRT(T)
        IF(IAXRL.GT.IPLANT_RL)THEN          !NEED TO CHECK REALLOCATIONS
          WRITE(0,*)'CAFLGLX: I*4/SP TOO SHORT FOR PLANTS'
          WRITE(6,*)'CAFLGLX: CHANGE TO I*8/EP IN MODULE COMMON_DXRL'
          IRL=-IAXRL
          NF=0
          GO TO 999
        ENDIF
      ELSE
        IPLANT_RL=IBUFF4
      ENDIF
C
      NMULT=NMULTE-1                           !LIMIT NO OF MULIPOLES
C
      IRL00=IRL
C
      MPOSC=MXORB+(LCONDW+1)/2                 !INIT CONT POINTER
C
C SET-UP INTERACTING PAIRS
C
      I=NEN(1,2)                               !BOUND ORB IN KF
      Q1(1,2)=I
      Q2(1,2)=QL(I)
      I=NEN(2,2)                               !BOUND ORB IN KG
      Q1(2,2)=I
      Q2(2,2)=QL(I)
      I=MPOSC                                  !CONT ON KF
      Q1(1,1)=I
      LI=LLCH(1)
      Q2(1,1)=LI
      QL(I)=LI                                 !FOR INTERFERENCE
      LF=LLCH(2)
      Q2(2,1)=LF
      I=(LF-LI)/2+MPOSC                        !CONT ON KG
      Q1(2,1)=I
      QL(I)=LF                                 !FOR INTERFERENCE
C
      mtl=li
      MQ=(LI+1)*(LF+1)                         !CONT. WEIGHT
      TQ=REAL(MQ,WP)
C
c      TQ=TQ/DFOUR                              !RYD TO A.U.
C
C FLAG REQUIREMENT FOR DIRECT AND EXCHANGE
C
      IDIR=0                                   !ALLOW DIRECT
      IXCH=0                                   !ALLOW EXCHANGE
      IF(MTL.GT.2*MAXLX)IXCH=1                 !NO EXCHANGE
ct      idir=1
ct      ixch=1
C
      IF(IDIR+IXCH.EQ.2)GO TO 999              !NULL
C
C DIRECT
C
      KP=0
C
C EQU  MJ11=Q2(1,1)
C EQU  MJ12=Q2(1,2)
C
      ID2=IRK
      ID1=ID2+1
C
      IF(IDIR.EQ.1)GO TO 76                    !NO DIRECT
C
      MXLAM=ABS(MXLAMX)                       !RESTRICT DIRECT LAMBDA
C
C EXCHANGE RE-ENTRY POINT
C
  77  CONTINUE
C
      MJ21=Q2(2,KP+1)
      MJ22=Q2(2,2-KP)
C
C MU=MAX LAM
      MU=MIN(MJ11+MJ21,MJ12+MJ22,ITWO*MXLAM)
C
C ML=MIN LAM
      ML=MAX(ABS(MJ11-MJ21),ABS(MJ12-MJ22))
C
C LIMIT NUMBER
      MU=MIN(MU,ML+IFOUR*NMULT)
C
      IF(ML.GT.MU)GO TO 76
C
C REORDER A,B,C,D IN AS MUCH FALLING ORDER AS SYMMETRY ALLOWS FOR
C
      L=0
      K=0
      IF(Q1(2,2-KP).GT.Q1(1,2))K=2                       !FO
      I=0
      IF(Q1(2,1+KP).GT.Q1(1,1))I=2                       !FO
      IF(KP.EQ.0)THEN
        I0=I
        K0=K
      ELSE
        I0=0
        K0=0
      ENDIF
C
  62  MRL(1+I+L)=Q1(1,1)*(1-I0)
      MRL(3-I+L)=Q1(2,1+KP)
      MRL(2+K-L)=Q1(1,2)*(1-K0)
      MRL(4-K-L)=Q1(2,2-KP)
      L=1
      IF(MRL(2).GT.MRL(1))GO TO 62                       !FO
C
C LAMBDA RE-ENTRY POINT
C
  78  CONTINUE
C
C GET VCA & VCB
C
      DVC=VCC(MJ11,MJ21,ML,IZERO,IZERO,IZERO,DFS)
      DDA=DVC*VCC(MJ22,MJ12,ML,IZERO,IZERO,IZERO,DFS)
c
      if(abs(dda).gt.tyny)then
C
C STORE COEFFICIENT
C
      LP=IRL+1
      IF(LP.GT.IAXRL)THEN                                     !GO TO 999
        IXXX=7*(IAXRL/5+1)
        WRITE(6,*)'*** CAFLGLX: increasing MAXRL from ',IAXRL,' to: '
     X            ,IXXX
        WRITE(0,*)'*** CAFLGLX: increasing MAXRL from ',IAXRL,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGLX: REALLOCATION FAILS FOR QRL'
          NF=0
          GO TO 999
        ENDIF
        IAXRL=IXXX
        IF(IAXRL.GT.IPLANT_RL)THEN
          WRITE(0,*)'CAFLGLX: I*4/SP TOO SHORT FOR PLANTS'
          WRITE(6,*)'CAFLGLX: CHANGE TO I*8/EP IN MODULE COMMON_DXRL'
          IRL=-IAXRL
          NF=0
          GO TO 999
        ENDIF
      ENDIF
C
      IRL=LP
      DO K=1,5
        QRL(K,LP)=MRL(K)
      ENDDO
      if(qrl(2,lp).gt.mxorb)qrl(5,lp)=qrl(5,lp)-mtl        !exchange
c
c       write(6,*)irk,kp,lp,(qrl(k,lp),k=1,5)
C
      IRK=IRK+1
      IF(IRK.GT.IAXRK)THEN                                    !GO TO 999
        IXXX=7*(IAXRK/5+1)
        WRITE(6,*)'*** CAFLGLX: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
        WRITE(0,*)'*** CAFLGLX: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGLX: REALLOCATION FAILS FOR DRK'
          NF=0
          GO TO 999
        ENDIF
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CAFLGLX: REALLOCATION FAILS FOR NRK'
          NF=0
          GO TO 999
        ENDIF
        IAXRK=IXXX
      ENDIF
C
      NRK(IRK)=LP
      DRK(IRK)=DDA/REAL(ML+1,WP)                               !W3J NORM
c
      else
        if(dda.eq.dzero)then   !cancellation error, since triangles o.k.
          write(6,*)"vcc=zero: ",MJ11,MJ21,MJ22,MJ12,'  ',ML
c now just drop
c        nf=-1
c        go to 999
        else
          write(6,*)"vcc=",dda,MJ11,MJ21,MJ22,MJ12,'  ',ML
c drop
        endif
      endif
C
C MOVE TO NEXT CONTRIBUTION
C
      ML=ML+4
      IF(ML.LE.MU)GO TO 78                     !NEXT LAMBDA
C
      IF(KP.EQ.0)ID2=IRK
C
  76  KP=KP+1+IXCH
      MXLAM=MXLAMX                             !RESTRICT EXCHANGE LAMBDA
      IF(KP.EQ.1)GO TO 77                      !EXCHANGE
C
C ELIMINATE ARGUMENTS OF QRL THAT HAVE BEEN LISTED BEFORE
C IN THE REFERENCE LIST
C
      KP=0
      DO K=IRK0,IRK
C
       JD=INT(NRK(K))
       LP=JD
       IF(JD.GT.IRL00)THEN
         LP=JD-KP
         DO L=1,IRL00
           DO J=1,4
             IF(abs(QRL(J,JD)).NE.abs(QRL(J,L)))GO TO 95
           ENDDO
           IF(QRL(5,JD).NE.QRL(5,L))GO TO 95
           KP=KP+1
           LP=L
           QRL(3,LP)=QRL(3,JD)
           QRL(4,LP)=QRL(4,JD)
           GO TO 92
  95     ENDDO
         DO J=1,5
           QRL(J,LP)=QRL(J,JD)
         ENDDO
       ENDIF
C
  92   NRK(K)=LP
C
      ENDDO
c
c      call flush(6)
C
      IRL=IRL-KP
C
C SUM INTERFERENCE
C
      IE1=ID2+1
      IE2=IRK
C
      DO K=ID1,ID2
C
        DDA=DRK(K)
C
        L=INT(NRK(K))
        ML=QRL(5,L)
C
        I0=QRL(3,L)
        IF(I0.LT.0)THEN
          I=2
          QRL(3,L)=-QRL(3,L)
        ELSE
          I=0
        ENDIF
        I1=QRL(1+I,L)
        MRL(1)=QL(I1)
        I3=QRL(3-I,L)
        MRL(3)=QL(I3)
C
        I0=QRL(4,L)
        IF(I0.LT.0)THEN
          I=2
          QRL(4,L)=-QRL(4,L)
        ELSE
          I=0
        ENDIF
        I2=QRL(2+I,L)
        MRL(2)=QL(I2)
        I4=QRL(4-I,L)
        MRL(4)=QL(I4)
C
        DO KP=IE1,IE2
C
          DDB=DRK(KP)
          LP=INT(NRK(KP))
          MLP=QRL(5,LP)+mtl
C
          SJ6=SJS(MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP,DFS)
C
          IF(ABS(SJ6).GT.TYNY)THEN
            IRK=IRK+1
            IF(IRK.GT.IAXRK)THEN                              !GO TO 999
              IXXX=7*(IAXRK/5+1)
              WRITE(6,*)'*** CAFLGLX: increasing MAXRK from ',IAXRK
     X                 ,' to: ',IXXX
              WRITE(0,*)'*** CAFLGLX: increasing MAXRK from ',IAXRK
     X                 ,' to: ',IXXX
C
              CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGLX: REALLOCATION FAILS FOR DRK'
                NF=0
                GO TO 999
              ENDIF
C
              CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'CAFLGLX: REALLOCATION FAILS FOR NRK'
                NF=0
                GO TO 999
              ENDIF
              IAXRK=IXXX
            ENDIF
C
            NRK(IRK)=-(IPLANT_RL*L+LP)                            !MAXRL
            DRK(IRK)=-DDA*DDB*SJ6*TQ*(1-MOD(ABS((ML-MLP)),IFOUR))
c
          else
            if(sj6.eq.dzero)then !cancellation error, since triangles ok
              write(6,*)"sjs=zero: ",MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP
c now just drop
c              nf=-1
c              go to 999
            else
c              write(6,*)"sjs=",sj6,MRL(1),MRL(3),ML,MRL(2),MRL(4),MLP
c drop
            endif
          ENDIF
C
        ENDDO
      ENDDO
C
C FINALIZE DIRECT & EXCHANGE
C
      DO K=ID1,ID2
        DDA=DRK(K)
        L=INT(NRK(K))
        ML=QRL(5,L)
        DRK(K)=TQ*DDA*DDA/REAL(ML+1,WP)
      ENDDO
C
      IF(IXCH.EQ.0)THEN
        DO KP=IE1,IE2
          DDB=DRK(KP)
          LP=INT(NRK(KP))
          MLP=QRL(5,LP)+mtl
          DRK(KP)=TQ*DDB*DDB/REAL(MLP+1,WP)
        ENDDO
      ENDIF
C
 999  RETURN
C
      END SUBROUTINE CAFLGLX
C
C                             *******************
C
      SUBROUTINE CALGEB(MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.CALGEB CALCULATES THE ALGEBRAIC CONFIGURATION AVERAGE COEFFICIENTS
C  FOR EACH NON-VANISHING ELECTROSTATIC INTERACTION MATRIX ELEMENT;
C  ALSO, ELECTRIC MULTIPOLE MATRIX ELEMENTS ARE COMPUTED.
C
C  IT CALLS:
C    SR.CAEKAL
C    SR.CAFLGL0
C    SR.CALFLG
C    SR.DIMUSE
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C    FN.QBINOM
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IWORD,IAXRK
     X                        ,IAXRL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBIAD, ONLY: IADJ,IADJ8,NP8
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB
CB     X,MENGB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXRK0=100000)
      PARAMETER (MAXRL0=  2500)
C
      PARAMETER (MG=-2)
      PARAMETER (MXD01=14)
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      CHARACTER(LEN=4) CODE
C
      DIMENSION DFS(MXDFS)
C
      COMMON /BASIC/NF,KF,KG,NEN(2,2),MGAP(5)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBNV/MAXNV
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      ALLOCATABLE :: IGRGR(:)
C
C-----------------------------------------------------------------------
C
C INITIALIZE
C
C-----------------------------------------------------------------------
C
      ALLOCATE (IGRGR(NF))
C
      IF(KMAX.GT.MAXTM)THEN
        WRITE(0,*)'*** SR.CALGEB: INCREASE MAXTM'
        WRITE(6,*)'*** SR.CALGEB: INCREASE MAXTM TO ',KMAX
        GO TO 999
      ENDIF
C
      CALL DIMUSE('MAXTM',KMAX)
C
      NP8=KMAX
      IADJ8=NP8*NP8                        !FOR H AND EK
C
      IF(IADJ8.GT.MAXAD)THEN
        IF(MAXAD.GT.0)WRITE(6,133)IADJ8,MAXAD
      ENDIF
C
      MXLAM=ABS(MAXLAM)
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
C DETAIL CONFIGS
C
      MAXNV=1
      DO KF=1,KMAX
        KP=0
        NU=0
        IW8=1
        DO K=1,MXORB
          N=NEL(K,KF)
          IF(N.GT.0)THEN
            IF(QN(K).LT.80.AND.QN(K).GT.MAXNV)
     X      MAXNV=MOD(INT(QN(K),SP),I70)                      !I60?
            IF(QN(K).LT.90)IW8=IW8*QBINOM(INT(2*QL(K)+2,SP),N)!OMIT CONT
            KP=KP+N*QL(K)
            NI=NU+1
            NU=NU+N
            DO I=NI,NU
              QCG(I,KF)=K
            ENDDO
            IF(NU.EQ.NF)GO TO 10                            !WE ARE DONE
          ENDIF
        ENDDO
  10    CONTINUE
        MSTAT(KF)=IW8
        QCP(KF)=MOD(KP,IFOUR)                                    !PARITY
        WRITE(6,30)KF,0,(QN(QCG(I,KF)),QL(QCG(I,KF))/2,I=1,NF)
      ENDDO
C
C NEED MAX ORBITRAL L FOR VCC STORAGE AND BORN.
C
C
      IF(MENGB.GE.0)THEN
        MXLL=-1                                     !NEED MAX ORBITRAL L
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO.AND.QL(K).GT.MXLL)MXLL=QL(K)
        ENDDO
        MPOLE=MIN(MPOLE,2*MXLL)                   !CAN NOW RESTRICT BORN
      ENDIF
C
C-----------------------------------------------------------------------
C
C FOR MPRINT.GE.0 MPOLE HAS ALREADY BEEN SET (DEFAULT=4), CF ALGEB2
C
C-----------------------------------------------------------------------
C
      IF(MPRINT.EQ.-1.OR.MPRINT.EQ.-4)MPOLE=2
      IF(MPRINT.EQ.MG)MPOLE=-1                                 !FOR INFO
      IF(MPOLE.GT.2*MXBLM)THEN
        IF(MXBLM.GT.0)THEN
          WRITE(6,955)MPOLE/2,MXBLM
C          WRITE(0,955)MPOLE/2,MXBLM
        ENDIF
C        IXBLM=MPOLE/2               !NOT NEEDED UNTIL MINIM
      ENDIF
C
      CALL DIMUSE('MXBLM',MAX(IONE,MPOLE/2))
C
CB      BBORN=MENGB.GE.0            !BORN CODING NOW USED MORE GENERALLY
CB      IF(BBORN)THEN
CC      MPOL0=MPOL00                                              !FLAGX
      IF(MPOL00.GE.0)THEN           !BORN CODING NOW USED MORE GENERALLY
        MXORB2=(MXORB*(MXORB+1))/2
        LHM=MPOLE/4
        IF(BREL)LHM=LHM+1
      ELSE
        MXORB2=1
        LHM=0
      ENDIF
C
C-----------------------------------------------------------------------
C
C EX-COMMON/DXRL/
C
      IAXRK=MAX(MAXRK0,MAXRK,IAXRK)                !USE LARGEST PREVIOUS
C      IAXRK=MAX(MAXRK0,MAXRK)                      !RESET
      IAXRL=MAX(MAXRL0,MAXRL,IAXRL)                !USE LARGEST PREVIOUS
C      IAXRL=MAX(MAXRL0,MAXRL)                      !RESET
C
      ALLOCATE (DRK(IAXRK),QRL(5,IAXRL),NRK(IAXRK),NAD(0:IADJ8)
     X         ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CALGEB: ALLOCATION FAILS FOR  DRK,QRL,NRK,NAD'
        NF=0
        RETURN
      ENDIF
      BDXRL=.TRUE.
C
C EX-COMMON/NRBRN2/
      ALLOCATE (BINDB(MXORB2,0:LHM),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ALGEB2: ALLOCATION FAILS FOR  BINDB'
        NF=0
        RETURN
      ENDIF
      BNRBRN2=.TRUE.
C
C-----------------------------------------------------------------------
C
C CALCULATE SOME (PRODUCTS OF) CLEBSCH-GORDAN COEFFICIENTS:
C
C VCA=C(L1,L2,L,0,0,0)*C(L1,L2,KT,ML1,ML2,MLK)/(L+1)
C VCB=C(L1,L2,L,0,0,0)*C(L1,L2,KT+2,ML1,ML2,MLK)
C
C-----------------------------------------------------------------------
C TBD - NOT WORTHWHILE? (STILL NEED DFS LATER)
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
C-----------------------------------------------------------------------
C
      WRITE(6,150)MAXAD,MAXCF,MAXCF,IAXRK,IAXRL,MXDFS
      IF(MAXLAM.NE.1000)WRITE(6,152)MAXLAM
C
C-----------------------------------------------------------------------
C
      DO LH=0,LHM
        DO I=1,MXORB2
          BINDB(I,LH)=.FALSE.
        ENDDO
      ENDDO
C
      NE=NF
      IF(NW.GT.0)THEN
        NP8=-1
        NF=0
      ELSE
        NAD(0)=0
        NP8=0
      ENDIF
C
      IOS=0
      JOS=1
      IRK=0
      IRL=0
      BLP=MPRINT.GT.0
C
C-----------------------------------------------------------------------
C
C   CALCULATE THE CONFIGURATION AVERAGE ALGEBRA OF THE ELECTROSTATIC
C   MATRIX BETWEEN TWO CONFIGS THAT DIFFER BY TWO ELECTRON PAIRS & WHICH
C   GIVES RISE TO AUTOIONIZATION. WE ARE NOT INTERESTED IN THE 1-BODY
C   OFF-DIAGONAL BOUND-BOUND (ENERGY) CONTRIBUTIONS NOR BOUND-CONTINUUM
C   AS THE LATTER CANNOT AUTOIONIZE ON ENERGY GROUNDS.
C   THE (DIAGONAL) CONFIGURATION AVERAGE ENERGY IS DETERMINED THOUGH.
C
C-----------------------------------------------------------------------
C
      IF(NF.EQ.1)THEN                    !THERE CAN BE NO TWO-BODY TERMS
        DO KF=1,KMAX
          DO KG=1,KF
            NP8=NP8+1
            NAD(NP8)=0
          ENDDO
        ENDDO
        GO TO 80
      ENDIF
C
      DO KF=1,KMAX                                        !BEGIN KF LOOP
        II=IEQ(QCG(NE,KF))
        KCF=0
        IF(QN(II).GE.90)KCF=II                                !CONTINUUM
C
        DO KG=1,KF                                        !BEGIN KG LOOP
C
   50     NP8=NP8+1
C
C FIRST CHECK GLOBAL SWITCHES
C
          IF(KF.EQ.KG)GO TO 54                            !FOR CA ENERGY
          IF(QCP(KF).NE.QCP(KG))GO TO 73                !OPPOSITE PARITY
C
          II=IEQ(QCG(NF,KG))
          KCG=0
          IF(QN(II).GE.90)KCG=II
          IF(KCF+KCG.EQ.0.OR.KCF*KCG.NE.0)GO TO 73       !NOT BOUND-CONT

C
C NOW, FIND NUMBER NK OF ELECTRON PAIRS IN WHICH KF, KG DIFFER
C
          DO M=1,NF
            IGRGR(M)=QCG(M,KG)
          ENDDO
          NK=0
          DO M=1,NF
            ICG=IEQ(QCG(M,KF))
            DO L=1,NF
              IF(IEQ(IGRGR(L)).EQ.ICG)THEN
                IGRGR(L)=0
                GO TO 53
              ENDIF
            ENDDO
            NK=NK+1
            IF(NK.GT.2)GO TO 73                     !THREE PAIRS OR MORE
            NEN(1,NK)=QCG(M,KF)
  53      ENDDO
C
C SKIP IF ONLY ONE-BODY EXISTS
C
          IF(NK.EQ.1)GO TO 73
C
C IDENITIFY THE PAIRS IN KG
C
          K=0
          DO L=1,NF
            IF(IGRGR(L).NE.0)THEN
              K=K+1
              NEN(2,K)=QCG(L,KG)
              IF(K.EQ.NK)GO TO 54
            ENDIF
          ENDDO
          write(6,*)'calgeb: should not be here - report to nrb'
          write(0,*)'calgeb: should not be here - report to nrb'
C
  54      CONTINUE
c
c          write(6,*)'kf, kg=',kf,kg,' 2-body:',nen(1,1),nen(1,2)
c     x    ,'  ',nen(2,1),nen(2,2)
C
          IRK0=IRK+1
C
          IF(KF.EQ.KG)THEN
            CALL CAFLGL0(DFS)                             !  <B|H|B>
          ELSE
            CALL CAFLGL(DFS)                              ! |<B|H|C>|**2
          ENDIF
C
          IF(IRL.GT.IAXRL.or.irl.lt.0)JOS=-1
          IF(IRK.GT.IAXRK)JOS=0
          IF(JOS.LE.0)GO TO 67             !DIMENSION EXCEEDED, BAIL OUT
          IF(NF.LT.0)GO TO 900             !.LT. AS .EQ.0 FLAGS CORE
C
          IF(BLP.AND.IRK.GE.IRK0)THEN
            IF(IRK-IRK0.NE.5)THEN
             WRITE(6,120)NP8,KF,KG,IRK,IRL
     X                 ,(NRK(I),DRK(I),I=IRK0,IRK)
            ELSE
             WRITE(6,119)NP8,KF,KG,IRK,IRL
     X                 ,(NRK(I),DRK(I),I=IRK0,IRK)
            ENDIF
            WRITE(6,120)
          ENDIF
C
  73      NAD(NP8)=IRK
C
          IF(NF.EQ.0)THEN                             !RESTORE FROM CORE
            NF=NE
            GO TO 50
          ENDIF
C
        ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
  80  CONTINUE
C
      IADJ8=NP8
      IADJ=INT(IADJ8)                                  !FOR I*4 BRANCHES
C
      CALL DIMUSE('MAXAD',IADJ)
      CALL DIMUSE('MAXRK',IRK)
      CALL DIMUSE('MAXRL',IRL)
C
  67  IF(.NOT.BLP.OR.JOS.LE.0)THEN
        WRITE(6,120)NP8,KMAX,KMAX,IRK,IRL
        IF(JOS.LT.0)GO TO 93
        IF(JOS.EQ.0)GO TO 95
        WRITE(6,199)MPRINT
      ELSE
C
C PRINT SLATER INTEGRAL (ADRESS REFERENCE) LIST
C
        IF(IRL.GT.0)THEN
          WRITE(6,300)
          DO  L=1,IRL
            WRITE(6,700)L,(QRL(I,L), I=1,5)
          ENDDO
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C   CALCULATE THE CONFIGURATION AVERAGE ALGEBRA OF THE EK RADIATION
C   MATRIX FOR BOTH BOUND-BOUND AND BOUND-CONTINUUM, THE LATTER ONLY IF
C   PHOTOIONIZATION IS FLAGGED.
C
C-----------------------------------------------------------------------
C
      IOS0=IRK
      IOS=IOS0
      IF(MPRINT.EQ.MG)GO TO 100
C
      IF(BLP)WRITE(6,600)
      IF(.NOT.BLP)WRITE(6,601)
C
      IFOTMX=0
      IF(BFOT)IFOTMX=1
      JOS=1
C
      DO KF=1,KMAX                                        !BEGIN KF LOOP
        II=IEQ(QCG(NF,KF))
        IFOT1=0
        IF(QN(II).GE.90)IFOT1=1                               !CONTINUUM
C
        DO KG=1,KF-1                                      !BEGIN KG LOOP
C
          NP8=NP8+1
C
C FIRST CHECK GLOBAL SWITCHES
C
          II=IEQ(QCG(NF,KG))
          IFOT2=0
          IF(QN(II).GE.90)IFOT2=1
          IF((IFOT1+IFOT2).GT.IFOTMX)GO TO 83                !NOT WANTED
C
C NOW, FIND NUMBER NK OF ELECTRON PAIRS IN WHICH KF, KG DIFFER
C
          DO M=1,NF
            IGRGR(M)=QCG(M,KG)
          ENDDO
          NK=0
          DO M=1,NF
            ICG=IEQ(QCG(M,KF))
            DO L=1,NF
              IF(IEQ(IGRGR(L)).EQ.ICG)THEN
                IGRGR(L)=0
                GO TO 63
              ENDIF
            ENDDO
            NK=NK+1
            IF(NK.GT.1)GO TO 83                       !TWO PAIRS OR MORE
            LD1=QCG(M,KF)
  63      ENDDO
C
C IDENTIFY THE MATCH IN KG AND SEE IF ONE-BODY EXISTS
C
          DO L=1,NF
            IF(IGRGR(L).NE.0)THEN
              LD2=QCG(L,KG)
              GO TO 64
            ENDIF
          ENDDO
          write(6,*)'calgeb: should not be here - report to nrb'
          write(0,*)'calgeb: should not be here - report to nrb'
  64      CONTINUE
C
          MMIN=MAX(MPOL00,ABS(INT(QL(LD1)-QL(LD2),SP)))      !MIN LAMBDA
          IF(MOD(QCP(KF)+QCP(KG)+MMIN,IFOUR).NE.0)MMIN=MMIN+2
          MMAX=MIN(MPOLE,INT(QL(LD1)+QL(LD2),SP),ITWO*MXLAM) !MAX LAMBDA
          IF(MOD(QCP(KF)+QCP(KG)+MMAX,IFOUR).NE.0)MMAX=MMAX-2
          MMAX=MIN(MMAX,MMIN+IFOUR*NMULT)                     !LIMIT NO.
          IF(MMIN.GT.MMAX)GO TO 83
c
c          write(6,*)'kf, kg=',kf,kg,' 1-body:',ld1,ld2,'  '
c     x              ,ql(ld1)/2,ql(ld2)/2,mpole/2
C
          NEN(1,1)=LD1
          NEN(2,1)=LD2
C
          CALL CAEKAL(MMIN,MMAX,DFS,JOS)
C
          IF(IOS.GT.IAXRK)GO TO 92
          IF(NF.LE.0)GO TO 999
C
  83      CONTINUE
C
          NAD(NP8)=IOS
C
        ENDDO                                   !END LOOP KG
C
      ENDDO                                     !END LOOP KF
C
      CALL DIMUSE('MAXRK',IOS)
C
      IF(IOS.GE.IOS0)JOS=JOS-1
C
      MPOLE0=MPOLE
      MPOLE=-1
      LHM0=LHM
      IF(BREL)LHM=LHM-1
      DO LH=LHM,0,-1
        I=0
        DO K=1,MXORB
          DO J=1,K
            I=I+1
            IF(BINDB(I,LH))THEN
              MP=ABS(QL(J)-QL(K))/2
              MP=MOD(MP,ITWO)
              M=4*LH+2-2*(1-MP)
c       write(6,*)j,k,ql(j)/2,ql(k)/2,m/2
              MPOLE=MAX(M,MPOLE)
              IF(MP.EQ.1)GO TO 97
            ENDIF
          ENDDO
        ENDDO
        IF(MPOLE.GE.0)GO TO 97
      ENDDO
C
  97  CONTINUE
C
      IF(REAL(MPOLE,WP).GE.5*REAL(MPOLE0,WP)/7
     X                 .OR.MPOLE0*MXORB2.LT.I100000)GO TO 98
C
      WRITE(6,*)'*** CALGEB: decreasing KPOLE from ',MPOLE0/2,' to: '
     X                ,MPOLE/2
      WRITE(0,*)'*** CALGEB: decreasing KPOLE from ',MPOLE0/2,' to: '
     X                ,MPOLE/2
C
      LHM=MPOLE/4
      IF(BREL)LHM=LHM+1
C
      CALL RE_ALLOC2(BINDB,IONE,MXORB2,IZERO,LHM0,MXORB2,LHM,IERR)
C
  98  IF(.NOT.BLP)THEN
        WRITE(6,701)JOS,KMAX,KMAX,MPOLE/2,MPOLE/2,IOS
        WRITE(6,199)MPRINT
      ENDIF
      GO TO 900
C
 100  WRITE(6,1000)
C
 900  CONTINUE
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MAXRL)/5
      IF(BDXRL.AND.IRL.LT.IXXX)THEN
C
c       WRITE(6,*)'*** CALGEB: decreasing MAXRL from ',IAXRL,' to: ',IRL
c       WRITE(0,*)'*** CALGEB: decreasing MAXRL from ',IAXRL,' to: ',IRL
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IRL,IERR)
C
        IAXRL=IRL
C
      ENDIF
C
      IXXX=(4*MAXRK)/5
      IF(BDXRL.AND.IOS.LT.IXXX)THEN
C
c       WRITE(6,*)'*** CALGEB: decreasing MAXRK from ',IAXRK,' to: ',IOS
c       WRITE(0,*)'*** CALGEB: decreasing MAXRK from ',IAXRK,' to: ',IOS
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IOS,IERR)
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IOS,IERR)
C
        IAXRK=IOS
C
      ENDIF
C
      DEALLOCATE (IGRGR)
C
      RETURN
C
C     E R R O R   M E S S A G E S
C
  95  WRITE(6,188)
      MPOLE=-1
  92  IF(MPOLE.GE.4)WRITE(6,192)
      IF(MPOLE.EQ.2)WRITE(6,189)
      IF(IRL.LE.IAXRL.and.irl.ge.0)GO TO 96
  93  if(irl.ge.0)then
        WRITE(6,193)
      else
        WRITE(6,194)
      endif
  96  IF(MPRINT.EQ.MG-1)GO TO 900
      WRITE(6,190)
C
 999  NF=-1
      GO TO 900
C
  30  FORMAT(//' CONFIGURATION CF=',  I4,',',I11,' ON DISK, (N-L)-'
     X,'COMBINATIONS  ', 12(I4,I2)/64X, 12(I4,I2) )
  119 FORMAT(I9,3X, 2I6, I9,I5, 6(I6,F11.6))
  120 FORMAT(I9,3X, 2I6, I9,I5, 6(I6,F11.6)/(38X,6(I6,F11.6)))
  133 FORMAT('SR.CALGEB: ALLOCATION INCREASES NUMBER OF MATRIX '
     X,' ELEMENTS IADD =',I12,' .GT. MAXAD=',I12)
  150 FORMAT(//' SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING   ',
     X'( KF !  H  ! KG ) = SUM( F(A,...) * R(A,...) );   NCYC=0: COMMON'
     X,' DIAGONAL CORE TERM'/I9,3X,2I6,I9,I5,' STORAGE'
     X,' RESTRICTIONS FOR (MAXAD,MAXCF,MAXCF,MAXRK,MAXRL), MXDFS=',I3
     X/'     NCYC       KF    KG      MNF  MNR',6(3X,'I(R)  F(A,...)'))
  152 FORMAT(/' **** SLATER MULTIPOLE EXPANSION LIMITED TO LAMDA=',I3/)
  188 FORMAT(/' SR.CALGEB: *MAXRK TOO SMALL, ARRAYS DRK AND NRK ')
  189 FORMAT(/' SR.CALGEB: *MAXRK TOO SMALL, ARRAYS DRK AND NRK;'/
     X' MAYBE SUFFICIENT IF NO RADIATIVE RATES (MPRINT=-2) REQUIRED.')
  190 FORMAT( ' SR.CALGEB: STORAGE EXCEEDED - CASE SKIPPED')
  192 FORMAT(/' SR.CALGEB: *MAXRK TOO SMALL, ARRAYS DRK AND NRK;'/' ',
     X'MAYBE SUFFICIENT IF NO RADIATIVE RATES (MPRINT=-2) OR DIPOLE'
     X,' ONLY (MPRINT=-1) REQUIRED')
  193 FORMAT(/' SR.CALGEB: *MAXRL TOO SMALL, ARRAYS DRL AND QRL')
  194 FORMAT(/' SR.CALGEB: *MAXRL TOO LARGE FOR INTEGER(SP) POINTER IN '
     X,'NRK:'/12X,'*TRY REDUCING MAXRL TO ACTUAL USAGE,'
     X,'*OR USE INTEGER *8 FOR NRK - SEE MODULE COMMON_DXRL'/)
  199 FORMAT(/ ' *** PRINTOUT OF COEFFICIENTS SUPPRESSED - MPRINT'
     X,'(MODULO 5)=',I2/)
  300 FORMAT(/ ' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS',7X
     X,'A,B,C,D=1,2,3,..15: 1S,2S,2P,..5G-ORBITAL',9X,'REFERENCE LIST')
  600 FORMAT( ' IOSC     KF  KG,   B   D,   MNF,    <CA!CK!CAP>   K')
  601 FORMAT( '  IOSC    KF    KG    B   D      MNF')
  700 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,2F19.5, 6X,2I4, 5X,'E',I1,I6)
  701 FORMAT( I6,I6,I6,I5,I4,I9)
  955 FORMAT(//'SR.CALGEB: ALLOCATION INCREASES MAX 2K-POLE '
     X,'RADIATION IXBLM =',I3,' .GT. MXBLM =',I3)
 1000 FORMAT(/' SR.CALGEB: RADIATIVE CALCULATIONS SKIPPED'/12X,30('*'))
C
      END SUBROUTINE CALGEB
C
C                             *******************
C
      SUBROUTINE CALGX(KACT,MXCF,DFS)
C
C-----------------------------------------------------------------------
C
C  SR.CALGX CALCULATES THE ALGEBRAIC CONFIGURATION AVERAGE COEFFICIENTS
C  FOR EACH NON-VANISHING ELECTROSTATIC INTERACTION MATRIX ELEMENT;
C
C  IT CALLS:
C    SR.CAFLGLX
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IRLAST
     X                        ,IWORD,IAXRK,IAXRL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
C NEED SENSIBLE MINIMUM STARTING VALUES FOR RE-ALLOCATION
C (I.E. SUBVERT ANY "SMALL" USER VALUES IN PARAM, BUT ALLOW TO INCREASE)
C
      PARAMETER (MAXRK0=100000)
      PARAMETER (MAXRL0=  2500)
C
      DIMENSION KACT(MXCF,*),DFS(*)
C
      COMMON /BASIC/NF,KF,KG,NEN(2,2),MGAP(2),LL(2),NGAP
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
C      COMMON /CHARY/DEY(MAXGR)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
c      COMMON /NRBDW/IDW,IGAP(MXD01),btop
c      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
C
C-----------------------------------------------------------------------
c
      if(btimex)then
cpar      if(iam.ge.0)then                                          !par
cpar        write(iw,*)'Starting proc',iam,' for calgx '            !par
cpar      else                                                      !par
        write(iw,*)'Starting calgx'
cpar      endif                                                     !par
        call cpu_time(timei)
        time0=timei
      endif
C
C-----------------------------------------------------------------------
C
C EX-COMMON/DXRL/
C
C      IAXRK=MAX(MAXRK0,MAXRK,IAXRK)               !USE LARGEST PREVIOUS
      IAXRK=MAX(MAXRK0,MAXRK)                     !RESET
C      IAXRL=MAX(MAXRL0,MAXRL,IAXRL)               !USE LARGEST PREVIOUS
      IAXRL=MAX(MAXRL0,MAXRL)                     !RESET
      IL=ABS(MAXLT)
C
      ALLOCATE (DRK(IAXRK),QRL(5,IAXRL),NRK(IAXRK),NAD(0:IADD)
     X         ,IRLAST(0:IL),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CALGX: ALLOCATION FAILS FOR  DRK,QRL,NRK,NAD'
        GO TO 999
      ENDIF
      BDXRL=.TRUE.
C
C-----------------------------------------------------------------------
C
      WRITE(6,150)MAXAD,MAXCF,MAXCF,MAXRK,MAXRL,MXDFS
      IF(MAXLAM.NE.1000)WRITE(6,152)MAXLAM
C
C-----------------------------------------------------------------------
C
      NF1=NF+1                                       !CONTINUUM LOCATION
C
      NEN(1,1)=NF1                               !CURRENTLY, NOT NECESSY
      NEN(2,1)=NF1                                 !TO SPECIFY - ASSUMED
C
      NAD(0)=0
      NCOR=0
C
      IOS=0
      JOS=1
      IRK=0
      IRL=0
C
      BLP=MPRINT.GT.0
C
C-----------------------------------------------------------------------
C LOOP OVER TOTAL SYMMETRIES
C-----------------------------------------------------------------------
C
      DO IX=1,INAST
C
        IL=LSPI(IX)
        MTL=IL+IL
        LI=MTL                                                   !FOR CA
        LL(1)=LI                        !ASSIGN ALGEBRAIC INITIAL CONT L
C
C-----------------------------------------------------------------------
C
C   CALCULATE THE CONFIGURATION AVERAGE ALGEBRA OF THE ELECTROSTATIC
C   MATRIX BETWEEN TWO TARGET CONFIGS THAT DIFFER BY ONE ELECTRON PAIR
C   FOR ELECTRON-IMPACT EXCITATION. CURRENTLY, WE ARE NOT INTERESTED IN
C   ELASTIC TRANSITIONS.
C
C-----------------------------------------------------------------------
C
c        lcon0=4*((nmulte-1)/2)                                   !local
c
        DO KF=1+ione1,KMAX                                !BEGIN KF LOOP
C
          DO KG=1,KF-ione1                                !BEGIN KG LOOP
C
            IF(KACT(KG,KF).LT.0)GO TO 73
C
            L1=KACT(KF,KG)
            NEN(1,2)=L1
            L1=QL(L1)
            L2=KACT(KG,KF)
            NEN(2,2)=L2
            L2=QL(L2)
C
            L12M=ABS(L1-L2)
            L12=L1+L2
C
            LCON=L12
   57       LMIN=MTL-LCON
            IF(LMIN.LT.0)THEN                  !EFFECTIVE MULTIPOLE LOOP
              LCON=LCON-IFOUR
              IF(LCON.GE.L12M)GO TO 57
              LMIN=ABS(MTL-L12M)
            ENDIF
C
            LCON=MIN(L12,LCONDW-1)                               !GLOBAL
c            lcon0=3*abs(l1-l2)                                  !local
c            if(l12m.eq.2)lcon=min(lcon,14)                      !dipole
C
            MT=MTL-LCON
            IF(LMIN.LT.MT)THEN
              LMIN=MT
              IF(MOD(L12/2,ITWO).NE.MOD(LCON/2,ITWO))LMIN=LMIN+2  !ALIGN
            ENDIF
C
            LMAX=MTL+L12
            MT=MTL
C            MT=MAX(MT,LMIN)   !NEED MEMORY REPOINTED AS ACCESSES>LCONDW
            MT=MT+LCON
            IF(LMAX.GT.MT)THEN
              LMAX=MT
              IF(MOD(LMIN/2,ITWO).NE.MOD(LMAX/2,ITWO))LMAX=LMAX-2 !ALIGN
            ENDIF
C
            IF(LMAX.LT.LMIN)GO TO 73
C
            DO LF=LMIN,LMAX,4
C
              LL(2)=LF                    !ASSIGN ALGEBRAIC FINAL CONT L
c
c          write(6,*)'kf, kg=',kf,kg,' 2-body:',nen(1,1),nen(1,2)
c     x    ,'  ',nen(2,1),nen(2,2)
C
              IRK0=IRK+1
C
              CALL CAFLGLX(DFS)
C
              NCOR=NCOR+1
C
              IF(IRL.GT.IAXRL.or.irl.lt.0)JOS=-1
              IF(IRK.GT.IAXRK)JOS=0
              IF(JOS.LE.0)GO TO 67             !DIMEN EXCEEDED, BAIL OUT
              IF(NF.LE.0)GO TO 900
C
c        write(6,*)'cf=',kf,kg,li/2,lf/2
              IF(BLP.AND.IRK.GE.IRK0)THEN
                IF(IRK-IRK0.NE.5)THEN
                  WRITE(6,120)NCOR,li/2,lf/2,KF,KG,IRK,IRL
     X                       ,(NRK(I),DRK(I),I=IRK0,IRK)
                ELSE
                  WRITE(6,119)NCOR,li/2,lf/2,KF,KG,IRK,IRL
     X                       ,(NRK(I),DRK(I),I=IRK0,IRK)
                ENDIF
                WRITE(6,120)
              ENDIF
C
              NAD(NCOR)=IRK                       !ONLY FLAG INTERACTING
C
            ENDDO                                 !END LOOP OVER FINAL L
C
  73        CONTINUE
C
          ENDDO                                   !END LOOP KG
C
        ENDDO                                     !END LOOP KF
C
        IRLAST(IL)=IRL                         !POINT TO END FOR THIS IL
C
      ENDDO                             !END LOOP OVER INITIAL L
C
C RESULTS
C
      IF(IADD.NE.NCOR)THEN
        WRITE(6,*)'SR.CALGX: GLOBAL INDEX ERROR:',IADD,NCOR        !test
        GO TO 995
      ENDIF
c      write(0,*)iadd
C      IADD=NCOR
C
      CALL DIMUSE('MAXAD',IADD)
      CALL DIMUSE('MAXRK',IRK)
      CALL DIMUSE('MAXRL',IRL)
C
  67  IF(.NOT.BLP.OR.JOS.LE.0)THEN
        WRITE(6,120)NCOR,-1,-1,KMAX,KMAX,IRK,IRL
        IF(JOS.LT.0)GO TO 93
        IF(JOS.EQ.0)GO TO 95
        WRITE(6,199)MPRINT
      ELSE
C
C PRINT SLATER INTEGRAL (ADRESS REFERENCE) LIST
C
        IF(IRL.GT.0)THEN
          WRITE(6,300)
          DO  L=1,IRL
            WRITE(6,700)L,(QRL(I,L), I=1,5)
          ENDDO
        ENDIF
      ENDIF
C
 900  CONTINUE
C
C IF ACTUAL USAGE IS SUFFICIENTLY SMALLER THAN *INITIAL* ALLOCATION,
C THEN REDUCE USAGE TO ACTUAL - FOR SMALL CASES ON SMALL MEMORY MACHINES
C
      IXXX=(4*MAXRL)/5
      IF(BDXRL.AND.IRL.LT.IXXX)THEN
C
c        WRITE(6,*)'*** CALGX: decreasing MAXRL from ',IAXRL,' to: ',IRL
c        WRITE(0,*)'*** CALGX: decreasing MAXRL from ',IAXRL,' to: ',IRL
C
        CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IRL,IERR)
C
        IAXRL=IRL
C
      ENDIF
C
      IXXX=(4*MAXRK)/5
      IF(BDXRL.AND.IRK.LT.IXXX)THEN
C
c        WRITE(6,*)'*** CALGX: decreasing MAXRK from ',IAXRK,' to: ',IRK
c        WRITE(0,*)'*** CALGX: decreasing MAXRK from ',IAXRK,' to: ',IRK
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IRK,IERR)
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IRK,IERR)
C
        IAXRK=IRK
C
      ENDIF
C
C-----------------------------------------------------------------------
C
      if(btimex)then
        call cpu_time(timef)
        times=timef-time0
cpar      if(iam.ge.0)then                                          !par
cpar        write(iw,*)'Ending proc',iam,' for calgx:'              !par
cpar     x           ,' time=',nint(times),'sec'                    !par
cpar     x             ,nint(times/60),'min'                        !par
cpar        call flush(iw)                                          !par
cpar      else                                                      !par
        write(iw,*)'Ending calgx: time=',nint(times),'sec,     '
     x             ,nint(times/60),'min'
cpar      endif                                                     !par
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C     E R R O R   M E S S A G E S
C
  95  WRITE(6,188)
      IF(IRL.LE.IAXRL.and.irl.ge.0)GO TO 96
  93  if(irl.ge.0)then
        WRITE(6,193)
      else
        WRITE(6,194)
      endif
  96  WRITE(6,190)
C
 995  NF=-1
      GO TO 900
C
 999  NF=0
      GO TO 900
C
C  119 FORMAT(I9,3X, 2I6, I9,I5, 6(I6,F11.6))
  119 FORMAT(I7,2X, 2I3,1X,2I5, I7,I5, 6(I6,F11.6))
  120 FORMAT(I7,2X, 2I3,1X,2I5, I7,I5, 6(I6,F11.6)/(38X,6(I6,F11.6)))
  150 FORMAT(/ /' SLATER COEFFICIENTS  F(A,...)  FOR CONSTRUCTING   ',
     X'( KF !  H  ! KG ) = SUM( F(A,...) * R(A,...) )'
     X/I7,9X,2I5,I7,I5,1X,
     X'STORAGE RESTRICTIONS FOR (MAXAD,MAXCF,MAXCF,MAXRK,MAXRL), MXDFS='
     X,I3/ '   NCYC   LF LG    KF   KG    MNF  MNR'
     X,6(3X,'I(R)  F(A,...)'))
  152 FORMAT(/' **** SLATER MULTIPOLE EXPANSION LIMITED TO LAMDA=',I3/)
  188 FORMAT(/' SR.CALGX: *MAXRK TOO SMALL, ARRAYS DRK AND NRK ')
  190 FORMAT( ' SR.CALGX: STORAGE EXCEEDED - CASE SKIPPED')
  193 FORMAT(/' SR.CALGX: *MAXRL TOO SMALL, ARRAYS DRL AND QRL')
  194 FORMAT(/' SR.CALGX: *MAXRL TOO LARGE FOR INTEGER(SP) POINTER IN '
     X,'NRK:'/12X,'*TRY REDUCING MAXRL TO ACTUAL USAGE,'
     X,'*OR USE INTEGER *8 FOR NRK - SEE MODULE COMMON_DXRL'/)
  199 FORMAT(/ ' *** PRINTOUT OF COEFFICIENTS SUPPRESSED - MPRINT'
     X,'(MODULO 5)=',I2/)
  300 FORMAT(/ ' I(R)  R(  A,  B,   C,  D,  2LBD )=SLATER-INTEGRALS '
     X,' REFERENCE LIST  (EXCHANGE LAMBDA = LBD + LTOT)')
  700 FORMAT( I5, 2X,2(I5,I4),I7)
C
      END SUBROUTINE CALGX
C
C                             *******************
C
      SUBROUTINE CARATE(DECORE,DF)
C
C-----------------------------------------------------------------------
C
C  SR.CARATE CALCULATES CA ENERGIES AND DATA FOR ELECTRIC RADIATIVE
C  TRANSITIONS.
C  ALSO CALCULATES AUTOIONIZATION RATES AND PHOTOIONIZATION CROSS
C  SECTIONS - SEE ALSO NOTES IN SR.RADCON.
C
C  N.B. CONTAINS LEGACY OF MORE GENERAL MIXED CODE.
c
C  IT CALLS:
C    SR.BRNINT
C    SR.DATA_AND_TIME (SYSTEM)
C    FN.QBINOM
C    SR.RKINT
C    SR.HPSRTI
C    SR.SLATR
C
C  IT CONTAINS:
C    FN.ICOL
C    FN.ICOL8
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CACC,   ONLY: ACC
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD,IPLANT_RL,n8
      USE COMMON_INTS,   ONLY: DRL,DOSC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBIAD, ONLY: IADJ,IADJ8,NP8
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
      USE COMMON_NRBORN, ONLY: BL,OBO,TM2,IXBLM
      USE COMMON_NRBRN1, ONLY: SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK
      USE COMMON_NRBRN2, ONLY: BINDB,MENGB
      USE COMMON_NRBRN3, ONLY: V0,V1,XB,XS,DB0,DB1,OMEGAB
     X                        ,MV0,MV1,MINFB,MXNXB,MXNXB1,NLAGB
     X                        ,IEXP,XMANT
      USE COMMON_NRBTS1, ONLY: DFOT,DFOSS,PMIN,NFOSS,IPIG,IGAG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLIT=62)
      PARAMETER (MXSTRG=32)                            !MAX STRING WRITE
      PARAMETER (MSTRGH=16)                          !SHORT STRING WRITE
      PARAMETER (MXLAB1=29)                                    !0:MXLAB1
      PARAMETER (MXLAB2=19)                                    !0:MXLAB2
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
      parameter (mxlenx=2000)                               !card length
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
C
      PARAMETER (D0PT8=0.8D0)
      PARAMETER (D1PT2=1.2D0)
COLD      PARAMETER (D1PT5=1.5D0)
      PARAMETER (DKON=1.653656D17)
      PARAMETER (C1=DFSC**3/HBAR)
      PARAMETER (C2=2.567895D-18)    !4*pi*a_0**2*alpha
C      PARAMETER (C3=C2/DTHREE)
      PARAMETER (EINF=1.0D6)
C
      PARAMETER (MW=7)               !INITIALIZE UNIT NOS
      PARAMETER (MWW=MW+10)
      PARAMETER (MWU=MW+20)
      PARAMETER (MWWU=MWU+2)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                   !2**31 -1
C
      INTEGER(EP) I8,J8 !,ICOL8
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      INTEGER QLB,LIT     !HISTORIC DEFAULT KIND TO SYNC WITH POST PROCS
C
      REAL(RP) OMEGA
C
      CHARACTER(LEN=1) BIGL,NUMB,STRING,CLIT,CMBLK1
COLD  X,SMAL
CHAR  X,LIT,MBLK1  !USE OF CHAR REQUIRES CHANGES TO PP'S FOR UNFORM I/O
      CHARACTER(LEN=2) CELMNT,ELEM
      CHARACTER(LEN=4) MBCOR,MCOR,MBLK,CODE,MYRGE,LAB4,CARD4
      CHARACTER(LEN=8) DATE
      character(len=9) orbfmt
      character(len=31) ceiss,cstan
      CHARACTER(LEN=17) F762
      CHARACTER(LEN=29) F761
      character(len=51) f542,f543
      character(len=mxlenx) cardx
      CHARACTER(LEN=MXLEN) CARD
      CHARACTER(LEN=6) FORM,FORM2,FORM3
C
      PARAMETER (FORM2='(60I2)')
      PARAMETER (FORM3='(40I3)')
C
      ALLOCATABLE :: LMX(:),QSB(:,:),QLB(:,:),DG(:)
C
      ALLOCATABLE :: OMR(:),OMC(:),OMEGA(:,:),ITMP(:),DDY(:)
C
      ALLOCATABLE :: DENERG(:),IWRK2(:),IORIG(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
     X              ,IWRK1(:)
C
      ALLOCATABLE :: MNAL(:),MXAL(:)
c
      allocatable :: isorb(:),decorn(:)
C
      DIMENSION BIGL(0:MXLAB1),NUMB(0:MXLAB2)
     X         ,STRING(MXSTRG),CLIT(MXLIT),LIT(MXLIT)
C
      COMMON /BASIC/NF,MGAP(10),IGAUGE
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCL0,JPRINT
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /TRANLS/NADRU(MAXTM),NAI(MAXTM),NC0,IEORD(MAXTM)
      COMMON /WEIGHT/WGHT(MAXTM),INDEXW(MAXTM)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBRNG/DSTRNG(6,MAXGR)
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBTAR/ETAR(MAXTM),ISTAR(MAXTM),LTAR(MAXTM),JTAR(MAXTM)
     X              ,NTAR,IGAPE
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
C      COMMON /WORKLS/DWRK(MAXTM),IWRK3(MAXTM),IWRK4(MAXTM)
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
      common /hps/badas
C
      DATA CMBLK1/' '/,MBLK/'    '/,MCOR/' COR'/,BSCRO/.FALSE./
C
      DATA CLIT( 1),CLIT( 2),CLIT( 3),CLIT( 4)  /'1','2','3','4'/,
     X     CLIT( 5),CLIT( 6),CLIT( 7),CLIT( 8)  /'5','6','7','8'/,
     X     CLIT( 9),CLIT(10),CLIT(11),CLIT(12)  /'9','A','B','C'/,
     X     CLIT(13),CLIT(14),CLIT(15),CLIT(16)  /'D','E','F','G'/,
     X     CLIT(17),CLIT(18),CLIT(19),CLIT(20)  /'H','I','J','K'/,
     X     CLIT(21),CLIT(22),CLIT(23),CLIT(24)  /'L','M','N','O'/,
     X     CLIT(25),CLIT(26),CLIT(27),CLIT(28)  /'P','Q','R','S'/,
     X     CLIT(29),CLIT(30),CLIT(31),CLIT(32)  /'T','U','V','W'/,
     X     CLIT(33),CLIT(34),CLIT(35),CLIT(36)  /'X','Y','Z','a'/,
     X     CLIT(37),CLIT(38),CLIT(39),CLIT(40)  /'b','c','d','e'/,
     X     CLIT(41),CLIT(42),CLIT(43),CLIT(44)  /'f','g','h','i'/,
     X     CLIT(45),CLIT(46),CLIT(47),CLIT(48)  /'j','k','l','m'/,
     X     CLIT(49),CLIT(50),CLIT(51),CLIT(52)  /'n','o','p','q'/,
     X     CLIT(53),CLIT(54),CLIT(55),CLIT(56)  /'r','s','t','u'/,
     X     CLIT(57),CLIT(58),CLIT(59),CLIT(60)  /'v','w','x','y'/,
     X     CLIT(61),CLIT(62)  /'z','*'/
      DATA (BIGL(I),I=0,MXLAB1)/'S','P','D','F','G','H','I','K','L','M'
     X                         ,'N','O','P','Q','R','S','T','U','V','W'
     X                         ,'X','Y','Z','a','b','c','d','e','f','*'/
      DATA (NUMB(I),I=0,MXLAB2)/'0','1','2','3','4','5','6','7','8','9'
     X                         ,'A','B','C','D','E','F','G','H','I','*'/
C      DATA (XB0(I),I=1,MXNXB)/1.001D0,1.1D0,1.2D0,1.3D0,1.55D0,2.D0
C     X   ,3.D0,5.5D0,1.D1,2.D1,3.D1,5.5D1,1.D2,2.D2,3.D2,5.5D2,1.D3/
C                                                               !17-vals
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE CARATE
c      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
c      ICOL8(I8,J8,IONE1)=((J8-1)*(J8-2*IONE1))/2+I8
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      IF(IEQ(0).NE.0)THEN
        ALLOCATE (ITMP(2*MXORB),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CARATE: ALLOCATION FAILS FOR ITMP'
          NF=0
          GO TO 750
        ENDIF
      ENDIF
C
C FIX FOR FORTRAN 90 COMPILERS THAT DON'T ALLOW ASSIGNMENT OF CHARACTERS
C TO INTEGER VARIABLES, REQUIRED FOR HISTORIC BACKWARDS COMPATIBILITY
C
      OPEN(80,STATUS='SCRATCH',FORM='FORMATTED')
      WRITE(80,1111)CMBLK1,(CLIT(I),I=1,MXLIT)
 1111 FORMAT(80A1)
      BACKSPACE(80)
      READ(80,1111)MBLK1,(LIT(I),I=1,MXLIT)
      CLOSE(80)
C
C INITIALIZE LOGICALS ETC
C
      BCONT=MODE.EQ.2.OR.MODE.EQ.3               !FOR BOUND-CONTINUUM
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
      BREL2=ABS(IREL).EQ.2
      BDR=IDR.NE.0
      BBORN=MENGB.GE.0
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG
      IF(.NOT.BFOTJ.AND.PMIN.GT.DZERO)IPIG=1
      BELONG=IGAUGE.EQ.0                 !IGAG(0)  !AEK/SEK LENGTH GAUGE
      BORT=MORT.LT.0
C
      NPRNT5=MOD(NPRINT,IFIVE)
      INCLUD=MOD(INCL0,I1000000)
      nmeta0=nmeta
      TOLB2=TOLB/DTWO                                         !RYD->A.U.
C
C LOCAL
C
      ALLOCATE (LMX(KMAX),QSB(10,KMAX),QLB(10,KMAX))
C
      ALLOCATE (DENERG(KMAX),IWRK2(KMAX),IORIG(KMAX))
C
      ALLOCATE (DWRK(KMAX),IWRK3(KMAX),IWRK4(KMAX))
c
      ngrp=1
      mxborb=0
      if(irlx.lt.0)then
        ngrp=-irlx/100000             !until /nrborb/ in a module
        mxborb=-irlx-100000*ngrp
      endif
c
      allocate (decorn(ngrp))
C
C SET CHARGES ETC.
C
      NZA=NZION-MION+1
      DZA2=NZA*NZA
      DZA=-NZA
c      DZM=-NZION
      DZ2=NZION-MION
      IF(NZION.EQ.MION)DZ2=DONE
      DZ2=DZ2*DZ2
      TSHFT=MSHIFT+MSHIFT
C
C INITIALIZE FOR NLAG-POINT LAGRANGE INTERPOLATION FORMULA FOR
C  BOUND-CONTINUUM INTEGRALS.
C  NLAG MUST BE AN EVEN NUMBER .GE. 4 . READ IN SRADCON.
C  DEFAULT:   NLAG=6.
C  IF MENG.EQ.1 THEN NO INTERPOLATION (& NLAG NOT IUSED)
C
      NLAG2=NLAG-2
      NP1=1
      NP2=MAX(IONE,NLAG)
      NPH=NP2/2
      BBC1=MENG.LE.NP2
      IF(BBC1)NP2=MENG
C
      IF(BCONT)THEN
        IF(BLAG)THEN
          ALLOCATE (DDY(MENG))
        ELSE
          ALLOCATE (DDY(1))
          DDY(1)=DONE
        ENDIF
      ENDIF
C
C RE-SCALE ONE-BODY TERMS INVOLVING RYDBERG ORBITAL IN DR OPERATION
C
      IF(BJUMP2)THEN
        DO K=1,MXORB                    !1/N**3 SCALING
          IF(DEY(K).EQ.DZERO)GO TO 115
C         IF(K.LE.ABS(MPSEUD))GO TO 115
          IF(IVAL(K).NE.0)THEN
            TM=NNEW
            IF(KSHIFT.LE.0)TM=TM-SCREEN(K)                  !NEEDS Q.D.
            TN=DZA/TM
            TN=TN*TN                    !COULOMB
            IF(BREL)THEN
              T=DTWO*TM/(QL(K)+1)-DTHREE/DFOUR
              TMV=T*TN*TN               !M-V
              IF(QL(K).EQ.0)THEN        !DARWIN
                TT=dza/TM               !DZM->dza since large n
                TT=TT*TT
                TD=-TT*TT*TM
              ELSE
                TD=DZERO
              ENDIF
              T=(TMV+TD)*DFSC*DFSC
              if(tn+t.lt.dzero)t=dzero  !use non.rel.
              TN=TN+T
            ENDIF
            DSHIFT(K)=TN/DTWO
            TN=NNOLD
            IF(KSHIFT.LE.0)TN=TN-SCREEN(K)                  !NEEDS Q.D.
            TN=TN/TM
            FACT(K)=TN**3
            DUY(K,K)=DUY(K,K)*FACT(K)
            DEY(K)=DUY(K,K)-DSHIFT(K)
            IF(KSHIFT.GT.0)DSHIFT(K)=DZERO
            IF(QED.LT.0.AND.QN(K).GT.0)THEN
              VPINT(K)=FACT(K)*VPINT(K)
              SLFINT(K)=FACT(K)*SLFINT(K)
            ENDIF
            FACT(K)=SQRT(FACT(K))
          ENDIF
          IF(K.EQ.1)GO TO 115
          I=K-1
          DO J=1,I
            DUY(K,J)=DUY(K,J)*FACT(K)*FACT(J)
          ENDDO
          IF(BMVD)THEN
            DO J=1,K
              IF(DEY(J).NE.DZERO.AND.QL(J).EQ.QL(K))THEN
                DD=FACT(J)*FACT(K)
                DMASS(K,J)=DMASS(K,J)*DD
                DCD(K,J)=DCD(K,J)*DD
C                D2LL(K,J)=D2LL(K,J)*DD
              ENDIF
            ENDDO
          ENDIF
  115   ENDDO
        GO TO 114
      ENDIF
C
C DETERMINE CONFIGURATION OVERLAP MATRIX
C (FOR USE WITH RELAXED ORBITALS, IRLX=2 ONLY.)
C
      IF(IRLX.EQ.2)THEN      !DETERMINE OVERLAPS BETWEEN CF'S
C
        ALLOCATE (IWRK1(NF))
C
        KK=0
        DO KF=2,KMAX
          DO KG=1,KF-1
            KK=KK+1
            DO  I=1,NF
              IWRK3(I)=QCG(I,KG)
            ENDDO
            K=0
            OVL=DONE
            DO I=1,NF
              DO L=1,NF
                IF(IEQ(IWRK3(L)).EQ.IEQ(QCG(I,KF)))THEN
                  IWRK3(L)=0
                  I1=MIN(QCG(I,KF),QCG(L,KG))
                  I2=MAX(QCG(I,KF),QCG(L,KG))
                  II=((I2-1)*(I2-2))/2+I1
                  OVL=OVL*OVLPGR(II)
                  GO TO 51
                ENDIF
              ENDDO
              K=K+1
              IPAIR(KK)=K
              IF(K.GT.2)GO TO 52
  51        ENDDO
            OVLPCF(KK)=OVL
  52      ENDDO
        ENDDO
C
        DEALLOCATE (IWRK1)
C
        IF(BPRINT)THEN
          WRITE(6,768)(K,K=1,KMAX-1)
          K2=0
          DO KF=2,KMAX
            K1=K2+1
            K2=K2+KF-1
            WRITE(6,767)KF,(OVLPCF(K),K=K1,K2)
          ENDDO
        ENDIF
C
C MULTIPLY ONE-BODY INTEGRALS BY OVERLAPS
C
        DO J=2,MXORB
          KF=IGRCF(J)
          IF(DEY(J).EQ.DZERO.OR.KF.EQ.0)GO TO 78
          DO I=1,J-1
            KG=IGRCF(I)
            IF(DEY(I).EQ.DZERO.OR.KG.EQ.0)GO TO 77
            IF(BJUMP.AND.IVAL(I)+IVAL(J).EQ.0)GO TO 77
            IF(QL(I).NE.QL(J))GO TO 77
            IF(KF.NE.KG)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              IF(IPAIR(KK).EQ.1)THEN
                OVL=OVLPCF(KK)
                DUY(I,J)=DUY(I,J)*OVL
                DUY(J,I)=DUY(J,I)*OVL         !NEEDED?
                IF(BMVD)THEN
                  DMASS(I,J)=DMASS(I,J)*OVL
                  DCD(I,J)=DCD(I,J)*OVL
C                  D2LL(I,J)=D2LL(I,J)*OVL
                  DMASS(J,I)=DMASS(J,I)*OVL   !DITTO
                  DCD(J,I)=DCD(J,I)*OVL
C                  D2LL(J,I)=D2LL(J,I)*OVL
                ENDIF
              ENDIF
            ENDIF
   77     ENDDO
   78   ENDDO
C
      ENDIF
C
C GENERATE AND PRINT SOME EXPECTATION VALUES
C (NOT USED SUBSEQUENTLY, SO CAN SKIP IF PRINTING SUPPRESSED.)
C
  114 IF(.NOT.BPRNT0)GO TO 805
C
      IF(MGRP.GE.0)WRITE(6,200)MAXRS
      IF(MGRP.LT.0)WRITE(6,201)MAXRS
      L=MAXRS-2
C
      DO K=1,MXORB
C
        IF(DEY(K).EQ.DZERO)GO TO 816
C       IF(K.LE.ABS(MPSEUD))GO TO 816
        K17=K
        N1=QL(K)/2
        N3=N1
        IF(BORT)N3=K-1
        IF(BJUMP.AND.IVAL(K).EQ.0)GO TO 613
        DO J=1,6
          DSTRNG(J,K)=DZERO
        ENDDO
        DSTRNG(3,K)=-DUY(K,K)
        DSTRNG(1,K)=(DEY(K)+DSTRNG(3,K))*DTWO
        IF(.NOT.BDR)DSTRNG(1,K)=DSTRNG(1,K)+DTWO*DSHIFT(K)
        IF(MODE.LT.6.AND.QN(K).LT.0)GO TO 613    !MODE=1-4, CURRENTLY...
C
        DO J=2,6
          M=J-3
          IF(M.NE.0)THEN
            IF(BREL2)THEN
              DO I=1,MAXRS
                DD=DPNL(I,K)*DPNL(I,K)+DQNL(I,K)*DQNL(I,K)
                DPA(I)=DD*DX(I)**M
              ENDDO
            ELSE
              DO I=1,MAXRS
                DPA(I)=DPNL(I,K)*DPNL(I,K)*DX(I)**M
              ENDDO
            ENDIF
            CALL WEDDLE(DZERO,DPA,DC,MNH,DHNS,MJH,MAXRS)
            DSTRNG(J,K)=DC
          ENDIF
        ENDDO
C
  613   N2=JEND(N3+1)
        IF(N2.EQ.0)N2=MAXRS
C
        WRITE(6,250)K,QN(K),N1,MION,NZION,SCREEN(K),(DSTRNG(J,K),J=1,6),
     X              DADJUS(N3+1),DX(N2),(DPNL(I,K)*FACT(K),I=L,MAXRS)
C
  816 ENDDO
C
      WRITE(6,100)(DX(I),I=L,MAXRS)
C
C  DETAILED PRINTOUT OF MASS-VELOCITY PLUS DARWIN INTEGRALS
C (SKIPPED IF PRINTING SUPPRESSED.)
C
      IF(BMVD.AND.BPRNT0)THEN
        WRITE(6,901)JPRINT
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            DD1=DMASS(K,K)
            DD2=DCD(K,K)
            DD=DD1+DD2
            L=QL(K)/2
            WRITE(6,902)K,QN(K),L,DEY(K),DD1,DD2,DD,D2LL(K,K)
          ENDIF
        ENDDO
C
        WRITE(6,903)
        DO L=1,IRL
          IF(QRL(5,L).EQ.-1)THEN
            L1=QRL(1,L)
            L2=QRL(3,L)
            WRITE(6,904)L,L1,L2,DMASS(L1,L2),DCD(L1,L2),D2LL(L1,L2)
          ENDIF
        ENDDO
      ENDIF
C
C  DETAILED PRINTOUT OF ONE-BODY INTEGRALS I(A,C)
C
      IF(IRL.LT.0)THEN            !.LT.0 SUPRESSES PRINTOUT
        WRITE(6,701)
        DO K=1,K17
          I=K
          IF(DEY(K).EQ.DZERO)I=10000
          WRITE(6,702)I,(DUY(K,J),J=1,K)
        ENDDO
      ENDIF
C
C DETAILED PRINTOUT OF ANY QED CONTRIBUTIONS
C
      IF(QED.LT.0.AND.BPRNT0)THEN
        WRITE(6,3005)
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            IF(QN(K).LT.0)GO TO 805                 !WE ARE DONE
            DD=VPINT(K)+SLFINT(K)
            WRITE(6,3010)K,QN(K),QL(K)/2,VPINT(K),SLFINT(K),DD
          ENDIF
        ENDDO
      ENDIF
C
  805 CONTINUE
C----------------------------------------------------------
C  *** CALCULATE SLATER INTEGRALS:  DRL(L)  (AND 2-NFS) ***
C----------------------------------------------------------
C
           if(btime)call cpu_time(timei)
c
      IF(IRL.GT.0)THEN
C
        CALL SLATR(BPRNT0)
C
        IF(NF.LE.0)GO TO 2000
      ENDIF
C
C
      IF(BPRNT0.AND.MAXLAM.NE.1000)WRITE(6,301)2*MAXLAM
C
      BRADAT=BPRINT.OR.JPRINT.EQ.3.AND.INCL0.EQ.0       !ORIGINAL INCLUD
      IF(.NOT.BPRINT)BRADAT=JPRINT.LT.0.AND.NPRNT5.GT.-2 !EVAL G FUNCTNL
C
      IF(.NOT.BRADAT)GO TO 830
      IF(BJUMP.AND..NOT.BRAD)GO TO 830
C
C-----------------------------------------------------
C *** CALCULATE R^K MULTIPOLE INTERGALS (INC BORN) ***
C-----------------------------------------------------
C
      CALL RKINT(BPRNT0)
C
      IF(NF.LE.0)GO TO 2000
C
  830 CONTINUE
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for carate:'                 !par
cpar          write(iwp,*)'    integral time=',nint(times),'sec'    !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'integral time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C  COLLAPSE BACK RELAXED ORBITAL LIST
C
      IF(IEQ(0).LT.0)THEN
        MXBORB=-IEQ(0)
        KF=MB+MXBORB                                                !MB0
        DO K=1,KF
          K2=2*K
          ITMP(K2-1)=QN(K)
          ITMP(K2)=QL(K)/2
          IORB(K)=K2
        ENDDO
        KP=2*KF
        KF=MB+MXBORB*KMAX                                           !MB0
        IF(BDR)THEN
          DO K=1,KMAX
            KF=KF+1
            IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN         !FIRST OCC.
              KP=KP+1
              ITMP(KP)=QN(KF)
              KP=KP+1
              ITMP(KP)=QL(KF)/2
              IORB(KF)=KP
            ENDIF
          ENDDO
        ENDIF
        DO K=1,KMAX
          KF=KF+1
          IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN           !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(KF)
            KP=KP+1
            ITMP(KP)=QL(KF)/2
            IORB(KF)=KP
          ENDIF
        ENDDO
      ELSEIF(IEQ(0).GT.0)THEN
        KP=0
        DO K=1,MXORB
          IF(K.EQ.IEQ(K))THEN                                !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(K)
            KP=KP+1
            ITMP(KP)=QL(K)/2
            IORB(K)=KP
          ENDIF
        ENDDO
      ENDIF
C
      IF(MODE.GT.0)THEN
        IF(IEQ(0).EQ.0)THEN
          KF=MIN(MXLIT,MXORB)
          IF(BPRNT0)THEN
            IF(KMAX.LT.1000)THEN
              WRITE(MW,507)KMAX,NZION,MION,(ABS(QN(K)),QL(K)/2
     X                            ,K=1,KF)
            ELSE
              WRITE(MW,1507)KMAX,NZION,MION,(ABS(QN(K)),QL(K)/2
     X                            ,K=1,KF)
            ENDIF
          ENDIF
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                    ,(int(ABS(QN(K))),int(QL(K)/2),K=1,KF)
        ELSE
          KF=MIN(KP,MXLIT)
          IF(BPRNT0)THEN
            IF(KMAX.LT.1000)THEN
              WRITE(MW,507)KMAX,NZION,MION,(ABS(ITMP(K))
     X                            ,ITMP(K+1),K=1,KF,2)
            ELSE
              WRITE(MW,1507)KMAX,NZION,MION,(ABS(ITMP(K))
     X                            ,ITMP(K+1),K=1,KF,2)
            ENDIF
          ENDIF
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                  ,(int(ABS(ITMP(K))),int(ITMP(K+1)),K=1,KF,2)
        ENDIF
      ENDIF
C
      DO K=1,KMAX
        LM=0
C
        DO J=1,MXORB
          IF(NEL(J,K).GT.0)THEN
            LM=LM+1
            QSB(LM,K)=NEL(J,K)
            IF(LM.GT.1)QSB(LM,K)=QSB(LM,K)+50
            IF(IEQ(0).NE.0)THEN
              JM=MIN(IORB(IEQ(J))/2,MXLIT)
            ELSE
              JM=MIN(J,MXLIT)
            ENDIF
            QLB(LM,K)=LIT(JM)
CHAR        QLB(LM,K)=ICHAR(CLIT(JM))
            NCC0(LM)=J
          ENDIF
        ENDDO
        LMX(K)=LM
C
        IF(LM.LT.10)THEN
          LP=LM+1
          DO J=LP,10
            QSB(J,K)=0
            QLB(J,K)=MBLK1
CHAR        QLB(J,K)=ICHAR(CMBLK1)
          ENDDO
        ENDIF
        M2=QCG(NF,K)
        KW=K
        MST=MSTAT(K)
        IF(IYY(M2).GT.0)THEN
          KW=-K
C          M1=QL(M2)+1
C          MST=MSTAT(K)/(M1+M1)                 !AS CA OMITS CONTINUUM
        ENDIF
        IF(MODE.GT.0)THEN
          IF(BPRNT0)THEN
            if(mst.gt.99999)mst=0      !as I5 - use unformatted !MA0,MB0
            WRITE(MW,517)KW,MST,MA,MB,(QSB(L,K)
     X             ,QLB(L,K),L=1,LM)
CHAR  X             ,CHAR(QLB(L,K)),L=1,LM)
          ELSE                                                  !MA0,MB0
            WRITE(MWU)int(KW),int(MST),int(MA),int(MB)
     X              ,(int(QSB(L,K)),int(QLB(L,K)),L=1,10)
          ENDIF
        ENDIF
        DO L=1,LM
          QLB(L,K)=NCC0(L)
        ENDDO
      ENDDO
C
      IF(MODE.GT.0)THEN
        IF(BPRNT0)WRITE(MW,505)NZION,MION
        IF(.NOT.BPRNT0)WRITE(MWU)int(NZION),int(MION)
      ENDIF
C
C***********************************************************************
C
C  CONSTRUCT HAMILTONIAN MATRICES (H FOR ENERGY AND H**2 FOR RATES).
C
C***********************************************************************
C
C
C  CALCULATE ENERGY CONTRIBUTION DECORE OF THE NW CORE ELECTRONS
C  (MAYBE GROUP DEPENDENT)
C
        do n=1,ngrp
c
          n1=n-1
          decor0=dzero
c
      DC1=DZERO                                      ! 1-BODY
      DC2=DZERO                                      ! 2-BODY
C
C 1-BODY (INC. NFS IF CAM)
C
      DO L=1,NW
        J=NNL(L,1)            +mxborb*n1
        DC1=DC1+DEY(J)
        IF(BMVD)THEN
          DC1=DC1+DCD(J,J)+DMASS(J,J)
          IF(QED.LT.0)DC1=DC1+VPINT(J)+SLFINT(J)
        ENDIF
      ENDDO
C
C 2-BODY (NON-REL ONLY)
C
      DO I=1,NAD(0)
        J=INT(NRK(I))          +n1
        DC2=DC2+DRL(J)*DRK(I)
      ENDDO
C
      DECORE=DC1+DC2                        ! 1-BODY + 2-BODY
C
      IF(BPRNT0)WRITE(6,400)DC2,DC1
c
          decorn(n)=decore
          decor0=min(decor0,decore)
c
        enddo
c
        decore=decor0
c
        do n=1,ngrp
          decorn(n)=decorn(n)-decore
        enddo
C
C***********************************************************************
C FIRST, GENERATE ALL CA ENERGIES.
C (WE ARE NOT CONSTRAINED TO THE LOOP ORDER IN CALGEB)
C***********************************************************************
C
      DMIN=DKCM
      EIONMN=DZERO
C
      DO K=1,KMAX
C
C 1-BODY (INC. NFS IF CAM)
C
        M2=0
        E1BODY=DZERO
        DO L=1,NF
          IF(QCG(L,K).NE.M2)THEN
            M2=QCG(L,K)
            DD=DEY(M2)
            IF(BMVD)DD=DD+DCD(M2,M2)+DMASS(M2,M2)
            IF(QED.LT.0.AND.QN(M2).GT.0)DD=DD+VPINT(M2)+SLFINT(M2)
          ENDIF
          E1BODY=E1BODY+DD
        ENDDO
        IF(ICAV.NE.0)E1BODY=E1BODY+ECAVX(K)-ECAV(K)    !RLXD CA CORRECTN
c
        if(irlx.lt.0)then
          n=icfgp(k)
          e1body=e1body+decorn(n)
        endif
C
C 2-BODY (NON-REL ONLY)
C
        I8=K
        NP8=ICOL8(I8,I8,IZERO)
        N1=NAD(NP8-1)+1
        N2=NAD(NP8)
C
        E2BODY=DZERO
        DO  L=N1,N2
          M1=INT(NRK(L))
          E2BODY=E2BODY+DRL(M1)*DRK(L)
        ENDDO
C
        DD=E1BODY+E2BODY
C
        IF(ISHFTLS.EQ.1)DD=DD+DELELS(K,1)         !SHIFT
C
        KK=K
        IF(IYY(M2).GT.0)THEN                      !CONT
          KK=-K
          DD=DD+ECOR1
          IF(MODE.LT.3)DD=DD-DYY(NREL)            !REMOVE ENERGY OF CONT
          DD=MOD(DD,TSHFT)
          IF(DD.LT.EIONMN)EIONMN=DD
          IWRK3(K)=M2
        ELSE
          IWRK3(K)=-M2
        ENDIF
        IF(DD.LT.DMIN)THEN
          DMIN=DD
        ENDIF
C
        DENERG(K)=DD
C
        IF(BPRNT0)WRITE(6,180)K,MSTAT(K),QCP(K)/2,DENERG(K),KK
C
      ENDDO
C
      IF(BPRNT0)THEN
        WRITE(6,900)DC1,DECORE
        IF(BCONT)THEN
          WRITE(6,504)
          IF(ISHFTLS.NE.0)WRITE(6,509)
        ENDIF
      ENDIF
C
      EIONMN=EIONMN+DECORE
      EIONMN=EIONMN+EIONMN
C
C********************************************
C
C     ***COMPUTE AUTOIONIZATION RATES***
C
C********************************************
C
      IF(.NOT.BCONT)GO TO 728
c
               if(btime)call cpu_time(timei)
C
      DO KF=1,KMAX
C
        IF(IWRK3(KF).GT.0)GO TO 603
C
        DO KG=1,KMAX
C
          IF(IWRK3(KG).LT.0)GO TO 605
C
          I8=MIN(KF,KG)
          J8=MAX(KF,KG)
          NP8=ICOL8(I8,J8,IZERO)                  !ENERGY IS ON DIAGONAL
          N1=NAD(NP8-1)+1
          N2=NAD(NP8)
          IF(N1.GT.N2)GO TO 605
C
          IF(ABS(DENERG(KG)+DYY(NREL)-DENERG(KF)).GT.ACE)GO TO 605
          DRY=DENERG(KG)
C   DRY STILL EQUAL TO ENERGY OF TARGET BUT DENERG ALSO EQUAL TO IT NOW
          DS=DENERG(KF)-DRY
C
          IF(.NOT.BLAG)GO TO 419              !ELSE SET-UP INTERPOLATION
C
          IF(DS.LT.DZERO         )GO TO 605
C                       .AND.BLAG
          IF(IGAPE.GT.0)THEN
            IF(DS.LT.DYY(IGAPE).AND.DS.GT.DYY(IGAPE-1))THEN
              WRITE(6,*)'***EXTRAPOLATING AUGERS2'
              WRITE(6,*)IGAPE,2*DYY(IGAPE-1),2*DS,2*DYY(IGAPE)
              IF(DS.LT.D0PT8*DYY(IGAPE).AND.DS.GT.D1PT2*DYY(IGAPE-1))
     X                                                           THEN
                WRITE(0,*)'***EXTRAPOLATING AUGERS2'
C                GO TO 2000
              ENDIF
            ENDIF
          ENDIF
C
          M2=-IWRK3(KF)
          TM=DS+DSHIFT(M2)
          IF(.NOT.BBC1)THEN
            DO L=1,MENG
              IF(DYY(L).GE.TM)THEN
                LP=L
                GO TO 412
              ENDIF
            ENDDO
            LP=MENG
C
 412        IF(.NOT.BBC2)THEN
              NP2=LP+NPH-1
              NP1=LP-NPH
              IF(NP1.LE.0)THEN
                NP2=NP2-NP1+1
                NP1=1
              ELSEIF(NP2.GT.MENG)THEN
                NP1=NP1-NP2+MENG
                NP2=MENG
              ENDIF
            ELSE
              NP2=LP
              NP1=LP-1
              DO M=1,NLAG2
                IF(NP2.EQ.MENG)THEN
                  NP1=NP2-NLAG+1
                  GO TO 414
                ELSEIF(NP1.LE.1)THEN
                  NP2=NLAG
                  NP1=1
                  GO TO 414
                ELSE
                  DD=DYY(NP2+1)-TM
                  DAS=TM-DYY(NP1-1)
                  IF(DD.LE.DAS)NP2=NP2+1
                  IF(DD.GT.DAS)NP1=NP1-1
                ENDIF
              ENDDO
            ENDIF
          ENDIF
C                                         SET INTERPOLATION COEFFICIENTS
 414      DO L=NP1,NP2
            DD=DONE
            DO M=NP1,NP2
              IF(L.NE.M)THEN
                DD=DD*(TM-DYY(M))
                DD=DD/(DYY(L)-DYY(M))
              ENDIF
            ENDDO
            DDY(L)=DD
          ENDDO
C
C FORM AUTOIONIZATION RATE
C
 419      DAS=DZERO
C
          DO L=N1,N2
            n8=NRK(L)
            IF(n8.GT.0)THEN                  !DIRECT & EXCHANGE
              M0=INT(n8)
              K0=NRLI(M0)
              IF(K0.GT.0)THEN
                DO M=NP1,NP2
                  DAS=DAS+DDY(M)*DRLI(M,K0)*DRLI(M,K0)*DRK(L)
                ENDDO
              ENDIF
            ELSE                             !INTERFERENCE
              M1=-INT(n8/IPLANT_RL)                               !MAXRL
              M2=-INT(M1*IPLANT_RL+n8)                            !MAXRL
              K1=NRLI(M1)                    !DIRECT
              K2=NRLI(M2)                    !EXCHANGE
              IF(K1*K2.GT.0)THEN
                DO M=NP1,NP2
                  DAS=DAS+DDY(M)*DRLI(M,K1)*DRLI(M,K2)*DRK(L)
                ENDDO
              ENDIF
            ENDIF
          ENDDO
C
          DAS=abs(DAS)*DKON   !CA IS ALREADY SQUARED, but for extrapn...
          IF(DAS.GT.D1M2)THEN
            MWJ=MSTAT(KF)
            MWI=MSTAT(KG)
            IF(BPRNT0)WRITE(6,502)MWJ,KF,KG,DAS,DS,DRY
            DS=DS+DS
            DRY=DRY+DECORE
            DRY=DRY+DRY
C
            IF(BPRNT0)THEN
              if(mwj.gt.99999)mwj=0             !as I5 - use unformatted
              WRITE(MW,506)KF,KF,MWJ,-KG,KG,DAS,DS,DRY
C              WE KNOW MWI, BUT FOR ADASDR COMPATIBILITY WITH LS/IC OMIT
            ELSE
              WRITE(MWU)int(KF),int(KF),int(MWJ),int(-KG),int(KG)
     X                 ,DAS,DS,DRY
            ENDIF
          ENDIF
C
  605   ENDDO                    !END LOOP OVER FINAL CFS
C
  603 ENDDO                      !END LOOP OVER INIITAL CFS
c
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for carate:'                 !par
cpar          write(iwp,*)'    auger time=',nint(times),'sec'       !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'auger time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
  728 CONTINUE
C
C ******* END GENERATION OF ENERGIES AND AUGERS
C
      NENERG=KMAX
c
      lupe=nenerg
      if(idw.eq.0)lupe=min(lupe,lupmx)
C
C SORT ENERGIES (assumes all are negative...)
C
      CALL HPSRTI(NENERG,DENERG,IORIG)
C
C PRELIMINARY WRITES
C
      IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,514)MENG,NZION,MION,EIONMN
          WRITE(MWW,515)(DTWO*DYY(M8),M8=1,MENG)
          WRITE(MWW,516)NZION,MION
        ELSE
          WRITE(MWWU)int(MENG),int(NZION),int(MION),EIONMN
          WRITE(MWWU)(DTWO*DYY(M8),M8=1,MENG)
          WRITE(MWWU)int(NZION),int(MION)
          WRITE(MWWU)MBLK
        ENDIF
      ENDIF
      IF(MODE.GT.0)THEN
        IF(BPRNT0)THEN
          WRITE(MW,503)EIONMN
        ELSE
          WRITE(MWU)int(IZERO),int(IZERO),int(IZERO),int(IZERO)
     X             ,int(IZERO),DZERO,DZERO,EIONMN
        ENDIF
      ENDIF
C
      IF(.NOT.BRAD.AND.BJUMP)GO TO 750
C
      DG0=DECORE+DMIN             !GROUND ENERGY (A.U.)
      IF(MODE.GT.0)THEN
        IF(BPRNT0)THEN
          WRITE(MW,510)NENERG,2*DG0
        ELSE
          WRITE(MWU)int(NENERG),2*DG0
          WRITE(MWU)MBLK
        ENDIF
      ENDIF
C
      IF(INCLUD.GT.NENERG)INCLUD=NENERG
C
      BAUX=JPRINT.GE.4.OR.BPRINT
      IF(BAUX.AND.BPRNT0)THEN
        WRITE(6,997)INCLUD,(DADJUS(I),I=1,NPARAM)
        IF(IPOLFN.LT.0)THEN
          NP0=-IPOLFN
          DO N=1,NP0
            N0=N*NPARAM
            WRITE(6,1002)N,(DADJUS(N0+I)-DONE,I=1,NPARAM)  !DADJUS(N0+I)
          ENDDO
        ENDIF
        WRITE(6,996)2*DG0
        IF(MODE.EQ.1.AND.IUNIT(14).GT.0)WRITE(14,981)
      ENDIF
C
      BPUNCH=IUNIT(3).LT.0           !WRITE ENERGY-ORDERED CONFIG.DAT_EO
      IF(BPUNCH)THEN
C
        IPUNCH=3
        OPEN(IPUNCH,FILE='CONFIG.DAT_EO',STATUS='REPLACE')
        IUNIT(IPUNCH)=1
C
        IF(ECORR.NE.DZERO)THEN
          ETEST=ECORR/DTWO                                    !ECORR RYD
          IF(ECORR.LT.DZERO)THEN
            ETEST=ETEST-DECORE                           !ECORR ABSOLUTE
          ELSE
            ETEST=ETEST+DMIN                   !ECORR RELATIVE TO GROUND
          ENDIF
          DO J=1,NENERG
            I=IORIG(J)
            IF(DENERG(I).GT.ETEST)GO TO 130
          ENDDO
          J=NENERG+1
  130     KKX=J-1
        ELSE
          KKX=NENERG
        ENDIF
C
        I0=MB+1                                                     !MB0
        WRITE(IPUNCH,3060)MB,MXORB
        WRITE(IPUNCH,3070)(QN(L),QL(L)/2,L=I0,MXORB)
C
        ALLOCATE (MNAL(MXORB),MXAL(MXORB))
C
        I=IORIG(1)
        DO L=I0,MXORB
          MNAL(L)=NEL(L,I)
          MXAL(L)=NEL(L,I)
        ENDDO
C
        DO J=2,KKX
          I=IORIG(J)
          DO L=I0,MXORB
            MNAL(L)=MIN(MNAL(L),NEL(L,I))
            MXAL(L)=MAX(MXAL(L),NEL(L,I))
          ENDDO
        ENDDO
C
        FORM=FORM2
        DO L=I0,MXORB
          IF(MXAL(L).GT.9)FORM=FORM3
        ENDDO
C
        WRITE(IPUNCH,3060)KKX
        WRITE(IPUNCH,FORM)(MNAL(L),L=I0,MXORB)
        WRITE(IPUNCH,FORM)(MXAL(L),L=I0,MXORB)
C
        DEALLOCATE (MNAL,MXAL)
C
      ENDIF
C
      IF(IUNIT(21).GT.0)WRITE(21,537)            !NENERG need NSPECE now
C
      IF(MENGB.GE.-1)THEN
        ELEM=CELMNT(NZION)
        NZAM=NZA-1
        FIP=ADASIP(ELEM,NZAM)
        if(badas)then
          lab4='    '
        else
          lab4='(0Y)'
        endif
        WRITE(25,541)ELEM,NZAM,NZION,NZA,FIP,lab4
        ISMX=0
        DO K=1,KMAX                             !CHECK MAX STRING LENGTH
          IS=4*LMX(K)
          IF(IS.GT.MXSTRG)THEN
            WRITE(6,536)MXSTRG
            WRITE(6,*)'***SR.CARATE: INCREASE INTERNAL DIMENSION MXSTRG'
            GO TO 2000
          ENDIF
          ISMX=MAX(ISMX,IS)
        ENDDO
      ENDIF
C
C********************************************
C
C WRITE ENERGY-ORDERED CF LIST
C
C********************************************
C
      DF=DZERO
      DS=DZERO
      IF(IOPTIM.NE.0)DS=DONE
      LL=-INCLUD
      IPP=0
      ISP=0
      LSP=0
      IE0=0
      NSPECE=0
      EMIN=EIONPOT
      IF(EMIN.GT.DZERO)THEN
        IAUTO=0
      ELSE
        IAUTO=-1
      ENDIF
      DECMIN=-D1P20
C
C LIST DEGENERATE CONFIGS BY ASCENDING CF INDEX
C
      IF(BCONT.AND.BPRNT0)THEN
        J0=1
  131   MSUM=1
        DO J=J0,NENERG
          I=IORIG(J)
          IF(DENERG(I).LT.(DECMIN+TOLB2))THEN                      !A.U.
            MSUM=MSUM+1
          ELSE
            IF(MSUM.GT.1)GO TO 132
          ENDIF
          DECMIN=DENERG(I)
        ENDDO
        J=NENERG+1
C
  132   DECMIN=DENERG(I)
        DO M=MSUM,1,-1
          I=IORIG(J-M)
          DWRK(M)=I
        ENDDO
C
        CALL HPSRTI(MSUM,DWRK,IWRK2)
C
        DO M=1,MSUM
          I=IWRK2(M)
          I=NINT(DWRK(I))
          IORIG(J-M)=I
        ENDDO
        IF(J.LT.NENERG)THEN
          J0=J+1
          GO TO 131
        ENDIF
        DECMIN=-D1P20                                  !RE-SET FOR LATER
      ENDIF
C
C BEGIN CONFIG ENERGY LOOP
C
      DO J=1,NENERG
C
        I=IORIG(J)                              !J=EO -> I=SO
        IEORD(I)=J                              !I=SO -> J=EO
C
        DAU=DENERG(I)
        DENERG(I)=DENERG(I)-DMIN
        DRY=DENERG(I)*DTWO
C
        IF(DRY*ECORR.GT.ECORR*ECORR)THEN
          IORIG(J)=-I
          MBCOR=MCOR
        ELSE
          IORIG(J)=I
          MBCOR=MBLK
          if(j.le.lupe)NSPECE=NSPECE+1
        ENDIF
C
        DD=DZERO
        IF(LL.EQ.0)GO TO 30
        IF(LL.GT.0)THEN
          DO K=1,LL
            IF(INDEXW(K).EQ.I)THEN
              DD=WGHT(K)
              GO TO 65
            ENDIF
          ENDDO
          IF(IOPTIM.EQ.0)GO TO 30
        ENDIF
        IF(J.GT.INCLUD.AND.IOPTIM.EQ.0)GO TO 30
C
        IF(IORIG(J).LT.0)GO TO 30       !OMIT CORR. FROM DF FOR INCLUD>0
C
C STATISTICAL WEIGHTED AVERAGE
C
c        IF(IWGHT.NE.1)DD=(QLI(JJ)+1)*ISS
C
C EQUAL WEIGHTED AVERAGE
C
        IF(IWGHT.EQ.1)DD=DONE
C
C ADD TO ENERGY FUNCTIONAL
C
   65   IF(IOPTIM.EQ.0)THEN                        !STANDARD
          DF=DAU*DD+DF
          DS=DS+DD
        ENDIF
C
   30   DEM=DRY*DKCM
        DWRK(I)=DEM
C
        MYRGE=MBLK
        IF(IWRK3(I).GT.0)THEN                      !CONT
          IF(DRY.GT.(DECMIN+TOLB))IE0=IE0+1
          IWRK2(I)=IE0
          MI=-I
CW          M2=QCG(NF,I)
CW          M1=QL(M2)+1
        ELSE
          MI=I
        ENDIF
        IF(MYRGE.EQ.MBLK)ISP=MSTAT(I)
        IPP=QCP(I)/2
        LSP=0
        IF(MBCOR.EQ.MBLK)DECMIN=DRY
C
        IF(IAUTO.GT.0.AND.DENERG(I)-EMIN.LE.TOLE)IAUTO=J+1
        IF(IWRK3(I).GT.0.AND.IAUTO.LT.0)THEN
          IAUTO=J
          EMIN=DENERG(I)
        ENDIF
C
        IF(.NOT.BAUX)GO TO 80
C
        II=MSTAT(I)      !*(1-QCP(I))
CW        IF(MI.LT.0)II=II*(M1+M1)                !AS CA OMITS CONTINUUM
        W=ABS(II)-1
        W=W/2
C
        IF(MODE.GT.0)THEN
          IF(BPRNT0)THEN
            if(mi.gt.0)then
              WRITE(MW,511)J,IORIG(J),II,MI,DRY
            else
              WRITE(MW,511)J,IORIG(J),II,MI,DRY,ie0
            endif
          ELSE
            WRITE(MWU)int(IORIG(J)),int(IZERO),int(II),int(IZERO)
     X               ,int(IZERO),int(MI),DRY,int(ie0)
          ENDIF
        ENDIF
C
        IF(BPRNT0)THEN
          if(mi.gt.0)then
            WRITE(6,995)J,I,DEM,II,MI,MBCOR,DD,DRY
          else
            WRITE(6,995)J,I,DEM,II,MI,MBCOR,DD,DRY,ie0
          endif
          IF(MODE.EQ.1.AND.IORIG(J).GT.0.AND.IUNIT(14).GT.0)
     X    WRITE(14,992)ISP,IPP,I,DRY,MYRGE
        ENDIF
C
        IF(BPUNCH.AND.J.LE.KKX)WRITE(IPUNCH,FORM)(NEL(L,I),L=I0,MXORB)
     X                                           ,IZERO
C
        IF(MENGB.GE.-1.AND.IORIG(J).GT.0.and.j.le.lupe)THEN
          ISS=0
          IS=0
          K=I
          DO L=1,LMX(K)
            IS=IS+1
            JJK=ABS(QN(QLB(L,K)))
            IF(JJK.GT.9)THEN
              STRING(IS)=NUMB(JJK/10)
            ELSE
              STRING(IS)=' '
            ENDIF
            IS=IS+1
            STRING(IS)=NUMB(MOD(JJK,ITEN))
            IS=IS+1
            JJK=MIN(INT(QL(QLB(L,K))/2,SP),MXLAB1)
            STRING(IS)=BIGL(JJK)
            IS=IS+1
            N=MOD(INT(QSB(L,K),SP),I50)
            STRING(IS)=NUMB(N)
          ENDDO
          DO L=IS+1,MXSTRG
            STRING(L)=' '
          ENDDO
          if(badas)then                                      !adf04 only
            if(iunit(25).gt.0)then
              cstan=' '
              ceiss=' '
              if(ismx.le.mstrgh)then
                f542="(i5,1x,1a15,3x,'(',i1,')',i1,'(',f10.1,')',f15.1)"
                write(cstan(1:15),'(15a1)')(string(l),l=2,mstrgh)
                call xxcftr(itwo,cstan,ceiss)
                write(25,f542)nspece,ceiss(1:15),iss,lsp,w,dem
              else
                f543="(i5,1x,1a31,3x,'(',i1,')',i1,'(',f10.1,')',f15.1)"
                write(cstan(1:31),'(31a1)')(string(l),l=2,mxstrg)
                call xxcftr(itwo,cstan,ceiss)
                write(25,f543)nspece,ceiss(1:31),iss,lsp,w,dem
              endif
            endif
          else                                   !adf04 or adsex.in.form
            IF(ISMX.LE.MSTRGH)THEN
              F542="(I5,1X,15(A1),3X,'(',A1,')',A1,'(',F10.1,')',F15.1)"
              IF(IUNIT(21).GT.0)WRITE(21,F542)NSPECE
     X                 ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),W,DEM
              IF(IUNIT(25).GT.0)WRITE(25,F542)NSPECE
     X                 ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),W,DEM
            ELSE
              F543="(I5,1X,31(A1),3X,'(',A1,')',A1,'(',F10.1,')',F15.1)"
              IF(IUNIT(21).GT.0)WRITE(21,F543)NSPECE
     X                 ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),W,DEM
              IF(IUNIT(25).GT.0)WRITE(25,F543)NSPECE
     X                 ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),W,DEM
            ENDIF
          endif
        ENDIF
C
   80 ENDDO
C
C  *** END ENERGY WRITE LOOP
C
      IF(BCONT)DEALLOCATE (DDY)
      DEALLOCATE (LMX,QSB,QLB)
      deallocate (decorn)
C
      IF(MODE.EQ.1.AND.BPRNT0.AND.IUNIT(14).GT.0)
     X                  WRITE(14,992)0,0,0,2*DG0
      IF(IUNIT(21).GT.0)WRITE(21,540)
      IF(IDW.NE.0)THEN
C Currently, CA does not make use of any RESTART file, so comment-out
C        WRITE(MR)NMETA
C        WRITE(MR)(NMETAG(I),I=1,NSL0)                   !NSL0.LT.0 (CA)
C        NNN=NENERG
C        IF(BECOR)NNN=-NNN                             !FLAG ENERGY CORR
C        WRITE(MR)NNN,KCUT
C        WRITE(MR)(IORIG(I),I=1,NENERG)
C        WRITE(MR)(DENERG(abs(IORIG(I)))*DTWO,I=1,NENERG)
C        NCTOT=0
C        WRITE(MR)NCTOT
C        TFU=DZERO
C        WRITE(MR)(TFU,I=1,NCTOT)
C... and transfer directly, since this is bypassed (sr.algx0) then.
         NSPECE=0
         DO J=1,NENERG
          I=IORIG(J)
          if(i.lt.0)then
            jndex(-i)=-j
          else
            NSPECE=NSPECE+1
            JNDEX(I)=NSPECE                             !=J IN ORIG E.O.
            INDEX(NSPECE)=I
            DSPECE(NSPECE)=DENERG(I)*DTWO
          endif
        ENDDO
      ENDIF
      IF(IAUTO.LT.0)IAUTO=NENERG+1
C
C ALTERNATE FORM OF ENERGY FUNCTIONAL
C
      IF(DS.EQ.DZERO)THEN
        DS=DONE
        DECORE=DZERO
        DO I=1,LL
          II=-INDEXW(I)
          IF(II.EQ.0)II=IORIG(I)
          DO J=1,I
            JJ=-INDEXW(J)
            IF(JJ.EQ.0)JJ=IORIG(J)
            DF=(DWRK(II)-DWRK(JJ)-WGHT(I)+WGHT(J) )**2+DF
          ENDDO
          IF(BAUX)WRITE(6,70)I,DWRK(II),WGHT(I),DF
        ENDDO
      ENDIF
C
C FINALIZE ENERGY FUNCTIONAL DF
C
      DF=DF/DS
C
c 7600 CONTINUE
C
c      IF(NF.LE.0)GO TO 750                                      !RETURN
C
C
C********************************************
C
C   ***COMPUTE MULTIPOLE RADIATIVE DATA***
C
C********************************************
C
C
      NGF=0
      SGF=DZERO
      IF(.NOT.BRADAT.OR.NPRNT5.EQ.-2)GO TO 745
C
      NPOSX=(IOS-IRK)
      if(nposx.le.0)go to 745
C
      BOMRC=.FALSE.
C
      MXORB2=MXORB*MXORB      !MXORB -> MXORBR UNNECESS. FOR CA   !FLAGX
c
      i1=1
cc      i1=mb+1                                                   !FLAGX
      i2=i1
C
      BDEL=MDEL.GT.0
      IF(IDIAG.LT.0.AND.BDEL)WLG0=DTEN**MDEL
      DEM=2*DG0                               !GROUND ENERGY (RYD)
C
      IF(BPRNT0.AND.MODE.GT.0)WRITE(MW,508)NZION,MION
      IF(.NOT.BPRNT0.AND.MODE.GT.0)WRITE(MWU)int(NZION),int(MION)
C
      IF(MENGB.GE.-1)THEN                     !INITIALIZE OMEGA BORN
C
        WRITE(6,989)
        TOLO=D1M10
c
        if(nmeta.gt.0)then
          nmin=min(NMETA,NSPECE)
          ixr=irow(nmin,nspece,ione1,nspece)
          ixc=0
          if(idw.eq.0.and.ABS(MENGB).EQ.1)ixc=icol(nmin,nspece,ione1)
          nomwrt=max(ixr,ixc)
        else
          NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
        endif
C
        ITEST4=IBUFF4
        ITEST4=ITEST4+1
        IF(NOMWRT/2.GT.IBUFF4.AND.ITEST4.LT.IBUFF4)THEN !nomwrt is i4...
          WRITE(0,*)'*** SR.CARATE: TOO MANY CONFIGS FOR I*4'
          WRITE(6,*)'*** SR.CARATE: TOO MANY CONFIGS FOR I*4',
     X              ', SET DEFAULT INTEGER SP=8 IN MODULE PRECSN'
          GO TO 7450
        ENDIF
C
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY ONLY
C
          BSCRO=.TRUE.       !(REMOVE "ELSE" TO USE INTERNAL - WASTEFUL)
C
          ALLOCATE (OMR(NOMWRT),OMC(NOMWRT),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'CARATE: ALLOCATION FAILS FOR OMR,OMC'
            NF=0
            GO TO 7450
          ENDIF
          BOMRC=.TRUE.
          NOMWRX=NOMWRT
C
          IF(NOMWRT.GT.NOMWRX)THEN
            NNN=2*NOMWRT/MXENG+1
            WRITE(6,991)NNN
            WRITE(0,*)'*** WORKING ARRAYS TOO SMALL IN SR.CARATE'
            GO TO 3000
          ENDIF
          DO I=1,NOMWRX
            OMR(I)=DZERO
            OMC(I)=DZERO
          ENDDO
C
        ELSE                                  !FINITE ENERGY
C
          BSCRO=.TRUE.      !.T. USE SCRATCH FILE, .F. STORE INTERNALLY
C
          IF(.NOT.BSCRO)THEN
            ALLOCATE (OMEGA(0:MXNXB1,NOMWRT),STAT=IERR)
            IF(IERR.NE.0)THEN
              BSCRO=.TRUE.
            ELSE
              BSCRO=.FALSE.
            ENDIF
          ENDIF
          NOMWRY=NOMWRT
C
C
          IF(BSCRO)THEN
C            WRITE(0,*)'CARATE: USING SCRATCH FOR BORN MULTIPOLE SUM'
C            WRITE(6,*)'CARATE: USING SCRATCH FOR BORN MULTIPOLE SUM'
          ELSE
            DO N=1,NOMWRT
              DO NX=0,MXNXB1
                OMEGA(NX,N)=0
              ENDDO
            ENDDO
          ENDIF
C
          DO NX=1,MXNXB
            XS(NX)=SQRT(DONE-DONE/XB(NX))
          ENDDO
C
        ENDIF
C
        MSC0=80
        MSC=MSC0-1
C
      ENDIF
C
      IF(MENGB.EQ.1)THEN
        WLGO=D1M7/DZA2
      ELSE
        WLGO=D1M5/DZA2
      ENDIF
C                 INITIALIZE GEOMETRIC COEFFICIENTS
      ALLOCATE (DG(0:IXBLM))
C
      DG(0)=DZERO
      IF(MPOLE.LE.8)THEN
        IP=1
        DO I=2,MPOLE,2
          IP=IP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*REAL(IP,WP)*REAL(IP,WP))
        ENDDO
      ELSE
        TIP=1
        DO I=2,MPOLE,2
          TIP=TIP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*TIP*TIP)
c          write(0,*)im,tip,2*(i+1)*(im+1),im*tip*tip,dg(im)
        ENDDO
      ENDIF
c
               if(btime)call cpu_time(timei)
C
      MLAM=MPOL00-2
  740 MLAM=MLAM+2
      NGROUP=MLAM/2
C
      IF(NGROUP.EQ.1)THEN
        MP=0
        IF(BPRNT0)THEN
          WRITE(6,*)' '
          IF(.NOT.BELONG)WRITE(6,601)
          WRITE(6,600)NGROUP
        ENDIF
        IF(WLG1.LT.DZERO)THEN
          WLG=D1M2
          IF(IDIAG.LT.0.AND.BDEL)WLG=WLG0
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG1)
        WLGS=DKON
        IF(NPRNT5.GE.0)WLGS=D1M20
c        MPR=5
      ELSE
        MP=5
        IF(BPRNT0)THEN
          WRITE(6,*)' '
          IF(.NOT.BELONG)WRITE(6,810)
          IF(NGROUP.LT.10)THEN
            WRITE(6,800)NGROUP,MP
          ELSE
            WRITE(6,801)NGROUP,MP
          ENDIF
        ENDIF
        IF(WLG2.LT.DZERO)THEN
          WLG=D1M7
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG2)
        WLGS=DKON
c        MPR=5
      ENDIF
C
      BBORN=MENGB.GT.1.OR.(MENGB.EQ.1.AND.NGROUP.NE.1)
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG
C      BFOTJ=BFOTJ.OR.NGROUP.NE.1            !UNCOMMENT TO WRITE E1 ONLY
C
      IF(BSCRO)THEN                                         !MENGB.GE.-1
        MSC=MSC0+NGROUP
        OPEN(MSC,STATUS='SCRATCH',FORM='UNFORMATTED')
      ENDIF
C
      JOS=0
      KTRAN=0
C
      JJMN=1+ione1
      JJMX=NENERG
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.2.OR.JRAD.EQ.3.OR.JRAD.EQ.5)JJMN=MAX(JJMN,IAUTO)
        IF(JRAD.EQ.1)JJMX=MIN(IAUTO-1,NENERG)
      ENDIF
      JJMX=MIN(JJMX,LUPMX)
      JJMN=MAX(JJMN,LUPMN-1+ione1)
C
      ILF=ione1
C
C***********************************
C START LOOP OVER UPPER ENERGY CFGS
C***********************************
C
      DO 732 JJ=JJMN,JJMX
C
      ILF=ILF+1
      J=IORIG(JJ)
      if(j.lt.0)go to 732
      IF(.NOT.BFOT.AND.IWRK3(J).GT.0)GO TO 732           !CONT BUT NO PI
C
      IIMN=1
      IIMX=JJ-ione1
      if(nmeta.gt.0)iimx=min(iimx,nmeta)
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.3)IIMN=MAX(IONE,IAUTO)
        IF(JRAD.EQ.1.OR.JRAD.EQ.2.OR.JRAD.EQ.4)IIMX=MIN(IAUTO-1,IIMX)
      ENDIF
      IIMN=MAX(IIMN,LLOWMN-1+ione1)
      IIMX=MIN(IIMX,LLOWMX)
C
C***********************************
C START LOOP OVER LOWER ENERGY CFGS
C***********************************
C
      ILI=0
C
      DO 733 II=IIMN,IIMX
C
      ILI=ILI+1
      KTRAN=KTRAN+1
      I=IORIG(II)
      if(i.lt.0)go to 733
      IF(IWRK3(I).GT.0)GO TO 733               !LOWER CANNOT BE CONT
C
      IF(ABS(MENGB).EQ.1.AND.MOD(NGROUP,ITWO).EQ.1)THEN
        IX=IROW(ILI,ILF,ione1,NSPECE)
        IF(OMR(IX).LT.-TOLO)GO TO 733          !DIPOLE ALREADY COMPUTED
      ENDIF
C
      BINT=I.LE.J                              !DOWN TRUE
      IF(BINT)THEN
        M1=I
        M2=J
      ELSE
        M1=J
        M2=I
      ENDIF
      I8=M1
      J8=M2
      NP8=ICOL8(I8,J8,IONE)
      NP8=NP8+IADJ8
      K2=NAD(NP8)
      K1=NAD(NP8-1)+1
C
C FIND REQUIRED MULTIPOLE (COULD PRE-DECODE WITH NPOS AS PER DIAGON...)
C
      DO K=K1,K2
        MX=INT(NRK(K)/MXORB2)
        MK=MX
CC        MK=MK+MPOL0/2                                           !FLAGX
        IF(MK.EQ.NGROUP)GO TO 736                 !EXISTS
      ENDDO
      GO TO 733
C
 736  n4=MX*MXORB2
      n4=INT(NRK(K)-n4)
cc      if(irlx.lt.0)then
cc        i1=icfgp(m2)*mb+1
cc        i2=icfgp(m1)*mb+1
cc      endif
      M0=int(n4/MXORB)
      NG=M0+I1                            !ORB OF HIGHER ALGEB CF
      NT=n4-M0*MXORB+I2                   !ORB OF LOWER ALGEB CF
      M2=MIN(NG,NT)
      M1=NG+NT-M2
C
      dry=denerg(j)-denerg(i)
      if(iwrk3(j).gt.0)dry=dry+dyy(nrel)
      if(dry.gt.dzero)then
        dry=dry+dry
        db=dg(ngroup)*(dry*dfsc)**(mlam-1)/dfsc
      else
        db=dzero
      endif
      if(db.eq.dzero)then                        !avoids overflow*zero
        if(bborn.or..not.bfotj.and.iwrk3(j).gt.0)then!born/pi maybe o.k.
          dlen=dzero
          dvel=dzero
          dacc=dzero
          dry=drk(k)
          obox=dzero
          go to 334
        else
          go to 733
        endif
      endif
C
      DRY=DRK(K)                          !ALREADY SQUARED
      DB=DOSC(NGROUP,M1,M2)
      DLEN=DB*DB*DRY                      !LENGTH
C
      OBOX=DZERO
      IF(MENGB.EQ.-1.AND.ABS(DLEN).GT.WLGO)OBOX=D1P30
      IF(NGROUP.EQ.0)DLEN=DZERO
      IF(NGROUP.GT.0.AND.DLEN.EQ.DZERO)GO TO 733    !not poss for ca?
C
      DB=DZERO
      IF(M2.NE.M1)THEN
        DB=DOSC(NGROUP,M2,M1)
      ELSE                         !NOT POSS FOR CA?
        IF(NGROUP.GT.0)DB=DOSC(NGROUP-1,M2,M1)
      ENDIF
      DVEL=DB*DB*DRY                      !VELOCITY
      DB=ACC(M1,M2)
      DACC=DB*DB*DRY                      !ACCELERATION
C
  334 IF(.NOT.BFOTJ.AND.IWRK3(J).GT.0)THEN  !PHOTO
        M7=NFOSS(ngroup/2,M1,M2)
        IF(M7.GT.0)THEN
          DO M8=1,MENG
            DB=DFOSS(M7,M8,1)
            DFOT(M8)=DB*DB*DRY
          ENDDO
        ENDIF
      ENDIF
C
      IF(BINT)THEN
        NU=NG
        NL=NT
      ELSE
        NU=NT
        NL=NG
      ENDIF
C                           CANCELLING OF BINOMS IS INELEGANT, BUT CLEAR
      NUX=NEL(NU,J)
      NLX=NEL(NL,I)
      LWJ=2*QL(NU)+2
      LWI=2*QL(NL)+2
      NWJ=QBINOM(LWJ,NUX)
      NWI=QBINOM(LWI,NLX)
      MWJ=QBINOM(LWI,NLX-1)*NWJ
      MWI=QBINOM(LWJ,NUX-1)*NWI
c
c      if(mwj.ne.mstat(j))write(0,*)'j',j,mwj,mstat(j)
c      if(mwi.ne.mstat(i))write(0,*)'i',i,mwi,mstat(i)
C
C      NWT=NUX*NLX*NWJ*NWI                        !ABSORBED INTO ALGEBRA
      NWT=1
C
C BORN MULTIPOLES
C
      IF(BBORN)THEN     !BORN
        DO IE=1,MENGB
          OBO(IE)=DZERO
        ENDDO
        OMG1=DZERO
        DLAM=2*NGROUP+1
        NH=NGROUP/2
        IN=ICOL(M2,M1,IZERO)
        IF(BINDB(IN,NH))THEN
          IX=INDX(IN)
        ELSE
          WRITE(6,*)JJ,II,J,I,NGROUP,M2,M1
          WRITE(0,*)'CARATE: BORN M1 M2 NOT FOUND'
          GO TO 3000
        ENDIF
C                   !NOT GREAT, BUT UTILIZES GENERAL (MIXED) CASE SET-UP
        DO N=1,MB4(0)
          L=INDL(N)
          K=INDK(N)
          if(l.ne.k)stop 'carate inl, indk error'
          IF(L.EQ.IX)THEN
            DO IE=1,MENGB
              DB=DRY*BL(IE,N,NH)
              OBO(IE)=OBO(IE)+DB
            ENDDO
            IF(NGROUP.EQ.1)THEN
              DB=DRY*TM2(N)
              OMG1=OMG1+DB
            ENDIF
            GO TO 734                             !AS WE ARE DONE FOR CA
          ENDIF
        ENDDO
  734   DB=DEIGHT*DLAM*NWT
        DO IE=1,MENGB
          OBO(IE)=DB*OBO(IE)
        ENDDO
        OBOX=OBO(MINFB)
        OMG1=DB*OMG1
      ENDIF
C
C ELECTRIC MULTIPOLE
C
      JOS=JOS+1
      DRY=DENERG(J)-DENERG(I)
      IF(DRY.EQ.DZERO)then
        if(mengb.lt.-1)GO TO 733                     !CASE E2 DEGENERATE
        dry=d1m10
      endif
c
      IF(IWRK3(J).GT.0)DRY=DRY+DYY(NREL)
      GFA=DACC/DRY**4                                 !as squared
c      gfa=dacc                                       !if orb ener. used
      DRY=DRY+DRY
      MI=II
      MJ=JJ
C     IF(IWRK3(I).GT.0)MI=-MI
      IF(IWRK3(J).GT.0)MJ=-MJ
      WLG=ABS(WLG)
      IF(IWRK3(J).GT.0)WLG=-WLG
C
      DB=DG(NGROUP)*(DRY*DFSC)**(MLAM-1)/DFSC
      SEK=DLEN*NWT                               !SEK_L
      GFL=DB*SEK                                 !GF_L
      IF(IWRK3(J).LT.0)AEK=C1*GFL*DRY*DRY/MWJ    !AEK
      IF(IWRK3(J).GT.0)AEK=C2*GFL/MWI            !PI
C
      IF(AEK*AEK.Lt.AEK*WLG.AND.OBOX.LT.WLGO
     X                     .AND.GFL*GFL.LT.WLGS)GO TO 733
C
      DB=DB*NWT*DTEN**MP
      DVEL=DVEL/(DRY*DRY)                        !skip if orb ener. used
      GFV=DB*DVEL                                !GF_V
      GFLV=DB*SQRT(DVEL)*SQRT(DLEN)              !SQRT(GF_L*GF_V)
      GFA=DB*GFA                                 !GF_A
      WLEN=D1P8/(DRY*DKCM)                       !WAVELENGTH(A)
      GFL=GFL*DTEN**MP                           !GF_L STILL
      IF(.NOT.BELONG.AND.AEK.GT.WLG)THEN         !USE VEL AEK,SEK
        AEK=GFV*AEK/GFL
        SEK=GFV*SEK/GFL
      ENDIF
      FAB=GFL/MWI                                !F(UP)_L
      FEM=GFL/MWJ                                !F(DOWN)_L
C
      IF(NGROUP.EQ.1)THEN
        APOL=DFOUR*FAB/(DRY*DRY)                 !POLARIZABILITY
        IF(.NOT.BELONG)APOL=APOL*GFV/GFL
        OMG=DFOUR*GFL/DRY                        !MP=0, NGROUP=1
        IF(ABS(MENGB).EQ.1)THEN
          OMGINF=-ABS(OMG)
          OMG=OMG*LOG(EINF*DZ2)
          OMG=-ABS(OMG)                          !TAG DIPOLE NEGATIVE
          IF(OMG.GE.-TOLO)OMG=DZERO          !ZERO VANISHINGLY SMALL CPT
        ELSEIF(MENGB.GT.1)THEN
          OMG=-ABS(OMG)                          !4S/3
          if(nmeta.eq.0)nmeta=iimx               !pwb
        ENDIF
        if(idw.eq.0)then
          if(nmeta.eq.0)nmeta=nenerg             !for RM
        else
          if(nmeta.eq.0)nmeta=iimx
        endif
      ELSE
        APOL=OBOX                                !COPY BORN IN
        OMG=OBOX
        OMGINF=OMG
      ENDIF
C
C DETERMINE BORN OMEGAS
C
      BPRNTO=.FALSE.
      IF(MPOL00.EQ.0)THEN                     !MPOL0 CATCHES E1
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY BORN ONLY
          BPRNTO=.TRUE.
          IXC=ICOL(ILI,ILF,ione1)
          IF(IXC.LE.NOMWRX)OMC(IXC)=OMC(IXC)+OMG
          IXR=IROW(ILI,ILF,ione1,NSPECE)
          IF(IXR.LE.NOMWRX)OMR(IXR)=OMR(IXR)+OMG
          OMEGAB(MXNXB1)=OMGINF
        ELSEIF(MENGB.GT.1.AND.abs(OBO(MINFB)).GT.WLGO)THEN  !FINITE BORN
          BPRNTO=.TRUE.
          CALL BRNINT(BPRNT0,NLAGB,MXNXB,MV0,MV1,DRY,V0,V1,XB,XS
     X               ,DB0,DB1,OMG1,OBO,OMEGAB)
          OMEGAB(MXNXB1)=OMG                       !INFINITE ENERGY
c          if(nlagb.lt.0)go to 3000                !brnint failure
        ENDIF
      ENDIF
C
C OUTPUT ELECTRIC MULTIPOLE DATA.
C
      IF(BPRNT0)WRITE(6,500)JOS,MBLK,MJ,MI,AEK,SEK,GFL,FAB,FEM,WLEN,GFV
     X                     ,GFLV,GFA,APOL
      IF(BPRNTO)THEN
        T=ABS(AEK)
        IF(BSCRO)THEN
          WRITE(MSC)MJ,MI,T,(OMEGAB(K),K=1,MXNXB1)
        ELSE
          OMEGA(0,KTRAN)=OMEGA(0,KTRAN)+REAL(T,RP)
          T=REAL(OMEGA(MXNXB1,KTRAN),WP)
          KMX=MXNXB1
          IF(MOD(NGROUP,ITWO).EQ.1.AND.T.LT.-TOLO)KMX=MXNXB  !OLD DIPOLE
          DO K=1,KMX
            OMEGA(K,KTRAN)=OMEGA(K,KTRAN)+REAL(OMEGAB(K),RP)
          ENDDO
        ENDIF
      ENDIF
C
      IF(MODE.LT.1)GO TO 615
      DB=DENERG(I)+DENERG(I)+DEM
      IF(IWRK3(I)*IWRK3(J).LT.0)GO TO 335
C
      IF(BPRNT0)THEN
        mi=MSTAT(I)
        if(mi.gt.99999)mi=0                     !as I5 - use unformatted
        mj=MSTAT(J)
        if(mj.gt.99999)mj=0                     !as I5 - use unformatted
        WRITE(MW,501)J,J,mj,I,I,mi,AEK,DRY,DB
      ELSE
       WRITE(MWU)int(J),int(J),int(MSTAT(J)),int(I),int(I),int(MSTAT(I))
     X           ,AEK,DRY,DB
      ENDIF
      GO TO 615
C
  335 IF(BFOTJ)GO TO 733
C
      DC0=C2*DG(NGROUP)*REAL(NWT,WP)/(REAL(MWI,WP)*DFSC)
      T=DENERG(J)-DENERG(I)
      DO M8=1,MENG
        DRY=T+DYY(M8)
        DRY=DRY+DRY
        T1=DRY*DFSC
        TT=T1**NGROUP
        DFOT(M8)=DC0*TT*DFOT(M8)*TT/T1
        IF(BPRNT0.AND.ABS(DFOT(M8)).LT.D1M99)DFOT(M8)=DZERO
      ENDDO
C
      DRY=DENERG(J)+DENERG(J)+DEM
C
C PI DAS IS ALWAYS LENGTH, EVEN WHEN VEL/ACC SET.
C
      IF(BPRNT0)THEN
        mi=MSTAT(I)
        if(mi.gt.99999)mi=0                     !as I5 - use unformatted
        WRITE(MWW,501)I,I,mi,-J,J,IWRK2(J),AEK,DB,DRY
        WRITE(MWW,515)(DFOT(M8),M8=1,MENG)
      ELSE
        WRITE(MWWU)int(I),int(I),int(MSTAT(I)),int(-J),int(J)
     X            ,int(IWRK2(J)),AEK,DB,DRY
        WRITE(MWWU)(DFOT(M8),M8=1,MENG)
      ENDIF
      GO TO 733
C
C IN ELECTRIC DIPOLE CASE ADD CONTRIBUTION TO FUNCTIONAL G
C
  615 IF(NGROUP.EQ.1.AND.INCLUD.NE.0)THEN
C
        IF(LL.GT.0)THEN      !EXCLUDE TRANSITIONS OF ZERO-WEIGHT TERMS
          NN=-1
          DO K=1,LL
            IF(INDEXW(K).EQ.I.OR.INDEXW(K).EQ.J)THEN
              NN=NN+1
              IF(NN.GT.0)GO TO 746
            ENDIF
          ENDDO
          GO TO 733
        ENDIF
C
  746   NGF=NGF+1
        GFL=ABS(GFL)
        GFV=ABS(GFV)
        GFLV=ABS(GFLV)
        SGF=(GFL+GFV-2*GFLV)/(GFL+GFV+2*GFLV)+SGF
C
      ENDIF
C
C
  733 CONTINUE                               !END LOOP OVER LOWER CFGS
C
C
  732 CONTINUE                               !END LOOP OVER UPPER CFGS
C
C
C     END MULTIPOLE LOOP OVER RADIATIVE TRANSITIONS
C
      IF(MLAM.LT.MPOLE)GO TO 740
C
      DEALLOCATE (DG)
c
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for carate:'                 !par
cpar          write(iwp,*)'    radiative time=',nint(times),'sec'   !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'radiative time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C     WRITE AN INFINITE ENERGY OMEGA FILE
C
      IF(MENGB.GE.-1)THEN                   !BBORN
c
        lupe=NSPECE
C
        IF(ABS(MENGB).EQ.1)THEN            !INF ENG BORN, ROW *AND* COL
C
          IF(MENGB.EQ.-1)THEN
            DO I=1,NOMWRT
              OMR(I)=MIN(OMR(I),D1P30)
              OMC(I)=MIN(OMC(I),D1P30)
            ENDDO
          ENDIF
C
          DO K=1,lupe                       !NENERG
            I=IORIG(K)
c            i=abs(i)
            IWRK3(K)=(1-QCP(I))*MSTAT(I)
            IWRK4(K)=0
            DWRK(K)=DENERG(I)*DTWO/DZ2
          ENDDO
c
          if(nmeta.eq.0)nmeta=nspece                         !case no E1
          if(nmeta.lt.nspece)then
            ixr=irow(nmeta,nspece,ione1,nspece)
            if(ixr.lt.nomwrt)nomwrt=ixr
            ixc=icol(nmeta,nspece,ione1)
          else
            ixc=nomwrt
          endif
          if(nmeta0.eq.0)nmeta=-nmeta
C
          WRITE(23,*)NZION,MION
          WRITE(23,*)NSPECE,ABS(MENGB),NOMWRT
          WRITE(23,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
          WRITE(23,711)(DWRK(I),I=1,NSPECE)
          WRITE(23,713)EINF,(OMR(I),I=1,NOMWRT)
C
          IF(IDW.EQ.0)THEN                           !COLUMNWISE AS WELL
            NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
            if(ixc.lt.nomwrt)nomwrt=ixc
C
            WRITE(23,*)NZION,MION
            WRITE(23,*)NSPECE,ABS(MENGB),-NOMWRT
            WRITE(23,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
            WRITE(23,711)(DWRK(I),I=1,NSPECE)
            WRITE(23,713)EINF,(OMC(I),I=1,NOMWRT)
          ENDIF
C
        ENDIF                                 !SUM BORN MULTIPOLES
C
C WRITE DATA TO ADF04 FILE
C
        BEXP=.FALSE.                          !TRUE=1.0E+0, FALSE=1.0+0
        IF(NSPECE.LT.1000)THEN
          i1=0
          IF(BEXP)THEN
            F761='(F5.2,4X,"1", 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
          ENDIF
        ELSE
          i1=1
          IF(BEXP)THEN
            F761='(F5.2,4X,"1",10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
          ENDIF
        ENDIF
C
C        WRITE(25,542)-1
c                                      !now write orbital energy in s.o.
        cardx=' '
        cardx(4:5)='-1'
        orbfmt='(1x,f7.?)'
c
c truncate to spectroscopic orbitals
        if(bort)then
          isob=0
          inx=0
          do i=1,mxorb
            if(dey(i).ne.dzero)then
              if(dadjus(i).lt.dzero)go to 646
              isob=i
              in=abs(qn(i))
              inx=max(inx,in)
            endif
          enddo
        else
          isob=mxorb
          inx=abs(qn(isob))
        endif
c re-map
 646    isox=0
        inx=(inx*(inx+1))/2
c
        allocate (isorb(0:inx))
c
        do i=1,inx
          isorb(i)=0
        enddo
        do i=1,isob
          in=qn(i)
          il=ql(i)/2
          iso=(in*(in-1))/2+il+1
c          if(iso.le.maxgr)
          isorb(iso)=i
          isox=max(isox,iso)
        enddo
c
c        if(isox.gt.maxgr)then
c          write(6,*)'***sr.carate: maxgr buffer too short, need ',isox
c          isox=-maxgr
c        endif
        is=9+2*i1
        ie=is+abs(isox)*8
        if(ie.gt.mxlenx)then!note, >200(=7d) not passed by cadwx,adasexj
          write(6,*)'***sr.carate: cardx too short, need mxlenx=',ie
          isox=-(mxlenx-is)/8
        endif
        if(isox.lt.0)then
          write(6,*)'***adf04ca note: truncated orbital energy list'
c          write(0,*)'***adf04ca note: truncated orbital energy list'
          isox=-isox
        endif
c print
        do ix=1,isox
          ie=is+7
          i=isorb(ix)
          t=dzero
          if(i.gt.0)then                !break into two for bounds check
            if(dey(i).ne.dzero)then
              t=dey(i)-duy(i,i)
              if(bmvd)t=t+dmass(i,i)+dcd(i,i)
              t=-2*t
            endif
          endif
          write(orbfmt(8:8),'(i1)')
     x          max(2,5-max(0,int(log10(max(t,d1m30)))))
          write(cardx(is:ie),orbfmt)t
          is=ie+1
        enddo
c
        orbfmt=' '
        orbfmt(1:7)='(a    )'
        write(orbfmt(3:6),'(i4)')ie
        write(25,orbfmt)cardx(1:ie)
c
        deallocate (isorb)
C
        IF(BEXP)THEN
          WRITE(25,F761)REAL(NZA),(XB(K),K=1,MXNXB)
        ELSE
          MSCP=MSC+1
          OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
          WRITE(MSCP,764)(XB(K),K=1,MXNXB)
          BACKSPACE(MSCP)
          READ(MSCP,765)(XMANT(K),IEXP(K),K=1,MXNXB)
          WRITE(25,F761)REAL(NZA),(XMANT(K),IEXP(K),K=1,MXNXB)
        ENDIF
C
        DO M=MSC0,MSC                     !RE-POINT BORN MULTIPOLE FILES
          REWIND(M)
        ENDDO
c
        if(nenerg.eq.1)go to 373
C
        IOLD=JJMN               !1+ione1
        JOLD=IIMN               !1
        INEW=IOLD
        JNEW=JOLD
        KTRAN=0
C
  371   IF(BSCRO)THEN
C
          BBORN=.FALSE.
C        DAS=DZERO
          DO K=0,MXNXB1
            OMEGAB(K)=DZERO
          ENDDO
C
          IP=IORIG(IOLD)
          IP=QCP(IP)
          JP=IORIG(JOLD)
          JP=QCP(JP)
          IF(IP.NE.JP)THEN
            MMN=MSC0+1                     !ODD MULTIPOLES
            MMX=MSC+MOD(MSC,ITWO)-1
          ELSE
            MMN=MSC0
            MMX=MSC-MOD(MSC,ITWO)
          ENDIF
C
          IFLAGO=999
          DO M=MMN,MMX,2
            READ(M,END=370,ERR=370)I,J,(XS(K),K=0,MXNXB1)
            IF(I.GT.IOLD.OR.J.GT.JOLD)THEN
              BACKSPACE(M)
              GO TO 370
            ELSE
              if(jold.gt.iimx)then
                if(nmeta0.eq.0)then
                  go to 370          !unfortunate interchange of i,j use
                else
                  stop '370'
                endif
              endif
              BBORN=.TRUE.
              KMX=MXNXB1
              IF(IP.NE.JP)THEN
                LAM=MOD(M,I80)
                IF(LAM.EQ.1.AND.ABS(XS(MXNXB1)).GT.TOLO)IFLAGO=1 !E1 LIM
                IF(LAM.GT.IFLAGO)KMX=MXNXB    !DON'T OVEFRWRITE E1 LIMIT
              ENDIF
              DO K=0,KMX
                OMEGAB(K)=OMEGAB(K)+XS(K)
              ENDDO
            ENDIF
  370     ENDDO
C
        ELSE
          KTRAN=KTRAN+1
          DO K=0,MXNXB1
            OMEGAB(K)=REAL(OMEGA(K,KTRAN),WP)
          ENDDO
        ENDIF
C
        IF(BBORN)THEN
          DO K=0,MXNXB
            OMEGAB(K)=ABS(OMEGAB(K))
            IF(OMEGAB(K).LT.D1M99)OMEGAB(K)=DZERO
          ENDDO
          IF(OMEGAB(0).LT.D1M30)OMEGAB(0)=D1M30
          IF(OMEGAB(MXNXB1).GT.D1P30)OMEGAB(MXNXB1)=D1P30
          IF(BEXP)THEN
            WRITE(25,F762)INEW,JNEW,(OMEGAB(K),K=0,MXNXB1) !IOLD,JOLD
          ELSE
            BACKSPACE(MSCP)
            WRITE(MSCP,764)(OMEGAB(K),K=0,MXNXB1)
            BACKSPACE(MSCP)
            READ(MSCP,765)(XMANT(K),IEXP(K),K=0,MXNXB1)
            WRITE(25,F762)INEW,JNEW
     X                  ,(XMANT(K),IEXP(K),K=0,MXNXB1)     !IOLD,JOLD
          ENDIF
        ENDIF
C
  373   JOLD=JOLD+1
        IF(JOLD.Gt.IOLD-ione1.or.JOLD.GT.IIMX.and.nmeta0.ne.0)THEN
  372     IOLD=IOLD+1
          IF(IOLD.GT.lupe)THEN                 !NENERG        !TERMINATE
            WRITE(25,F762)-1
            WRITE(25,F762)-1,-1
           if(.not.badas)then                       !adas skip comments
            WRITE(25,758)
            NREC=1
  121       NREC=NREC+1
            BACKSPACE(5)
            BACKSPACE(5)
            READ(5,766)CARD4
            IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
            REWIND(5)
            DO N=1,NREC
              READ(5,760)CARD
              WRITE(25,759)CARD
            ENDDO
            DATE='        '
            CALL DATE_AND_TIME(DATE)
            WRITE(25,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X                  ,DATE(3:3),DATE(4:4)
           endif
            DO M=MSC0,MSC
              CLOSE(M)
            ENDDO
            IF(.NOT.BEXP)CLOSE(MSCP)
          ELSE
            IF(IORIG(IOLD).LT.0)GO TO 372
            JOLD=IIMN          !1
            JNEW=IIMN          !1
            INEW=INEW+1
            GO TO 371
          ENDIF
        ELSE
          IF(IORIG(JOLD).LT.0)GO TO 373
          JNEW=JNEW+1
          GO TO 371
        ENDIF
      ENDIF
C
C DE-ALLOCATE
C
 7450 CONTINUE
C
      IF(BOMRC)THEN
        DEALLOCATE (OMR,OMC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CARATE: DE-ALLOCATION FAILS FOR OMR,OMC'
          NF=MIN(NF,IZERO)
        ENDIF
        BOMRC=.FALSE.
      ENDIF
C
      IF(ALLOCATED(OMEGA))THEN
        DEALLOCATE (OMEGA,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CARATE: DE-ALLOCATION FAILS FOR OMEGA'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(NF.LE.0)GO TO 750                                       !RETURN
C
C UPDATE FUNCTIONAL (RE-ENTRY POINT IF NO RADIATION)
C
      IF(NGF.NE.0)SGF=DTWO*SGF/NGF
  745 DRY=DF
      IF(IOPTIM.EQ.0)DRY=DRY+DECORE
      DRY=DRY*DTWO
      IF(BPRNT0)WRITE(6,999)INCLUD,DRY,SGF,NGF,JPRINT  !.AND.INCLUD.NE.0
      IF(JPRINT.EQ.-2)THEN
        DF=SGF
        if(includ.ne.0)WRITE(6,998)
        DECORE=DZERO
      ENDIF
C
C WRITE TERMINATORS
C
  750 IF(MODE.GT.0)THEN
        IF(BPRNT0)WRITE(MW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWU)int(IZERO),int(IZERO),int(IZERO)
     X       ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
      IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)WRITE(MWW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO)
     X        ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
C
      IF(ALLOCATED(ITMP))THEN
        DEALLOCATE (ITMP,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'CARATE: DE-ALLOCATION FAILS FOR ITMP'
          NF=0
        ENDIF
      ENDIF
C
C LOCAL DEALLOCATE
C
      IF(ALLOCATED(DENERG))DEALLOCATE (DENERG,IWRK2,IORIG)
C
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
C CLOSE SOME FILES
C
      IF(IUNIT(1).GT.0)THEN
        CLOSE(1)
        IUNIT(1)=-1
      ENDIF
      IF(IUNIT(3).GT.0)THEN
        CLOSE(3)
        IUNIT(3)=-1
      ENDIF
      IF(IUNIT(4).GT.0)THEN
        CLOSE(4)
        IUNIT(4)=-1
      ENDIF
      IF(IUNIT(21).GT.1)THEN
        CLOSE(21)
        IUNIT(21)=-1
      ENDIF
      IF(IUNIT(23).GT.1)THEN                  !so par scratch not closed
        CLOSE(23)
        IUNIT(23)=-1
      ENDIF
      IF(IUNIT(25).GT.1)THEN
        CLOSE(25)
        IUNIT(25)=-1
      ENDIF
C
C
      RETURN
C
C
 2000 IF(NF.GT.0)NF=-1
      GO TO  750                                            !DE-ALLOCATE
C
 3000 IF(NF.GT.0)NF=-1
      GO TO 7450                                            !DE-ALLOCATE
C
C***********************************************************************
C
   70 FORMAT(I6,' CALC ',F10.1,'     OBS ',F10.1, '   SQ-DIF.SUM',E16.5)
  100 FORMAT(88X, 'R OF 3 LAST P(R):',3F9.4)
  180 FORMAT(' ',I3,I7,I3,F14.5,13X,I4)
  200 FORMAT(//   ' GAM ( N,  L,NION, Z,SIG/D/P)  EPSILON/RY      <1/R>
     X <Z/R-V>      <R>   <R**2>   <R**3>   (ADJUST, REND, 3 LAST P), IN
     X',I7,' STEPS')
  201 FORMAT(//   ' GAM ( N,  L,NION, Z,Q.D/D/P)  EPSILON/RY      <1/R>
     X <Z/R-V>      <R>   <R**2>   <R**3>   (ADJUST, REND, 3 LAST P), IN
     X',I7,' STEPS')
  250 FORMAT(5I4,F9.5,F13.5,1X, 3F9.5,2F9.4, 2X,F8.4,F6.2,1X,3(1PE9.2))
  301 FORMAT(22X,'2MXLBD=',I3)
  400 FORMAT (//'   C      W (P)  H(ZZ)/2RY',14X,'   CF  E(CORE)/2RY ='
     X,F10.5,F11.4)
  500 FORMAT(1X,I4,A4,2I4,1PE15.3,0PF14.7,F16.6,3X,2F10.5,F12.4,4F12.4)
  501 FORMAT(    6I5,1PE15.5   ,2(0PF15.6))
  502 FORMAT(I9,2I4,1PE15.3,   2(0PF15.4))
  503 FORMAT(60X,F15.6)
  504 FORMAT(//8X,'W',3X,'C  CP',8X,'AA*SEC',6X,'ECONT(A.U)',
     X7X,'E-I(A.U)')
  505 FORMAT(8X,'I-S',12X,'C-S',11X,'AUTO-IONIZATION DATA',7X,'Z=',I2,
     X3X,'N=',I2/3X,'CF',4X,'C',4X,'W',3X,'CF',4X,'C',4X,'W',6X,'AA*SEC'
     X,9X,'E-C(RYD)',6X,'E-I(RYD)')
  506 FORMAT(5I5,4X,'X',1PE15.5,2(0PF15.6))
  507 FORMAT(I3,'CFCA',2X,'G',3X,'Z=',I2,4X,'N=',I2,2X,'NL',62(I3,I2))
 1507 FORMAT(I5,'CA',2X,'G',3X,'Z=',I2,4X,'N=',I2,2X,'NL',62(I3,I2))
  508 FORMAT(8X,'I-S',12X,'G-S',15X,'RADIATIVE DATA',9X,'Z=',I2,3X,'N='
     X,I2/3X,'CF',4X,'C',4X,'W',3X,'CF',4X,'C',4X,'W',6X,'AR*SEC', 9X,
     X'DEL(RYD)',6X,'E-G(RYD)')
  509 FORMAT('+',67X, '(AA DATA INCLUDES CFG-AV ENERGY CORRECTION)' )
  510 FORMAT(4X,'NCFGS=',I5,39X,'E1/RY=',F15.6/4X,'I',4X,'C',9X,'W'
     X,13X,'CF',5X,'(EI-E1)/RY')
  511 FORMAT(2I5,I10,5X,I10,F15.6,I10)
  512 FORMAT(A4)
  514 FORMAT(I3,' E(RYD) ' ,2X,'Z=',I2,4X,'N=',I2,5X,'Config-Average'
     X,8X,'EIONMIN=',F15.6)
  515 FORMAT(5(1PE15.5))
  516 FORMAT(8X,'I-S',12X,'C-S',10X,'PHOTO-IONIZATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',4X,'C',4X,'W',3X,'CF',4X,'C',3X,'EO',6X
     X,' P/CM2',9X,'E-I(RYD)',6X,'E-C(RYD)')
  517 FORMAT(2I5,4X,I1,I2,1X,10(I2,A1))
  536 FORMAT('*** SR.CARATE: INCREASE INTERNAL DIMENSION MXSTRG TO',I3)
  537 FORMAT(' &ADASEX NCFG= XXX',' &END')                      !,I3
  540 FORMAT('NAME:'/'DATE:'/'.')
  541 FORMAT(A2,'+',I2,2I10,F15.4,A4)
  600 FORMAT('   E',I1, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    ',
     X 12X,'G*F',8X,'F(ABS)   -F(EMI)    WAVEL/AE',
     X 5X,'GF(VEL)  V(GFL*GFV)',5X,'GF(ACC)',2X,'ALPHA(POL)')
  601 FORMAT(24X,'VELOCITY',6X,'VELOCITY',91X,'VELOCITY')
  701 FORMAT(/ ' GAM   I(A,C) = ONE-BODY INTEGRALS')
  702 FORMAT(1X,I3,9F14.7/(4X,9F14.7))
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE PLANE-WAVE BORN'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  767 FORMAT(I6,40(F6.3))
  768 FORMAT(/"CONFIGURATION OVERLAP MATRIX (SET TO ZERO IF CF'S DIFFER"
     X," BY MORE THAN 2 PAIRS) CASE IRLX=2:"/6X,40(I6))
  800 FORMAT('   E',I1, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    ',
     X 4X,'10**',I1,'*','  G*F',7X,'*F(ABS)   -F(EMI)    WAVEL/AE',
     X 4X,'*GF(VEL) *V(GFL*GFV)',4X,'*GF(ACC)',3X,'OMG(BORN)')
  801 FORMAT('  E',I2, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    ',
     X 4X,'10**',I1,'*','  G*F',7X,'*F(ABS)   -F(EMI)    WAVEL/AE',
     X 4X,'*GF(VEL) *V(GFL*GFV)',4X,'*GF(ACC)',3X,'OMG(BORN)')
  810 FORMAT(24X,'VELOCITY',6X,'VELOCITY')
  900 FORMAT( ' CORE CONTRIB. ',F12.4,F12.5)
  901 FORMAT(//9X,'ONE-BODY RELATIVISTIC CORRECTIONS TO INDIVIDUAL '
     X,'ORBITALS IN UNITS OF 2*RY',35X,'CA.JPRINT =',I4
     X/9X, 'GAM    N    LE(NON.REL)',8X,'E(MASS)',6X,'E(DAR)'
     X,7X,'E(TOT)',23X,'<P**2/RY>')
  902 FORMAT(7X,3I5,F14.6,3X,2F12.6,F13.7,20X,F12.6)
  903 FORMAT(/  ' ONE-BODY RELATIVISTIC INTEGRALS'/ ' I(R)  I(  A,  C )
     X= ',6X,'MASS',9X,'DARWIN',24X,'<P**2>')
  904 FORMAT(I5,3X,2I4,3X,2F14.7,16X,F14.7)
  981 FORMAT(8X,'W P',3X,'CF',7X,'ENERGY(RYD)')
  989 FORMAT(//'*** ATTN: BECAUSE BORN MULTIPOLES ARE BEING COMPUTED'
     X,' FOR NON-E1 TRANSITIONS, RADIATIVE DATA IS NOT COMPUTED FOR',
     X' THOSE E3 TRANSITIONS'/10X,'FOR WHICH E1 DATA ALREADY'
     X,' EXISTS (SO AS NOT TO OVERWRITE THE E1-LIMIT)'/)
  991 FORMAT(/' *** WORKING ARRAYS TOO SMALL IN SR.CARATE, INCREASE',
     X' MXAAI TO:',I6/' *** OR REDUCE NUMBER OF SPECTROSCOPIC CFGS')
  992 FORMAT(I9,I2,I5,F18.6,3X,A4)
  995 FORMAT(2I10,F13.0,I7,I5,A4,F8.3,F18.6,I10)
  996 FORMAT(8X,' I',9X,'C',8X,'K*CM',2X, '     W   CF',5X,'WEIGHTS',8X
     X,'(EI-E1)/RY     E1/RY =',F14.6)
  997 FORMAT(//I6,' (IF .GT. 0: LOWEST STAT-WEIGHTED) CFS ARE'
     X,' MINIMIZED;      SCALING PARAMETERS ',5F9.5,/((84X,5F9.5)))
  998 FORMAT(68X, '*WARNING*  G WILL BE MINIMIZED, AS JPRINT=-2')
  999 FORMAT(//9X,'INCLUD =',I5,9X, 'FUNCTIONAL F =',1PE14.7,9X
     X,'FUNCTIONAL G =',E10.3,' (',I4, ' TRANSITIONS)',9X
     X, 'CA.JPRINT=',I2//)
 1002 FORMAT(33X,I1,'-POLE PERTURBED TFDA POTENTIAL SCALING PARAMETERS '
     X,5F9.5,/((84X,5F9.5)))
 3005 FORMAT (/25X,' Q.E.D. CONTRIBUTIONS /2RY'/8X,'  GAM    N    L'
     X,3X,'VACUUM POLARIZ.',6X,'SELF ENERGY',9X,'TOTAL')
 3010 FORMAT (8X,3I5,3(2X,F15.7),2F10.5)
 3060 FORMAT(2I5)
 3070 FORMAT(30(I3,I2))
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION ICOL(ILI,ILF,IONE1)
C
      ICOL=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      END FUNCTION ICOL
C-----------------------------------------------------------------------
      FUNCTION ICOL8(I8,J8,IONE1)
C
      INTEGER(EP) I8,J8,ICOL8
C
      ICOL8=((J8-1)*(J8-2*IONE1))/2+I8
C
      END FUNCTION ICOL8
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE CARATE
C
C                             *******************
C
      SUBROUTINE CASC
C
C-----------------------------------------------------------------------
C
C  SR.CASC CALCULATES CASCADE COEFFICIENTS.
C
C    NOTE: IF THE NUMBER OF LOWER LEVELS (NG) IS GREATER THAN IN THE
C    NUMBER OF LEVELS WITHIN THE GROUND CONFIG THEN THERE IS A CHOICE
C    OF WHETHER OR NOT TO INCLUDE E1 TRANSTIONS BETWEEN THE NG LEVELS
C    IN THE CASCADE COEFFICIENTS.
C    DEFAULT IS TO INCLUDE THEM, SO POPULATION MODELING WITH THESE
C    COEFFICIENTS SHOULD INCLUDE ONLY FORBIDDEN RADIATIVE RATES STILL.
C    SEE COMMENT FLAG ***INCLUDE E1 CASC THRU NG BELOW.
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE COMMON_NRBCAS, ONLY: BCASC,AP,MADD,IXNOR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD14=100)
C
      CHARACTER(LEN=2) NY,NO,NB
C
      ALLOCATABLE ::  ATOT(:),CAS(:),NPOS(:),NEX(:),NS(:)
C
      COMMON /BASIC/NF,KVAR,MGAP(10)
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBTRN/NENERG,JORIG(MAXLV)
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C
      DATA  NY,NO/'  ','NO'/
C
C OPEN PUNCHFILE
C
      IF(MPNCH.LT.0)THEN
        MP=2                       !FIXED PUNCH TO UNIT2 CASE MPNCH.LT.0
        IF(IUNIT(MP).LT.0)THEN
          WRITE(6,*)"TRYING TO RE-OPEN FILE='CASC'..."
          WRITE(0,*)'TRYING TO RE-OPEN UNIT=2'
          NF=-1
          RETURN
        ENDIF
        IUNIT(MP)=1
        OPEN(MP,FILE='CASC',STATUS='REPLACE')   !OPTIONAL CASCADE COEFFS
      ENDIF
C
C FIND NUMBER OF LEVELS IN LOWEST CONFIGURATION
C
      ALLOCATE (ATOT(NENERG),NPOS(NENERG),NEX(NENERG),NS(NENERG)
     X        ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CASC: ALLOCATION FAILS FOR ATOT,NPOS,NEX,NS'
        NF=0
        GO TO 100
      ENDIF
C
      NG=0
      BLCOR=.FALSE.
C
      DO I=1,NENERG
        ATOT(I)=DZERO
        NPOS(I)=0
        IOLD=JORIG(I)                           !EO -> SO
        BLCOR=BLCOR.OR.IOLD.LT.0
        IF(IOLD.GE.0)THEN
          N=NRR(IOLD)
          IF(NG.EQ.0)NFK1=NFK(N)
          IF(NFK(N).EQ.NFK1)NG=NG+1
        ENDIF
      ENDDO
C
      IF(KUTCAS.GT.0)NG=KUTCAS     !WAS.GT.NG, .GT.0 ALLOWS RESTRICTION
      IF(KUTCAS.GT.(NENERG-1))NG=NENERG-1
C
      IF(NG.LE.1)THEN                       !TRIVIAL RETURN
        WRITE(6,5)
        GO TO 101
      ENDIF
C
      NCA=NG*(2*NENERG-NG-1)/2
      IF(NCA.GT.MXCAS)THEN
        IF(MXCAS.GT.0)WRITE(6,77)NCA,MXCAS
      ENDIF
C
      ALLOCATE (CAS(NCA),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CASC: ALLOCATION FAILS FOR CAS'
        NF=0
        GO TO 101
      ENDIF
C
      CALL DIMUSE('MXCAS',NCA)
C
      NB=NO
      IF(MPNCH.LT.0)NB=NY
      WRITE(6,60)KUTCAS,NG,MPNCH,NB
      IF(BLCOR)WRITE(6,95)
      WRITE(6,61)
C
C FOR A GIVEN LEVEL NU, STORE POINTER NPOS(NU)=I OF LAST TRANS. PROB.,
C STORED IN ARRAY AP(I).
C
      NAC=MADD(0)
      DO I=1,NAC
        NU=MADD(I)/NENERG+1
        ATOT(NU)=ATOT(NU)+AP(I)
        NPOS(NU)=I
      ENDDO
      DO I=1,NCA
        CAS(I)=DZERO
      ENDDO
C
      NS(1)=0
      NBEG=0
      DO  I=2,NENERG
        IS=NS(I-1)+I-2
        IF(I.GT.NG+2)IS=NS(I-1)+NG
        NS(I)=IS
C
        IF(JORIG(I).GE.0)THEN
          IMT=I-1
          IM=MIN(IMT,NG)
          NFIN=NPOS(I)
          NM=0
          IF(NFIN.NE.0)THEN
            DO N=1,I
              NEX(N)=0
            ENDDO
            NBEG=NBEG+1
            DO N=NBEG,NFIN
              NL=MADD(N)-(I-1)*NENERG+1
              NEX(NL)=N
            ENDDO
            NBEG=NFIN
C
            DO N=1,IM
              NTRAN=NEX(N)
              IF(NTRAN.GT.0)THEN             !FOR STUPID COMPILERS
                CAS(IS+N)=AP(NTRAN)/ATOT(I)
                NM=N
              ENDIF
              IF(N.LT.IMT)THEN               !IMT NOT IM
                NP=N+1             !***INCLUDE E1 CASC THRU NG
C                NP=NG+1           !***EXCLUDE E1 CASC THRU NG
                DO J=NP,IMT
                  NTRAN=NEX(J)
                  IF(NTRAN.GT.0)THEN
                    IT=NS(J)
                    CAS(IS+N)=CAS(IS+N)+CAS(IT+N)*AP(NTRAN)/ATOT(I)
                    NM=N
                  ENDIF
                ENDDO
              ENDIF
            ENDDO
          ENDIF
C
          IF(NM.GT.0)WRITE(6,90)(I,N,CAS(N+IS),N=1,NM)
          IF(MPNCH.LT.0)WRITE(MP,50)(I,N,CAS(N+IS),N=1,IM)
        ENDIF
C
      ENDDO
C
      DEALLOCATE (CAS,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CASC: DEALLOCATION FAILS FOR CAS'
        NF=0
      ENDIF
C
  101 DEALLOCATE (ATOT,NPOS,NEX,NS,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CASC: DEALLOCATION FAILS FOR ATOT,NPOS,NEX,NS'
        NF=0
      ENDIF
C
  100 IF(MPNCH.LT.0)THEN
        CLOSE(MP,STATUS='KEEP')
        IUNIT(MP)=-1
      ENDIF
C
      RETURN
C
    5 FORMAT(//20X,'CASCADE COEFFS NOT CALCULATED SINCE CONFIG 1 HAS'
     X,' 1 LEVEL')
   50 FORMAT(5(I7,I5,F10.6))
   60 FORMAT(//35X, 'CASCADE COEFFICIENTS'//'   CONTROL PARAMETERS FOR '
     X,'CASC:  INPUT KUTCAS=',I6,8X,'EFFECTIVE KUTCAS=',I6,8X,'MPNCH='
     X,I4/3X,A2,' CASCADE COEFFICIENTS WILL BE PUNCHED')
   61 FORMAT(//7(6X,'K',3X,'KP','  C(KP,K) ')/)
   77 FORMAT('SR.CASC: ALLOCATION INCREASES NUMBER OF CASCADE'
     X,' COEFFICIENTS NCA =',I10,' .GT. MXCAS=',I10/)
   90 FORMAT(7(I7,I5,F10.6))
   95 FORMAT('  TRANSITIONS INVOLVING CORRELATION LEVELS HAVE BEEN',
     X' OMITTED.     IF REQUIRED SET IC.JPRINT=1.')
C
      END SUBROUTINE CASC
C
C                             *******************
C
      SUBROUTINE CASYM(KACT,MXCF)
C
C-----------------------------------------------------------------------
C
C  SR.CASYM
C     SETS-UP THE CA "SYMMETRIES" AND "CHANNEL" LIST BASED-UPON THE USER
C     SPECIFIED MINLT, MAXLT.
C     SLIGHT OVERKILL FOR CA, BUT "REUSES" SYMLS .c.f. ALGXLS.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION KACT(MXCF,*)
C
      COMMON /BASIC/NF,MGAP(2),J1,J2,J1P,J2P,ND1,NDP1,LL(2),MAXLX0
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
c      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
c     X              ,NENERG
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
      if(ione1.eq.0)then
        write(6,*)'Re-setting IONE1=1 since elastic not coded for CA'
        write(0,*)'Re-setting IONE1=1 since elastic not coded for CA'
        ione1=1
      endif
C
C-----------------------------------------------------------------------
C
C INITIALIZATIONS
C
      BPRNT0=JPRINT.NE.-3
C
      BTHRSH=LVMAX.GE.0
C
C SCATTERING SYMMETRY RESTRICTIONS
C
      IF(MXLAMX.EQ.1000)THEN                     !MAX EXCHANGE MULTIPOLE
        IF(MAXLX.GE.100)THEN
CX          MXLAMX=NXLL+3                    !TWICE MAX ORB L+3 (was +1)
          MXLAMX=NXLL/2+NMULTE-1             !NMULTE=NO. LAMBDAS:  GEFGW
        ELSE
C          MXLAMX=(MAXLX+1)/2
          MXLAMX=MAXLX-NXLL/2
        ENDIF
      ENDIF
C
C      IF(MAXLX.GE.100)MAXLX=2*MXLAMX                !MAX L FOR EXCHANGE
      IF(MAXLX.GE.100)MAXLX=MXLAMX+NXLL/2            !MAX L FOR EXCHANGE
ct      IF(MAXLX.LT.MAXLT+2)THEN      !CA only for comparison with LS/BP
ct        MAXLX=MAX(MAXLX,QCL0/2-1)   !NEED ALL CHANNELS TO SCALE DIRECT
ct      ENDIF
      MAXLX0=MAXLX                                 !PASS THRU TO CAFLGLX
C
      WRITE(6,1007)
      WRITE(6,1112)MAXLX
      IF(MXLAMX.NE.1000)WRITE(6,152)MXLAMX
      IF(NMULTE.LT.100)WRITE(6,153)NMULTE
C
      IF(INAST0.GT.0)THEN                        !FOR PARALLEL OPERATION
C
        WRITE(6,1113)
        MAXLT=0
        DO I=1,INAST0
          IS=LSPI(I)/10000
          if(is.ne.0)then              !case user specifies serial as ls
            IP=LSPI(I)-IS*10000
            IL=IP/10
            IP=IP-IL*10
          else                                  !internal parallel spec.
            IL=LSPI(I)
          endif
          WRITE(6,1114)I,IL
          LSPI(I)=IL                                               !ibid
          MAXLT=MAX(MAXLT,IL)
        ENDDO
        MAXLT=-MAXLT                                     !FLAG FOR CALGX
C
      ELSE
C
        IF(BTHRSH)THEN
C
          MAXL=LVMAX+QCL0/2
          IF(MAXLT.EQ.1000)MAXLT=MAXL
          IF(MAXLT.GT.MAXL)THEN
            WRITE(6,1007)
            WRITE(6,1008)MAXL,LVMAX
            WRITE(6,1007)
            MAXLT=MAXL
          ELSEIF(MAXLT.LT.MAXL)THEN
            WRITE(6,1007)
            WRITE(6,1009)MAXLT,LVMAX,MAXL
            WRITE(6,1007)
C            MAXLT=MAXL                       !ALLOW USER TO RESTRICT...
          ENDIF
C
          MINL=LVMIN-QCL0/2
          MINL=MAX(IZERO,MINL)
          IF(MINLT.GT.MINL)THEN
            WRITE(6,1007)
            WRITE(6,1010)MINLT,LVMIN,MINL
            WRITE(6,1007)
c            MINLT=MINL                       !ALLOW USER TO RESTRICT...
          ELSEIF(MINLT.LT.MINL)THEN
            WRITE(6,1007)
            WRITE(6,1011)MINL,LVMIN
            WRITE(6,1007)
            MINLT=MINL
          ENDIF
C
        ELSE
C
          IF(MAXLT.EQ.1000)MAXLT=30
          IF(MAXLT.GT.100)THEN
            MAXLT=100
            WRITE(0,*)'*** SR.CASYM: REDUCING MAXLT TO',MAXLT
            MINLT=MIN(MINLT,MAXLT)
          ENDIF
C
          IF(MINLT.LT.0)MINLT=0
C
        ENDIF
C
        WRITE(6,1115)MINLT,MAXLT
C
      ENDIF
C
      WRITE(6,1007)
C
C SET-UP SCATTERING SYMMETRY (L-VALUE) LIST
C
      IF(INAST0.GT.0)THEN
C
        INAST=INAST0
        LFACT=100
C
      ELSE
C
        INAST=0
C
        FACTL=REAL(LFACT,WP)/D100
        IL=MINLT
C
   54   INAST=INAST+1
        BLX=INAST.LE.MAXSL
        IF(BLX)LSPI(INAST)=IL
C
        if(lfact.gt.100)il0=il
        IF(IL.GT.MAX(MAXLX,15_SP))IL=NINT(IL*FACTL)
        IL=IL+1
        IF(IL.LE.MAXLT)GO TO 54
c
        if(lfact.gt.100)then
          if(lrglam.gt.il0)lrglam=il0               !case factl "misses"
          maxlt=il0
        endif
C
        IF(INAST.GT.MAXSL)THEN
          WRITE(6,194)INAST
          WRITE(0,194)INAST
          GO TO 999
        ENDIF
C
      ENDIF
C
C SET-UP "CHANNEL LIST" - WE NEED THE NUMBER OF INTERACTIONS.
C
      NNN=0
      INAST0=INAST                     !SINCE WILL REDUCE IF NO CHANNELS
      IX=0
C
      DO I0=1,INAST0
C
        IX=IX+1
        IL=LSPI(IX)
        MTL=IL+IL
C
c          if(il.gt.maxlx)go to 60                             !nx
        IF(BPRNT0)WRITE(6,1130)IX,IL
C
c        lcon0=4*((nmulte-1)/2)                                   !local
        LUP=0
        LLOW=999
        NN=0
C
        DO KF=1+ione1,KMAX
          DO KG=1,KF-ione1
C
            IF(KACT(KG,KF).GE.0)THEN
C
              L1=KACT(KF,KG)
              L1=QL(L1)
              L2=KACT(KG,KF)
              L2=QL(L2)
C
              L12M=ABS(L1-L2)
              L12=L1+L2
C
              LCON=L12
   57         LMIN=MTL-LCON
              IF(LMIN.LT.0)THEN                !EFFECTIVE MULTIPOLE LOOP
                LCON=LCON-IFOUR
                IF(LCON.GE.L12M)GO TO 57
                LMIN=ABS(MTL-L12M)
              ENDIF
C
              LCON=MIN(L12,LCONDW-1)                             !GLOBAL
c              lcon0=3*abs(l1-l2)                                !local
c              if(l12m.eq.2)lcon=min(lcon,14)                    !dipole
C
              MT=MTL-LCON
              IF(LMIN.LT.MT)THEN
                LMIN=MT
                IF(MOD(L12/2,ITWO).NE.MOD(LCON/2,ITWO))LMIN=LMIN+2!ALIGN
              ENDIF
C
              LMAX=MTL+L12
              MT=MTL
C              MT=MAX(MT,LMIN) !NEED MEMORY REPOINTED AS ACCESSES>LCONDW
              MT=MT+LCON
              IF(LMAX.GT.MT)THEN
                LMAX=MT
                IF(MOD(LMIN/2,ITWO).NE.MOD(LMAX/2,ITWO))LMAX=LMAX-2!ALGN
              ENDIF
C
              IF(LMAX.GE.LMIN)THEN
                IF(BPRNT0)WRITE(6,1125)KF,KG,LMIN/2,LMAX/2
                NN=NN+1+(LMAX-LMIN)/4
                LUP=MAX(LUP,LMAX)
                LLOW=MIN(LLOW,LMIN)
              ENDIF
C
            ENDIF
C
          ENDDO
        ENDDO
c
c 60    continue
C
        IF(BTHRSH.AND.(LVMAX.LT.LLOW/2.OR.LVMIN.GT.LUP/2))NN=0  !DROP
C
        IF(NN.GT.0)THEN
          NNN=NNN+NN
          IF(.NOT.BPRNT0)WRITE(6,1120)IX,IL,NN
        ELSE                                            !QUIETLY DISCARD
          INAST=INAST-1
          DO I=IX+1,INAST0
            LSPI(I-1)=LSPI(I)
          ENDDO
          IX=IX-1
        ENDIF
C
      ENDDO                                           !END SYMMETRY LOOP
C
      IADD=NNN                    !N.B. USED TO ALLOCATE NAD IN SR.CALGX
C
      IF(IADD.GT.MAXAD)THEN
        IF(MAXAD.GT.0)WRITE(6,133)IADD,MAXAD
      ENDIF
C
      RETURN
C
C
 999  WRITE(6,190)
      NF=-1                                                       !ABORT
C
      RETURN
C
  133 FORMAT('SR.CASYM: ALLOCATION INCREASES NUMBER OF MATRIX '
     X,' ELEMENTS IADD =',I10,'.GT.MAXAD=',I10)
  152 FORMAT(/44X,' MAX EXCHANGE LAMDA (MXLAMX)=',I3)
  153 FORMAT(/44X,' No. OF MULTIPOLES (NMULTE) =',I3)
  190 FORMAT( ' SR.SYMLS: FAILURE - CASE SKIPPED')
  194 FORMAT('***SR.CASYM: TOO MANY SYMMETRIES, INCREASE MAXSL',
     X              ' TO:',I4)
 1007 FORMAT(//1X,136('-')//)
 1008 FORMAT(/' NOTE: REDUCING MAXLT TO',I3,', THAT NEEDED BY LVMAX='
     X,I3)
 1009 FORMAT(/' ***WARNING: YOU HAVE SET MAXLT=',I3,', LESS THAN THAT'
     X,' FORMALLY NEEDED BY LVMAX=',I3/22X,'SET MAXLT=',I3
     X,', TO SATISFY TRIANGLE RELATION')
 1010 FORMAT(/' ***WARNING: YOU HAVE SET MINLT=',I3,', GREATER THAT'
     X,' FORMALLY NEEDED BY LVMIN=',I3/22X,'SET MINLT=',I3
     X,', TO SATISFY TRIANGLE RELATION')
 1011 FORMAT(/' NOTE: INCREASING MINLT TO',I3,', THAT NEEDED BY LVMIN='
     X,I3)
 1112 FORMAT(' *** PARTIAL WAVE SYMMETRY RESTRICTIONS:',5X,'MAXIMUM'
     X,' EXCHANGE L (MAXLX) =',I3)
 1113 FORMAT(//'   SY   L')
 1114 FORMAT(1X,2I4)
 1115 FORMAT(//' MINLT=',I2,3X,'MAXLT=',I3)
 1120 FORMAT(' SY=',I3,5X,' LF=',I4,5X,'NC=',I4)
 1125 FORMAT(20X,2I5,2X,2I4)
 1130 FORMAT(/' SY=',I3,5X,'  L=',I4,'    C','   CP',3X,'LP=...,+2')
C
      END SUBROUTINE CASYM
C
C                             *******************
C
      SUBROUTINE CAVE(KF,EAV)
C
C-----------------------------------------------------------------------
C
C  SR.CAVE DETERMINES THE AVERAGE ENERGY OF CONFIGURATION KF
C  USING ORBITALS (PREVIOUSLY GENERATED) STORED IN COMMON /RADF/.
C  IT OMITS ANY COMMON CLOSED-SHELL CORE SINCE WE ARE ONLY INTERESTED
C  IN RELATIVE DIFFERENCES BETWEEN CONFIGURATIONS: RELAXED-UNRELAXED.
C
C  IT CALLS:
C    SR.YLAMK
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBNF2, ONLY: DXSI
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TOLW=D1M3)    !TOLERANCE FOR MATCHING OCCUPATION NOS WK
C
      DIMENSION DFS(MXDFS)
C
C      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/POT(MAXB1),TOL,MEND
      COMMON /COM6/DA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBFR/DP(MAXB1)
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
      DFS(1)=1
      DFS(2)=1
      DO K=3,MXDFS,2
        DFS(K)=-DFS(K-2)
        DFS(K+1)=(K-1)*DFS(K-1)/32
      ENDDO
C
      BREL2=ABS(IREL).EQ.2
      AJUST=DONE
C
C RESTRICT RANGE OF ORBITALS
C (N.B. FOR CUP='CA', ENERGIES ARE CALCULATED IN CARATE AND SO WE CAN
C  OMIT RYDBERG HERE, AS WE MUST SINCE RELAXED ARE COMPUTED ONCE ONLY)
C
      MXB=0
      DO J=1,MXORB         !FIRST (RELAXED) CALL   !SECOND (UNIQUE) CALL
        IF(DEY(J)*NEL(J,KF).NE.0.AND.
     X     QN(J).GT.0.and.ival(j).eq.0)MXB=J
      ENDDO
c      write(0,*)kf,mxb
C
C INITIALIZE POT(I)
C
      DO I=1,MAXRS
        POT(I)=DZERO
      ENDDO
C
      IDIR=0                                  !INCLUDE DIRECT 2-BODY
      IXCH=0                                !INCLUDE EXCHANGE 2-BODY
ct      idir=1
ct      ixch=1
C
C FORM CONFIGURATION AVERAGE POTENTIAL
C
      DO J=1,MXB                           !LOOP OVER FIRST ELECTRON
C
       IF(NEL(J,KF).NE.0)THEN
C
        IF(IDIR.EQ.0)THEN                   !PRE-CALC DIRECT YLAMK=0
C
          IF(BREL2)THEN
            DO I=1,MAXRS
              DP(I)=DPNL(I,J)*DPNL(I,J)+DQNL(I,J)*DQNL(I,J)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DP(I)=DPNL(I,J)*DPNL(I,J)
            ENDDO
          ENDIF
C
          MI=QL(J)+2
C
          CALL YLAMK(IZERO,MI,DP,DERV,DD1,DD2,MNH,DHNS,MJH,IZERO)
C                                                             !NO RETARD
          F0=REAL((MI-1),WP)/REAL((2*MI-3),WP)
          MJX=MIN(INT(QL(J),SP),IEIGHT)
C
        ENDIF
C
        K0=MAX(J,MB+1)                    !EXCLUDE ANY CLOSED CORE  !MB0
C
        DO K=MXB,K0,-1                    !LOOP OVER SECOND ELECTRON
C
          BEQNL=J.EQ.K
C
          C=NEL(K,KF)
          IF(BEQNL)C=(C-DONE)/DTWO
C
          IF(ABS(C).GT.TOLW)THEN
C
            C=C*ABS(NEL(J,KF))
c
            IF(IDIR.EQ.1)GO TO 101
C
C DIRECT
C
            IF(BEQNL.AND.MJX.GT.0)THEN
C
              IF(BREL2)THEN
                DO I=1,MAXRS
                  DP(I)=DPNL(I,J)*DPNL(I,J)+DQNL(I,J)*DQNL(I,J)
                ENDDO
              ELSE
                DO I=1,MAXRS
                  DP(I)=DPNL(I,J)*DPNL(I,J)
                ENDDO
              ENDIF
C
              DO MJ=2,MJX,2
C
                CALL YLAMK(MJ,MI,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
C                                                             !NO RETARD
                DC1=
     X       VCC(INT(QL(J),SP),2*MJ,INT(QL(J),SP),IZERO,IZERO,IZERO,DFS)
                F=-F0*DC1*DC1/(MI-1)
c                write(6,*)j,k,ql(j),2*mj,ql(j),'  f=',f
C
                DO I=1,MAXRS
                  DERV(I)=DERV(I)+F*DA(I)
                ENDDO
C
              ENDDO
C
            ENDIF
C
            IF(BREL2)THEN
              DO I=1,MAXRS
                POT(I)=POT(I)-C*DERV(I)
     X                      *(DPNL(I,K)*DPNL(I,K)+DQNL(I,K)*DQNL(I,K))
              ENDDO
            ELSE
              DO I=1,MAXRS
                POT(I)=POT(I)-C*DERV(I)*DPNL(I,K)*DPNL(I,K)
              ENDDO
            ENDIF
C
C EXCHANGE
C
 101        IF(.NOT.BEQNL.AND.IXCH.EQ.0)THEN
C
              ME1=ABS(QL(J)-QL(K))/2
              ME2=(QL(J)+QL(K))/2
              MI=ME2+2
              ME2=MIN(ME2,8_SP)
C
              IF(BREL2)THEN
                DO I=1,MAXRS
                  DP(I)=DPNL(I,J)*DPNL(I,K)+DQNL(I,J)*DQNL(I,K)
                ENDDO
              ELSE
                DO I=1,MAXRS
                  DP(I)=DPNL(I,J)*DPNL(I,K)
                ENDDO
              ENDIF
C
              DO MJ=ME1,ME2,2
C
                CALL YLAMK(MJ,MI,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
C                                                             !NO RETARD
                DC1=
     X       VCC(INT(QL(J),SP),2*MJ,INT(QL(K),SP),IZERO,IZERO,IZERO,DFS)
                G=-DC1*DC1/(2*QL(K)+2)
                G=G*AJUST                          !TRY SCALING EXCHANGE
c                write(6,*)j,k,ql(j),2*mj,ql(k),'  g=',g
C
                IF(BREL2)THEN
                  DO I=1,MAXRS
                    POT(I)=POT(I)-C*G*DA(I)
     X                        *(DPNL(I,J)*DPNL(I,K)+DQNL(I,J)*DQNL(I,K))
                  ENDDO
                ELSE
                  DO I=1,MAXRS
                    POT(I)=POT(I)-C*G*DA(I)*DPNL(I,J)*DPNL(I,K)
                  ENDDO
                ENDIF
C
              ENDDO
C
            ENDIF
C
          ENDIF
C
        ENDDO
C
       ENDIF
C
      ENDDO
C
C TWO-BODY
C
      CALL WEDDLE(DZERO,POT,E,MNH,DHNS,MJH,MAXRS)
C
      E2BODY=-E                                                    !A.U.
C
C ONE BODY (EXCLUDE ANY CLOSED CORE)
C
      E1BODY=DZERO
C
      DO J=MB+1,MXB                                                 !MB0
        IN=NEL(J,KF)
        IF(IN.GT.0)THEN
c          write(6,*)'j=',j,'  ne=',in
          E=DEY(J)
c          write(6,200)dey(j)-duy(j,j),duy(j,j)
c 200      format('eps=',1p,d12.5,'  V-Z/R=',d12.5)
          IF(BMVD.OR.NJO.NE.0)E=E+DCD(J,J)+DMASS(J,J)
c          if(bmvd.or.njo.ne.0)write(6,201)dcd(j,j),dmass(j,j)
c 201      format('darwin=',1p,d12.5,'  mass=',d12.5)
          IF(QED.NE.0.AND.QN(J).GT.0)E=E+VPINT(J)+SLFINT(J)
c          if(qed.ne.0.and.qn(j).gt.0)write(6,202)vpint(j),slfint(j)
c 202      format('vac=',1p,d12.5,'  self=',d12.5)
          IF(KUTOO.EQ.98)E=E+DXSI(J,J)
c          if(kutoo.eq.98)write(6,203)dxsi(j,j)
c 203      format('dxsi=',1p,d12.5)
          E1BODY=E1BODY+IN*E
        ENDIF
      ENDDO
C
c      write(6,204)kf,e1body,e2body
c 204  format(/'cf=',i3,'  e1body=',1p,d12.5,'  e2body=',d12.5)
c
      EAV=E1BODY+E2BODY
C
      RETURN
C
      END SUBROUTINE CAVE
C
C                             *******************
C
      SUBROUTINE CAVE0(ICAV)
C
C-----------------------------------------------------------------------
C
C  SR.CAVE0 DETERMINES CONFIGURATION AVERAGE ENERGIES BOTH USING AN
C  INTERNAL RELAXED ORBITALS BASIS (ICAV.GT.0) AND THEN USING THE
C  EXISTING (UNIQUE) ORBITAL BASIS (ICAV.LT.0). THE TWO ARE STORED
C  SEPARATELY IN ECAVX AND ECAV TO ENABLE THE LATTER TO BE UPDATED
C  E.G. DURING MINIMIZATION. THE DIFFERENCE IS THEN APPLIED TO THE
C  DIAGONAL OF THE HAMILTONIAN IN SR.DIAGON AND SR.DIAGFS.
C
C  IT CALLS:
C    SR.CAVE
C    SR.RADIAL
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D999=999.0D0)
C
      ALLOCATABLE ::  DEXTRE(:),MSTOH(:),DEYH(:),SCREEH(:),TELH(:)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /CALAN/DALAN(MXVAR),BALAN
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV0
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
C
      IF(ICAV.GT.0)THEN                       !NEW SELF-CONSISTENT BASIS
C
C HOLD USER VALUES
C
        ALLOCATE (MSTOH(MXORB),DEYH(MXORB),SCREEH(MXORB),TELH(MXORB))
C
        MAUTOH=MAUTO
        MDENH=MDEN
        MEXH=MEXPOT
        MHFH=MHF
        MRADH=MRAD
        MCFMXH=MCFMX
        BSTOH=BSTO
        NOCCH=NOCC
C
        DO I=1,MXORB
          MSTOH(I)=MCFSTO(I)
          TELH(I)=TEL(I)
          DEYH(I)=DEY(I)
          SCREEH(I)=SCREEN(I)
        ENDDO
C
C NOW SET-UP FOR A SELF-CONSISTENT CALCULATION
C
        MAUTO=MIN(IZERO,MAUTO)
        MHF=0
        MRAD=0
        MCFMX=MXORB
        BSTO=.TRUE.
        MDEN=-10
        IF(NOCC.EQ.0)THEN                     !ELSE STICK WITH USER INPT
          MEXPOT=0                            !FULL EXCHANGE
          NOCC=-1000                          !NON-UNIQUE, I.E. FAC=NO
        ELSEIF(NOCC.LT.0)THEN                 !USE INDIVIDUAL CF OCC NOS
          NOCC=-1000
        ELSE                                  !BUT ALLOW FAC='YES' POT
          NOCC=1000
        ENDIF
C
        NP0=0
        IF(IPOLFN.LT.0)NP0=-IPOLFN
        NPARM3=(NP0+1)*NPARAM                 !MXVAR
C
        ALLOCATE (DEXTRE(NPARM3))
C
        DO I=1,NPARM3                         !ASSIGN GLOBAL SCALE VALUE
          DEXTRE(I)=AJUSTX
          IF(BALAN)DALAN(I)=AJUSTX
        ENDDO
C
      ELSE
C
        WRITE(6,200)
C
      ENDIF
C
C LOOP OVER THE KMAX CONFIGURATIONS
C
      DO K=1,KMAX
C
        IF(ICAV.GT.0)THEN
C
          DO I=1,MXORB
            MCFSTO(I)=K
            IF(NEL(I,K).NE.0)THEN
              IF(QN(I).GE.80)THEN
                DEY(I)=DZERO
c                SCREEN(I)=DZERO
              ELSEIF(SCREEH(I).GT.-D999)THEN
                SCREEN(I)=SCREEH(I)
                DEY(I)=DONE
              ENDIF
            ELSEIF(QN(I).LT.70)THEN
              DEY(I)=DZERO
c              SCREEN(I)=DZERO
            ENDIF
          ENDDO
C
          CALL RADIAL(DEXTRE)                 !UPDATE RADIAL FUNCTIONS
C
          IF(NF.LE.0)GO TO 20                 !FAILURE
C
          DO I=1,NPARAM                       !RE-SET
            IF(SCREEN(I).GT.-D999)THEN
              DO N=0,NP0
                N0=N*NPARAM+I
                DADJUS(N0)=DZERO
              ENDDO
            ENDIF
          ENDDO
C
        ENDIF
C
        CALL CAVE(K,EAV)
C
C
        IF(ICAV.GT.0)THEN
          ECAVX(K)=EAV
          MAXRS=0                             !RESET INITIAL RADIAL MESH
        ELSE
          ECAV(K)=EAV
          WRITE(6,202)K,ECAVX(K),ECAV(K),ECAVX(K)-ECAV(K)
        ENDIF
C
      ENDDO                                   !END LOOP OVER CFS
C
  20  IF(ICAV.GT.0)THEN                       !RE-INSTATE
C
        MAUTO=MAUTOH
        MDEN=MDENH
        MEXPOT=MEXH
        MHF=MHFH
        MRAD=MRADH
        MCFMX=MCFMXH
        BSTO=BSTOH
        NOCC=NOCCH
C
        DO I=1,MXORB
          MCFSTO(I)=MSTOH(I)
          TEL(I)=TELH(I)
          IF(SCREEH(I).GT.-D999)THEN
            DEY(I)=DEYH(I)
            SCREEN(I)=SCREEH(I)
          ENDIF
        ENDDO
C
        DEALLOCATE (DEXTRE,MSTOH,DEYH,SCREEH,TELH)
C
      ENDIF
C
      RETURN
C
 200  FORMAT(//'  CONFIGURATION AVERAGE ENERGIES/2RY:'
     X         /45X,'CF',10X,'ECAVX',12X,'ECAV',12X,'DIFFERENCE')
 202  FORMAT(42X,I5,2X,1P,2D17.7,3X,D15.5)
C
      END SUBROUTINE CAVE0
C
C                             *******************
C
      FUNCTION CELMNT(NZION)
C
C
C-----------------------------------------------------------------------
C
C  FN.CELMNT RETURNS 2-CHARACTER ELEMENT SYMBOL FOR NUCLEAR CHRAGE NZION
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=2) ELEM2(92),CELMNT
C
      DATA
     XELEM2/'H ','HE','LI','BE','B ','C ','N ','O ','F ','NE','NA','MG'
     X,'AL','SI','P ','S ','CL','AR','K ','CA','SC','TI','V ','CR','MN'
     X,'FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR','KR','RB','SR'
     X,'Y ','ZR','NB','MO','TC','RU','RH','PD','AG','CD','IN','SN','SB'
     X,'TE','I ','XE','CS','BA','LA','CE','PR','ND','PM','SM','EU','GD'
     X,'TB','DY','HO','ER','TM','YB','LU','HF','TA','W ','RE','OS','IR'
     X,'PT','AU','HG','TL','PB','BI','PO','AT','RN','FR','RA','AC','TH'
     X,'PA','U '/
C
      IF(NZION.LE.0.OR.NZION.GT.92)THEN
        CELMNT='  '
      ELSE
        CELMNT=ELEM2(NZION)
      ENDIF
C
      RETURN
C
      END FUNCTION CELMNT
C-CGNRC
C-CGNRC                             *******************
C-CGNRC
C-CGNR      SUBROUTINE CGNR(DEXTRE,NVAR,IMAXIT)
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNRC  SR.CGNR INTERFACE WITH THE NUMERICAL RECIPES CONJUGATE GRADIENT
C-CGNRC  CODE SUITE
C-CGNRC
C-CGNRC  THE SOURCE IS *NOT* PROVIDED HERE DUE TO THEIR LICENSING
C-CGNRC  RESTRICTIONS. LINK AT THE COMPILATION STAGE TO YOUR OWN COPY
C-CGNRC  OF THE LIBRARY.
C-CGNRC  THIS HAS BEEN TESTED TO WORK WITH VANILLA RIGHT-OUT-OF-THE-TIN
C-CGNRC  UNMODIFIED NUMERICAL RECIPES CODE. IT *MUST* BE THE REAL *8
C-CGNRC  VERSION, FORCING IT VIA A COMPILER SWITCH IS NOT RECOMMENED.
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNR      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C-CGNR      USE PARAM
C-CGNR      USE CONSTANTS
C-CGNR
C-CGNR      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
C-CGNR      IMPLICIT LOGICAL(BP) (B)
C-CGNR      IMPLICIT INTEGER(SP) (I-N)
C-CGNR      IMPLICIT INTEGER(QP) (Q)
C-CGNRC
C-CGNR      INCLUDE './INCLUDE'
C-CGNRC
C-CGNR      PARAMETER (NMAX=50)                      !NUM. REC. DEFAULT
C-CGNR      DIMENSION pcom(NMAX),xicom(NMAX)         !NUM. REC. COMMON
C-CGNR      COMMON /f1com/ pcom,xicom,ncom           !NUM. REC. COMMON
C-CGNRC
C-CGNR      DIMENSION DEXTRE(*)
C-CGNRC
C-CGNRc      common /cadj/dajnew(mxvar),df0,iequal(mxvar),icount
C-CGNR      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
C-CGNR     X              ,ITOL,INCLUD,JPRINT
C-CGNR      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
C-CGNRC
C-CGNR      NP0=0
C-CGNR      IF(IPOLFN.LT.0)NP0=-IPOLFN
C-CGNR      NPARM3=(NP0+1)*NPARAM                   !MXVAR
C-CGNRC
C-CGNR      NVAR=-NVAR
C-CGNRC
C-CGNR      IF(NVAR.GT.NMAX)THEN                  !SHIRELY, SOME MISTAKE
C-CGNR        WRITE(6,1081)NVAR,NMAX
C-CGNR        WRITE(0,*)' TOO MANY VARIATIONAL PARAMETERS...!!!'
C-CGNR        GO TO 999
C-CGNR      ENDIF
C-CGNRC
C-CGNR      TOL=D1M6                                  !SUBJECT TO CHANGE
C-CGNR      IF(NP0.GT.0)TOL=D1M6                      !   "     "    "
C-CGNRC
C-CGNRc      LIMIT=NVAR*IMAXIT+IMAXIT+2        !200 IS NUM. REC. DEFAULT
C-CGNRc      itout=limit                      !itmax= in modified frprmn
C-CGNRc
C-CGNR      ncom=-NPARM3                              !PASS THRU TO FUNC
C-CGNR      DUMMY=FUNC(DEXTRE)                  !INITIALIZE DEXTRE STORE
C-CGNRC
C-CGNR      ncom=NVAR                          !PASS THRU TO FUNC, DFUNC
C-CGNRC
C-CGNR      CALL FRPRMN(DEXTRE,NVAR,TOL,ITOUT,DF)!REQUIRES REAL *8 VERSN
C-CGNRC
C-CGNR      WRITE(6,1082)ITOUT
C-CGNRC
C-CGNR      IF(ITOUT.EQ.1)THEN
C-CGNR        WRITE(6,1084)TOL,DF
C-CGNR        WRITE(0,*)
C-CGNR     X        'NR CONJUGATE GRADIENT DOES NOT CHANGE FUNCTIONAL..'
C-CGNR        GO TO 999
C-CGNR      ENDIF
C-CGNRC
C-CGNR      IF(ITOUT.EQ.200)THEN    !LIMIT
C-CGNR        WRITE(6,1083)TOL,DF
C-CGNR        WRITE(0,*)'NR CONJUGATE GRADIENT HAS FAILED TO CONVERGE..'
C-CGNR        GO TO 999
C-CGNR      ENDIF
C-CGNRC
C-CGNRc      write(0,*)DF,imaxit,limit,itout,icount
C-CGNRC
C-CGNR      RETURN
C-CGNRC
C-CGNR  999 IMAXIT=-1
C-CGNR      RETURN
C-CGNRC
C-CGNR 1084 FORMAT(//' *** NR CONJUGATE GRADIENT DOES NOT CHANGE'
C-CGNR     X,' FUNCTIONAL:,2(1PD10.2))
C-CGNR 1083 FORMAT(//' *** NR CONJUGATE GRADIENT HAS FAILED TO CONVERGE'
C-CGNR     X,' TO CONVERGE TO THE REQUESTED ACCURACY:',2(1PD10.2))
C-CGNR 1082 FORMAT(I5,' ITERATIONS COMPLETED BY NR CONJUGATE GRADIENT'
C-CGNR     X,' METHOD')
C-CGNR 1081 FORMAT(//' *** CGNR: NUMBER OF VARIATIONAL PARAMETERS '
C-CGNR     X,'EXCEEDS THAT ALLOWED BY NUMERICAL RECIPES - SOME MISTAKE?'
C-CGNR     X,2I4)
C-CGNRC
C-CGNR      END SUBROUTINE CGNR
C-CGNRC
C-CGNRC                             *******************
C-CGNRC
C-CGNR      FUNCTION FUNC(X)
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNRC  FN.FUNC EVALUATES THE COST (C) OF THE FUNCTIONAL AT X(N).
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNR      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C-CGNR      USE PARAM
C-CGNR      USE CONSTANTS
C-CGNR
C-CGNR      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
C-CGNR      IMPLICIT LOGICAL(BP) (B)
C-CGNR      IMPLICIT INTEGER(SP) (I-N)
C-CGNR      IMPLICIT INTEGER(QP) (Q)
C-CGNRC
C-CGNR      INCLUDE './INCLUDE'
C-CGNRC
C-CGNR      PARAMETER (NMAX=50)                      !NUM. REC. DEFAULT
C-CGNR      DIMENSION pcom(NMAX),xicom(NMAX)         !NUM. REC. COMMON
C-CGNR      COMMON /f1com/ pcom,xicom,ncom           !NUM. REC. COMMON
C-CGNRC
C-CGNR      DIMENSION XOLD(MXVAR),X(*)
C-CGNRC
C-CGNR      DATA NOLD/0/
C-CGNRC
C-CGNR      SAVE NOLD,XOLD
C-CGNRC
C-CGNRC FIRST CALL MUST BE WITH N=-NPARAM TO STORE ALL SCALING PARAMETRS
C-CGNRC IN XOLD. THEN SUBSEQUENT CALLS WITH N=NVAR.GT.0. X(I.GT.NVAR)
C-CGNRC ARE SUPPLEMENTED BY THOSE FROM XOLD. THIS IS BECAUSE (NUM. REC.)
C-CGNRC CG USES DIFFERENT VECTORS FOR ADJUSTED VALUES, RATHER THAN
C-CGNRC OVERWRITING THE ORIGINAL, NECESSARILY. SO THE DORMANT VALUES ARE
C-CGNRC NOT PRESENT.
C-CGNRC
C-CGNR      N=ncom
C-CGNRC
C-CGNR      IF(N.LT.0)THEN                          !STORE IN XOLD
C-CGNR        NOLD=-N
C-CGNR        DO I=1,NOLD
C-CGNR          XOLD(I)=X(I)
C-CGNR        ENDDO
C-CGNR        C=DZERO
C-CGNR        GO TO 10
C-CGNR      ELSEIF(N.GT.0)THEN                      !SUPPLEMENT X
C-CGNR        IF(NOLD.EQ.0)THEN
C-CGNR          WRITE(6,*)'*** CG: FUNC, NOT INITIALIZED'
C-CGNRC          STOP '*** CG: FUNC, NOT INITIALIZED'
C-CGNR          C=DZERO
C-CGNR          GO TO 10
C-CGNR        ENDIF
C-CGNR        DO I=N+1,NOLD
C-CGNR          X(I)=XOLD(I)
C-CGNR        ENDDO
C-CGNR      ELSE
C-CGNR        WRITE(6,*)'*** CG: FUNC, ILLEGAL INPUT N=0'
C-CGNRC        STOP '*** CG: FUNC, ILLEGAL INPUT N=0'
C-CGNR        C=DZERO
C-CGNR        GO TO 10
C-CGNR      ENDIF
C-CGNRC
C-CGNR      CALL CALCFX(NOLD,X,C)
C-CGNRC
C-CGNR      IF(NOLD.EQ.0)THEN
C-CGNR        WRITE(6,*)'*** CG: FUNC, CALCFX ABORTED'
C-CGNRC        STOP '*** CG: FUNC, CALCFX ABORTED'
C-CGNR        C=DZERO
C-CGNR        GO TO 10
C-CGNR      ENDIF
C-CGNRC
C-CGNR 10   FUNC=C
C-CGNRC
C-CGNR      RETURN
C-CGNR      END SUBROUTINE FUNC
C-CGNRC
C-CGNRC                             *******************
C-CGNRC
C-CGNR      SUBROUTINE DFUNC(X,G)
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNRC  SR.DFUNC EVALUATES THE GRADIENT (G(N)) OF THE FUNCTIONAL AT X.
C-CGNRC
C-CGNRC-----------------------------------------------------------------
C-CGNRC
C-CGNR      USE PRECSN, ONLY: BP,QP,SP,EP,WP
C-CGNR      USE PARAM
C-CGNR      USE CONSTANTS
C-CGNR
C-CGNR      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
C-CGNR      IMPLICIT LOGICAL(BP) (B)
C-CGNR      IMPLICIT INTEGER(SP) (I-N)
C-CGNR      IMPLICIT INTEGER(QP) (Q)
C-CGNRC
C-CGNR      INCLUDE './INCLUDE'
C-CGNRC
C-CGNR      PARAMETER (NMAX=50)                      !NUM. REC. DEFAULT
C-CGNR      DIMENSION pcom(NMAX),xicom(NMAX)         !NUM. REC. COMMON
C-CGNR      COMMON /f1com/ pcom,xicom,ncom           !NUM. REC. COMMON
C-CGNRC
C-CGNR      DIMENSION X(*),G(*)
C-CGNRC
C-CGNR      N=ncom
C-CGNRC
C-CGNR      DX=D1M4                    !SUBJECT TO CHANGE
C-CGNR      DX2=DX+DX
C-CGNRC
C-CGNR      DO I=1,N
C-CGNR        X(I)=X(I)+DX
C-CGNR        FP=FUNC(X)
C-CGNR        X(I)=X(I)-DX2
C-CGNR        FM=FUNC(X)
C-CGNR        X(I)=X(I)+DX
C-CGNR        G(I)=(FP-FM)/DX2
C-CGNR      ENDDO
C-CGNRC
C-CGNR      RETURN
C-CGNR      END SUBROUTINE DFUNC
C
C                             *******************
C
      SUBROUTINE CGNR(DEXTRE,NVAR,IMAXIT)
C
C-----------------------------------------------------------------------
C
C  SR.CGNR: THIS IS A DUMMY REPLACEMENT FOR THE INTERFACE ROUTINE TO THE
C  NUMERICAL RECIPES CONJUGATE GRADIENT BRANCH
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DEXTRE(*)
C
C SUPPRESS COMPILER WARNINGS (SIGH...)
C
      DDUM=DEXTRE(1)
      NDUM=NVAR
C
      WRITE(6,1000)
C
      WRITE(0,*)
     X'*** CGNR: DUMMY INTERFACE ROUTINE TO NUM REC CONJ GRAD ***'
C
      IMAXIT=-1
C
      RETURN
C
1000  FORMAT(//'*** THIS IS A DUMMY INTERFACE ROUTINE FOR THE NUMERICAL'
     X,' RECIPES CONJUGATE GRADIENT METHOD. SET NVAR.GT.0 TO USE VA04A.'
     X/'*** OR UNCOMMENT NON-DUMMY CGNR ROUTINE, RECOMPILE *AND* '
     X,'LINK TO YOUR OWN LICENSED NUMERICAL RECIPES LIBRARY!'///)
C
      END SUBROUTINE CGNR
C
C***********************************************************************
C
      FUNCTION CNORM(E,Z,L)
C
C-----------------------------------------------------------------------
C
C FN.CNORM RETURNS NORMALIZATION COEFFICIENT FOR A COULOMB FUNCTION OF
C ENERGY E, ANGULAR MOMENTUM L IN A CHARGE Z (<0) - BASED ON FCF4.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PI=ACOS(-DONE)
      ZZ=Z*Z
C
      IF(E.GT.D1M40)GO TO 6
      IF(ABS(Z).GT.D1M15)GO TO 3
C
   38 CNORM=DZERO                                     !FAILURE
C
      RETURN
C
    3 IF(Z.LT.DZERO)GO TO 5
    4 CNORM=-DONE
      GO TO 38
C
    5 C=-Z*(PI+PI)
      GO TO 11
C
    6 EK=SQRT(E)
      T1=PI*Z/EK
      T2=ABS(T1)
      IF(T2.GT.D1M2)GO TO 8
C
      C=DTHREE*EK/(DTHREE+T1*(DTHREE+T1*(DTWO+T1)))
      GO TO 11
C
    8 IF(T2.LT.D80)GO TO 10
      IF(Z.LT.DZERO)GO TO 5
      GO TO 4
C
   10 C=DONE-EXP(T1+T1)
      C=-(PI+PI)*Z/C
   11 C2=DONE
C
      IF(L.GT.0)THEN
        DO J=1,L
          CJ=J
          CJ2=J+J
          C2=C2*CJ*(CJ2+DONE)
          C=C*(ZZ+E*CJ*CJ)
   30     IF(C+C2.GE.D1P70)THEN
            C2=D1M5*C2
            C=D1M10*C
            GO TO 30
          ENDIF
        ENDDO
      ENDIF
C
      CNORM=SQRT(C)/C2
C
      RETURN
C
      END FUNCTION CNORM
C
C                             *******************
C

      SUBROUTINE CONFG(ICFG0,K2,MXORBR,MXORB,MXCONF,MXCCF,IFILL0,ival0)
C
C-----------------------------------------------------------------------
C
C  SR.CONFG GENERATES CONFIGURATION INPUT FOR THE A.S. OPTION
C
C     ICFG.EQ. 0 DEFAULT: READS USER INPUT OF THE VALENCE OCCUPATION NOS
C                         FOR THE MXCONF CONFIGS.
C         .EQ. 1 READS GLOBAL MIN AND MAX ALLOWED OCCUPATION NOS
C               (MNAL,MXAL) THEN AS ICFG=0, PLUS NUMBER OF EXCITATIONS
C                IN POSITION MXORB+1.
C         .EQ. 2 READS MNAL,MXAL FOR EACH(BASE)MXCONF CONFIG.
C         .GE. 0 WRITES THIS INFO TO A CONFIG.DAT FILE
C         .LT. 0 READS A PREVIOUSLY WRITTEN CONFIG.DAT FILE
C
C         MXCONF IS THUS REDEFINED FOR ICFG.NE.0.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      USE COMMON_DBD2,   ONLY: QL,QN
      USE COMMON_MQVC,   ONLY: LBASSH=>NEL,IAXGR,IAXCF
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=6) FORM,FORM2,FORM3
      CHARACTER(LEN=4) CSTAR
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      PARAMETER (MXD14=100)
      PARAMETER (MXD17=20)
C
      PARAMETER (FORM2='(60I2)')
      PARAMETER (FORM3='(40I3)')
C
      DIMENSION NGROUP(MXD17)
C
      ALLOCATABLE :: MNAL(:,:),MXAL(:,:),MXN(:,:)
     X              ,IBASSH(:,:),JBASSH(:,:),LOCSH(:)
     X              ,NXCITE(:),IOCSH(:),NSPARE(:),IGRP(:)
     X              ,NI(:),NTOTI(:),MN(:)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C
C SOME INITIALIZATIONS
C
      NCON1=0
      NGRP0=0
C
      NOPTN=MXCONF
      IFILL1=MOD(IFILL0,ITEN)
      IFILL2=IFILL0/10
C
      ICFG=MOD(ICFG0,ITEN)
C
      IF(ABS(ICFG).GT.2)THEN                    !ILLEGAL OPTIONAL VALUE
        WRITE(IWRITE,*)'*SR.CONFIG: ERROR, ICFG HAS ILLEGAL VALUE:',ICFG
        WRITE(0,*)'*SR.CONFIG: ERROR, ICFG HAS ILLEGAL VALUE:'
        GO TO 999
      ENDIF
C
      BPUNCH=ICFG0.GE.0
      BTWO=.FALSE.                       !***BTWO*** FIRST TREAT N-ELEC
      BBUG=.TRUE.
C
      IREAD=5
      IWRITE=6
      IPUNCH=3
C
      IF(IUNIT(IPUNCH).LE.0)THEN
        IF(BPUNCH)THEN
          OPEN(IPUNCH,FILE='CONFIG.DAT',STATUS='REPLACE')
        ELSE
          INQUIRE(FILE='CONFIG.DAT',EXIST=BEX)
          IF(BEX)THEN
            OPEN(IPUNCH,FILE='CONFIG.DAT',STATUS='OLD')
            WRITE(IWRITE,3000)IREAD
            IREAD=IPUNCH
          ELSE
            WRITE(6,*)'USER INPUT FILE "CONFIG.DAT" MISSING, '
     X               ,'BUT IS REQUIRED BECAUSE OF ICFG SETTING'
            WRITE(0,*)'USER INPUT FILE "CONFIG.DAT" MISSING, '
     X               ,'BUT IS REQUIRED BECAUSE OF ICFG SETTING'
            GO TO 999
          ENDIF
        ENDIF
        IUNIT(IPUNCH)=1
      ELSE
        REWIND(IPUNCH)
      ENDIF
C
C NUMBER OF CONFIGURATION SETS TO BE READ, AND ORBITALS
C
      IF(.NOT.BPUNCH)THEN                         !READ AN OLD CONFG.DAT
C
        ICFG=1
C
        READ(IREAD,*)K2,MXORB
C
        IF(MXORB.GT.MAXGR)THEN              !ONLY IF USER HAS RECOMPILED
          WRITE(IWRITE,3020)MXORB
          WRITE(0,*)'INCREASE MAXGR'               !FOR REMAINING COMMON
          GO TO 999
        ENDIF
C
        IF(MXORB.GT.IAXGR)THEN          !ONLY IF USER HAS CHANGED BUFFER
          WRITE(IWRITE,3021)MXORB
          WRITE(0,*)'INCREASE BUFFER IAXGR IN SR.ALGEB0'
          GO TO 999
        ENDIF
C
        MXORBR=MXORB
C
      ENDIF
C
      I00=ABS(K2)
      I0=I00+1
C
      IF(.NOT.BPUNCH)READ(IREAD,*)(QN(L),QL(L),L=I0,MXORB)
C
   1  IF(.NOT.BPUNCH)READ(IREAD,*)NOPTN
C
      IF(NOPTN.GT.MAXCF)THEN                       !FOR REMAINING COMMON
        WRITE(IWRITE,3010)NOPTN
        WRITE(0,*)'INCREASE MAXCF'
       GO TO 999
      ENDIF
C
      IF(BBUG)WRITE(IWRITE,3080)NOPTN,MXORB
C
      JAXCF=MAX(NOPTN,IAXCF)
C
      ALLOCATE (MNAL(MXORB,JAXCF),MXAL(MXORB,JAXCF),MXN(MXORB,JAXCF)
     X         ,IBASSH(MXORB,JAXCF),JBASSH(MXORB,JAXCF)
     X         ,NXCITE(JAXCF),IOCSH(JAXCF),NSPARE(JAXCF),IGRP(JAXCF)
     X         ,NI(MXORB),NTOTI(MXORB),MN(MXORB),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'CONFG: ALLOCATION FAILS FOR MNAL,MXAL,IBASSH...'
        NF=0
        GO TO 500
      ENDIF
C
C A CONFIGURATION SET CONSISTS OF MIN OCCUPATION NOS, MAX
C OCCUPATION NOS, OCCUPATION NOS OF A BASIC CONFIGURATION
C TOGETHER WITH NUMBER OF EXCITATIONS FROM THE BASIC CONFIG.
C
      IFLG3=0
      NCON=NOPTN
      IF(IEQ(0).GT.0.AND.BPUNCH)THEN
        NGRP=0
      ELSE
        NGRP=999999
        IGROUP=0
      ENDIF
      M2=0
C
      IF(ICFG.EQ.0)THEN
C
   4    IF(IEQ(0).GT.0)THEN
          READ(IREAD,*)IGROUP,NOPTN
          NGRP=NGRP+1
          IF(NGRP0+NGRP.LE.MXD17)THEN
            NGROUP(NGRP0+NGRP)=IGROUP
          ELSE
            WRITE(6,*)'*** sr.confg: increase local mxd17 to',ngrp0+ngrp
          ENDIF
        ENDIF
C
        M1=M2+1
        M2=M2+NOPTN
        if(m2.gt.jaxcf)stop 'sr.confg: increase iaxcf read allocation'
        DO M=M1,M2
          ICFGP(NCON1+M)=IGROUP
          NXCITE(M)=0
          READ(IREAD,*)(JBASSH(I,M),I=I0,MXORBR)
          IF(BBUG)WRITE(IWRITE,3110)M,(JBASSH(I,M),I=I0,MXORBR)
          DO I=I0,MXORBR
            IF(JBASSH(I,M).GT.9)IFLG3=1
          ENDDO
          DO I=MXORBR+1,MXORB      !CASE ICFG=10, MXORBR.LT.MXORB
            JBASSH(I,M)=0
          ENDDO
        ENDDO
C
        IF(NGRP.LT.NCON)GO TO 4
C        NOPTN=M2
        NCON=M2
        GO TO 200
C
      ENDIF
C
C
      IF(ICFG.EQ.1)THEN
C
   5    IF(IEQ(0).GT.0.AND.BPUNCH)THEN
          READ(IREAD,*)IGROUP,NOPTN
          NGRP=NGRP+1
          IF(NGRP0+NGRP.LE.MXD17)THEN
            NGROUP(NGRP0+NGRP)=IGROUP
          ELSE
            WRITE(6,*)'*** sr.confg: increase local mxd17 to',ngrp0+ngrp
          ENDIF
        ENDIF
C
        M1=M2+1
        M2=M2+NOPTN
        if(m2.gt.jaxcf)stop 'sr.confg: increase iaxcf read allocation'
C
        READ(IREAD,*)(MNAL(I,M1),I=I0,MXORBR)
        IF(BBUG)WRITE(IWRITE,3090)(MNAL(I,M1),I=I0,MXORBR)
        READ(IREAD,*)(MXAL(I,M1),I=I0,MXORBR)
        IF(BBUG)WRITE(IWRITE,3100)(MXAL(I,M1),I=I0,MXORBR)
C
        DO M=M1,M2
          IGRP(M)=IGROUP
          READ(IREAD,*,END=10)(IBASSH(I,M),I=I0,MXORBR),NXCITE(M)
          IF(BBUG)THEN
            WRITE(IWRITE,3110)M,(IBASSH(I,M),I=I0,MXORBR)
            IF(IEQ(0).LE.0.OR.BPUNCH)THEN
              WRITE(IWRITE,3120)NXCITE(M)
            ELSE
              WRITE(IWRITE,3121)IGRP(M)
            ENDIF
          ENDIF
          DO I=I0,MXORB
            MNAL(I,M)=MNAL(I,M1)
            MXAL(I,M)=MXAL(I,M1)
          ENDDO
          IFILL=IFILL1
          IF(BTWO)IFILL=IFILL2
          IF(IFILL.LT.0)IFILL=NXCITE(M)
          DO I=MXORBR+1,MXORB
            IBASSH(I,M)=0
            MNAL(I,M)=0
            MXAL(I,M)=IFILL
          ENDDO
        ENDDO
C
        IF(NGRP.LT.NCON)GO TO 5
C
        NOPTN=M2
        GO TO 20
C
  10    M=M-1
        WRITE(IWRITE,3040)NOPTN,M
        NOPTN=M
C        NCON=M
C
  20    IF(.NOT.BPUNCH)THEN    !JUST READ (PAST TENSE) A CONFIG.DAT FILE
C
          NOPTN0=NOPTN  !QUIETLY DROP DUPLICATE CFS, E.G. DUE TO MERGING
          DO M0=2,NOPTN0
            M=M0-NOPTN0+NOPTN
            DO L=1,M-1
              DO I=I0,MXORB
                IF(IBASSH(I,L).NE.IBASSH(I,M))GO TO 22
              ENDDO
              WRITE(0,*)'*** DUPLICATE CONFIGURATIONS',L,' AND',M0
              DO J=M+1,NOPTN                                       !DROP
                NXCITE(J-1)=NXCITE(J)
                DO I=I0,MXORB
                  IBASSH(I,J-1)=IBASSH(I,J)
                ENDDO
              ENDDO
              IF(M.LE.KCUT)KCUT=KCUT-1
              NOPTN=NOPTN-1
              GO TO 23
  22        ENDDO
  23      ENDDO
          NCON=NOPTN
C                                 TRANSFER TO FINAL LOCATION
          NEX=0
          IF(IEQ(0).GT.0)THEN
            DO M=1,NOPTN
              ICFGP(NCON1+M)=NXCITE(M)
              NXCITE(M)=0
              IEQ(0)=MAX(IEQ(0),ICFGP(NCON1+M))
            ENDDO
          ELSE
            DO M=1,NOPTN
              NEX=NEX+NXCITE(M)
            ENDDO
          ENDIF
          IF(NEX.EQ.0)THEN
            DO M=1,NOPTN
              DO I=I0,MXORB
                JBASSH(I,M)=IBASSH(I,M)
              ENDDO
            ENDDO
            GO TO 200
          ENDIF
C
        ENDIF
C
      ENDIF
C
C
      IF(ICFG.EQ.2)THEN
C
   6    IF(IEQ(0).GT.0)THEN
          READ(IREAD,*)IGROUP,NOPTN
          NGRP=NGRP+1
          IF(NGRP0+NGRP.LE.MXD17)THEN
            NGROUP(NGRP0+NGRP)=IGROUP
          ELSE
            WRITE(6,*)'*** sr.confg: increase local mxd17 to',ngrp0+ngrp
          ENDIF
        ENDIF
C
        M1=M2+1
        M2=M2+NOPTN
        if(m2.gt.jaxcf)stop 'sr.confg: increase iaxcf read allocation'
        DO M=M1,M2
          IGRP(M)=IGROUP
          READ(IREAD,*)(MNAL(I,M),I=I0,MXORBR)
          IF(BBUG)WRITE(IWRITE,3090)(MNAL(I,M),I=I0,MXORBR)
          READ(IREAD,*)(MXAL(I,M),I=I0,MXORBR)
          IF(BBUG)WRITE(IWRITE,3100)(MXAL(I,M),I=I0,MXORBR)
          READ(IREAD,*)(IBASSH(I,M),I=I0,MXORBR),NXCITE(M)
          IF(BBUG)THEN
            WRITE(IWRITE,3110)M,(IBASSH(I,M),I=I0,MXORBR)
            IF(IEQ(0).LE.0.OR.BPUNCH)THEN
              WRITE(IWRITE,3120)NXCITE(M)
            ELSE
              WRITE(IWRITE,3121)IGRP(M)
            ENDIF
          ENDIF
          IFILL=IFILL1
          IF(BTWO)IFILL=IFILL2
          IF(IFILL.LT.0)IFILL=NXCITE(M)
          DO I=MXORBR+1,MXORB
            IBASSH(I,M)=0
            MNAL(I,M)=0
            MXAL(I,M)=IFILL
          ENDDO
        ENDDO
C
        IF(NGRP.LT.NCON)GO TO 6
        NOPTN=M2
C
      ENDIF
C
c perform sanity checks. this is to catch typos etc.
c
  25  do m=1,noptn
        if(nxcite(m).lt.0)nxcite(m)=0
        do i=i0,mxorbr
          if(mxal(i,m).lt.0)mxal(i,m)=0
          if(mnal(i,m).lt.0)mnal(i,m)=0
          if(ibassh(i,m).lt.0)ibassh(i,m)=0
          im=ibassh(i,m)-nxcite(m)
          if(mnal(i,m).lt.im)mnal(i,m)=im
          mx=4*ql(i)+2
          if(mnal(i,m).gt.mx)mnal(i,m)=mx
          if(mxal(i,m).gt.mx)mxal(i,m)=mx
          if(ibassh(i,m).gt.mx)ibassh(i,m)=mx
          ip=ibassh(i,m)+nxcite(m)
          if(mxal(i,m).gt.ip)mxal(i,m)=ip
        enddo
        if(ival0.gt.0)mxal(ival0,m)=0                 !suppress Ryd orb.
      enddo
C
C DETERMINE NUMBER OF ELECTRONS
C
      NELC=0
      DO I=I0,MXORB
        NELC=NELC+IBASSH(I,1)
      ENDDO
      IF(BBUG)WRITE(IWRITE,3270)NELC
C
C CHECK OTHER CONFIGS FOR CONSISTENCY
C
      IFAIL=0
      DO M=2,NOPTN
        N=0
        DO I=I0,MXORB
          N=N+IBASSH(I,M)
        ENDDO
        IF(N.NE.NELC)THEN
          IFAIL=1
          WRITE(IWRITE,3280)M,N
        ENDIF
      ENDDO
C
      IF(IFAIL.NE.0)THEN
        WRITE(6,*)'SR.CONFG ERROR: CONFIGURATION MIS-MATCH'
        WRITE(0,*)'SR.CONFG ERROR: CONFIGURATION MIS-MATCH'
        GO TO 999
      ENDIF
C
C PERFORM SOME CHECKS ON MNAL AND MXAL FOR CONSISTENCY
C
      IFAIL=0
      DO M=1,NOPTN
        NSPARE(M)=NELC
        DO I=I0,MXORB
          NSPARE(M)=NSPARE(M)-MNAL(I,M)
        ENDDO
        IF(NSPARE(M).LT.0)THEN
          WRITE(IWRITE,3290)M
          IFAIL=1
        ENDIF
      ENDDO
C
      IF(IFAIL.NE.0)THEN
        WRITE(6,*)'SR.CONFG ERROR: MNAL INCONSISTENCY'
        WRITE(0,*)'SR.CONFG ERROR: MNAL INCONSISTENCY'
        GO TO 999
      ENDIF
C
      DO M=1,NOPTN
        DO I=I0,MXORB
          NE=MNAL(I,M)+NSPARE(M)
          IF(NE.LT.MXAL(I,M))THEN
            MXAL(I,M)=NE
            WRITE(IWRITE,3300)I,M
          ENDIF
          MXN(I,M)=MXAL(I,M)+1
        ENDDO
      ENDDO
C
C CHECK CONSISTENCY OF BASIC CONFIG WITH MNAL,MXAL AND
C STORE LAST OCCUPIED SHELL FOR EACH BASIC CONFIGURATION
C
      IFAIL=0
      DO M=1,NOPTN
        DO I=I0,MXORB
          J=MXORB-I+I0
          IF(IBASSH(J,M).GT.0)THEN
            IOCSH(M)= J
            DO L=I0,J
              IF(IBASSH(L,M).GT.MXAL(L,M).and.l.ne.ival0)THEN
                WRITE(IWRITE,3292)M
                IFAIL=1
              ELSEIF(IBASSH(L,M).LT.MNAL(L,M))THEN
                WRITE(IWRITE,3295)M
                IFAIL=1
              ENDIF
            ENDDO
            GO TO 90
          ENDIF
          IF(MNAL(J,M).GT.0)THEN
            WRITE(IWRITE,3295)M
            IFAIL=1
          ENDIF
        ENDDO
   90 ENDDO
C
      IF(IFAIL.NE.0)THEN
        WRITE(6,*)'SR.CONFG ERROR: BASIC CONFIG INCONSISTENCY'
        WRITE(0,*)'SR.CONFG ERROR: BASIC CONFIG INCONSISTENCY'
        GO TO 999
      ENDIF
C
C LOOP OVER ALL POSSIBLE ELECTRON DISTRIBUTIONS
C
      NCON=0
      DO M=1,NOPTN
C
        n2cum=0
        do i=i0,mxorb
          n2cum=n2cum+mnal(i,m)
        enddo
c
        I=I00
C
  110   I=I+1
        n2cum=n2cum-mnal(i,m)
        NI(I)= 0
C
  120   NI(I)= NI(I)+ 1
        NSTOP=I
C
        MI=MXN(I,M)- NI(I)
        IF(MI.LT.MNAL(NSTOP,M))GO TO 130
        NTOT=MI
        IF(I.GT.I0)NTOT=NTOT+NTOTI(I-1)
        NTOTI(I)= NTOT
        MN(I)= MI
        IF(NTOT+n2cum.GT.NELC)GO TO 130
        IF(NTOT.LT.NELC)GO TO 125
C
C CHECK FOR CORRECT PARITY (IF NECESSARY)
C
        IF(IPAR.LT.2)THEN
          LPAR=0
          DO L=I0,NSTOP
            IF(MOD(INT(QL(L),SP),ITWO).NE.0)LPAR=LPAR+MN(L)
          ENDDO
          IF(MOD(LPAR,ITWO).NE.IPAR)GO TO 125
        ENDIF
C
C TEST FOR EXCITATION ALLOWED FROM THE BASIC CONFIGURATIONS
C
        NEX=0
        DO L=I0,IOCSH(M)
          IF(L.GT.NSTOP)THEN
            NEX=NEX+IBASSH(L,M)
            GO TO 30
          ENDIF
          NB=IBASSH(L,M)
          NA=MN(L)
          IF(NA.LT.NB)NEX=NEX+NB-NA
   30   ENDDO
C
        IF(NEX.LE.NXCITE(M))THEN  !ALLOWED
C
          DO N=1,NCON               !SEE IF WE ALREADY HAVE IT
            DO L=I0,NSTOP
              IF(MN(L).NE.JBASSH(L,N))GO TO 122
            ENDDO
            GO TO 125               !OLD
  122     ENDDO
C
          IF(BTWO)THEN           !SEE IF N+1 CAN BE FORMED FROM N CONFIG
            IDIFF1=1             !FOR R-MATRIX
C            IDIFF1=3             !FOR DR
            DO L=NSTOP+1,MXORB
              MN(L)=0
            ENDDO
            DO N=1,NCON1
              IDIFF=0
              LMAX=MAX(NSTOP,LOCSH(N))
              DO L=I0,LMAX
                IDIFF=IDIFF+ABS(LBASSH(L,N)-MN(L))
              ENDDO
              IF(mod(IDIFF,ITWO).EQ.0)THEN
                WRITE(6,*)'SR.CONFG ERROR: IDIFF=0!!'
                WRITE(0,*)'SR.CONFG ERROR: IDIFF=0!!'
c         write(*,*)n,idiff
               GO TO 999
              ENDIF
              IF(IDIFF.le.IDIFF1)GO TO 124  !O.K.
            ENDDO
c        write(*,*)n,idiff
            GO TO 125
          ENDIF
C NEW
  124     NCON=NCON+1
          IF(NCON.GT.JAXCF)THEN                               !GO TO 500
C
            JXXX=7*(JAXCF/5+1)
C
            WRITE(6,*)'*** CONFG: increasing MAXCF from ',JAXCF,' to: '
     X                ,JXXX
            WRITE(0,*)'*** CONFG: increasing MAXCF from ',JAXCF,' to: '
     X                ,JXXX
C
            CALL RE_ALLOC2(MNAL,IONE,MXORB,IONE,JAXCF,MXORB,JXXX,IERR)
            CALL RE_ALLOC2(MXAL,IONE,MXORB,IONE,JAXCF,MXORB,JXXX,IERR)
            CALL RE_ALLOC2(MXN,IONE,MXORB,IONE,JAXCF,MXORB,JXXX,IERR)
            CALL RE_ALLOC2(IBASSH,IONE,MXORB,IONE,JAXCF,MXORB,JXXX,IERR)
            CALL RE_ALLOC2(JBASSH,IONE,MXORB,IONE,JAXCF,MXORB,JXXX,IERR)
C
            CALL RE_ALLOC(NXCITE,IONE,JAXCF,JXXX,IERR)
            CALL RE_ALLOC(IOCSH,IONE,JAXCF,JXXX,IERR)
            CALL RE_ALLOC(NSPARE,IONE,JAXCF,JXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SR.CONFG: RE-ALLOCATION FAILS FOR XBASSH ETC'
              NF=0
              GO TO 500
            ENDIF
C
            JAXCF=JXXX
C
          ENDIF
C
          ICFGP(NCON1+NCON)=IGRP(M)
C
          DO L=I0,NSTOP
            JBASSH(L,NCON)=MN(L)
            IF(MN(L).GT.9)IFLG3=IFLG3+1
          ENDDO
          DO L=NSTOP+1,MXORB
            JBASSH(L,NCON)=0
          ENDDO
C
        ENDIF
C
  125   IF(I.LT.MXORB)GO TO 110
        IF(I.GT.MXORB)GO TO 140
C
  130   IF(NI(I).LT.MXN(I,M))GO TO 120
        n2cum=n2cum+mnal(i,m)
        I=I-1
        IF(I.GT.I00)GO TO 130
C
  140 ENDDO
C
C DETERMINE GLOBAL MAX AND MIN OCCUPATIONS
C
      DO M=2,NOPTN
        DO L=I0,MXORB
          MNAL(L,1)=MIN(MNAL(L,1),MNAL(L,M))
          MXAL(L,1)=MAX(MXAL(L,1),MXAL(L,M))
        ENDDO
      ENDDO
C
C WRITE CONFIGS TO FILE
C (CURRENTLY, NO GROUP INFO WRITTEN, SO CUT-AND-PASTE TO UNIT5 & ADD.)
C
  200 IF(BPUNCH)THEN
        IF(IFLG3.EQ.0)THEN
          FORM=FORM2
        ELSE
          FORM=FORM3
        ENDIF
        IF(.NOT.BTWO)THEN
          WRITE(IPUNCH,3060)I0-1,MXORB
          WRITE(IPUNCH,3070)(QN(L),QL(L),L=I0,MXORB)
        ENDIF
        WRITE(IPUNCH,3060)NCON
        WRITE(IPUNCH,FORM)(MNAL(L,1),L=I0,MXORB)
        WRITE(IPUNCH,FORM)(MXAL(L,1),L=I0,MXORB)
        DO N=1,NCON
          WRITE(IPUNCH,FORM)(JBASSH(L,N),L=I0,MXORB),ICFGP(NCON1+N)
        ENDDO
      ENDIF
C
      IF(BTWO)THEN                        !FALSE ON FIRST PASS)
C
        DEALLOCATE (LOCSH,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG: DEALLOCATION FAILS FOR (BTWO) LOCSH'
          NF=0
          GO TO 500
        ENDIF
C
        MXCCF=NCON
        NCON=NCON+NCON1
C
        IF(NCON.GT.IAXCF)THEN
C
c          IXXX=NCON
C                     ESTIMATE TO REDUCE POSSIBILITY OF FURTHER RE-ALLOC
          IXXX=10*NCON1+MXCCF
C
          WRITE(6,*)'** CONFG: increasing MAXCF from ',IAXCF,' to: '
     X              ,IXXX
          WRITE(0,*)'** CONFG: increasing MAXCF from ',IAXCF,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC2(LBASSH,IONE,MXORB,IONE,NCON1,IAXGR,IXXX,IERR)
C                                                     NOT MXORB
          IAXCF=IXXX
C
        ENDIF
C
C ARCHIVE N+1-ELEC AT END OF CF STORAGE
C
        NN=IAXCF-MXCCF
        DO N=1,MXCCF
          IN=N-1
          ICFGP(IAXCF-IN)=ICFGP(NCON-IN)
          NN=NN+1
          DO L=I0,MXORB
            LBASSH(L,NN)=JBASSH(L,N)
          ENDDO
        ENDDO
C
        GO TO 300                        ! *** RETURN
C
      ENDIF                              !END N+1
C
      BTWO=MXCCF.NE.0                    ! ***BTWO***
C
      IF(NCON.GT.IAXCF)THEN
C
        DEALLOCATE (LBASSH,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG: DEALLOCATION FAILS FOR LBASSH=>NEL'
          NF=0
          GO TO 500
        ENDIF
C
        IAXCF=NCON
        IF(BTWO)IAXCF=3*IAXCF      !3* TO REDUCE CHANCE OF N+1 RE-ALLOC
C
        ALLOCATE (LBASSH(IAXGR,IAXCF),STAT=IERR)   !AS MXORB NOT MAXIMAL
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG: ALLOCATION FAILS FOR LBASSH=>NEL'
          NF=0
          GO TO 500
        ENDIF
C
      ENDIF
C
C ARCHIVE N-ELEC
C
      DO N=1,NCON
       DO I=I0,MXORB
          LBASSH(I,N)=JBASSH(I,N)
        ENDDO
      ENDDO
C
      IF(BTWO)THEN                                   !NOW TREAT N+1-ELEC
C
        ALLOCATE (LOCSH(NCON),STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG: ALLOCATION FAILS FOR LOCSH'
          NF=0
          GO TO 500
        ENDIF
C
        DO N=1,NCON
          DO I=I0,MXORB
            IF(LBASSH(I,N).GT.0)LOCSH(N)=I
          ENDDO
        ENDDO
C
        NCON1=NCON
        NGRP0=NGRP
        ICFG=1
C
        IF(ICFG0.LT.0)THEN
          DEALLOCATE (MNAL,MXAL,MXN,IBASSH,JBASSH,NXCITE,IOCSH
     X               ,NSPARE,IGRP,NI,NTOTI,MN,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SR.CONFG:DEALLOCATION FAILS FOR MNAL,MXAL,IBASSH'
            NF=0
            GO TO 500
          ENDIF
          GO TO 1
        ENDIF
C
        IF(MXCCF.LT.0)THEN               !FORM N+1 SET
          IF(IEQ(0).GT.0)THEN
            WRITE(IWRITE,*)
     X          "***SR.CONFG: CANNOT USE MXCCF.LT.0 WITH BASIS='SRLX'"
            WRITE(0,*)"SR.CONFG: NEED MXCCF.GT.0 FOR BASIS='SRLX'"
            GO TO 999
          ENDIF
          NOPTN=1
          DO I=I0,MXORB
            IBASSH(I,1)=JBASSH(I,1)
            IF(MXAL(I,1).LT.4*QL(I)+2)MXAL(I,1)=MXAL(I,1)+1
          ENDDO
          NXCITE(1)=NXCITE(1)+1
          II=LOCSH(1)
          IF(IBASSH(II,1).LT.4*QL(II)+2)THEN
            IBASSH(II,1)=IBASSH(II,1)+1
          ELSE
            II=II+1
            IBASSH(II,1)=1
            IF(MXORBR.LT.II)MXORBR=II
          ENDIF
          IF(BBUG)THEN
            M=1
            WRITE(IWRITE,3080)NOPTN,MXORBR
            WRITE(IWRITE,3090)(MNAL(I,M),I=I0,MXORBR)
            WRITE(IWRITE,3100)(MXAL(I,M),I=I0,MXORBR)
            WRITE(IWRITE,3110)M,(IBASSH(I,M),I=I0,MXORBR)
            WRITE(IWRITE,3120)NXCITE(M)
          ENDIF
          GO TO 25
        ELSE
          ICFG=ICFG0/10
          NOPTN=MXCCF
          DEALLOCATE (MNAL,MXAL,MXN,IBASSH,JBASSH,NXCITE,IOCSH
     X               ,NSPARE,IGRP,NI,NTOTI,MN,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SR.CONFG:DEALLOCATION FAILS FOR MNAL,MXAL,IBASSH'
            NF=0
            GO TO 500
          ENDIF
          GO TO 1
        ENDIF
      ENDIF
C
  300 MXCONF=NCON
C
      IF(IEQ(0).GT.0.AND.ICFG0.GE.0)THEN              !CHECK GROUP NOS
        NGPMIN=9999
        NGPMAX=0
        NGRP=NGRP+NGRP0
        IEQ(0)=NGRP
        DO N1=1,NGRP
          NGPMIN=MIN(NGPMIN,NGROUP(N1))
          NGPMAX=MAX(NGPMAX,NGROUP(N1))
          DO N2=N1+1,NGRP
             IF(NGROUP(N2).EQ.NGROUP(N1))THEN
               WRITE(6,*)'SR.CONFG ERROR: GROUP NO. INCONSISTENCY'
               WRITE(0,*)'SR.CONFG ERROR: GROUP NO. INCONSISTENCY'
               DO N=1,NGRP
                 IF(N.EQ.N1.OR.N.EQ.N2)THEN
                   CSTAR=' ***'
                 ELSE
                   CSTAR='    '
                 ENDIF
                 WRITE(6,*)NGROUP(N),CSTAR
               ENDDO
               GO TO 999
             ENDIF
          ENDDO
        ENDDO
        IF(NGPMIN.LE.0)THEN
          WRITE(6,*)'SR.CONFG ERROR: NEGATIVE GROUP NO. NOT ALLOWED'
          WRITE(0,*)'SR.CONFG ERROR: NEGATIVE GROUP NO. NOT ALLOWED'
          GO TO 999
        ENDIF
        IF(NGPMAX.GT.NGRP)THEN
          WRITE(6,*)'SR.CONFG ERROR: NO GAPS IN GROUP NUMBERS ALLOWED'
          WRITE(0,*)'SR.CONFG ERROR: NO GAPS IN GROUP NUMBERS ALLOWED'
          GO TO 999
        ENDIF
      ENDIF
C
      DEALLOCATE (MNAL,MXAL,MXN,IBASSH,JBASSH,IGRP,NXCITE,IOCSH
     X           ,NSPARE,NI,NTOTI,MN,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'SR.CONFG: DEALLOCATION FAILS FOR MNAL,MXAL,IBASSH'
        NF=0
      ENDIF
C
  500 CONTINUE
C
      IF(IUNIT(3).GT.0)THEN
        CLOSE(3)
        IUNIT(3)=-1
      ENDIF
C
      RETURN
C
  999 NF=-1
      GO TO 500
C
 3000 FORMAT(/' NOTE: READING CONFIGURATIONS FROM FILE CONFIG.DAT:'
     X,' ANY CONFIGURATION DATA ON UNIT',I3,' WILL BE IGNORED.'/)
 3010 FORMAT(' INCREASE MAXCF TO',I7)
 3011 FORMAT(' INCREASE BUFFER IAXCF IN SR.ALGEB0 TO',I7)
 3020 FORMAT(' INCREASE MAXGR TO',I5)
 3021 FORMAT(' INCREASE BUFFER IAXGR IN SR.ALGEB0 TO',I5)
 3040 FORMAT(/'NO. OF CONFIGS REDUCED FROM',I5,' TO',I5,'; ALL THAT'
     X       ,' ARE PRESENT IN CONFIG.DAT FILE'/)
 3060 FORMAT(2I5)
 3070 FORMAT(30(I3,I2))
 3080 FORMAT(/6X,'OPTION CHOSEN, NOPTN=',I5,' FOR ORBITALS MXORB='
     X       ,I4)
 3090 FORMAT(
     X       ' THE MINIMUM NUMBER OF ELECTRONS ALLOWED IN THIS SHELL IS'
     X       ,2X,(20I3))
 3100 FORMAT(
     X       ' THE MAXIMUM NUMBER OF ELECTRONS ALLOWED IN THIS SHELL IS'
     X       ,2X,(20I3))
 3110 FORMAT(' BASIC CONFIGURATION',I5,34X,(20I3))
 3120 FORMAT(' THE MAXIMUM NUMBER OF ELECTRON EXCITATIONS REQUIRED=',
     X       I3)
 3121 FORMAT(' GROUP NUMBER',I3)
 3270 FORMAT(' TOTAL NUMBER OF ELECTRONS =',I3)
 3280 FORMAT(' ERROR, CONFIGURATION ',I5,' HAS ',I3,' ELECTRONS')
 3290 FORMAT(' ERROR, TOO MANY ELECTRONS REQUIRED BY MNAL FOR'
     X        ,' CONFIGURATION',I5)
 3292 FORMAT(' ERROR, BASIC OCCUPATION NO GT MXAL FOR CONFIG ',I5)
 3295 FORMAT(' ERROR, BASIC OCCUPATION NO LT MNAL FOR CONFIG ',I5)
 3300 FORMAT(' WARNING, MXAL TOO LARGE FOR ORBITAL ',I4
     X        ,' IN CONFIGURATION ',I5)
C
      END SUBROUTINE CONFG
C
C                             *******************
C
      SUBROUTINE CONFG0(RUN,ICFG,MXVORB,MXCONF,MXCCF,KCUTCC,NXTRA,LXTRA
     X                 ,LCONT,LCON0,KCUT0,IFILL)
C
C-----------------------------------------------------------------------
C
C  SR.CONFG0 READS USER INPUT, CONFIGURATIONS FOR CASE A.S. VIA
C  FREE-FORMAT OCCUPATION NUMBERS R-MATRIX STG2 STYLE. INDEED, IT CALLS
C  A MODIFIED SR.CONFIG TO APPLY PROMOTION RULES ETC.
C  ALSO, AUTOMATICALLY GENERATES N+1 ELECTRON CONFIGS FROM
C  N-ELECTRON TARGET, FOR BOUND-CONTINUUM PROBLEMS (DR/RR ETC.)
C
C  IT CALLS:
C    SR.CONFG
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,KMAX,NEL,IAXGR,IAXCF
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=4) CODE,RUN
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)                !NO. OF NON-SEQ RYD N-VALUES
C
      ALLOCATABLE :: KORDER(:)                                   !LOCAL
C
      COMMON /BASIC/NF,KX,KG,K1,K2,MGAP(7)
c      COMMON /NRBAL0/IRET0,LORIG,LMIN,MPRNT0,MOD0,MSTRT0,BPASS,MLIT(2)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      BDR=IDR.NE.0
      KPOLE=MPOLE/2
      KPOL0=MPOL00/2                        !.LT.0 FLAGS HISTORIC SET-UP
      MPOL00=ABS(MPOL00)                               !NOW REMOVE FLAG
C
      MXCCF0=MXCCF
      IF(MXCCF.LT.0)THEN
        MXCCF=MOD(MXCCF,I999)
        IF(MOD(ICFG,ITEN).EQ.0)MXCCF=0               !INITIALIZE DEFAULT
      ENDIF
C
      IF(MXVORB.NE.0)THEN
C
C READ NL DEFINITIONS. CORE BASE CONFIGS WILL CONTAIN MXVORBS
C
        MXORB=ABS(K2)+ABS(MXVORB)
        IF(MXORB.GT.MAXGR)THEN                     !FOR REMAINING COMMON
          WRITE(6,1004)MXORB
          WRITE(0,*)'*** SR.CONFG0: TOO MANY ORBITALS, INCREASE MAXGR'
          GO TO 999
        ENDIF
C
        IF(MXORB.GT.IAXGR)THEN
C
          WRITE(6,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X              ,' to: ',MXORB
          WRITE(0,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X              ,' to: ',MXORB
C
          DEALLOCATE (NEL,QL,QN)
          IAXGR=MXORB
C
          ALLOCATE (NEL(IAXGR,IAXCF),STAT=IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SR.CONFG0: ALLOCATION FAILS FOR NEL'
            NF=0
            GO TO 996
          ENDIF
C
          ALLOCATE (QL(IAXGR),QN(IAXGR),STAT=IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SR.CONFG0: RE-ALLOCATION FAILS FOR QL,QN'
            NF=0
            GO TO 996
          ENDIF
C
        ENDIF
C
        IF(K1.GT.1)THEN
          WRITE(6,1005)K1
          WRITE(0,*)
     X        '*** SR.CONFG0: CLOSED SHELLS MUST BE ORBITALS 1,2,3...'
          GO TO 999
        ENDIF
C
        I0=ABS(K2)+1           !SO ALL CLOSED MUST BE BEFORE ALL OPEN
C
        IF(K2.LE.0)THEN
          KS=0
        ELSE
          KS=K2
        ENDIF
C
        IF(MXVORB.GT.0)THEN                           !REDEFINE, MAYBE
          READ(5,*)(QN(I),QL(I),I=KS+1,MXORB)
          DO I=KS+1,MXORB
            IF(QN(I).LT.1.OR.QL(I).LT.0.OR.QL(I).GE.QN(I))THEN
              WRITE(6,1110)I,QN(I),QL(I)
              WRITE(0,*)'*** SR.CONFG0: ILLEGAL NL COMBINATION!'
              GO TO 999
            ENDIF
          ENDDO
        ELSE                                           !STANDARD ORDER
           MXVORB=-MXVORB
           II=INT(SQRT(DTWO*MXORB))+1
           K=0
           DO I=1,II
             DO  L=1,I
               K=K+1
               IF(K.LE.MXORB)THEN
                 QN(K)=I
                 QL(K)=L-1
               ENDIF
             ENDDO
          ENDDO
        ENDIF
C
C SET-UP DEFAULT PARTIAL WAVE EXPANSION FOR PROBLEM
C
        ival0=0
        IF((RUN.NE.'  '.OR.MXCCF.GT.0).and.(LCON.LT.0.or.lcon0.lt.0))
     X                                                             THEN
          LC=0
          LC0=0
          LCONT=LCON
          LCONT0=LCON0
          DO I=I0,MXORB
            IF(QN(I).LT.80)then
              LC=MAX(LC,INT(QL(I),SP))
            elseif(qn(i).lt.90)then              !flag core re-arrange
              lc0=-1
              if(.not.bdr)ival0=i
            else                          !flag user continuum present
              lc=-1
            endif
          ENDDO
          if(lc.ge.0)then
            if(bfot)then
              if(bdr)then
                if(lcon0.lt.0.and.lc0.lt.0)lcon0=lc+2
                if(lcmin.lt.0.and.kpol0.ge.lmax)lcmin=kpol0-lmax
                if(lcon.lt.0)then
                  lcon=kpole+1
                  lcon=lcon+min(lmax,kpole)
                  if(lcmin.gt.0)lcon=lcon-lcmin
                endif
              else
                if(lcmin.lt.0.and.kpol0.ge.lc)lcmin=kpol0-lc
                if(lcon.lt.0.and.kpole.gt.0)then
                  lcon=lc+kpole+1
                  if(lcmin.gt.0)lcon=lcon-lcmin     !l=lcmin,...lcon-1
                endif
              endif
            else
              LC=2*LC+1                     !AS QL=L HERE, NOT 2*L YET
              if(bdr)then
                lc=min(5_sp,lc)
                if(abs(MODD).le.1)lc=max(5_sp,lc)
                if(lcon0.lt.0.and.lc0.lt.0)lcon0=min(lc,3_sp)!for s-hole
              endif
              if(lcon.lt.0)lcon=lc
            endif
          endif
          IF((RUN.NE.'  '.OR.MXCCF.GT.0).AND.LC.GE.0.AND.IDW.EQ.0)THEN
            IF(LCONT.LT.0)WRITE(6,1007)LCON
            IF(LCONT0.LT.0.AND.LC0.LT.0)WRITE(6,1003)LCON0
          ENDIF
          LCONT=LCON
        ENDIF
C
C EXTEND USER SPECIFIED ORBITAL SET
C       (needs standard ordering, wrt to mxorbx)
C
        MXORBX=MXORB
        IF(NXTRA.GT.0.AND.ICFG.NE.0)THEN                      !FILL-IN
C
          QNX=QN(MXORBX)
          QLX=QL(MXORBX)
C
          IF(LXTRA.LT.0)LXTRA=QLX
c
          do i=i0,mxorbx                           !i=1 -> i=i0
            if(qn(i).gt.qnx)then                   !nxtra will duplicate
              write(6,1114)i,qn(i),qnx,i,mxorbx
              go to 999
            elseif(qn(i).eq.qnx)then
              if(ql(i).gt.qlx)then                 !lxtra will duplicate
                write(6,1115)i,ql(i),qlx,i,mxorbx
                go to 999
              endif
            endif
          enddo
C
  10      K=MXORB
          MNT=MIN(IAXGR,MAXGR)
          IMX=MIN(LXTRA,INT(QNX-1,SP))
          DO I=QLX+1,IMX                     !COMPLETE SUBSHELL
            K=K+1
            IF(K.LE.MNT)THEN
              QN(K)=QNX
              QL(K)=I
            ENDIF
          ENDDO
C
          DO N=QNX+1,NXTRA
            LMX=MIN(LXTRA,N-1)
            DO L=0,LMX
              K=K+1
              IF(K.LE.MNT)THEN
                QN(K)=N
                QL(K)=L
              ENDIF
            ENDDO
          ENDDO
C
          IF(K.GT.MAXGR)THEN                       !FOR REMAINING COMMON
            WRITE(6,1004)K
            WRITE(0,*)'*** SR.CONFG0: TOO MANY ORBITALS, INCREASE MAXGR'
            GO TO 999
          ENDIF
C
          IF(K.GT.IAXGR)THEN
C
            WRITE(6,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X                ,' to: ',K
            WRITE(0,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X                ,' to: ',K
C
            DEALLOCATE (NEL)
            IAXGR=K
C
            ALLOCATE (NEL(IAXGR,IAXCF),STAT=IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SR.CONFG0: ALLOCATION FAILS FOR NEL'
              NF=0
              GO TO 996
            ENDIF
C
            CALL RE_ALLOC(QL,IONE,MXORB,IAXGR,IERR)
            CALL RE_ALLOC(QN,IONE,MXORB,IAXGR,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SR.CONFG0: RE-ALLOCATION FAILS FOR QL,QN'
              NF=0
              GO TO 996
            ENDIF
C
            GO TO 10
C
          ENDIF
C
          MXORB=K
C
        ENDIF
C
      ELSE
        WRITE(0,*)
     X         'INPUT MXVORB IN NAMELIST SALGEB MUST BE SET .NE. ZERO'
        GO TO 999
      ENDIF
C
C READ CONFIGURATION INPUT.
C
      IF(MXCONF.GT.0.OR.ICFG.LT.0)THEN
c
        iflagcf=0
c user flags split target for cont/ryd
c (need to sync with run_PP if increase 1000 to 10000, say)
        if(run.ne.'  '.and.mxconf.ge.1000)then
          mc1=mxconf/1000                     !cont on these only
          mc2=mxconf-1000*mc1                 !addtional Ryd only
          mxconf=mc1+mc2                      !tot target cfs to read
          if(icfg.gt.0)then
            iflagcf=mxconf                    !cannot promote
          endif
        else
          mc1=999999999                       !all
          mc2=0
        endif
C
        CALL CONFG(ICFG,K2,MXORBX,MXORB,MXCONF,MXCCF,IFILL,ival0)
C
        IF(NF.LE.0)GO TO 996                                   !RETURN
c
        if(iflagcf*(mxconf-mxccf).gt.iflagcf*iflagcf.or.
     x     iflagcf*(mxconf-mxccf).lt.iflagcf*iflagcf.and.ival0.eq.0)
     x                                                            then
          write(6,*)
     x         'sr.confg0: cannot mix ICFG.gt.0 with MXCONF.ge.1000'
          write(0,*)
     x         'sr.confg0: cannot mix ICFG.gt.0 with MXCONF.ge.1000'
          go to 999
        endif
C
        IF(MXCONF.GT.MAXCF)THEN                    !FOR REMAINING COMMON
          WRITE(6,1006)MXCONF
          WRITE(0,*)'*** INCREASE MAXCF'
          GO TO 999
        ENDIF
C
        IF(MXCONF.GT.IAXCF)THEN          !TOO LATE TO SALVAGE BUFFER ETC
          WRITE(6,1066)MXCONF            !SHOULD NOT HAPPEN NOW
          WRITE(0,*)'*** INCREASE BUFFER IAXCF IN SR.ALGEB0'
          GO TO 999
        ENDIF
C
        IF(IDW.NE.0)THEN
          MXCONF=MXCONF-MXCCF
          MXCCF=0
        ENDIF
C
C SET-UP N+1 PROBLEM, FOR TARGET SEPCIFIED
C
        IF(RUN.NE.'  '.OR.MXCCF.GT.0)THEN
          IVAL=0                     !ASSUME SINGLE RYD ORBITAL
          ISUM=0
          DO I=I0,MXORB              !I=1 -> I=I0
            IF(QN(I).GE.90)THEN      !CONT ORB ALREADY SET, ASSUME N+1
              IF(MXCCF.GT.0)THEN     !MOVE N+1 CFGS BACK
                M0=IAXCF+1                                     !MAXCF
                KMAX=MXCONF-MXCCF
                DO K=MXCCF,1,-1
                  KMAX=KMAX+1
                  M=M0-K
                  ICFGP(KMAX)=ICFGP(M)
c          write(0,*)kmax,m,'*',(NEL(i,m),i=i0,mxorb)
                  DO II=I0,MXORB
                    NEL(II,KMAX)=NEL(II,M)
                    IF(NEL(II,M).GT.0.AND.QN(II).GE.80)THEN
                      WRITE(6,*)
     X              '***ALGEB ERROR: RYD/CONT ORB FOUND IN MXCCF CFGS'
                      WRITE(0,*)
     X              '***ALGEB ERROR: RYD/CONT ORB FOUND IN MXCCF CFGS'
                      GO TO 999
                    ENDIF
                  ENDDO
                ENDDO
              ENDIF
              GO TO 70
            ENDIF
            IF(QN(I).GE.80)THEN      !SEE IF ANY CORE RE-ARRANGEMENT
              IVAL=I
              ISUM=ISUM+1
            ENDIF
          ENDDO
C
          KT=MXCONF-MXCCF           !NO OF TARGET CFGS
          JVAL=0
          IF(IVAL.GT.0)THEN !SPECIFY RYD IN TARGET FOR CORE RE-ARRANGE
C
            IF(.NOT.BDR)THEN  !PRESENT IN ORB LIST BUT NOT CFGS NOW
              WRITE(6,*)'***ALGEB NOTE: RUN NOT SET FOR RYD ORBS'
              IF(MOD(ICFG,ITEN).EQ.0)THEN
                WRITE(0,*)'***ALGEB NOTE: RUN NOT SET FOR RYD ORBS'
                WRITE(6,*)'***USE MOD(ICFG,10).GT.0 TO DROP'
                WRITE(0,*)'***USE MOD(ICFG,10).GT.0 TO DROP'
                GO TO 999
              ENDIF
            ENDIF
            IF(ISUM.GT.1)THEN
              WRITE(6,*)'***ALGEB ERROR: CAN ONLY SET ONE RYDBERG ORB'
              WRITE(0,*)'***ALGEB ERROR: CAN ONLY SET ONE RYDBERG ORB'
              GO TO 999
            ENDIF
            IF(IVAL.NE.MXORB)THEN
              WRITE(6,*)'***ALGEB ERROR: RYDBERG ORB MUST BE LAST SET'
              WRITE(0,*)'***ALGEB ERROR: RYDBERG ORB MUST BE LAST SET'
              GO TO 999
            ENDIF
            IF(BDR)THEN
              IVAL=1
            ELSE
              IVAL=0
            ENDIF
C
            K0=KT
            DO K=KT,1,-1     !SEE WHICH TARGET CONFIGS TO SKIP RYD
              IF(NEL(MXORB,K).NE.0)THEN
                JVAL=JVAL+1
                K0=K-1
              ENDIF
            ENDDO
C
            IF(JVAL.EQ.0)THEN   !GET USER TO RESET INCASE IN N+1
             WRITE(6,*)'***ALGEB NOTE: RYD ORB NOT USED, COULD REMOVE'
C            WRITE(0,*)'***ALGEB NOTE: RYD ORB NOT USED, COULD REMOVE'
C              GO TO 999        !NOW CHECKED CFGS EXPLICITLY ABOVE
            ENDIF
            IF(KT-JVAL.NE.K0)THEN
              WRITE(6,*)'***ALGEB ERROR: MUST LIST RYD TARG CFGS LAST'
              WRITE(0,*)'***ALGEB ERROR: MUST LIST RYD TARG CFGS LAST'
              GO TO 999
            ENDIF
C
          ENDIF
C
          IRYD=0
          IF(BDR)IRYD=1     !FLAG SPACE FOR RYDBERG CFGS (NON-CORE)
          IF(LCON.LT.0)THEN
            LCON=3
            WRITE(6,1007)LCON
          ENDIF
          IF(JVAL.GT.0)THEN
            IF(LCON0.LT.0)THEN
              LCON0=3
              WRITE(6,1003)LCON0
            ENDIF
          ELSE
            LCON0=0
          ENDIF
C
C NEW MXCONF
          if(mc2.eq.0)then
            IYYY=(KT-JVAL)*(LCON+IRYD)+JVAL*LCON0+MXCCF
          else
            IYYY=mc1*LCON+(KT-JVAL)*IRYD+JVAL*LCON0+MXCCF
          endif
C
          IF(IYYY.GT.MAXCF)THEN                    !FOR REMAINING COMMON
            WRITE(6,1006)IYYY
            WRITE(0,*)'*** INCREASE MAXCF'
            GO TO 999
          ENDIF
C
C NEW MXORB
          I8TY=IRYD-IVAL
          IXXX=MXORB+LCON+LCON0+I8TY
C
          IF(IXXX.GT.MAXGR)THEN                    !FOR REMAINING COMMON
            WRITE(6,1004)IXXX
            WRITE(0,*)'SR.CONFG0: TOO MANY ORBITALS, INCREASE MAXGR'
            GO TO 999
          ENDIF
C
C MAY INCREASE ALLOC
          IF(IXXX.GT.IAXGR.OR.IYYY.GT.IAXCF)THEN
C
            IXX1=MAX(IXXX,IAXGR)              !BUT DO NOT REDUCE "OTHER"
            IYY1=MAX(IYYY,IAXCF)              !BUT DO NOT REDUCE "OTHER"
C
            CALL RE_ALLOC2(NEL,IONE,MXORB,IONE,IAXCF,IXX1,IYY1,IERR)
C                                               N+1
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SR.CONFG0: RE-ALLOCATION FAILS FOR NEL'
              NF=0
              GO TO 999
            ENDIF
C
            IF(IYYY.GT.IAXCF)THEN             !REPOSITION N+1
C
              WRITE(6,*)'*** CONFG0: increasing MAXCF from ',IAXCF
     X                  ,' to: ',IYYY
              WRITE(0,*)'*** CONFG0: increasing MAXCF from ',IAXCF
     X                  ,' to: ',IYYY
C
              M=IYYY+1
              N=IAXCF+1
              DO J=1,MXCCF
                M=M-1
                N=N-1
                ICFGP(M)=ICFGP(N)
                DO I=I0,MXORB
                  NEL(I,M)=NEL(I,N)
                ENDDO
              ENDDO
C
              IAXCF=IYYY
C
            ENDIF
C
            IF(IXXX.GT.IAXGR)THEN
C
              WRITE(6,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X                  ,' to: ',IXXX
              WRITE(0,*)'*** CONFG0: increasing MAXGR from ',IAXGR
     X                  ,' to: ',IXXX
C
              CALL RE_ALLOC(QL,IONE,MXORB,IXXX,IERR)
              CALL RE_ALLOC(QN,IONE,MXORB,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'SR.CONFG0: RE-ALLOCATION FAILS FOR QN, QL'
                NF=0
                GO TO 999
              ENDIF
C
              IAXGR=IXXX
C
            ENDIF
C
          ENDIF
C
          MXCONF=IYYY                         !.LE. IAXCF
C
          IF(I8TY.GT.0)THEN
            MXORB=MXORB+I8TY
            QN(MXORB)=80
            QL(MXORB)=LCON/2
          ENDIF
C
          KMAX=MXCONF-MXCCF                   !NO OF CONT + RYD CFGS
          KK=KMAX
          LLL=LCON+LCON0
          DO K=KT,1,-1
            IF(IVAL.GT.0.AND.NEL(MXORB,K).NE.0)THEN
              KK=KK-LCON0
              DO L=1,LCON0
                KK=KK+1
                ICFGP(KK)=ICFGP(K)
                DO I=I0,MXORB
                  NEL(I,KK)=NEL(I,K)
                ENDDO
                DO LL=1,LLL
                  NEL(MXORB+LL,KK)=0
                ENDDO
                NEL(MXORB+LCON+L,KK)=1
              ENDDO
              KK=KK-LCON0
            ELSE
              IF(I8TY.GT.0)NEL(MXORB,K)=0
C              KK=(K-1)*LCON+IRYD*KT
             if(k.le.mc1)then
              KK=KK-LCON
              DO L=1,LCON
                KK=KK+1
                ICFGP(KK)=ICFGP(K)
                DO I=I0,MXORB
                  NEL(I,KK)=NEL(I,K)
                ENDDO
                DO LL=1,LLL
                  NEL(MXORB+LL,KK)=0
                ENDDO
                NEL(MXORB+L,KK)=1
              ENDDO
              KK=KK-LCON
             endif
              IF(IRYD.GT.0)THEN
                NEL(MXORB,K)=NEL(MXORB,K)+IRYD
                DO LL=1,LLL
                  NEL(MXORB+LL,K)=0
                ENDDO
              ENDIF
            ENDIF
          ENDDO
C
C PROCESS ANY N+1 CFGS
C
          IF((RUN.EQ.'PI'.OR.RUN.EQ.'DR'.OR.RUN.EQ.'YLD')
     X                                   .AND.MXCCF.EQ.0)THEN
            WRITE(6,1008)RUN
            IF(RUN.EQ.'PI'.OR.RUN.EQ.'YLD')THEN
              IF(MXCCF0.EQ.-999)THEN                   !USER DID NOT SET
                WRITE(0,*)
     X              'PI/YLD ERROR: NO INITIAL N+1 BOUND CFGS SPECIFIED!'
                GO TO 999
              ELSE                !ALLOW "DEBUG" OF TARGET+CONT ENERGIES
                WRITE(0,*)
     X            'PI/YLD WARNING: NO INITIAL N+1 BOUND CFGS SPECIFIED!'
              ENDIF
            ELSE
              WRITE(0,*)'DR/PE WARNING: NO N+1 BOUND CFGS SPECIFIED!'
            ENDIF
          ENDIF
C
          IF(MXCCF.GT.0)THEN             !MOVE N+1 CFGS BACK
            M0=IAXCF+1                               !MAXCF
            I2=MXORB-I8TY
            I1=LCON+LCON0+I8TY
            DO K=MXCCF,1,-1
              KMAX=KMAX+1
              M=M0-K
              ICFGP(KMAX)=ICFGP(M)
c          write(0,*)kmax,m,'*',(NEL(i,m),i=i0,mxorb)
              DO I=I0,I2
                NEL(I,KMAX)=NEL(I,M)
              ENDDO
              DO I=1,I1
                NEL(I2+I,KMAX)=0
              ENDDO
            ENDDO
          ENDIF
C
C INITIALIZE ORBITALS (DUMMY IF BDR)
C
          LM=-1
          IF(LCMIN.GT.0)LM=LM+LCMIN
          DO L=1,LCON
            QN(MXORB+L)=90
            QL(MXORB+L)=L+LM
          ENDDO
          MXORB=MXORB+LCON
          DO L=1,LCON0
            QN(MXORB+L)=99
            QL(MXORB+L)=L-1
          ENDDO
          MXORB=MXORB+LCON0
          MXVORB=MXORB-I0+1
          LCONT=LCON
C
C
C NOW BUBBLE SORT TO SEPARATE SPECTROSCOPIC AND CORRELATION.
C IN THIS INSTANCE USER INPUT KCUT/P REFER TO KT TARGET CFS AS
C USER DOES NOT KNOW NO. OF N+1 CFS RESULTANT, SO KCUT AND
C KCUTP SHOULD BE THE SAME, IF NOT TAKE KCUTP.
C USE KCUTCC TO SPECIFY SUBSET OF THE MXCCF N+1 BOUND CFGS
C THIS IS RELATIVE TO MXCFF ONLY AND IS INDEPENDENT OF KCUT/P.
C
          IF(KCUT+KCUTP+KCUTCC.GT.0)THEN
C
            IF(KCUTP.GT.0.AND.KCUTP.NE.KCUT)THEN
              IF(KCUT.GT.0)THEN
                WRITE(0,*)'***ATTENTION, USING KCUTP TO DEFINE TARGET'
                WRITE(6,*)'***ATTENTION, USING KCUTP TO DEFINE TARGET'
              ENDIF
              KCUT=KCUTP
            ENDIF
C
            IF(KCUTCC.EQ.0)KCUTCC=MXCCF
C                   KCUTI=KCUT0
            IF(KCUT+KCUT0.EQ.0)THEN      !NO RE-ORDER, JUST RESET KCUT
              KCUTP=MXCONF-MXCCF+KCUTCC
            ELSE                           !LABEL FOR SORTING
              if(mc2.gt.0)then
                write(6,*)' confg0: currently, cannot set kcut when ',
     x                    'using different target cfs for cont & Ryd'
                write(0,*)' confg0: currently, cannot set kcut when ',
     x                    'using different target cfs for cont & Ryd'
                go to 999
              endif
C
              ALLOCATE (KORDER(MXCONF))
C
              IF(KCUT.GT.0)KCUT=MIN(KCUT,KT)
              IF(KCUT0.EQ.0)KCUT0=JVAL     !KCUTI=KCUT0
              KMAX=(KT-JVAL)*(LCON+IRYD)
              KCUTP=0
              IF(BDR)THEN
                KA=1
                KB=KCUT
                DO K=KA,KB
                  KORDER(K)=1              !RYD SPECTROSCOPIC
                ENDDO
                KCUTP=KCUTP+KB-KA+1
                KA=KB+1
                KB=KT-JVAL
                DO K=KA,KB
                  KORDER(K)=5              !RYD CORRELATION
                ENDDO
              ELSE
                KB=0
              ENDIF
              KA=KB+1
              KB=KB+KCUT*LCON
              DO K=KA,KB
                KORDER(K)=2                !CONT SPECTROSCOPIC
              ENDDO
              KCUTP=KCUTP+KB-KA+1
              KA=KB+1
              KB=KMAX
              DO K=KA,KB
                KORDER(K)=6                !CONT CORRELATION
              ENDDO
              KA=KB+1
              KB=KB+KCUT0*LCON0            !KCUTI=KCUT0
              DO K=KA,KB
                KORDER(K)=3                !CORE CONT SPECTROSCOPIC
              ENDDO
              KCUTP=KCUTP+KB-KA+1
              KA=KB+1
              KB=KMAX+JVAL*LCON0
              DO K=KA,KB
                KORDER(K)=7                !CORE CONT CORRELATION
              ENDDO
              KA=KB+1
              KB=KB+KCUTCC
              DO K=KA,KB
                KORDER(K)=4                !N+1 SPECTROSCOPIC
              ENDDO
              KCUTP=KCUTP+KB-KA+1
              KA=KB+1
              KB=MXCONF
              DO K=KA,KB
                KORDER(K)=8                !N+1 CORRELATION
              ENDDO
c
c              do i=1,mxconf
c                write(6,*)i,korder(i)
c              enddo
C BEGIN SORT
              DO I=1,MXCONF
                K=I
                IP=KORDER(K)
                DO J=I+1,MXCONF
                  IF(KORDER(J).LT.IP)THEN
                    K=J
                    IP=KORDER(J)
                  ENDIF
                ENDDO
                IF(K.NE.I)THEN
                  KORDER(K)=KORDER(I)
                  KORDER(I)=IP
                  II=ICFGP(I)
                  ICFGP(I)=ICFGP(K)
                  ICFGP(K)=II
                  DO J=I0,MXORB
                    IP=NEL(J,I)
                    NEL(J,I)=NEL(J,K)
                    NEL(J,K)=IP
                  ENDDO
                ENDIF
              ENDDO
C
              DEALLOCATE (KORDER)
C
            ENDIF
            KCUT=KCUTP
          ENDIF
C
C END ANY N+1 SET-UP
C
        ENDIF
C
  70    CONTINUE
C
C WRITE CF OUTPUT IN CONFIG.DAT FORMAT
C
        WRITE(6,1011)MXCONF,MXORB
        WRITE(6,1012)(QN(I),QL(I),I=I0,MXORB)
        IGROUP=0
        DO K=1,MXCONF
          IF(IGROUP.NE.ICFGP(K))THEN                   !IEQ(0).GT.0
            IGROUP=ICFGP(K)
            WRITE(6,1009)IGROUP
          ENDIF
          WRITE(6,1010)K,(NEL(I,K),I=I0,MXORB)
c          do i=i0,mxorb                   !algeb0 check, remove evently
c            if(NEL(i,k).lt.0)then                          !not defined
c              write(6,*)'*** Bug, orbital not defined, setting =0'
c              write(0,*)'*** Bug, orbital not defined, setting =0',k,i
c              NEL(i,k)=0
c            endif
c          enddo
          IF(KCUT.GT.0.AND.K.EQ.KCUT)WRITE(6,*)
        ENDDO
        WRITE(6,1111)
C
C CHECK CFS
C
        CALL DIMUSE('MAXCF',MXCONF)
        CALL DIMUSE('MAXGR',MXORB)
C
        KMAX=MXCONF                             !FINAL TOTAL CF FOR MQVC
C
        DO J=1,KMAX
C
cold          READ(5,*)(NEL(I,J),I=I0,MXORB)
C
          DO L=1,J-1
            DO I=I0,MXORB
              IF(NEL(I,L).NE.NEL(I,J))GO TO 69
            ENDDO
C
            WRITE(6,*)
            WRITE(6,*)'***SR.CONFG0: CONFIGURATIONS',L,' AND',J,
     X                ' ARE IDENTICAL!'
            WRITE(0,*)'SR.CONFG0: DUPLICATE CONFIGURATIONS PRESENT!'
            GO TO 999                             !RETURN
  69      ENDDO
C
        ENDDO
C
      ELSE
        WRITE(0,*)
     X'SR.CONFG: INPUT MXCONF IN NAMELIST SALGEB MUST BE SET GT ZERO'
        GO TO 999                                 !RETURN
      ENDIF
C
 996  RETURN
C
 999  NF=-1
      GO TO 996
C
 1003 FORMAT('***ATTENTION: LCON0 RE-SET TO',I5)
 1004 FORMAT(' TOO MANY ORBITALS, INCREASE DIMENSION OF MAXGR TO:',I4)
 1005 FORMAT(' A.S. CODE REQUIRES KCOR1=1 (OR 0), REDEFINE ORBITALS SO'
     X,' THAT CLOSED SHELLS ARE 1,2,3 ETC. CURRENTLY KCOR1=',I2)
 1006 FORMAT(' TOO MANY CONFIGURATIONS, INCREASE DIMENSION OF MAXCF TO:'
     X,I6,5X,'- OR MORE, IF ICFG.NE.0')
 1066 FORMAT(' INCREASE BUFFER IAXCF IN SR.ALGEB0 TO AT LEAST',I6)
 1007 FORMAT('***ATTENTION: LCON  RE-SET TO',I5)
 1008 FORMAT('*** ATTENTION: RUN=',A4,' BUT NO N+1 BOUND CFGS SPECIFIED'
     X/' SET MXCCF.GT.0 TO SPECIFY AS FOR N CFGS, OR .LT.0 FOR INTERNAL'
     X,' GENERATION - REQUIRES ICFG.NE.0'/)
 1009 FORMAT(I2,'::')
 1010 FORMAT(I4,':',(60I2))
 1011 FORMAT(/2I5)
 1012 FORMAT(30(I3,I2))
 1110 FORMAT(/'*** ILLEGAL NL COMBINATION FOR ORBITAL',I3,' N L =',2I4)
 1111 FORMAT(//1X,138('-')//)
 1114 FORMAT(/'*** ERROR: ORBITAL',I3,' HAS AN N-VALUE',I3,', LARGER'
     X,' THAN THE LAST USER-SPECIFIED ONE',I3/4X,'NXTRA WILL DUPLICATE'
     X,', SO RE-ORDER TO MAKE ORBITAL',I3,' ORBITAL',I3)
 1115 FORMAT(/'*** ERROR: ORBITAL',I3,' HAS AN L-VALUE',I3,', LARGER'
     X,' THAN THE LAST USER-SPECIFIED ONE',I3/4X,'LXTRA WILL DUPLICATE'
     X,', SO RE-ORDER TO MAKE ORBITAL',I3,' ORBITAL',I3)
C
      END SUBROUTINE CONFG0
C
C                             *******************
C
      SUBROUTINE CONFG1
C
C-----------------------------------------------------------------------
C
C  SR.CONFG1:
C    FOR 'S.S.' INPUT, DECODES THE KMAX INPUT CONFIGURATIONS FROM THE
C    INPUT IN IWRK1+IWRK2, PREVIOUSLY LOADED IN ALGEB0.
C    FOR 'A.S.' INPUT, MAINLY CHECK AND INITIALIZE.
C    OPTIONALLY, SET-UP FOR RELAXED ORBITALS (BOTH)
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL,IAXCL
      USE COMMON_DBD2,   ONLY: QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,KMAX,NEL,IAXGR,IAXCF
      USE COMMON_NRBRN2, ONLY: MENGB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXRED=90)                 !S.S. REDEFINED ORBITALS
      PARAMETER (MXLIT=60)                 !S.S. NO. ORBS CHAR DEFINED
      PARAMETER (MXLIT0=30)                !S.S. NO. ORB OCCUP. NOS
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD07=100)       !S.S. NO. OF UNIT5 CONFIG INPUT LINES
      PARAMETER (MXD08=MXD07*21)  !S.S. MXD07*NO. OF CHARS/LINE *FIXED*
      PARAMETER (MXD12=100)                !NO. OF NON-SEQ RYD N-VALUES
      PARAMETER (MXD14=100)
C
      CHARACTER(LEN=1) LIT0,LIT
      CHARACTER(LEN=4) CODE
c
      ALLOCATABLE :: ICHK(:)
C
      DIMENSION LIT(MXLIT),LIT0(MXLIT0)
C
      COMMON /BASIC/NF,KY,KG,JA,JB,MGAP(7)
      COMMON /CHARY/DEY(MAXGR)
c      COMMON /OUTP1/MPRINT
      COMMON /SSWRK/IWRK1(MXD08),IWRK2(MXD08)
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C
      NAMELIST/SRADWIN/KEY
C
      DATA LIT0(1),LIT0(2),LIT0(3),LIT0(4),LIT0(5) /'0','1','2','3','4'/
     X    ,LIT0(6),LIT0(7),LIT0(8),LIT0(9),LIT0(10)/'5','6','7','8','9'/
     X,LIT0(11),LIT0(12),LIT0(13),LIT0(14),LIT0(15)/'A','B','C','D','E'/
     X,LIT0(16),LIT0(17),LIT0(18),LIT0(19),LIT0(20)/'F','G','H','I','J'/
     X,LIT0(21),LIT0(22),LIT0(23),LIT0(24),LIT0(25)/'K','L','M','N','O'/
     X,LIT0(26),LIT0(27),LIT0(28),LIT0(29),LIT0(30)/'P','Q','R','S','T'/
C
      DATA LIT( 1),LIT( 2),LIT( 3),LIT( 4)  /'1','2','3','4'/,
     X     LIT( 5),LIT( 6),LIT( 7),LIT( 8)  /'5','6','7','8'/,
     X     LIT( 9),LIT(10),LIT(11),LIT(12)  /'9','A','B','C'/,
     X     LIT(13),LIT(14),LIT(15),LIT(16)  /'D','E','F','G'/,
     X     LIT(17),LIT(18),LIT(19),LIT(20)  /'H','I','J','K'/,
     X     LIT(21),LIT(22),LIT(23),LIT(24)  /'L','M','N','O'/,
     X     LIT(25),LIT(26),LIT(27),LIT(28)  /'P','Q','R','S'/,
     X     LIT(29),LIT(30),LIT(31),LIT(32)  /'T','U','V','W'/,
     X     LIT(33),LIT(34),LIT(35),LIT(36)  /'X','Y','Z','a'/,
     X     LIT(37),LIT(38),LIT(39),LIT(40)  /'b','c','d','e'/,
     X     LIT(41),LIT(42),LIT(43),LIT(44)  /'f','g','h','i'/,
     X     LIT(45),LIT(46),LIT(47),LIT(48)  /'j','k','l','m'/,
     X     LIT(49),LIT(50),LIT(51),LIT(52)  /'n','o','p','q'/,
     X     LIT(53),LIT(54),LIT(55),LIT(56)  /'r','s','t','u'/,
     X     LIT(57),LIT(58),LIT(59),LIT(60)  /'v','w','x','y'/
C
      LBLNK=ICHAR(' ')
C
      BDR=IDR.NE.0
      BCONTSS=CODE.EQ.'S.S.'.OR.lcmin.EQ.-999      !ASSIGN L_C BY PARITY
C
      BLF=.FALSE.
C
      ALLOCATE (ICHK(IAXCF))                       !CF OCC. CHECK
C
      IF(QQCUT.LE.0)THEN
        IF(QCUT.NE.LBLNK)THEN
          DO I=10,12
            IF(QCUT.EQ.ICHAR(LIT(I)))QQCUT=I-8
          ENDDO
        ELSE
          QQCUT=1                    !DEFAULT ALL 2FS
        ENDIF
      ENDIF
C
C DEFINE GROUP INDICES K=1,2,..MAXGR FOR NL=1S,2S,2P...;
C K MAY HAVE BEEN REDEFINED THROUGH INPUT, SEE LOOP 31
C
      MNT=MIN(MAXGR,IAXGR)
      MNTL=MIN(MXLIT,MNT)
      II=INT(SQRT(DTWO*MNTL))+1
      K=0
      DO I=1,II
        DO L=1,I
          K=K+1
          IF(K.GT.MNT)GO TO 32                            !MAXGR
C
          IF(CODE.EQ.'S.S.'.OR.K.LE.ABS(JB))THEN
            DEY(K)=DZERO
            IF(JB.GE.0)THEN
              QN(K)=I
              QL(K)=L-1
            ENDIF
            QL(K)=QL(K)*2
          ENDIF
C
        ENDDO
      ENDDO
C
  32  JB=ABS(JB)                      !KCOR2 PASSED FROM ALGEB0
      JB1=JB+1
C
      IF(CODE.EQ.'S.S.')THEN
        BLT=.FALSE.
        NT=MIN(MXRED,MAXGR)
        MNT=NT
        M15=15
        K21=KG+18
  55    IF(IWRK1(K21).NE.LBLNK)THEN
          K21=K21+21
          M15=M15+15
          GO TO 55
        ENDIF
        MNT=MIN(MNT,M15)
      ELSE                             !CODE.EQ.'A.S.'
        BLT=.TRUE.
        MNT=MXORB
        DO K=JB1,MXORB
          DEY(K)=DZERO
          QL(K)=QL(K)*2
        ENDDO
      ENDIF
c
      do i=1,jb
        if(qn(i).eq.qn(jb1).and.ql(i).eq.ql(jb1))then
          write(0,*)'SR.ALGEB:CLOSED SHELLS OVERLAP VALENCE!'
          go to 999
        endif
      enddo
C
      IVAL=0
      L=999
C
      IF(BDR)THEN
co        LCO=-1
        if(lcmin.ge.0)then                     !absolute
          ic=-lnew+lcmin-1
        else                                   !relative
          IC=(LCON-1)/2
          IF(IC.GT.LNEW.AND..NOT.BCONTSS)IC=LNEW         !new initialize
          IC=-IC-1
        endif
      ENDIF
C
      DO K=1,MNT
C
        IF(CODE.EQ.'S.S.')THEN                 !ORBITAL REDEF. LINE
          I=KG+K+2
          KX=(K-1)/15
          I=I+6*KX
          IF(IWRK2(I).EQ.0)GO TO 31
          QN(K)=IWRK2(I)
          DO M=1,30
            IF(IWRK1(I).EQ.ICHAR(LIT0(M)))THEN
              L=M-1
              GO TO 27
            ENDIF
          ENDDO
          GO TO 24
        ENDIF
C
  27    IF(.NOT.BDR)GO TO 61
        IF(.NOT.BLOOP)GO TO 61
        IF(QN(K).LT.80)GO TO 61
        IF(QN(K).EQ.99)GO TO 61
        IF(QN(K).LT.90)THEN              !RYDBERG
          IVAL=IVAL+1
          IF(IVAL.GT.1)WRITE(6,101)
C
          L=LNEW
C          IF(NMIN.LT.L+1)NMIN=L+1        !BYPASSED BY RESTART, SO MINIM
          GO TO 60
        ENDIF
C                                        !CONTINUUM
c       if(l.eq.lco.and.bcontss)then      !cannot see use for lco
c         write(0,*) 'confg1: l=lco...',l
c         go to 999
c       endif
co   IF(L.NE.LCO.or..not.bcontss)    !FOR S.S. - why? lcon=2 still wrong
       IC=IC+1
co        LCO=L
        L=LNEW+IC
        IF(L.LT.0)THEN                   !not poss with new initialize
          IP=LCON/2
          IP=IP+L
          IP=1-2*mod(abs(IP),ITWO)         !(-1)**IP
          IP=IP*(1-2*mod(abs(LNEW),ITWO))  !(-1)**LNEW
          IM=1-(1-2*mod(abs(LCON),ITWO))   !(-1)**LCON
          IM=IM/2
          IP=IP*IM
          L=L+LCON+IP
        ENDIF
        GO TO 60
C
  61    IF(CODE.EQ.'A.S.')GO TO 31       !BOUND ALREADY DEFINED
C
  60    QL(K)=2*L
        BLT=.TRUE.
        IF(QN(K).GT.L)GO TO 31
C
  24    WRITE(6,93)K,QN(K),IWRK1(I)
        BLF=.TRUE.
C
  31  ENDDO
C
C DECODE INPUT ARRAYS IWRK1 AND IWRK2 (ACCORDING TO GROUP DEFINITION)
C OF KMAX CONFIGURATIONS, EACH CONFIGURATION KF DEFINED BY THE NUMBER
C NEL(K,KF) OF EQUIVALENT ELECTRONS N,L=QN(K),QL(K)/2;
C DECODE CLOSED SHELL CONFIGURATION C0 (OF NW ELECTRONS) COMMON TO
C ALL KMAX CONFIGURATIONS (THIS FACILITY REDUCES STORAGE REQUIREMENTS)
C
C
      BLG=.FALSE.
C
      IF(CODE.EQ.'S.S.')THEN
C
        MXORB=0
        KMAX=0
        DO  I=1,KG
          IF(IWRK1(I).EQ.LBLNK)GO TO 36
          M=IWRK2(I)
C
          DO K=1,MNTL                                             !MAXGR
            IF(IWRK1(I).NE.ICHAR(LIT(K)))GO TO 39
            DEY(K)=DONE
            MXORB=MAX(K,MXORB)
C
            IF(M.GT.50)THEN
              M=M-50
              IF(KMAX.GT.0)GO TO 35
            ENDIF
C
            KMAX=KMAX+1
C
            IF(KMAX.GT.IAXCF)THEN               !UNLIKELY FOR USER TYPED
              WRITE(6,192)MAXCF
              GO TO 999
            ENDIF
C
            IF(KMAX.GT.MAXCF)THEN                  !FOR REMAINING COMMON
              IF(.NOT.BLF)THEN
                WRITE(6,92)MAXCF
                BLF=.TRUE.
              ENDIF
              KMAX=KMAX-1
            ENDIF
C
            J1=MNTL
            IF(IEQ(0).NE.0)J1=IAXGR                    !RELAXED: ZEROIZE
            DO J=1,J1                                             !MAXGR
              NEL(J,KMAX)=0
            ENDDO
            ICHK(KMAX)=0
C
  35        IF(K.LT.JA.OR.K.GT.JB)THEN
              L=NEL(K,KMAX)+M
              NEL(K,KMAX)=L
              ICHK(KMAX)=ICHK(KMAX)+M
              IF(L.GT.(QL(K)+1)*2)THEN
                WRITE(6,97)L,QN(K),QL(K)/2,KMAX
                BLF=.TRUE.
              ENDIF
            ENDIF
            GO TO 36
C
  39      ENDDO
C
          J=(I-1)/21+1
          L=(I-(J-1)*21)*3+9
          IF(MAXGR.LE.MXLIT)THEN
            WRITE(6,89)IWRK1(I),I,J,L,MAXGR
          ELSE
            WRITE(6,189)IWRK1(I),I,J,L,MXLIT
          ENDIF
          BLF=.TRUE.
  36    ENDDO
C
        CALL DIMUSE('MAXCF',KMAX)
C
C DUPLICATE CONFGS WILL BE DROPPED QUIETLY OR FLAGGED, SEE IF(BLG) BELOW
C
        KMAX0=KMAX
        DO K0=2,KMAX0
          K=K0-KMAX0+KMAX
          DO L=1,K-1
            DO J=1,MNTL                                           !MAXGR
              IF(NEL(J,L).NE.NEL(J,K))GO TO 42
            ENDDO
            BLG=.TRUE.
            WRITE(6,*)'*** DUPLICATE CONFIGURATIONS',L,' AND',K0
            DO I=K+1,KMAX                          !DROP, MAY STOP LATER
              DO J=1,MNTL                                         !MAXGR
                NEL(J,I-1)=NEL(J,I)
              ENDDO
            ENDDO
            IF(K.LE.KCUT)KCUT=KCUT-1
            KMAX=KMAX-1
            GO TO 43
  42      ENDDO
  43    ENDDO
C
        IF(BLF)GO TO 999
C
      ELSE                          !'A.S.'
C
        DO K=1,KMAX                 !SET IN CONFG0
C
          ICHK(K)=0
          DO J=JB1,MXORB            !SET IN CONFG0
            IF(NEL(J,K).NE.0)THEN
              ICHK(K)=ICHK(K)+NEL(J,K)
              DEY(J)=DONE
            ENDIF
          ENDDO
C
          IF(IEQ(0).NE.0)THEN                   !RELAXED: ZEROIZE
            DO J=MXORB+1,IAXGR
              NEL(J,K)=0
            ENDDO
          ENDIF
C
        ENDDO
C
      ENDIF
C
      MXBORB=0
      MXVORB=0
C
      DO J=JB1,MXORB
        IF(QN(J).LT.80)MXBORB=MAX(J,MXBORB)
        IF(QN(J).LT.90)MXVORB=MAX(J,MXVORB)
      ENDDO
C
      IF(BFOT)THEN                !FOR PLANTING E_K POINTERS
        MXORBR=MXORB
      ELSE
        MXORBR=MXVORB
      ENDIF
C
      MXORBR=MXORBR-JB                                            !FLAGX
C
      MXORB=MAX(MXORB,ISCALR)     !FOR SLATER SCALING DUMMY ORB
C
      CALL DIMUSE('MAXGR',MXORB)
C
      IF(MENGB.GE.0)THEN          !I.E. BBORN
        K=MXORB-JB
C        IF(JA.GT.0)K=K+JA-1       !JA=1 FIXED
        IF(K.GT.MXGRB)THEN        !TOO MANY ORBS FOR BORN
          IF(MXGRB.GT.0)WRITE(6,*)
     X        '***SR.CONFG1: ALLOCATION INCTREASES MXGRB TO ',K
        ENDIF
        CALL DIMUSE('MXGRB',K)
      ENDIF
C
      DO K=1,MXORB        !INITIALIZE MAP
        IEQ(K)=K
      ENDDO
C
C SET-UP COMMON CORE OF CONFIGS
C
      IF(JB.GT.0)THEN
        IAXCL=0
        DO J=1,JB
          IAXCL=IAXCL+2*(QL(J)+1)
        ENDDO
      ELSE
        IAXCL=1                                       !FOR RESTART WRITE
      ENDIF
C
      ALLOCATE (NNL(IAXCL,3))
C
      NW=0
      MB=JB                                                         !MB0
      IF(JB.GT.0)THEN
        IF(JA.EQ.0)JA=1
        MA=JA                                                       !MA0
        DO J=JA,JB
          DEY(J)=DONE
          L=QL(J)
C
  82      I=NW+1
          NW=I+1
          IF(NW.GT.IAXCL)THEN            !DIMENSION EXCEEDED - SHOULDN'T
            WRITE(6,95) IAXCL
            GO TO 999
          ENDIF
          DO K=I,NW
            NNL(K,1)=J
            NNL(K,2)=L
            NNL(K,3)=(NW-K)*2-1
          ENDDO
          L=L-2
          IF(L.GE.-QL(J) )GO TO 82
C
          DO I=1,KMAX                                           !MAXCF
            NEL(J,I)=-2*(QL(J)+1)
          ENDDO
        ENDDO
C
        CALL DIMUSE('MAXCL',NW)
C
        WRITE(6,40)NW,NF,KMAX,(QN(J),QL(J)/2,J=JA,JB)
      ELSE
        WRITE(6,100)NF,KMAX
      ENDIF
C
      DO K=1,KMAX                         !CHECK CONFIGS CONSISTENT
        IF(ICHK(K).NE.NF)THEN           !DIFF NO. ELECTRONS...
          WRITE(6,94)K,ICHK(K)
          WRITE(0,*)'***SR.CONFG1: INCONSISTENT INPUT FOR CONFIGURATION'
     X              ,K
          BLF=.TRUE.
        ENDIF
      ENDDO
C
C WRITE ORBITAL RE-DEFINITION INFO
C
      IF(BLT)THEN
C
        KPP=MNT
        K1=1
        K2=15
        IF(KPP.GT.K2)KPP=K2
        WRITE(6,50)(K,K=K1,K2),(QN(K),QL(K)/2,K=K1,KPP)
C
  52    K1=K1+15
        IF(K1.LE.MNT)THEN
          K2=K2+15
          KPP=MNT
          IF(KPP.GT.K2)KPP=K2
          WRITE(6,51)(K,K=K1,K2),(QN(K),QL(K)/2,K=K1,KPP)
          GO TO 52
        ENDIF
C
C CHECK ORBITALS, REMAP FOR NON-UNIQUE ORBITAL BASIS
C
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            DO I=1,K-1
              IF(QN(K).EQ.QN(I).AND.QL(K).EQ.QL(I))THEN
C                IF(IEQ(0).EQ.0)IEQ(0)=1        !COMMENT-OUT FOR INEQUIV
                IF(IEQ(0).EQ.0)THEN
                  WRITE(6,90)I,K,QN(I),QL(I)/2
                  WRITE(0,90)I,K,QN(I),QL(I)/2
                ELSE
                  WRITE(6,91)I,K,QN(I),QL(I)/2
C                  IEQ(K)=IEQ(I)     !REMAP EQUIVALENT ORBITALS (UNSAFE)
                ENDIF
COLD                TEST BLF=.TRUE.
              ENDIF
            ENDDO
          ENDIF
        ENDDO
C
C CHECK FOR CLEMENTI "EXTERNAL" ORBITALS AND FLAG,
C THEN WE CANNOT EXTEND USAGE OF 60-69.
C
        IF(IUNIT(12).EQ.0)THEN
          DO K=1,MXORB
            IF(QN(K).GE.70.AND.QN(K).LE.79)THEN   !WE HAVE "EXTERNAL"
              KEY=0
              READ(5,SRADWIN,END=53)
  53          IF(KEY.EQ.-10)THEN                  !WE HAVE CLEMENTI
                IUNIT(12)=-1                      !FLAG
              ENDIF
              REWIND(5)                           !REPOSITION FOR SMINIM
              GO TO 56
            ENDIF
          ENDDO
        ENDIF
C
      ENDIF
C
  56  IF(BLF)GO TO 999
C
C UN/COMMENT-OUT FOR QUIETLY DROPPING DUPLICATE CONFIGS
C
      IF(BLG)THEN
        WRITE(6,*)'***CHECK CONFIG INPUT,  DUPLICATE CONFIGS EXIST'
        WRITE(0,*)'***CHECK CONFIG INPUT,  DUPLICATE CONFIGS EXIST'
        GO TO 999
      ENDIF
C      IF(BLG)WRITE(0,*) 'NOTE: DUPLICATE CONFIGS EXIST...'
C
C CHECK COLLISION CASE FOR MISTAKEN USER SETTING OF RYDBERG/CONTINUUM
C
      IF(IDW.NE.0)THEN
        DO I=1,MXORB
          IF(QN(I).GE.90)THEN
            WRITE(6,*)"***CONFG1 ERROR: USER MUST NOT SET CONTINUUM",
     X             " ORBITALS FOR RUN='DE','DI', LET THE CODE DO IT"
            WRITE(0,*)"***CONFG1 ERROR: USER MUST NOT SET CONTINUUM",
     X             " ORBITALS FOR RUN='DE','DI', LET THE CODE DO IT"
            GO TO 999
          ENDIF
          IF(QN(I).GE.80)THEN
            WRITE(6,*)"***CONFG1 ERROR: CANNOT USE RYDBERG",
     X                " ORBITALS FOR RUN='DE','DI' - WHY WOULD YOU!"
            WRITE(0,*)"***CONFG1 ERROR: CANNOT USE RYDBERG",
     X                " ORBITALS FOR RUN='DE','DI' - WHY WOULD YOU!"
            GO TO 999
          ENDIF
        ENDDO
      ENDIF
C
      IF(IEQ(0).EQ.0)GO TO 996                                   !RETURN
C
C SET-UP DISTINCT ORBITAL BASES FOR EACH CONFIG IF BASIS='RLX', OR
C GROUP OF CONFIGS, IF BASIS='SRLX', IF USER-SPECIFIED BACK IN SALGEB.
C BASIS='RLX' MUST USE COMMON ORBITALS FOR CLOSED-SHELLS SPECIFIED
C VIA JA,JB, IF REQUIRE DISTINCT THEN SPECIFY AS VALENCE.
C BASIS='SRLX' DEFAULTS TO DISTINCT CORE ORBITAL BASES (IRLX=0).
C
      IF(JA.GT.1)THEN           !USER MUST RE-ORDER SO START WITH CLOSED
        WRITE(6,*)
        WRITE(6,*)'***SR.CONFG1: MUST START CLOSED SHELL ORBITALS'
     X           ,' AT KCOR1=1'
        WRITE(6,*)'***USE ORBITAL RE-DEFINITION LINE'
        WRITE(0,*)'***SR.CONFG1: MUST START CLOSED SHELL ORBITALS'
     X           ,' AT KCOR1=1'
        GO TO 999
      ENDIF
C
      JB0=JB
      IF(IEQ(0).GT.0.AND.IRLX.LT.0)JB0=0        !FOR BASIS='SRLX'
c
c      write(6,*)mxorb,(qn(i),ql(i)/2,i=1,mxorb)
c      do k=1,kmax
c       write(6,*)k,(nel(i,k),i=1,mxorb)
c      enddo
C
      MXORB0=MXORB
      MXFORB=MXORB-MXVORB
      MXVORB=MXVORB-MXBORB
      MXBORB=MXBORB-JB0
C
      IF(MXBORB.LE.0)THEN
         WRITE(6,*)'***SR.CONFG1: RELAXED ORBITAL OPTION REQUIRES AT'
     X,' LEAST ONE NON-CLOSED-SHELL NON-VALENCE/CONTINUUM ORBITAL'
         WRITE(0,*)'***NEED AN OPEN-SHELL NON-VALENCE/CONTINUUM ORBITAL'
         GO TO 999
      ENDIF
C
      IF(IEQ(0).LT.0)THEN
        NGRP=1
        IEQ(0)=-MXBORB
        MXORB=KMAX*MXBORB+JB                    !=JB0 HERE
        IF(MXVORB.GT.0)MXORB=MXORB+KMAX
        IF(.NOT.BFOT)MXORBR=MXORB
        IF(MXFORB.GT.0)MXORB=MXORB+KMAX
        IF(BFOT)MXORBR=MXORB
      ELSE
        NGRP=IEQ(0)
        MXORB=NGRP*(MXORB-JB0)+JB0
        IF(BFOT)THEN
          MXORBR=MXORB
        ELSE
          MXORBR=NGRP*(MXVORB+MXBORB)+JB0
        ENDIF
        IEQ(0)=MXORB+MXBORB             !PACK, EVENTUALLY, PUT IN MODULE
        if(ieq(0).ge.1000.or.mxvorb.ge.10.or.mxforb.ge.10)
     x                                      stop'sr.confg1 pack failure'
        IEQ(0)=IEQ(0)+1000*MXVORB+10000*MXFORB+100000*NGRP
        IF(IRLX.LT.0)IRLX=-MXBORB-100000*NGRP                 !FOR FLGL2
      ENDIF
C
      MXORBR=MXORBR-JB0                                           !FLAGX
C
      MXORB=MAX(MXORB,ISCALR)     !FOR SLATER SCALING DUMMY ORB
C
      IF(MXORB.GT.MAXGR)THEN      !FOR REMAINING COMMON
        WRITE(6,*)
        WRITE(6,*)'***SR.CONFG1: INCREASE MAXGR TO',MXORB,
     X            ' OR USE UNIQUE ORBITAL BASIS'
        WRITE(0,*)'***SR.CONFG1: INCREASE MAXGR'
        GO TO 999
      ENDIF
C
      IF(MXORB.GT.IAXGR)THEN
C
        CALL RE_ALLOC2(NEL,IONE,MXORB0,IONE,KMAX,MXORB,KMAX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG1: RE-ALLOCATION FAILS FOR NEL'
          NF=0
          GO TO 996
        ENDIF
C
        CALL RE_ALLOC(QL,IONE,MXORB0,MXORB,IERR)
        CALL RE_ALLOC(QN,IONE,MXORB0,MXORB,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.CONFG1: ALLOCATION FAILS FOR QL,QN'
          NF=0
          GO TO 996
        ENDIF
C
        DO K=1,KMAX
          DO J=IAXGR+1,MXORB
            NEL(J,K)=0
          ENDDO
        ENDDO
C
        IAXGR=MXORB
C
      ENDIF
C
      CALL DIMUSE('MAXGR',MXORB)
C
      IF(MXVORB.GT.0.AND..NOT.BDR)THEN
        WRITE(6,*)
        WRITE(6,*)"***SR.CONFG1: YOU HAVE SPECIFIED VALENCE ORBITALS"
     X," FOR DR BUT RUN='  ', SET RUN='DR' OR SWITCH-OFF VALENCE ORBS"
        WRITE(0,*)'***SR.CONFG1: VALENCE ORBITALS SET FOR NON-DR RUN!'
        GO TO 999
      ENDIF
C
      IF(MENGB.GE.0)THEN          !I.E. BBORN
        K=MXORB-JB*NGRP           !COULD PACK MORE IF IRLX.LT.0...
C        IF(JA.GT.0)K=K+JA-1       !JA=1 FIXED
        IF(K.GT.MXGRB)THEN        !TOO MANY ORBS FOR BORN
          IF(MXGRB.GT.0)WRITE(6,*)
     X        '***SR.CONFG1: ALLOCATION INCTREASES MXGRB TO ',K
        ENDIF
        CALL DIMUSE('MXGRB',K)
      ENDIF
C
C DUPLICATE ORBITAL LIST FOR EACH CF/GROUP,
C   PUT ALL VALENCE AFTER ALL BOUND
C   PUT ALL CONT AFTER ALL BOUND & VALENCE
C AND REDEFINE CONFIG NEL.
C
      IF(IEQ(0).GT.0)GO TO 900
C
C FULL RELAXED ORBITAL BASIS, ONE PER CONFIG (SO JB=JB0 HERE)
C
      IF(MXFORB.GT.0)THEN
        K0=KMAX*MXBORB
        JBB=JB+MXBORB
        IF(MXVORB.GT.0)THEN
          K0=K0+KMAX
          JBB=JBB+MXVORB
        ENDIF
C
        DO K=1,KMAX                 !CONTINUUM
          II=K0+K+JB
          DEY(II)=DZERO
          IEQ(II)=II
          DO I0=1,MXFORB
            I=I0+JBB
            IT=NEL(I,K)
            IF(IT.GT.0)THEN
              NEL(I,K)=0
              NEL(II,K)=IT
              QN(II)=QN(I)
              QL(II)=QL(I)
              DEY(II)=DONE
              IGRCF(II)=K
              DO J=1,K-1
                JJ=K0+J+JB
                IF(DEY(JJ).NE.DZERO)THEN
                  IF(QN(II).EQ.QN(JJ).AND.QL(II).EQ.QL(JJ))THEN
                    IEQ(II)=IEQ(JJ)
                    GO TO 1
                  ENDIF
                ENDIF
              ENDDO
              GO TO 1
            ENDIF
          ENDDO
   1    ENDDO
      ENDIF
C
      IF(MXVORB.GT.0)THEN
        K0=KMAX*MXBORB
        JBB=JB+MXBORB
C
        DO K=1,KMAX                 !VALENCE
          II=K0+K+JB
          DEY(II)=DZERO
          IEQ(II)=II
          DO I0=1,MXVORB
            I=I0+JBB
            IT=NEL(I,K)
            IF(IT.GT.0)THEN
              NEL(I,K)=0
              NEL(II,K)=IT
              QN(II)=QN(I)
              QL(II)=QL(I)
              DEY(II)=DONE
              IGRCF(II)=K
              DO J=1,K-1
                JJ=K0+J+JB
                IF(DEY(JJ).NE.DZERO)THEN
                  IF(QN(II).EQ.QN(JJ).AND.QL(II).EQ.QL(JJ))THEN
                    IEQ(II)=IEQ(JJ)
                    GO TO 2
                  ENDIF
                ENDIF
              ENDDO
              GO TO 2
            ENDIF
          ENDDO
   2    ENDDO
      ENDIF
C
      DO K=1,KMAX                 !BOUND
        ICFGP(K)=K
        K0=MXBORB*(K-1)
        DO I0=1,MXBORB
          I=I0+JB
          II=I+K0
          IT=NEL(I,K)
          NEL(I,K)=0
          NEL(II,K)=IT
          QN(II)=QN(I)
          QL(II)=QL(I)
          IEQ(II)=IEQ(I)
          IGRCF(II)=K
          IF(NEL(II,K).EQ.0)THEN
            DEY(II)=DZERO
          ELSE
            DEY(II)=DONE
          ENDIF
        ENDDO
      ENDDO
C
      GO TO 996
C
C SIMPLIFIED RELAXED ORBITAL BASIS (FOR GROUPS OF CONFIGS)
C
 900  CONTINUE
C
c while this may seem the natural way to pack, since orbitals only
c reference within the group, historically AS expects all (globally)
c rydbergs to follow all bound and all continuum to follow all rydbergs.
c mods to sr.algeb2, sr.diagon etc are needed to obtain bound-cont data.
c      mxborb=mxborb+mxvorb+mxforb
c      ieq(0)=mxorb+mxborb
c      mxvorb=0
c      mxforb=0
c nned to sync. packing with radial/radcon group orthog flag
c
      IF(MXFORB.GT.0)THEN
        K0=MXBORB*(NGRP-1)
        JBB=JB0+MXBORB
        IF(MXVORB.GT.0)THEN
          K0=K0+MXVORB*(NGRP-1)
          JBB=JBB+MXVORB
        ENDIF
        DO N=NGRP,1,-1                 !CONTINUUM
          KK=K0+MXFORB*(N-1)
          DO I0=MXFORB,1,-1
            I=I0+JBB
            II=I+KK
            QN(II)=QN(I)
            QL(II)=QL(I)
            IEQ(II)=I+K0                      !SO ANY USER REMAP IGNORED
            IGRCF(II)=N
            DEY(II)=DZERO
          ENDDO
        ENDDO
C
        DO K=1,KMAX
          N=ICFGP(K)
          KK=K0+MXFORB*(N-1)
          DO I0=MXFORB,1,-1
            I=I0+JBB
            II=I+KK
            IT=NEL(I,K)
            NEL(I,K)=0
            NEL(II,K)=IT
            IF(NEL(II,K).NE.0)DEY(II)=DONE
          ENDDO
        ENDDO
      ENDIF
C
      IF(MXVORB.GT.0)THEN
        K0=MXBORB*(NGRP-1)
        JBB=JB0+MXBORB
        DO N=NGRP,1,-1                  !VALENCE
          KK=K0+MXVORB*(N-1)
          DO I0=MXVORB,1,-1
            I=I0+JBB
            II=I+KK
            QN(II)=QN(I)
            QL(II)=QL(I)
            IEQ(II)=I+K0                      !SO ANY USER REMAP IGNORED
            IGRCF(II)=N
            DEY(II)=DZERO
          ENDDO
        ENDDO
C
        DO K=1,KMAX
          N=ICFGP(K)
          KK=K0+MXVORB*(N-1)
          DO I0=MXVORB,1,-1
            I=I0+JBB
            II=I+KK
            IT=NEL(I,K)
            NEL(I,K)=0
            NEL(II,K)=IT
            IF(NEL(II,K).NE.0)DEY(II)=DONE
          ENDDO
        ENDDO
      ENDIF
C
      DO N=1,NGRP                   !BOUND
        KK=MXBORB*(N-1)
        DO I0=1,MXBORB
          I=I0+JB0
          II=I+KK
          QN(II)=QN(I)
          QL(II)=QL(I)
          IEQ(II)=IEQ(I)                           !ALLOW ANY USER REMAP
          IGRCF(II)=N
          DEY(II)=DZERO
        ENDDO
      ENDDO
C
      DO K=1,KMAX
        N=ICFGP(K)
        KK=MXBORB*(N-1)
        DO I0=1,MXBORB
          I=I0+JB0
          II=I+KK
          IT=NEL(I,K)
          NEL(I,K)=0
          NEL(II,K)=IT
          IF(NEL(II,K).NE.0)DEY(II)=DONE
        ENDDO
      ENDDO
c
c      write(6,*)mxorb,(qn(i),ql(i)/2,i=1,mxorb)
c      write(6,*)(ieq(i),i=1,mxorb)
c      do k=1,kmax
c       write(6,*)k,(nel(i,k),i=1,mxorb)
c      enddo
C
 996  DEALLOCATE (ICHK)
C
      RETURN
C
C FLAG ABORT
C
 999  NF=-1
      GO TO 996
C
C
   40 FORMAT(///' ATOM WITH',I4,'+', I3,' ELECTRONS IN',I4
     X,' CONFIGURATIONS',', CLOSED (N L)-SHELLS: ', 6(I5,I3) )
   50 FORMAT( //' ATTENTION: SOME OF THE INTERNAL ORBITALS MAY HAVE ',
     X'BEEN REDEFINED, AND MAY NOT BE THE STANDARD CODE (K=1,2,3... FOR'
     X,'  1S,2S,2P...)'/'    K ',15I6/'   N L ',15(I4,I2))
   51 FORMAT(//'    K ',15I6/'   N L ',15(I4,I2))
c   88 FORMAT(//' SR.CONFG1:  MAXGR=',I3,' EXCEEDS MXLIT=',I2,
c     X '; EXTEND ARRAY LIT(MXLIT) AND ADJUST DATA:MXLIT IN SR.CONFG1')
   89 FORMAT(" SR.CONFG1: ORBITAL '",A1,  "' IN POSITION",I4
     X, " OF C-INPUT (CARD",I3," COLUMN",I3
     X,") IS OUTSIDE RANGE, MAXGR=",I3)
  189 FORMAT(" SR.CONFG1: ORBITAL '",A1,  "' IN POSITION",I4
     X, " OF C-INPUT (CARD",I3," COLUMN",I3
     X,") IS OUTSIDE RANGE, MXLIT=",I3)
   90 FORMAT( ' SR.CONFG1: *WARNING* ON REDEFINING ORBITAL INDICES K,'
     X,I4,' AND',I4, ' BOTH REPRESENT ELECTRONS NL=',I5,I3)
C   91 FORMAT( ' SR.CONFG1: NOTE ON REDEFINING ORBITAL INDICES K,',I4,
C     X' AND',I4, ' BOTH REPRESENT ELECTRONS NL=',2I5,', TREATING AS'
C     X,' EQUIVALENT')
   91 FORMAT( ' SR.CONFG1: NOTE ON REDEFINING ORBITAL INDICES K,',I4,
     X' AND',I4, ' BOTH REPRESENT ELECTRONS NL=',2I2,', TREATING AS'
     X,' INEQUIVALENT'/' IF YOU MEAN THEM TO BE EQUIVALENT THEN USE A'
     X,' UNIQUE ORBITAL INDEX AND DEFINE SEPARATE CONFIGURATION GROUPS')
   92 FORMAT(' SR.CONFG1: C-INPUT REQUIRES STORAGE FOR MORE THAN MAXCF='
     X,I4,' CONFIGURATIONS')
  192 FORMAT(' SR.CONFG1: C-INPUT REQUIRES STORAGE FOR MORE THAN MAXCF='
     X,I4,' CONFIGURATIONS - INCREASE IAXCF BUFFER IN SR.ALGEB0')
   93 FORMAT(" SR.CONFG1: YOU'VE REDEFINED K=",I4," AS NL=",I2,1X,A1)
   94 FORMAT(" SR.CONFG1: CONFIGURATION INPUT INCONSISTENT-YOUR",I4,
     X"'TH CONFIGURATION CONTAINS",I3," VALENCE ELECTRONS")
   95 FORMAT(' SR.CONFG1: SPACE FOR ONLY MAXCL=',I3,' CORE ELECTRONS')
   97 FORMAT(' SR.CONFG1:',I3,' ELECTRONS NL=',2I2,' IN CF=',I4)
  100 FORMAT(///' ATOM WITH',I4,' ELECTRONS IN',I4,' CONFIGURATIONS')
  101 FORMAT(//' ***WARNING IN SR.CONFG1, YOU HAVE SPECIFIED MORE THAN'
     X,' ONE VALENCE ORBITAL FOR THE DR L-LOOP...')
C
      END SUBROUTINE CONFG1
C
C                   *********************
C
      SUBROUTINE CORTFD(X,POT,IEND,ADJUS2,ADJUS3,CRRCT1,CRRCT2)
C
C-----------------------------------------------------------------------
C
C  SR.CORTFD COMPUTES DIPOLE AND QUADRUPOLE PERTURBATIONS TO THE STATIC
C  THOMAS-FERMI POTENTIAL - AS DESCRIBED BY:
C  M. A. BAUTISTA J.PHYS.B 41, 065701 (8pp) (2008).
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D15O16=15.0D0/16.0D0)
C
      PARAMETER (TOLC=0.1D0)
C
      DIMENSION POT(*),X(*)
      DIMENSION CORRCT(IEND)
C
C
      SQ2=SQRT(DTWO)
      PI=ACOS(-DONE)
C
      PIP=DONE/(PI*SQ2)
      PIP2=PIP*PIP
      COEFFA=DFOUR*SQ2/(DTHREE*PI)
      COEFFB=COEFFA*(ADJUS3-DONE)
      COEFFA=COEFFA*(ADJUS2-DONE)
C
      V0=PIP2-POT(IEND)-D15O16*PIP2
C
      DO J=1,IEND
C
        X1=X(1)
        V2=V0+POT(1)
        R2=((PIP+SQRT(V2))*X1)**3
        DELP1=R2*X1
        DELP3=DELP1*X1
C
        DO I=2,J
          X0=X1
          X1=X(I)
          DX=X1-X0
C          V1=V2
          V2=V0+POT(I)
          R1=R2
          R2=((PIP+SQRT(V2))*X1)**3
          DELP1=DELP1+(R1+R2)*DX
          DELP3=DELP3+(R1*X0+R2*X1)*DX
c          write(90,702)j,i,delp1,delp3
        ENDDO
C
C
        X1=X(J)
        V2=V0+POT(J)
        R2=(PIP+SQRT(V2))**3
        DELP2=DZERO
        DELP4=DZERO
C
        DO K=J+1,IEND
          X0=X1
          X1=X(K)
          DX=X1-X0
C          V1=V2
          V2=V0+POT(K)
          R1=R2
          R2=(PIP+SQRT(V2))**3
          DELP2=DELP2+(R1+R2)*DX
          DELP4=DELP4+(R1/X0+R2/X1)*DX
c          write(90,702)j,k,delp2,delp4
        ENDDO
C
C
        X1=X(J)
        T=X1*X1
        DELPA=DELP1/T+DELP2*X1
        DELPB=DELP3/(T*X1)+DELP4*T
        CORRCT(J)=DELPA*COEFFA+DELPB*COEFFB
C
c      write(90,*)x(i),pot(i),delpa,delpb,(delpa+delpb)/pot(i)
c      write(90,700)x(j),pot(j),delpa*COEFFA,delpb*COEFFB
C
      ENDDO
C
      T=CORRCT(IEND)/POT(IEND)
      IF(ABS(T).GT.TOLC)WRITE(6,710)T*100
      CRRCT1=DELPA*COEFFA/POT(IEND)
      CRRCT2=DELPB*COEFFB/POT(IEND)
C
c      write(92,*)'****** ',iend
      DO I=1,IEND-1
c        write(92,700)x(i), pot(i),corrct(i)
        POT(I)=POT(I)+CORRCT(I)
      ENDDO
c      write(0,*)iend,x(iend),pot(iend),x(iend)*pot(iend) !i=1,iend then
C
      RETURN
C
c 700   format(4(2x,1pe10.3))
c 702   format(2i5,4(2x,1pe10.3))
 710  FORMAT(//'***WARNING SR.CORTFD: PERTURBATION CORRECTION '
     X           ,'POTENTIAL EXCEEDS COULOMB AT X(IEND) BY',F5.1,'%'//)
C
      END SUBROUTINE CORTFD
C
C                             *******************
C
      SUBROUTINE DEIE(TIME,TTIME)
C
C-----------------------------------------------------------------------
C
C  SR.DEIE IS THE CONTROLING ROUTINE FOR:
C  DIRECT ELECTRON-IMPACT EXCITATION COLLISION STRENGTH DETERMINATION.
C
C  IT CALLS:
C    SR.ALGX:
C      SR.ALGXLS
C      SR.ALGXFS
C    SR.DWX
C      SR.DWXLS
C      SR.DWXJK
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /BASIC/NF,MGAP(11)
C
C-----------------------------------------------------------------------
C
C SR.ALGX CALCULATES COLLISION ALGEBRA
C
      CALL ALGX
C
C-----------------------------------------------------------------------
C
      CALL CPU_TIME(TTIME)
      TTIME=TTIME/D60
      TIME=TTIME-TIME
C
      WRITE(6,999) TIME, TTIME
C
      TIME=TTIME
C
C-----------------------------------------------------------------------
C
C SR.DWX CALCULATES COLLISION STRENGTHS
C
      if(nf.gt.0)CALL DWX
C
C-----------------------------------------------------------------------
C
      CALL CPU_TIME(TTIME)
      TTIME=TTIME/D60
      TIME=TTIME-TIME
C
      WRITE(6,999) TIME, TTIME
C
      TIME=TTIME
C
      RETURN
C
  999 FORMAT(//1X,'CPU TIME=',F9.3,' MIN',5X,'TOTAL CPU TIME=',F9.3
     X,' MIN')
C
      END SUBROUTINE DEIE
C
C                             *******************
C
      SUBROUTINE DIAG(NN,NE,IUP,Z,D,E,IRMX,IORD,MXMAT)
C
C-----------------------------------------------------------------------
C
C  BADNELL & BURGESS  D.A.M.T.P. CAMBRIDGE
C
C  SR.DIAG DIAGONALIZES A REAL SYMMETRIC N-BY-N MATRIX Z.
C
C  METHOD: HOUSEHOLDER REDUCTION TO TRI-DIAGONAL FORM AND IMPLICIT
C          SHIFTED QL ALGORITHM TO DETERMINE ALL E-VALUES AND E-VECTORS.
C
C  BASED ON MARTIN, REINSCH & WILKINSON: NUM. MATH. 11, 181-95(1968).
C
C  INPUT REQUIRED:
C
C       NN, (NE), IUP AND Z, WHERE N=ABS(NN).
C
C       MXMAT, IS THE ROW DIMENSION OF Z IN THE CALLING ROUTINE.
C       ONLY THE LOWER TRIANGLE OF Z NEED BE SUPPLIED.
C       ON OUTPUT, THE MATRIX Z IS OVERWRITTEN BY EIGENVECTORS OF Z.
C
C       IUP=1/-1 ASC/DESCENDING E-VALUE SORT.
C          =0 RE-ORDERS ACCORDING TO DOMINANT E-VECTOR COMPONENT.
C
C       IF NN.LT.0 THEN JUST RE-ORDER THE *INPUT* E-VECTORS IN Z,
C          E.G. FROM LAPACK.
C          IN THIS CASE ONLY, NE MAY FLAG THE ACTUAL NUMBER OF E-VECTORS
C          PRESENT, IN COLUMNS 1,2,...NE, WHICH CAN BE LESS THAN N.
C       ***THE COLUMN DIMENSION OF Z IS AT LEAST N STILL, IF IUP=0.
C
C  OUTPUT:
C
C        Z AND D, WHERE Z CONSISTS OF COLUMN EIGENVECTORS
C                 AND D CONSISTS OF CORRESPONDING EIGENVALUES.
C
C  NOTE: E IS A WORKING ARRAY, OF LENGTH N.
C       IRMX, IORD ARE WORKING ARRAYS OF LENGTH N, ONLY USED WHEN IUP=0.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TOL=D1M40)
      PARAMETER (EPS=D1M12)
      PARAMETER (JMAX=I30)
C
      DIMENSION D(*),E(*),Z(MXMAT,*),IRMX(*),IORD(*)
c
      DATA IFLAGE/0/
C
C
      IF(NN.EQ.0)GO TO 999
C
      N=ABS(NN)
      MM=N
C
      IF(NN.LT.0)THEN
        IF(NE.GT.0)MM=MIN(NE,N)
        GO TO 100
      ENDIF
C
      DO I=1,N
        D(I)=Z(N,I)
      ENDDO
      IF(N.EQ.1)GO TO 20
C
C HOUSEHOLDER REDUCTION TO TRI-DIAGONAL FORM
C
      DO I=N,2,-1
C
        L=I-1
        F=D(I-1)
        G=DZERO
        DO K=1,I-2
          G=G+D(K)*D(K)
        ENDDO
        H=G+F*F
        IF(G.LE.TOL)THEN
          E(I)=F
          H=DZERO
          DO J=1,L
            D(J)=Z(L,J)
            Z(I,J)=DZERO
            Z(J,I)=DZERO
          ENDDO
          GO TO 18
        ENDIF
C
        G=SQRT(H)
        IF(F.GE.DZERO)G=-G
        E(I)=G
        H=H-F*G
        D(L)=F-G
        DO  J=1,L
          E(J)=DZERO
        ENDDO
        DO J=1,L
          Z(J,I)=D(J)
          G=E(J)+Z(J,J)*D(J)
          DO K=J+1,L
            G=G+Z(K,J)*D(K)
            E(K)=E(K)+Z(K,J)*D(J)
          ENDDO
          E(J)=G
        ENDDO
C
        F=DZERO
        DO J=1,L
          E(J)=E(J)/H
          F=F+E(J)*D(J)
        ENDDO
        HH=F/(H+H)
        DO J=1,L
          E(J)=E(J)-HH*D(J)
        ENDDO
        DO J=1,L
          F=D(J)
          G=E(J)
          DO K=J,L
            Z(K,J)=Z(K,J)-F*E(K)-G*D(K)
          ENDDO
          D(J)=Z(L,J)
          Z(I,J)=DZERO
        ENDDO
C
  18    D(I)=H
C
      ENDDO
C
C
C ACCUMULATE TRANSFORMATION MATRICES
C
      DO I=2,N
        L=I-1
        Z(N,L)=Z(L,L)
        Z(L,L)=DONE
        H=D(I)
        IF(H.NE.DZERO)THEN
          DO K=1,L
            D(K)=Z(K,I)/H
          ENDDO
          DO J=1,L
            G=DZERO
            DO K=1,L
              G=G+Z(K,I)*Z(K,J)
            ENDDO
            DO K=1,L
              Z(K,J)=Z(K,J)-G*D(K)
            ENDDO
          ENDDO
        ENDIF
        DO J=1,L
          Z(J,I)=DZERO
        ENDDO
      ENDDO
      DO I=1,N
        D(I)=Z(N,I)
        Z(N,I)=DZERO
      ENDDO
C
  20  E(1)=DZERO
      Z(N,N)=DONE
C
C
C IMPLICIT SHIFTED QL ALGORITHM TO DETERMINE E-VALUES & E-VECTORS
C
      DO I=2,N
        E(I-1)=E(I)
      ENDDO
      E(N)=DZERO
      HMIN=DZERO
      F=DZERO
C
      DO L=1,N
C
        J=0
C
        H=EPS*(ABS(D(L))+ABS(E(L)))
        IF(HMIN.LT.H)HMIN=H
        DO M=L,N
          IF(ABS(E(M)).LE.HMIN)GO TO 37
        ENDDO
  37    IF(M.EQ.L)GO TO 53
  38    IF(J.EQ.JMAX)THEN
          WRITE(6,1000)
          GO TO 999
        ENDIF
C
        J=J+1
C
        P=E(L)+E(L)
        G=D(L)
        H=D(L+1)-G
        IF(ABS(H).LT.ABS(E(L)))THEN
          P=H/P
          R=SQRT(P*P+DONE)
          H=P+R
          IF(P.LT.DZERO)H=P-R
          D(L)=E(L)/H
        ELSE
          P=P/H
          R=SQRT(P*P+DONE)
          D(L)=E(L)*P/(R+DONE)
        ENDIF
C
        H=G-D(L)
        DO I=L+1,N
          D(I)=D(I)-H
        ENDDO
        F=F+H
        P=D(M)
        C=DONE
        S=DZERO
        DO I=M-1,L,-1
          G=C*E(I)
          H=C*P
          IF(ABS(P).GE.ABS(E(I)))THEN
            C=E(I)/P
            R=SQRT(C*C+DONE)
            E(I+1)=S*P*R
            S=C/R
            C=DONE/R
          ELSE
            C=P/E(I)
            R=SQRT(C*C+DONE)
            E(I+1)=S*E(I)*R
            S=DONE/R
            C=C/R
          ENDIF
          P=C*D(I)-S*G
          D(I+1)=H+S*(C*G+S*D(I))
          DO K=1,N
            H=Z(K,I+1)
            Z(K,I+1)=S*Z(K,I)+C*H
            Z(K,I)=C*Z(K,I)-S*H
          ENDDO
        ENDDO
C
        E(L)=S*P
        D(L)=C*P
        IF(ABS(E(L)).GT.HMIN)GO TO 38
  53    D(L)=D(L)+F
C
      ENDDO
C
C PUT BACK IN ORIGINAL ORDER
C
 100  IF(IUP.EQ.0)THEN
c
c      rewind(99)                    !debug info if assignment fails
c      write(99)n
c      write(99)(d(i),i=1,n)
c      write(99)((z(j,i),j=1,n),i=1,n)
c
      IFOUND=0
C
      DO I=1,MM                     !FIND(ROW)MAX CMPNT OF EACH E-VECTOR
C
        CALL HPSRTI(N,Z(1,I),IORD)             !FIND ORDER OF COMPONENTS
C
        J=IORD(1)
        IRMX(I)=J                        !INITIAL INPUT ORDER-> CPNT MAP
        ZAM=Z(J,I)
        IF(Z(J,I).LT.DZERO)THEN                !MAKE LARGEST CPT >0
          ZAM=-ZAM
          DO J=1,N
            Z(J,I)=-Z(J,I)
          ENDDO
        ENDIF
        E(I)=ZAM
        ISAME=0
C
        DO K=2,N
          J=IORD(K)
          ZABS=ABS(Z(J,I))
          IF(ZABS.EQ.ZAM)THEN                  !MAKE NON-EQUAL
            ISAME=ISAME+1
            ZABS=ZABS-ISAME*EPS*ZABS
            Z(J,I)=SIGN(ZABS,Z(J,I))
c            if(j.gt.0)then
c              stop 'degenerate case'
c            endif
          ELSE
            IF(ZABS.EQ.DZERO)GO TO 55          !WE ARE DONE FOR THIS I
            ZAM=ZABS
            ISAME=0
          ENDIF
        ENDDO
C
  55    CONTINUE
C
      ENDDO
C
      DO I=1,N                      !N NOT MM
        IORD(I)=0
      ENDDO
C
  56  P=DZERO
      DO I=1,MM                     !FIND LARGEST MAX CMPNT
        IF(E(I).GT.P)THEN
          P=E(I)
          K=I
        ENDIF
      ENDDO
      IF(IORD(IRMX(K)).EQ.0)THEN    !ASSIGN IF NOT ALREADY DONE SO
        IFOUND=IFOUND+1
        IORD(IRMX(K))=K             !MAPS COMPONENT ORDER TO ORIGINAL
        E(K)=DZERO
        IF(IFOUND.EQ.MM)GO TO 57    !WE ARE DONE
      ELSE                          !ELSE LOOK FOR NEXT LARGEST CMPNT
        P=-DONE
        IRMX(K)=0
        DO J=1,N
          ZABS=ABS(Z(J,K))
          IF(ZABS.GT.P.AND.ZABS.Lt.E(K))THEN  !ALL CPTS NON-EQUAL NOW
            IRMX(K)=J
            P=ZABS
          ENDIF
        ENDDO
        IF(IRMX(K).EQ.0)THEN        !JUST FILL-IN
          DO J=1,N
            IF(IORD(J).EQ.0)THEN
              IFOUND=IFOUND+1
              IRMX(K)=J
              IORD(J)=-K
              P=DZERO
            ENDIF
          ENDDO
c
c          write(6,*)'k=',k,zabs,e(k),n,ifound,isame
c          do j=1,n
c            write(6,1001)iord(irmx(j)),irmx(j),(z(j,k),k=1,n)
c          enddo
c 1001     format(2i5,1p,10e10.2/(10x,10e10.2))
c
          IF(IFLAGE.EQ.0)THEN
            WRITE(6,1002)
c
c alternatively, force the issue (for "safety").
c            go to 999               !bailout and use jacord
          ENDIF
          IFLAGE=IFLAGE+1
          IF(IFOUND.EQ.MM)GO TO 57  !WE ARE DONE
        ENDIF
        E(K)=P                      !TRY AGAIN
      ENDIF
      GO TO 56                      !GO FOR NEXT ONE
C
  57  CONTINUE
C
C THE NEW COMPONENT ORDER (IORD) HAS BEEN DETERMINED.
C
C FOR SAFETY, SINCE NON-SEQUENTIAL, ZERO OUT REMAINDER FIRST.
C
      DO I=MM+1,N
        D(I)=DZERO
        DO J=1,N
          Z(J,I)=DZERO
        ENDDO
      ENDDO
C
C NOW SWAP THE ORIGINAL E-VECTORS AND E-VALUES TO MATCH.
C
      DO I=1,N
        IORD(I)=ABS(IORD(I))
        IRMX(I)=I                   !CURRENT POSITION OF ORIG E-VECTOR I
        E(I)=I                      !WHAT'S CURRENTLY IN POSITION I
      ENDDO
      DO I=1,N
        K=IORD(I)
        IF(K.GT.0)THEN
         K=IRMX(K)
         IF(K.NE.I)THEN
          IRMX(IORD(I))=I
          L=NINT(E(I))
          IRMX(L)=K
          E(K)=L
          E(I)=IORD(I)
          P=D(K)
          D(K)=D(I)
          D(I)=P
          DO J=1,N
            P=Z(J,I)
            Z(J,I)=Z(J,K)
            Z(J,K)=P
          ENDDO
         ENDIF
        ENDIF
      ENDDO
C
      ELSE
C
C BEGIN SORTING INTO ASC/DESCENDING E-VALUES
C
      DO I=1,MM
        K=I
        P=D(I)
        DO J=I+1,N
          IF(IUP.GT.0.AND.D(J).GT.P)GO TO 58
          IF(IUP.LT.0.AND.D(J).LT.P)GO TO 58
          K=J
          P=D(J)
  58    ENDDO
        IF(K.NE.I)THEN
          D(K)=D(I)
          D(I)=P
          DO J=1,N
            P=Z(J,I)
            Z(J,I)=Z(J,K)
            Z(J,K)=P
          ENDDO
        ENDIF
      ENDDO
C
      ENDIF
C
      RETURN
C
C
 999  NN=0
      RETURN
C
1000  FORMAT(' FAILED IN DIAG, TOO MANY ITERATIONS')
1002  FORMAT('*** UNABLE TO ASSIGN ALL E-VECTORS BY COMPONENT'/
     X       '    YOU MIGHT WANT TO RUN-CHECK BY SETTING ',
     X                'IDIAG=1 IN SMINIM... (NO MORE WARNINGS)')
C
      END SUBROUTINE DIAG
C
C                             *******************
C
      SUBROUTINE DIAGFS(DECORE,DFFS)
C
C-----------------------------------------------------------------------
C
C                 N.R. BADNELL  D.A.M.T.P.  CAMBRIDGE
C
C  SR.DIAGFS CALCULATES LEVEL ENERGIES INCLUDING RELATIVISTIC
C  CORRECTIONS, AND PERMITTED AND FORBIDDEN RADIATIVE DATA.
C  IT ALSO CALCULATES INTERMEDIATE COUPLING AUTOIONIZATION RATES
C  AND PHOTOIONIZATION CROSS SECTIONS
C
C  IT CALLS:
C    SR.BRNINT
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.DIMUSE
C    SR.FSINT
C    SR.HDIAG
C    SR.HPSRTI
C    SR.LAGINT
C    SR.RADBP2
C    SR.RE_ALLOC
C
C  IT CONTAINS:
C    FN.ICOL
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_COEFF,  ONLY: DRKP,QRLP,IRLP,NRKP,NADP,N81,IPLANT_SOI
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: DSS,MSS,NADR,N82,IPLANT_MI
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD,n8
      USE COMMON_INTS,   ONLY: DRL,DOSC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_RELINT, ONLY: DRLP1,DNL
      USE COMMON_TRANS,  ONLY: TFU
      USE COMMON_NRBCAS, ONLY: BCASC,AP,MADD,IXNOR
      USE COMMON_NRBEKP, ONLY: NED
      USE COMMON_NRBFSI, ONLY: DNLI,NLI
      USE COMMON_NRBIAD, ONLY: IADJ8,NP8
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBMKP, ONLY: NMD1,NMD2
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
      USE COMMON_NRBNF2, ONLY: DETA,DXSI,DZL,DXTWO
      USE COMMON_NRBNFI, ONLY: DZLI,DXTWOI,DETAI,FRI,GRI
      USE COMMON_NRBORN, ONLY: BL,OBO,TM2,IXBLM
      USE COMMON_NRBRN1, ONLY: SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK,IXD33
      USE COMMON_NRBRN2, ONLY: BINDB,MENGB
      USE COMMON_NRBRN3, ONLY: V0,V1,XB,XS,DB0,DB1,OMEGAB
     X                        ,MV0,MV1,MINFB,MXNXB,MXNXB1,NLAGB
     X                        ,IEXP,XMANT
      USE COMMON_NRBTS1, ONLY: DFOT,DFOTm,DFOSS,PMIN,NFOSS,IPIG,IGAG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLIT=62)
      PARAMETER (MXSTRG=32)                            !MAX STRING WRITE
      PARAMETER (MSTRGH=16)                          !SHORT STRING WRITE
      PARAMETER (MXLAB1=29)                                    !0:MXLAB1
      PARAMETER (MXLAB2=29)                                    !0:MXLAB2
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
      parameter (mxlenx=2000)                               !card length
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
C
      PARAMETER (D2P1=2.0D1)
      PARAMETER (DKON=1.653656D17)
      PARAMETER (C1=DFSC**3/HBAR)
      PARAMETER (C2=2.567895D-18)    !4*pi*a_0**2*alpha
C      PARAMETER (C3=C2/DTHREE)
      PARAMETER (EINF=1.0D6)
      PARAMETER (DEPS=1.0D-15)
C
      PARAMETER (MW=8)               !INITIALIZE UNIT NOS
      PARAMETER (MWW=MW+10)
      PARAMETER (MWU=MW+20)
      PARAMETER (MWWU=MWU+2)
C
      INTEGER QLB,LIT     !HISTORIC DEFAULT KIND TO SYNC WITH POST PROCS
C
      REAL(RP) OMEGA
      INTEGER(EP) NHOLD8
C
      CHARACTER(LEN=1) BIGL,NUMB,STRING,CLIT,CMBLK1
COLD  X,SMAL
CHAR  X,LIT,MBLK1  !USE OF CHAR REQUIRES CHANGES TO PP'S FOR UNFORM I/O
      CHARACTER(LEN=2) CELMNT,ELEM,LABW
      CHARACTER(LEN=4) MBCOR,MCOR,MSCOR,MBLK,CODE,MYRGE,LAB4,CARD4,MBP
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=8) MOBS
      character(len=9) orbfmt,LAB9
      CHARACTER(LEN=10) MTEC,NTEC
      character(len=31) ceiss,cstan
      CHARACTER(LEN=17) F762
      CHARACTER(LEN=29) F761
      character(len=51) f542,f543
      character(len=mxlenx) cardx
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: DU(:,:),NPOS(:,:),DUI(:,:),DVI(:,:),DDY(:)
     X              ,DVP(:),OMR(:),OMC(:),OMEGA(:,:),TFUJ(:)
     X              ,DE(:),IDY(:),DVU(:),NVEC(:)
     X              ,DVECF(:,:),DVECM(:,:)
     X              ,ITMP(:)
     x              ,iwrkj(:),nadlu(:)
     x              ,ncf(:),jwrkb(:,:,:),kmap(:),iwrkn(:),jwrkg(:)
     x              ,isorb(:),iwrk1(:),nslb(:),luj(:),decorn(:),NGRPJ(:)
C
      ALLOCATABLE :: IHARRY(:),E1BCF(:),SUMA(:)
     X              ,JCP(:),JTP(:),JRP(:),JWRN(:),JWRD(:),ERN(:),ERD(:)
     X              ,SUMRN(:),SUMRD(:)
     X              ,SUMPN(:,:),SUMPD(:,:)
     X              ,DT(:),MMIKE(:),NMIKE(:)
C
      ALLOCATABLE :: LMX(:),QSB(:,:),QLB(:,:),ICF(:),DG(:)
C
      ALLOCATABLE :: DENERG(:),IWRK2(:),ID(:),NADRUJ(:),NAJ(:)
     X              ,DVECL(:),DVECV(:),DVECA(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
C
      ALLOCATABLE :: ETM(:),WGT(:)
c
      allocatable :: nal(:),iwrks(:),iwrk5(:)                !iwrk5=test
C
      DIMENSION DFS(MXDFS)
C
      DIMENSION BIGL(0:MXLAB1),NUMB(0:MXLAB2)
     X         ,STRING(MXSTRG),CLIT(MXLIT),LIT(MXLIT)
C
      COMMON /BASIC/NF,MGAP(10),IGAUGE
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCL0,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /TRANLS/NADRU(MAXTM),NAI(MAXTM),NC0,IEORD(MAXTM)
      COMMON /WEIGHT/WGHT(MAXTM),INDEXW(MAXTM)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFAN/BFANO
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBTCC/TOLTCC,KTCC,MTCC,NTCC,NNRGLS
      COMMON /NRBTRN/NENERG,JORIG(MAXLV)                !PASS TO SR.CASC
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
C      COMMON /WORKJ/DWRK(MAXLV),IWRK3(MAXLV),IWRK4(MAXLV)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
      common /hps/badas

COLD     X,(DP(1),DT(1),ETM(1)), (DPA(1),WGT(1),NMIKE(1),DFS(1))
C
      DATA CMBLK1/' '/,MBLK/'    '/,MCOR/' COR'/,MSCOR/'*COR'/
     X    ,BSCRO/.FALSE./
C
      DATA CLIT( 1),CLIT( 2),CLIT( 3),CLIT( 4)  /'1','2','3','4'/,
     X     CLIT( 5),CLIT( 6),CLIT( 7),CLIT( 8)  /'5','6','7','8'/,
     X     CLIT( 9),CLIT(10),CLIT(11),CLIT(12)  /'9','A','B','C'/,
     X     CLIT(13),CLIT(14),CLIT(15),CLIT(16)  /'D','E','F','G'/,
     X     CLIT(17),CLIT(18),CLIT(19),CLIT(20)  /'H','I','J','K'/,
     X     CLIT(21),CLIT(22),CLIT(23),CLIT(24)  /'L','M','N','O'/,
     X     CLIT(25),CLIT(26),CLIT(27),CLIT(28)  /'P','Q','R','S'/,
     X     CLIT(29),CLIT(30),CLIT(31),CLIT(32)  /'T','U','V','W'/,
     X     CLIT(33),CLIT(34),CLIT(35),CLIT(36)  /'X','Y','Z','a'/,
     X     CLIT(37),CLIT(38),CLIT(39),CLIT(40)  /'b','c','d','e'/,
     X     CLIT(41),CLIT(42),CLIT(43),CLIT(44)  /'f','g','h','i'/,
     X     CLIT(45),CLIT(46),CLIT(47),CLIT(48)  /'j','k','l','m'/,
     X     CLIT(49),CLIT(50),CLIT(51),CLIT(52)  /'n','o','p','q'/,
     X     CLIT(53),CLIT(54),CLIT(55),CLIT(56)  /'r','s','t','u'/,
     X     CLIT(57),CLIT(58),CLIT(59),CLIT(60)  /'v','w','x','y'/,
     X     CLIT(61),CLIT(62)  /'z','*'/
      DATA (BIGL(I),I=0,MXLAB1)/'S','P','D','F','G','H','I','K','L','M'
     X                         ,'N','O','P','Q','R','S','T','U','V','W'
     X                         ,'X','Y','Z','a','b','c','d','e','f','*'/
      DATA (NUMB(I),I=0,MXLAB2)/'0','1','2','3','4','5','6','7','8','9'
     X                         ,'A','B','C','D','E','F','G','H','I','J'
     X                         ,'K','L','M','N','O','P','Q','R','S','*'/
C
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DIAGFS
c      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      IF(IEQ(0).NE.0)THEN
        ALLOCATE (ITMP(2*MXORB),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR ITMP'
          NF=0
          GO TO 7500
        ENDIF
      ENDIF
C
C FIX FOR FORTRAN 90 COMPILERS THAT DON'T ALLOW ASSIGNMENT OF CHARACTERS
C TO INTEGER VARIABLES, REQUIRED FOR HISTORIC BACKWARDS COMPATIBILITY
C
      OPEN(80,STATUS='SCRATCH',FORM='FORMATTED')
      WRITE(80,1111)CMBLK1,(CLIT(I),I=1,MXLIT)
 1111 FORMAT(80A1)
      BACKSPACE(80)
      READ(80,1111)MBLK1,(LIT(I),I=1,MXLIT)
      CLOSE(80)
c
      if(btime)then
        btimet=.true.                            !.t. gives more details
        timefh=dzero
        timeh=dzero
        timea=dzero
        timea1=dzero
        timea2=dzero
        timer1=dzero
        timer2=dzero
      else
        btimet=.false.
      endif
C
C INITIALIZE LOGICALS  ETC
C
      BCONT=MODE.EQ.2.OR.MODE.EQ.3                  !FOR BOUND-CONTINUUM
      IF(BCONT.AND.ISHFTLS.GT.0)THEN
         WRITE(6,*)'**** SR.DIAGFS: TECs CURRENTLY NOT INDEXED',
     X           ' FOR USE IN PRESENCE OF CONTINUUM - SETTING ISHFTLS=0'
         WRITE(0,*)
     X    '*** TECs NOT INDEXED FOR CONTINUUM USAGE - SETTING ISHFTLS=0'
         IF(ISHFTIC.NE.0)THEN
           WRITE(6,*)'*** LECs in SHFTIC SHOULD TAKE ACCOUNT OF THIS!'
           WRITE(0,*)'*** LECs in SHFTIC SHOULD TAKE ACCOUNT OF THIS!'
         ENDIF
         ISHFTLS=0
         IF(ALLOCATED(TFU))DEALLOCATE (TFU)
C         NF=-1
C         GO TO 7500
      ENDIF
      BMODE=MODE.LT.1.OR.ABS(MORT).GT.20
C
      BKUTLS=KUTLS.LT.0                           !.T. FOR SINGLE CF MIX
      bposu=.false.             !.T. uses new e-evec dui pos, old is sym
      if(bkutls)bposu=.false.           !force, for now (.T. not coded!)
C
      b2fs=nl000.gt.0                                       !2-fs exists
c      brtard=irtard.ne.0                          !only for brel=.true.
      BREL2=ABS(IREL).EQ.2                           !SMALL CPT PRESENT
      BDR=IDR.NE.0                                         !RYDBERG LOOP
      BBORN=MENGB.GE.0                                         !PWB DATA
C
      BFOTJ=.NOT.BLAG.OR..NOT.BFOT
C
      BNOAUG=.false.  !NMETAPJ.GT.0                         !OMIT AUGERS
C                               !RESTRICT CAPTURES AND BUNDLE AUGER LOSS
      BUNA=EIMXIC.ne.DZERO.OR.NMETAPJ.GT.0
C
      IF(NMETARJ.LT.0)THEN                            !RESOLVE BY CONFIG
        MMM=KMAX
      ELSE                                                   !UNRESOLVED
        MMM=0
      ENDIF
      TOLB2=TOLB/DTWO                                         !RYD->A.U.
C
      BUNR=NRSLMX.LT.0
     X .OR.NRSLMX.GE.0.AND.NNEW.GT.NRSLMX         !BUNDLE LOWER RAD RATE
C
      BUNPA=.NOT.BFOTJ.AND.BUNA                   !BUNDLE PI ELECTN CONT
      BUNPR=.NOT.BFOTJ.AND.(BUNR.OR.NMETAPJ.GT.0) !BUNDLE PI PHOTON CONT
C
      BDOWN=NMETAPJ.LE.0                 !SO BUNDLED PI IS WEIGTHED DOWN
C
      BELONG=IGAUGE.EQ.0                 !IGAG(0)  !AEK/SEK LENGTH GAUGE
      BKUTOO=KUTOO.NE.0
C
      BJSEL=MULTS.EQ.0
      IF(IDIAG.LT.0)BJSEL=.TRUE.
C
      NPRNT5=MOD(NPRINT,IFIVE)
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3                    !.AND.JPRINT.NE.3
C      BPRNT5=BPRNT0.AND..NOT.BREL                         !NPRINT.GT.-5
C
      BRESAT=MODE.GT.1             !.OR.BREL               !NPRINT.LE.-5
      BORT=MORT.LT.0
      BCPRNT=MOD(MPNCH,ITWO).NE.0!PRINT TCC'S-COULD USE KTCC AS FLAG NOW
      BTCC=.NOT.BRESAT.AND.BCPRNT
      BLMOD=MODD.EQ.0.OR.MODD.EQ.-1    !IF FALSE, PHASES MAY BE AN ISSUE
C      BTCC=BTCC.AND.BLMOD
C
      nmetj0=nmetaj
      NL0=NL                           !HOLD
C
      MBP='+BP2'
      IF(MBP2MX.LT.0)MBP='+BP1'
C
CL      LAPAK=1                                                  !LAPACK

C
C DETERMINE DIMENSIONS REQUIRED TO ALLOCATE
C (SEE ALGEB3 SET-UP, NOTE IAXJU IS REDUCED IF NO RAD OR DW)
C
      ISXDK=1
      IAXDK=1
      IXAAK=0
      IAXJU=0
      NCI=0
      NCTOT=0
C
      IF(IDW.EQ.0.AND.NPRNT5.EQ.-2)THEN
        IFLAG=-1
      ELSE
        IFLAG=1
      ENDIF
c local
      if(bkutls)allocate (iwrkn(kmax))
C
      DO KGROUP=1,NJO
C
        NCJ=NT(KGROUP)
        IAXDK=MAX(IAXDK,NCJ)
C
        N0=0
        NCC=0
        NCI0=0
c
       if(bkutls)then
c
        do k=1,kmax
          iwrkn(k)=0
        enddo
        lu=0
C
        DO NGJ=1,NGSLJ(KGROUP)
          IS=NSLJ(NGJ,KGROUP)
          NP=NSL(IS)
C
          nc0=ncc
          N00=0
          DO NJ=1,NP
            J=NJ+NCI0
            I=NRR(J+NCI)
            K=ABS(NFK(I))
            II=QCG(NF,K)
            ii=ieq(ii)
            IF(IYY(II).GT.0)then
              NCC=NCC+1
            else
              N00=N00+1
            endif
            iwrkn(k)=iwrkn(k)+1
          ENDDO
          N0=N0+N00
          lu=lu+n00*(ncc-nc0)                   !if no 2-fs
          NCI0=NCI0+NP
        ENDDO
c
        ncft0=0
        ncft=0
        do k=1,kmax
          ncf0=iwrkn(k)
          isxdk=max(isxdk,ncf0)
          ncft=ncft+ncf0*ncf0
          if(.not.bfot)then
            II=QCG(NF,K)
            ii=ieq(ii)
            if(iyy(ii).lt.0)ncft0=ncft0+ncf0*ncf0
          endif
        enddo
c
        if(mode.eq.2)then
          if(bfot)then                          !need c-c e-vectors
            nctot=nctot+ncft
          else                                  !only b-b
            iaxju=max(iaxju,nctot+ncft)         !need buffer
            nctot=nctot+ncft0                   !so can overwite c-c
          endif
        else                                    !need full block
          if(mode.eq.4)then                     !bound only
            ncc=0
            lu=0
          endif
          nctot=nctot+ncft
        endif
c
       else
C
        do i=1,mxorb
          ncc0(i)=0
        enddo
        mx0=mxorb+1
        lu=0
C
        DO NGJ=1,NGSLJ(KGROUP)
          IS=NSLJ(NGJ,KGROUP)
          NP=NSL(IS)
C
          nc0=ncc
          N00=0
          DO NJ=1,NP
            J=NJ+NCI0
            I=NRR(J+NCI)
            K=ABS(NFK(I))
            II=QCG(NF,K)
            ii=ieq(ii)
            IF(IYY(II).GT.0)then
              NCC=NCC+1
              ncc0(ii)=ncc0(ii)+1
              mx0=min(mx0,ii)
            else
              N00=N00+1
            endif
          ENDDO
          N0=N0+N00
          lu=lu+n00*(ncc-nc0)                   !if no 2-fs
          NCI0=NCI0+NP
        ENDDO
C
        if(mode.eq.2)then
          isxdk=max(isxdk,n0)
          iorb(mx0-1)=n0*n0
          do i=mx0,mxorb
            n=ncc0(i)
            iorb(i)=iorb(i-1)+n*n
            isxdk=max(isxdk,n)
          enddo
c
          if(bfot)then                          !need c-c e-vectors
            nctot=nctot+iorb(mxorb)
          else                                  !only need b-b
            iaxju=max(iaxju,nctot+iorb(mxorb))  !but need c-c buffer
            nctot=nctot+n0*n0                   !so can overwite c-c
          endif
        else                                    !need full block
          if(mode.eq.4)then                     !bound only
            ncc=0
            lu=0
          endif
          isxdk=iaxdk
          NCTOT=NCTOT+NCJ*NCJ
        endif
c
       endif
C
        if(b2fs)LU=NCC*(NCJ-NCC)    !WE HAVE 2-FS, NEED ND.NE.NC
        IXAAK=MAX(IXAAK,LU)
C
        NCI=NCI+NCJ
      ENDDO
C
      IF(BNOAUG)IXAAK=0
c
c      write(0,*)ixaak,iaxju
c      write(0,*)isxdk,iaxdk
C
      IF(IFLAG.LT.0)THEN
        if(mode.ne.2)IAXJU=IAXDK*IAXDK
      ELSE
        if(mode.ne.2.or.bfot)IAXJU=NCTOT
      ENDIF
c      write(0,*)nctot,iaxju
C
      CALL DIMUSE('MAXJU',IAXJU)
      CALL DIMUSE('MAXDK',IAXDK)
      CALL DIMUSE('MXAAK',IXAAK)
C
C LOCAL (LARGE)
C
      BALLH=.FALSE.
      BALLA=.FALSE.
C
      ALLOCATE (DU(ISXDK,ISXDK)
     X         ,DVU(IAXDK),DE(IAXDK),IDY(IAXDK),NVEC(IAXDK)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR DU,DVU,DE,IDY,NVEC'
        NF=0
        GO TO 7500
      ENDIF
      BALLH=.TRUE.
C
      IF(BPRNT0)THEN
        IM=(IAXDK*(IAXDK+1))/2
        ALLOCATE (DVP(IM),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR DVP'
          NF=0
          GO TO 7600
        ENDIF
      ENDIF
C
      ALLOCATE (TFUJ(IAXJU),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR TFUJ'
        NF=0
        GO TO 7600
      ENDIF
      IAXJU=IFLAG*IAXJU
C
      IF(MENG*IXAAK.GT.0)THEN
C        ALLOCATE (DUI(MENG,IXAAK),DVI(MENG,IAXDK),STAT=IERR)
        ALLOCATE (DUI(IXAAK,MENG),DVI(IAXDK,MENG),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR DUI,DVI'
          NF=0
          GO TO 7600
        ENDIF
        BALLA=.TRUE.
        IF(BLAG)THEN
          ALLOCATE (DDY(MENG))
        ELSE
          ALLOCATE (DDY(1))
          DDY(1)=DONE
          NP1=1
          NP2=1
        ENDIF
      ENDIF
C
C LOCAL (SMALL)
C
      ALLOCATE (IHARRY(KMAX),E1BCF(KMAX),SUMA(0:MMM))
C
      ALLOCATE (LMX(KMAX),QSB(10,KMAX),QLB(10,KMAX),ICF(0:KMAX))
C
      NC1=NCI+1
      ALLOCATE (DENERG(NC1),IWRK2(NC1),ID(0:NCI),NADRUJ(NCI),NAJ(NCI)
     X         ,DVECL(NCI),DVECV(NCI),DVECA(NCI))
C
      ALLOCATE (DWRK(NCI),IWRK3(NCI),IWRK4(NCI))
C
      ALLOCATE (ETM(NTT),WGT(NTT))
C
      IF(BTCC)THEN
        IF(MAXTR.GT.1)THEN                      !ALLOW USER TO REDUCE...
          IAXTR=MAXTR
        ELSE
          IF(KTCC.GT.0)THEN
            IAXTR=2*INT(IADJ8)
          ELSE
            IAXTR=IAXDK*IAXDK
          ENDIF
        ENDIF
        ALLOCATE (DT(IAXTR),MMIKE(IAXTR),NMIKE(IAXTR),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR DT,MMIKE,NMIKE'
          NF=0
          GO TO 7600
        ENDIF
      ENDIF
C
      allocate (nal(nci))
      allocate (jwrkg(0:njo),NGRPJ(NJO))
c
      if(.not.bjsel)allocate (iwrkj(nci))
      if(bcont)allocate (nadlu(iaxdk))
c
      if(bkutls)then
        if(.not.b2fs)allocate (iwrk5(nci))                   !iwrk5=test
        allocate (jwrkb(2,kmax,njo),ncf(kmax),kmap(kmax),iwrk1(kmax)
     x           ,luj(0:nsl0))
      elseif(bcont)then
        allocate (iwrkn(mxorb))
      endif
c
      if(.not.b2fs)allocate(iwrks(nsl0),nslb(nsl0))
c
      ngrp=1
      mxborb=0
      if(irlx.lt.0)then
        ngrp=-irlx/100000             !until /nrborb/ in a module
        mxborb=-irlx-100000*ngrp
      endif
      allocate (decorn(ngrp))
C
C SET-UP TECS BASED-ON CONFIGURATION AVERAGE CORRECTIONS
C
      IF(ISHFTLS.EQ.1.AND.ICAV.NE.0)THEN
        NCT=0
        DO K=1,NSL0
          NC=NSL(K)
          DO ND1=1,NC
            ND=ND1+NCT
            KF=NFK(ND)
            DELELS(ND,1)=ECAVX(KF)-ECAV(KF)
          ENDDO
          NCT=NCT+NC                       !TOT NO. TERMS
        ENDDO
      ENDIF
C
C TEC/LEC SET-UP
C
      MOBS='        '
      MTEC='          '
      NTEC='          '
      LABW='  '
      IF(ISHFTLS.GT.1)THEN                 !SET NUMBER OF TEC ITERATIONS
        ITEC=ISHFTLS
        MTEC='  OBS-CALC'
      ELSE
        ITEC=0
        IF(IOPTIM.LT.0)THEN
          MTEC='DIFFERENCE'
          MOBS='OBSERVED'
        ENDIF
      ENDIF
C
      IF(ISHFTIC.GT.1)THEN                 !SET NUMBER OF LEC ITERATIONS
        JTEC=ISHFTIC
        NTEC='  OBS-CALC'
      ELSE
        JTEC=0
        IF(IOPTIM.GT.0)THEN
          NTEC='DIFFERENCE'
          MOBS='OBSERVED'
          LABW='WT'
        ENDIF
      ENDIF
C
C RESET INCLUD
C
      INCLUD=MOD(INCL0,I1000000)
C
C SET CHARGES ETC.
C
      NZA=NZION-MION+1
      DZA2=NZA*NZA
      DZ2=NZION-MION
      IF(NZION.EQ.MION)DZ2=DONE
      DZ2=DZ2*DZ2
      TSHFT=MSHIFT+MSHIFT
C
C  DETAIL ONE-BODY MAGNETIC INTEGRALS
C
      IF(BJUMP2)THEN                            !JUST RE-SCALE
        IF(BPRNT0)WRITE(6,180)
        DO L=1,IRLP
          DD=DONE
c          K=(QRLP(2,L)-1)/MAXGR
          DO I=1,2
            N=QRLP(I,L)
c            IF(K.NE.0)N=N-K*MAXGR
            DD=DD*FACT(N)
          ENDDO
          DRLP1(L)=DRLP1(L)*DD
          IF(BPRNT0)WRITE(6,181)L,QRLP(1,L),QRLP(2,L),DRLP1(L)
        ENDDO
      ENDIF
C
      IF(BPRNT0)WRITE(6,900)JPRINT
C
      DSHFT0=DZERO
      DO K=1,MXORB
        IF(DEY(K).EQ.DZERO)GO TO 612
        IF(NNEW.GE.NSW.AND.IVAL(K).NE.0)DSHFT0=MAX(DSHFT0,DSHIFT(K))
        K17=K
        IF(BJUMP2.AND..NOT.BMVD)THEN            !JUST RE-SCALE
          DO J=1,K
            IF(DEY(J).NE.DZERO.AND.QL(J).EQ.QL(K))THEN
              DD=FACT(J)*FACT(K)
              DMASS(K,J)=DMASS(K,J)*DD
              DCD(K,J)=DCD(K,J)*DD
              D2LL(K,J)=D2LL(K,J)*DD
              IF(KUTOO.EQ.98)DXSI(K,J)=DXSI(K,J)*DD
            ENDIF
          ENDDO
        ENDIF
        DD1=DMASS(K,K)
        DD2=DCD(K,K)
        DD=DD1+DD2
        L=QL(K)/2
        IF(BPRNT0)WRITE(6,899)K,QN(K),L,DEY(K),DD1,DD2,DD,D2LL(K,K)
  612 ENDDO
C
      IF(BPRNT0)THEN
C
        WRITE(6,200)
        DO L=1,IRL
          IF(QRL(5,L).EQ.-1)THEN
            L1=QRL(1,L)
            L2=QRL(3,L)
            WRITE(6,201)L,L1,L2,DMASS(L1,L2),DCD(L1,L2),D2LL(L1,L2)
          ENDIF
        ENDDO
C
C  DETAILED PRINTOUT OF ONE-BODY RELATIVISTIC CORRECTIONS
C
        IF(NL.LT.-1)THEN                                   !SUPPRESS
          DO L=1,3
            IF(L.EQ.1)THEN
              WRITE(6,891)
            ELSEIF(L.EQ.2)THEN
              WRITE(6,892)
            ELSEIF(L.EQ.3)THEN
              WRITE(6,893)
            ENDIF
C
            DO K=1,K17
              I=K
              IF(DEY(K).EQ.DZERO.OR.QL(J).NE.QL(K))I=10000
              IF(L.EQ.1)THEN
                WRITE(6,895)I,(DMASS(K,J),J=1,K)
              ELSEIF(L.EQ.2)THEN
                WRITE(6,895)I,(DCD(K,J),J=1,K)
              ELSEIF(L.EQ.3)THEN
                WRITE(6,895)I,(D2LL(K,J),J=1,K)
              ENDIF
            ENDDO
          ENDDO
        ENDIF
C
      ENDIF
C
C DETAILED PRINTOUT OF ANY QED CONTRIBUTIONS
C
      IF(QED.NE.0)THEN
        IF(BPRNT0)WRITE(6,3005)
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            IF(IYY(K).GT.0)GO TO 614                !WE ARE DONE
            IF(BJUMP2.AND.QED.GT.0)THEN             !JUST RE-SCALE
              DD=FACT(K)*FACT(K)
              VPINT(K)=DD*VPINT(K)
              SLFINT(K)=DD*SLFINT(K)
            ENDIF
            DD=VPINT(K)+SLFINT(K)
            IF(BPRNT0)WRITE(6,3010)K,QN(K),QL(K)/2,VPINT(K),SLFINT(K),DD
          ENDIF
        ENDDO
      ENDIF
C
  614 CONTINUE
C-----------------------------------------------------
C  *** CALCULATE TWO-BODY FINE-STRUCTURE INTEGRALS
C-----------------------------------------------------
C
           if(btimet)call cpu_time(timei)
c
C  HAMILTONIAN
C
      IF(NL000.GT.0)THEN
C
        CALL FSINT(BPRNT0)
C
        IF(NF.LE.0)GO TO 2000
      ENDIF
C
C  M1+BP INTEGRALS
C
      IF(NL.GT.NL000)THEN
C
        CALL RADBP2(BPRNT0)
C
        IF(NF.LE.0)GO TO 2000
      ENDIF
C
      if(btimet)then
        call cpu_time(timef)
        times=timef-timei
        if(nint(times).ne.0)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagfs:'                 !par
cpar          write(iwp,*)'    integral time=',nint(times),'sec'    !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'integral time=',nint(times),'sec'
cpar        endif                                                   !par
        endif
      endif
C
      ML=2*MAXLAM
      IF(MAXLAM.NE.1000.AND.BPRNT0)WRITE(6,301)ML
C
C
C***********************************************************************
C
C  CONSTRUCT AND DIAGONALIZE ENERGY (SUB-)MATRICES.
C
C***********************************************************************
C
C
C  CALCULATE ENERGY CONTRIBUTION DECORE OF THE NW CORE ELECTRONS
C  (MAYBE GROUP DEPENDENT)
C
        do n=1,ngrp
c
          n1=n-1
          decor0=dzero
C
C 1-BODY
C
      DC1=DZERO                              !NON-REL CONTRIB
      DR1=DZERO                                  !REL CONTRIB
      DO L=1,NW
        KX=NNL(L,1)            +mxborb*n1
        DC1=DC1+DEY(KX)
        DR1=DR1+DCD(KX,KX)+DMASS(KX,KX)
        IF(QED.NE.0)DR1=DR1+VPINT(KX)+SLFINT(KX)
        IF(KUTOO.EQ.98)DR1=DR1+DXSI(KX,KX)
      ENDDO
      DCR1=DC1+DR1                      !NON-REL + REL 1-BODY
C
C 2-BODY
C
      DC2=DZERO                              !NON-REL CONTRIB
      DR2=DZERO                                  !REL CONTRIB
      DO I=1,NAD(0)
        M=INT(NRK(I))          +n1
        DC2=DC2+DRL(M)*DRK(I)
        IF(BKUTOO)THEN
          IF(BFALL(I))THEN
            DR2=DR2-DRK(I)*DZL(M)
          ELSE
            DR2=DR2+DRK(I)*DZL(M)
          ENDIF
          DR2=DR2+DRK(I)*DXTWO(M)+DEK(I)*DETA(M)
C                                -              (MINUS) JONES
        ENDIF
      ENDDO
      DCR2=DC2+DR2                      !NON-REL + REL 2-BODY
      DR12=DR1+DR2                              !REL 1+2 BODY
C
      DECORE=DCR1+DCR2                      ! 1-BODY + 2-BODY
C
      IF(BPRNT0)THEN
        WRITE(6,400)DCR2,DCR1
        IF(BCONT)THEN
          WRITE(6,504)
          IF(ISHFTLS.NE.0.OR.ISHFTIC.NE.0)WRITE(6,509)
        ENDIF
      ENDIF
c
          decorn(n)=decore
          decor0=min(decor0,decore)
c
        enddo
c
        decore=decor0
c
        do n=1,ngrp
          decorn(n)=decorn(n)-decore
        enddo
C
C  CALCULATE 1-BODY CF ENERGY CONTRIBUTION OF THE NF VALENCE ELECTRONS
C
      DD=DZERO
      M2=0
      DO M1=1,KMAX
        E1BCF(M1)=DZERO
        DO L=1,NF
          IF(QCG(L,M1).NE.M2)THEN
            M2=QCG(L,M1)
            DD=DEY(M2)
            DD=DD+DCD(M2,M2)+DMASS(M2,M2)                !.NE. NOT .LT.!
            IF(QED.NE.0.AND.QN(M2).GT.0.and.qed.ne.99)
     X                         DD=DD+VPINT(M2)+SLFINT(M2)
          ENDIF
          E1BCF(M1)=E1BCF(M1)+DD
        ENDDO
        IF(ICAV.NE.0.AND.ISHFTLS.NE.1)
     X               E1BCF(M1)=E1BCF(M1)+ECAVX(M1)-ECAV(M1) !CA CORRECTN
      ENDDO
C
C  COLLAPSE BACK RELAXED ORBITAL LIST
C
      IF(IEQ(0).LT.0)THEN
        MXBORB=-IEQ(0)
        KF=MB+MXBORB
        DO K=1,KF
          K2=2*K
          ITMP(K2-1)=QN(K)
          ITMP(K2)=QL(K)/2
          IORB(K)=K2
        ENDDO
        KP=2*KF
        KF=MB+MXBORB*KMAX
        IF(BDR)THEN
          DO K=1,KMAX
            KF=KF+1
            IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN         !FIRST OCC.
              KP=KP+1
              ITMP(KP)=QN(KF)
              KP=KP+1
              ITMP(KP)=QL(KF)/2
              IORB(KF)=KP
            ENDIF
          ENDDO
        ENDIF
        DO K=1,KMAX
          KF=KF+1
          IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN           !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(KF)
            KP=KP+1
            ITMP(KP)=QL(KF)/2
            IORB(KF)=KP
          ENDIF
        ENDDO
      ELSEIF(IEQ(0).GT.0)THEN
        KP=0
        DO K=1,MXORB
          IF(K.EQ.IEQ(K))THEN                                !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(K)
            KP=KP+1
            ITMP(KP)=QL(K)/2
            IORB(K)=KP
          ENDIF
        ENDDO
      ENDIF
C
      IF(.NOT.BMODE)THEN
        EIONMN=DZERO
        IF(IEQ(0).EQ.0)THEN
          KF=MIN(MXLIT,MXORB)
          IF(BPRNT0)WRITE(MW,507)KMAX,NZION,MION,(ABS(QN(K)),QL(K)/2
     X                          ,K=1,KF)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                           ,(int(ABS(QN(K))),int(QL(K)/2),K=1,KF)
        ELSE
          KF=MIN(KP,MXLIT)
          IF(BPRNT0)WRITE(MW,507)KMAX,NZION,MION,(ABS(ITMP(K))
     X                          ,ITMP(K+1),K=1,KF,2)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                     ,(int(ABS(ITMP(K))),int(ITMP(K+1)),K=1,KF,2)
        ENDIF
      ENDIF
C
      DO K=1,KMAX
        LM=0
C
        DO J=1,MXORB
          IF(NEL(J,K).GT.0)THEN
            LM=LM+1
            QSB(LM,K)=NEL(J,K)
            IF(LM.GT.1)QSB(LM,K)=QSB(LM,K)+50
            IF(IEQ(0).NE.0)THEN
              JQ=IEQ(J)
              JM=MIN(IORB(JQ)/2,MXLIT)
            ELSE
              JQ=J
              JM=MIN(J,MXLIT)
            ENDIF
            QLB(LM,K)=LIT(JM)
CHAR        QLB(LM,K)=ICHAR(CLIT(JM))
            NCC0(LM)=JQ
          ENDIF
        ENDDO
        LMX(K)=LM
C
        IF(LM.LT.10)THEN
          LP=LM+1
          DO J=LP,10
            QSB(J,K)=0
            QLB(J,K)=MBLK1
CHAR        QLB(J,K)=ICHAR(CMBLK1)
          ENDDO
        ENDIF
        M2=QCG(NF,K)
        KW=K
        MST=MSTAT(K)
        IF(IYY(M2).GT.0)THEN
          M1=QL(M2)+1
          KW=-K
          MST=MSTAT(K)/(M1+M1)
        ENDIF
        IF(.NOT.BMODE)THEN
          IF(BPRNT0)WRITE(MW,517)KW,MST,MA,MB,(QSB(L,K)
     X             ,QLB(L,K),L=1,LM)
CHAR  X            ,CHAR(QLB(L,K)),L=1,LM)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KW),int(MST),int(MA),int(MB)
     X                           ,(int(QSB(L,K)),int(QLB(L,K)),L=1,10)
        ENDIF
        DO L=1,LM
          QLB(L,K)=NCC0(L)
        ENDDO
      ENDDO
C
      IF(NMETARJ.LT.0)THEN                       !MAP SUM OVER CHANNEL L
        ICF(0)=0
        DO K=1,KMAX
          I=QCG(NF,K)
          IF(IYY(I).GT.0)THEN
            ICF(K)=K
            K1=K-1
            IF(ICF(K1).NE.0)THEN                 !CHECK LAST FOR A MATCH
              IF(LMX(K).NE.LMX(K1))GO TO 841
              DO L=LMX(K)-1,1,-1
                IF(QLB(L,K).NE.QLB(L,K1))GO TO 841
                IF(QSB(L,K).NE.QSB(L,K1))GO TO 841
              ENDDO
              ICF(K)=ICF(K1)
            ENDIF
          ELSE
            ICF(K)=0
          ENDIF
 841    ENDDO
      ENDIF
C
      IF(.NOT.BMODE)THEN
        IF(BPRNT0)WRITE(MW,505)NZION,MION
        IF(.NOT.BPRNT0)WRITE(MWU)int(NZION),int(MION)
      ENDIF
C
      IF(BCPRNT)THEN
        IF(NTCC.NE.MTCC)WRITE(6,755)MTCC,NTCC-MTCC !FLAG MIXED SPEC/CORR
        IF(KTCC.GT.0)MTCC=NNRGLS                              !FOR TCCDW
        IF(BTCC.AND.KTCC.GT.0.AND.BPRNT0)WRITE(6,746)
      ENDIF
C
C
C*********************************************************************
C     THE FOLLOWING LOOP 528 RUNS THROUGH ALL THE NJO (J,P) GROUPS
C     IT CORRESPONDS TO LOOP 103 IN SR.ALGEB3
C*********************************************************************
C
      NCUT=KCUT
      IF(KCUT.LE.0)NCUT=10000
      BMULT=MULTS .GT. 0
      MULTSM=MULTS-1
      BAUXE=.FALSE.
      BAUX=JPRINT.EQ.1.OR.JPRINT.GT.4      !.NOT.BAUX IGNORE CORRELATION
c
C - no longer in use (unless uncommented for testing)
      TOLA=CMXICA*D1M4                           !MAX B-F MATRIX ELEMENT
      IF(NNEW.GT.1)THEN
        T=NNEW
        T=T/DTWO
        TOLA=TOLA/(T*SQRT(T))
      ENDIF
      tola1=tola
      tola2=tola1/100
C
      IF(WLG1.LT.DZERO)THEN                      !MAX AUGER RATE
        WLG=D1M2
      ELSE
        WLG=DZERO
      ENDIF
      WLG=MAX(WLG,WLG1)
c
c repeat of diagon...
      if(bkutls)then                   !map configs: all bound then cont
        kb=0
        do k=1,kmax
          if(iyy(qcg(nf,k)).lt.0)then
            kb=kb+1
            kmap(kb)=k
          endif
        enddo
        kc=kb
        do k=1,kmax
          if(iyy(qcg(nf,k)).gt.0)then
            kc=kc+1
            kmap(kc)=k
          endif
        enddo
        kmax0=kb
        if(kc.gt.kb)then
          kmax1=kmap(kmax0+1)
        else
          kmax1=-1                        !should not be used as no cont
        endif
      endif
C
C
 5000 BTEC=ITEC.GT.1.OR.JTEC.GT.1                 !SKIP L/TEC ITERATIONS
C
      NCI=0
      NP8=0
c      MC=0
      NTRAN=0
      ID(0)=0
      MJX=0
      LUMAX=0
      NCTOT=0
      BINT=IAXJU.GT.0
      DMIN=D1P20
      DMAX=-D1P20
      JTMIN=0
      NSKP=0
      NEIG=NEIGENJ                               !USER SETS NO. E-STATES
      IF(ECORRJ.LT.DZERO)THEN
        EEIG=ECORRJ/DTWO-DECORE                   !AS ECORR ABSOLUTE RYD
        if(eeig.ge.dzero)stop 'diagfs, eigg reset .ge. zero...'
      ELSE
        EEIG=DZERO
      ENDIF
c
      dionmn=dzero                   !should really be local, not global
      etest=eimxic
c
      jwrkg(0)=0
      ib0=0
C
C
      DO 528 KGROUP=1,NJO                                 !BEGIN JP LOOP
C
C
      NCJ=NT(KGROUP)
C
      IF(.NOT.BINT)NCTOT=0
C
      NGRPJ(KGROUP)=NCI
C
      IF(NASTJ.GT.0)THEN                          !MAY RESTRICT E-STATES
        I1=NCI+1
        IP=NSLJ(1,KGROUP)
        JP=10*JN(I1)+QPI(IP)/2
        DO N=1,NASTJ
          IF(JPI(N).EQ.JP)THEN                    !WE HAVE A WINNER
            IF(NJPI(N).GT.0)NEIG=NJPI(N)          !THEN USER SET
            GO TO 851
          ENDIF
        ENDDO
        NEIG=NEIGENJ                              !SHOULDN'T GET HERE
 851    CONTINUE
      ENDIF
C
C INDEX E-VECTORS AND, MAYBE, BOUND-CONT INTERACTIONS
C                                     !don't use parallel flag "par"!!
      if(bkutls)then                  !Partition by config (scf)
c
        do k=1,kmax
          ncf(k)=0
        enddo
c
        n0=0
        NCI0=0
        DO NGJ=1,NGSLJ(KGROUP)
         IS=NSLJ(NGJ,KGROUP)
         NP=NSL(IS)
         n00=0                       !no bound levels within a given slp
         DO NJ=1,NP
          I=NJ+NCI0
          II=I+NCI
          IT=NRR(II)
          M1=NFK(IT)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)then
            IDY(I)=-IDY(I)
            n0=n0+1
            if(.not.bjsel)then       !reverse index for jwrkg store
              ib0=ib0+1
              iwrkj(ib0)=ii
            endif
            n00=n00+1
            nal(ii)=n00
          ELSE
            NFK(IT)=-M1
          ENDIF
          ncf(m1)=ncf(m1)+1
          NAJ(II)=ncf(m1)            !REL POS OF ABS LEVEL IN JP GROUP
         ENDDO
         if(.not.b2fs)nslb(is)=n00   !only needed for .not.b2fs
         NCI0=NCI0+NP
        ENDDO
c
        jwrkg(kgroup)=jwrkg(kgroup-1)+n0
c
        k1=kmap(1)
        iwrk1(k1)=0
        jwrkb(1,k1,kgroup)=0
        jwrkb(2,k1,kgroup)=ncf(k1)
        iwrkn(k1)=0
        k0=k1
c
c      write(6,*)'kgroup=',kgroup
        do k=2,kmax
          k1=kmap(k)
          nn=ncf(k0)
          iwrk1(k1)=iwrk1(k0)+nn*nn
          iwrkn(k1)=iwrkn(k0)+nn
c       write(6,*)k,k1,ncf(k1),iwrkn(k1)
          if(k.le.kmax0)then          !not used if no radiation...
            jwrkb(1,k1,kgroup)=jwrkb(1,k0,kgroup)+nn
            jwrkb(2,k1,kgroup)=ncf(k1)
          endif
          k0=k1
        enddo
C
        DO I=1,NCJ
          II=I+NCI
          IT=NRR(II)
          M1=NFK(IT)
          M1=ABS(M1)
          nadruj(ii)=nctot+iwrk1(m1)+ncf(m1)*(naj(ii)-1)
        ENDDO
C
        if(bfot)then                         !need c-c e-vectors
          k=kmap(kmax)
        elseif(kmax0.gt.0)then               !only b-b, so overwrite c-c
          k=kmap(kmax0)
        else
          k=0
        endif
        if(k.gt.0)nctot=nctot+iwrk1(k)+ncf(k)*ncf(k)
c
      elseif(mode.eq.2)then             !need b-c partitioning
c
        n0=0                            !total number of bound levels
        do i=1,mxorb
          ncc0(i)=0                     !no of cont for each orb ang mom
        enddo
        mx0=mxorb    !+1
C
        NCI0=0
        DO NGJ=1,NGSLJ(KGROUP)
         IS=NSLJ(NGJ,KGROUP)
         NP=NSL(IS)
         n00=0                       !no bound levels within a given slp
         DO NJ=1,NP
          I=NJ+NCI0
          II=I+NCI
          IT=NRR(II)
          M1=NFK(IT)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)then
            IDY(I)=-IDY(I)
            n0=n0+1
            NAJ(II)=n0               !REL POS OF ABS LEVEL IN JP GROUP
            if(.not.bjsel)then       !reverse index for jwrkg store
              ib0=ib0+1
              iwrkj(ib0)=ii
            endif
            n00=n00+1
            nal(ii)=n00
          ELSE
            NFK(IT)=-M1
            ncc0(m2)=ncc0(m2)+1
            NAJ(II)=ncc0(m2)         !REL POS OF ABS LEVEL IN JP GROUP
            mx0=min(mx0,m2)
          ENDIF
         ENDDO
         if(.not.b2fs)nslb(is)=n00   !only needed for .not.b2fs
         NCI0=NCI0+NP
        ENDDO
c
        jwrkg(kgroup)=jwrkg(kgroup-1)+n0
        iorb(mx0)=n0*n0
        iwrkn(mx0)=0
c
c?        icc=1
        do i=mx0+1,mxorb
c?          icc=icc+1
          nn=ncc0(i-1)                  !maybe zero
          iorb(i)=iorb(i-1)+nn*nn
          iwrkn(i)=iwrkn(i-1)+nn
        enddo
c
        DO I=1,NCJ
          II=I+NCI
          IF(IDY(I).GT.0)THEN
            m2=idy(i)
            nadruj(ii)=nctot+iorb(m2)+ncc0(m2)*(naj(ii)-1)
          else
            nadruj(ii)=nctot+n0*(naj(ii)-1)
          ENDIF
        ENDDO
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+iorb(mxorb)+ncc0(mxorb)*ncc0(mxorb)
        else                                    !only b-b
          nctot=nctot+n0*n0                     !so can overwrite c-c
        endif
c
       if(bposu.and..not.b2fs)then              !new b-c pos
        lu=0
        do m2=mx0,mxorb
          nn=ncc0(m2)
          if(nn.gt.0)then
            NCI0=0
            DO NGJ=1,NGSLJ(KGROUP)
              IS=NSLJ(NGJ,KGROUP)
              NP=NSL(IS)
              N00=0
              DO NJ=1,NP
                I=NJ+NCI0
                IF(IDY(I).EQ.M2)THEN
                  nadlu(i)=lu                   !new pos
                  lu=lu+nslb(is)
                ENDIF
              ENDDO
              NCI0=NCI0+NP
            ENDDO
          endif
        enddo
       endif
C
      ELSE                                !INDEX B-B E-VECTORS
C
        N0=0
        DO I=1,NCJ
          II=I+NCI
          NAJ(II)=I
          IT=NRR(II)
          M1=NFK(IT)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)THEN
            IDY(I)=-IDY(I)
            n0=n0+1
          ELSE
            NFK(IT)=-M1
          ENDIF
          NADRUJ(II)=NCTOT                !END POSITION OF E-VECTOR II-1
          NCTOT=NCTOT+NCJ
          if(.not.bjsel)iwrkj(ii)=ii
        ENDDO
c
        jwrkg(kgroup)=jwrkg(kgroup-1)+ncj       !=ngrpj(kgroup)?
C
      ENDIF
C
      IF(BPRNT0)THEN                            !INITIALIZE FOR PRINTING
        IM=(NCJ*(NCJ+1))/2
        DO IP=1,IM
          DVP(IP)=DZERO
        ENDDO
      ENDIF
C
            if(btimet)call cpu_time(timei)
c
C SET-UP BOUND-CONTINUUM PROBLEM
C
      IF(BCONT)THEN
C                                                    !CHECK B-C INDEXING
      NHOLD8=NP8
C
      if(b2fs)then
c
        LU=0
        DO L=1,NCJ
          IF(IDY(L).GT.0)THEN
            nadlu(l)=lu                   !old pos, not used by new
            lu=lu+n0
          ENDIF
        ENDDO
C
      elseif(.not.bposu)then              !old pos
C
       LU=0
       DO L=1,NCJ
         IF(IDY(L).GT.0)THEN
           nadlu(l)=lu
           j=l+nci
           it=nrr(j)
           ip=nfq(it)
           DO M=1,NCJ
             IF(IDY(M).LT.0)THEN
               k=m+nci
               itp=nrr(k)
               ipp=nfq(itp)
               IF(ip.eq.ipp)LU=LU+1
             ENDIF
           ENDDO
         ENDIF
       ENDDO
c
      endif
C
      IF(LU.GT.LUMAX)LUMAX=LU
      IF(LU.GT.IXAAK)THEN                         !SHOULD NOT HAPPEN NOW
        WRITE(6,896)LU
        WRITE(0,*)'***INCREASE MXAAK'
        GO TO 2000
      ENDIF
      LUX=LU
C
C STORE BOUND-CONTINUUM (NON-REL, NFS & FS)
C
      NCI0=0
      DO NGJ1=1,NGSLJ(KGROUP)                             !BEGIN SL LOOP
       IS=NSLJ(NGJ1,KGROUP)
       NP=NSL(IS)
c test
       if(bkutls.and..not.b2fs)then
        n00=0
        do nj11=1,np                                     !begin slj loop
         i=nj11+nci0
         if(idy(i).lt.0)then
           n00=n00+1
           iwrk5(i)=n00
         endif
        enddo
       endif
C
       IB=NADG(IS)                                        !FOR H(LS) POS
C
       NCIP0=0
       DO NGJP1=1,NGJ1                                    !BEGIN SL LOOP
        ISP=NSLJ(NGJP1,KGROUP)
        NPP=NSL(ISP)
C
        n00=0
        DO NJ11=1,NP                                     !BEGIN SLJ LOOP
C
         I=NJ11+NCI0
         if(idy(i).lt.0)n00=n00+1                  !bound posn within SL
         it=nrr(i+nci)
C
         IF(IS.EQ.ISP)NPP=NJ11
C
         n00p=0
         DO NJP11=1,NPP                                  !BEGIN SLJ LOOP
C
          J=NJP11+NCIP0
          if(idy(j).lt.0)n00p=n00p+1               !bound posn within SL
c
          if(bkutls)then
           jt=nrr(j+nci)
           if(idy(i)*idy(j).gt.0.and.nfk(it).ne.nfk(jt))go to 620
          else
           if(idy(i).gt.0.and.idy(j).gt.0.and.idy(i).ne.idy(j))go to 620
          endif
c
          if(is.eq.isp)ib=ib+1                     !increment ls counter
          if(idy(i)*idy(j).lt.0.AND..NOT.BNOAUG)then                !b-c
            if(.not.b2fs.and.is.ne.isp)go to 620              !no 2-body
          else                                               !b-b or c-c
            NP8=NP8+1                                  !so increment np8
            go to 620                                       !and bailout
          endif
C
C INDEX & INITIALIZE
C
          if(idy(i).gt.0)then
            lc=i
            lb=j
          else
            lc=j
            lb=i
          endif
          llb=nci+lb
          llc=nci+lc
c
          if(b2fs)then
            if(bposu)then                         !new pos
              m1=naj(llc)
              if(bkutls)then
                itc=nrr(llc)
                m2=-nfk(itc)
                m1=m1-iwrkn(kmax1)
              else
                m2=idy(lc)
              endif
              lu=(iwrkn(m2)+m1-1)*n0+naj(llb)
            else                                  !old pos
              lu=nadlu(lc)+naj(llb)
            endif
            if(bkutls)then
              itb=nrr(llb)
              m2=nfk(itb)
              lu=lu+iwrkn(m2)
            endif
          else
            lu=nadlu(lc)+nal(llb)                 !old/new pos
c tests
           if(idy(i).gt.0)then
            n5=n00p
           else
            n5=n00
           endif
           if(nal(llb).ne.n5)stop  'nal'
           if(bkutls.and..not.b2fs)then
            if(iwrk5(lb).ne.n5)then               !iwrk5 test
              write(6,*)n5,iwrk5(lb)
              stop 'iwrk5'
            endif
           endif
c end test
          endif
C TBD remove below test
          if(lu.gt.ixaak)then
           write(0,*)kgroup,n0,(ncj-n0),ncj,n0*(ncj-n0)
           stop 'ixaak'
          endif
          DO M=1,MENG
C            DUI(M,LU)=DZERO
            DUI(LU,M)=DZERO
          ENDDO
C
C 2-BODY FS INTERPOLATABLE
C
          IF(B2FS)THEN
            K1=NADR(NP8)+1
            NP8=NP8+1
            K2=NADR(NP8)
            DO L=K1,K2
              KX=INT(MSS(L))
              KK=NLI(KX)
              IF(KK.GT.0)THEN
                DO M=1,MENG
C                  DUI(M,LU)=DUI(M,LU)+DNLI(M,KK)*DSS(L)
                  DUI(LU,M)=DUI(LU,M)+DNLI(M,KK)*DSS(L)
                ENDDO
              ENDIF
            ENDDO
          ENDIF
C
C ADD-IN LS TERM CONTRIBUTIONS
C
          IF(IS.EQ.ISP)THEN
C
            M1=NAD(IB-1)+1
            M2=NAD(IB)
C
            DO L=M1,M2
              KX=INT(NRK(L))
              KK=NRLI(KX)
              IF(KK.GT.0)THEN
C SLATER
                DO M=1,MENG
C                  DUI(M,LU)=DUI(M,LU)+DRLI(M,KK)*DRK(L)
                  DUI(LU,M)=DUI(LU,M)+DRLI(M,KK)*DRK(L)
                ENDDO
C NFS
                IF(BKUTOO)THEN
                  DO M=1,MENG
                    DS=DZLI(M,KK)*DRK(L)
                    IF(BFALL(L))DS=-DS
                    DS=DS+DXTWOI(M,KK)*DRK(L)+DETAI(M,KK)*DEK(L)!- JONES
C                    DUI(M,LU)=DUI(M,LU)+DS
                    DUI(LU,M)=DUI(LU,M)+DS
                  ENDDO
                ENDIF
C
              ENDIF
            ENDDO
C
          ENDIF
C
          IF(BPRNT0)THEN
            IP=ICOL(J,I,IZERO)
c            DVP(IP)=DUI(NREL,LU)                  !STORE FOR PRINTING
            DVP(IP)=DUI(LU,NREL)                  !STORE FOR PRINTING
          ENDIF
C
  620     CONTINUE
C
         ENDDO                                    !END SLJ LOOP
C
        ENDDO                                     !END SLJ LOOP
C
        NCIP0=NCIP0+NPP
       ENDDO                                      !END SL LOOP
C
       NCI0=NCI0+NP
      ENDDO                                       !END SL LOOP
C
      NP8=NHOLD8                                  !RE-INSTATE FS COUNTER
C
      ENDIF
C
C FORM H-MATRIX FOR DIAGONALIZATION
C
      ICB=0
      ICC=0
C
      NCI0=0
      DO NGJ1=1,NGSLJ(KGROUP)                             !BEGIN SL LOOP
       IS=NSLJ(NGJ1,KGROUP)
       NP=NSL(IS)
C
       IB=NADG(IS)                                        !FOR H(LS) POS
       IF(ISHFTLS.GT.0)THEN                                    !TEC ONLY
         IAB=ngrpi(is)
         IA=0
         DO L=1,IS-1
           IN=NSL(L)
           IA=IN*IN+IA
         ENDDO
         INN=NSL(IS)
       ENDIF
C
       NCIP0=0
       DO NGJP1=1,NGJ1                                    !BEGIN SL LOOP
        ISP=NSLJ(NGJP1,KGROUP)
        NPP=NSL(ISP)
C
        DO NJ11=1,NP                                     !BEGIN SLJ LOOP
C
         I=NJ11+NCI0
         II=I+NCI
         IT=NRR(II)
C
         NN=NADRUJ(II)
C
         IF(IS.EQ.ISP)THEN
C
           NPP=NJ11
C
           M1=NFK(IT)
           M1=ABS(M1)
C
           DE(I)=E1BCF(M1)
           IF(ISHFTIC.GE.1)DE(I)=DE(I)+DELEIC(II,1)      !PRE-DIAG SHIFT
c
           if(irlx.lt.0)then
             n=icfgp(m1)
             de(i)=de(i)+decorn(n)
           endif
C
           M2=QCG(NF,M1)
          if(bkutls)then
           IF(IYY(M2).GT.0)DE(I)=DE(I)+ECOR2
          else
           IF(IYY(M2).LT.0)THEN
             ICB=ICB+1
           ELSE
             DE(I)=DE(I)+ECOR2
             M2=IEQ(M2)
             DO M=1,ICC
               IF(M2.EQ.IORB(M))GO TO 317
             ENDDO
             ICC=ICC+1
             IORB(ICC)=M2
           ENDIF
          endif
C
         ENDIF
C
  317    CONTINUE
C
         DO NJP11=1,NPP                                  !BEGIN SLJ LOOP
C
          DD=DZERO
C
          J=NJP11+NCIP0
          JJ=J+NCI
          ITP=NRR(JJ)
c
          if(bcont)then
           if(bkutls)then
           if(idy(i)*idy(j).gt.0.and.nfk(it).ne.nfk(itp))go to 520
           else
           if(idy(i).gt.0.and.idy(j).gt.0.and.idy(i).ne.idy(j))go to 520
           endif
            if(is.eq.isp)ib=ib+1                  !increment ls counter
            if(idy(i)*idy(j).le.0)then            !b-c, already done
              if(mode.eq.2)then                   !else mode.eq.3
                if(b2fs)NP8=NP8+1
                go to 520
              endif
              if(.not.b2fs)go to 518              !no fs, no increment
            endif
          else
            if(bkutls.and.nfk(it).ne.nfk(itp))go to 520
            if(is.eq.isp)ib=ib+1
          endif
c
          if(bnobv.and.idy(i).lt.0.and.idy(j).lt.0)then
            ivi=abs(idy(i))
            ivj=abs(idy(j))
            if(ival(ivi).ne.ival(ivj))then         !zero ryd-N+1 int
              NP8=NP8+1
              go to 519
            endif
          endif
C
          N1=NADP(NP8)+1
          NP8=NP8+1
          N2=NADP(NP8)
c
c check for bkutls (just zero-out usual multi-config interactions)
          if(kutls.ge.0.and.nfk(it).ne.nfk(itp))then
            if(abs(nfk(it)).gt.kutls)go to 519
            if(abs(nfk(itp)).gt.kutls)go to 519
          endif
C
C 1-BODY FS
C
          DO L=N1,N2
            KX=INT(NRKP(L))
            DD=DRLP1(KX)*DRKP(L)+DD
          ENDDO
C
C 2-BODY FS
C
          IF(B2FS)THEN
            K1=NADR(NP8-1)+1
            K2=NADR(NP8)
            DO L=K1,K2
              KX=INT(MSS(L))
              DD=DNL(KX)*DSS(L)+DD
            ENDDO
          ENDIF
C
  518     IF(IS.NE.ISP)GO TO 519
C
C APPLY TERM ENERGY CORRECTION DELELS TO TERMS WITH INDICES T
C       IN THE TERM TABLES (NOT ENERGY ORDER)
C
          IF(ISHFTLS.GT.0)THEN
            L1=IT-IAB
            L2=ITP-IAB
            DO L=1,INN
              IF(ABS(TFU(IA+L1)).GT.D1M4)THEN
                IF(ABS(TFU(IA+L2)).GT.D1M4)THEN
                  DD=DELELS(L+IAB,1)*TFU(IA+L1)*TFU(IA+L2)+DD
                ENDIF
              ENDIF
              L1=INN+L1
              L2=INN+L2
            ENDDO
          ENDIF
C
C ADD-IN LS TERM CONTRIBUTIONS
C
          M1=NAD(IB-1)+1
          M2=NAD(IB)
C
          DO L=M1,M2
            KX=INT(NRK(L))
C
C 2-BODY NON-REL (SLATER)
C
            DD=DD+DRL(KX)*DRK(L)
C
C 1-BODY NFS
C
            IF(QRL(5,KX).LT.0)THEN    !DZL(KX)=DXTWO(KX)=DETA(KX)=0 HERE
              L1=QRL(1,KX)            !FALLING ORDER L1.GE.L2
              L2=QRL(3,KX)
              DS=DCD(L1,L2)+DMASS(L1,L2)
              IF(KUTOO.EQ.98)DS=DS+DXSI(L1,L2)
              DS=DS*DRK(L)
              DD=DD+DS
            ENDIF
C
C 2-BODY NFS
C
            IF(BKUTOO)THEN
              DS=DZL(KX)*DRK(L)
              IF(BFALL(L))DS=-DS
              DS=DS+DXTWO(KX)*DRK(L)+DEK(L)*DETA(KX)    !- JONES
              DD=DD+DS
            ENDIF
C
          ENDDO
C
C STORE H-MATRIX
C
  519     NJ=NAJ(JJ)
C
c      write(6,*)ii,jj,nj,nn,dd
          TFUJ(NJ+NN)=DD                         !STORE H FOR DIAG
C
          IF(BPRNT0)THEN
            IP=ICOL(J,I,IZERO)
            DVP(IP)=DD                           !STORE H FOR PRINTING
          ENDIF
C
  520     CONTINUE
C
         ENDDO                                   !END SLJ LOOP
C
         IF(IS.EQ.ISP)TFUJ(NJ+NN)=TFUJ(NJ+NN)+DE(I)   !ADD DIAG E HERE
C
        ENDDO                                    !END SLJ LOOP
C
        NCIP0=NCIP0+NPP
       ENDDO                                     !END SL LOOP
C
       NCI0=NCI0+NP
      ENDDO                                      !END SL LOOP
C
      LL=NCI               !FOR AUTOIONIZATION AS NCI GETS UPDATED
C
          if(btimet)then
            call cpu_time(timef)
            timefh=timefh+timef-timei
          endif
C
C*****************************************************************
C
C     DIAGONALIZE HAMILTONIAN
C
C*****************************************************************
C
           if(btime)call cpu_time(timei)
c
      INFO=0
C
      IF((MODE.NE.2.OR.ICC.LE.0).and..NOT.BKUTLS)THEN
C                           !DU IS LOWER, TFUJ UPPER (SIGH)
        NN=NADRUJ(LL+1)
        DO I=1,NCJ
          DO J=1,I
            DU(I,J)=TFUJ(NN+J)               !NAJ(J+LL)=J HERE (ALL B-B)
          ENDDO
CD          DU(I,I)=DU(I,I)+DE(I)
          NN=NN+NCJ
        ENDDO
C                           !BOTH UPPER HERE
        IF(IDIAG.GT.0)THEN
          NN=NADRUJ(LL+1)
          DO I=1,NCJ
            DO J=1,I-1
              DU(J,I)=TFUJ(NN+J)
            ENDDO
            NN=NN+NCJ
          ENDDO
        ENDIF
C
        CALL HDIAG(NCJ,NEIG,EEIG,DU,ISXDK,DVU,DVECV,NF,INFO)
C
        IF(NCJ*NF.LE.0.OR.INFO.GT.0)GO TO 2000
C
        IF(MODE.GE.4)THEN
          icc=0
          DO I=1,NCJ
            DO L=1,NCJ
              IF(IDY(L)*IDY(I).LE.0)DU(L,I)=DZERO
            ENDDO
          ENDDO
        ENDIF
C
        NN=NADRUJ(LL+1)
        DO J=1,NCJ
          DO I=1,NCJ
            TFUJ(NN+I)=DU(I,J)               !NAJ(I+LL)=I HERE (ALL B-B)
          ENDDO
          NN=NN+NCJ
        ENDDO
C
      ELSE
C
C DIAGONALIZE SEPARATELY THE ICC C-C BLOCKS PLUS THE B-B BLOCK
C
        IF(BKUTLS)THEN
          icb=0
          icc=0
          m0=1
          m1=kmax
        ELSE
          IF(ICB.GT.0)THEN
            M0=0
            IORB(0)=-1000
          ELSE
            M0=1
          ENDIF
          M1=ICC
        ENDIF
c
        nsubx=0
C
        DO M=M0,M1
C
          NSUB=0
          DO M7=1,NCJ
C
            IF(BKUTLS)THEN
              if(abs(nfk(nrr(m7+ll))).eq.m)then
                if(idy(m7).lt.0)then
                  icb=icb+1           !just flags existence
                else
                  icc=icc+1           !just flags existence
                endif
              else
                go to 675
              endif
            ELSE
              IF(IORB(M).LT.0.AND.IDY(M7).LT.0)GO TO 676
              IF(IORB(M).NE.IDY(M7))GO TO 675
            ENDIF
C
  676       NSUB=NSUB+1
            NVEC(NSUB)=M7
C
  675     ENDDO
c
          if(m.gt.0)nsubx=max(nsubx,nsub)
c
         if(bkutls)then
          if(nsub.eq.0)go to 677                !only if bkutls=.t.
         else
c - to be removed
          if(m.gt.0)then
            if(nsub.ne.ncc0(iorb(m)))then
              write(0,*)'icc=',m,'iorb=',iorb(m),'ncc0=',ncc0(iorb(m))
     x                 ,'nsub=',nsub
              stop 'cont orb index error...'
            endif
          else
            if(nsub.ne.n0)stop 'bound orb index error...'
          endif
         endif
C HOLD
          NSUB0=NSUB
          IDIAG0=IDIAG
C
  700     CONTINUE
C
          N1=NVEC(1)+LL
          NN=NADRUJ(N1)
          DO IS=1,NSUB
            DO JS=1,IS                !LOWER
              DU(IS,JS)=TFUJ(NN+JS)
c              if(abs(du(js,is)).lt.d1m10)du(js,is)=dzero
            ENDDO
CD            NI=NVEC(IS)
CD            DU(IS,IS)=DU(IS,IS)+DE(NI)
            NN=NN+NSUB
          ENDDO
C
          IF(IDIAG.GT.0)THEN
            DO IS=1,NSUB
              DO JS=IS+1,NSUB
                DU(IS,JS)=DU(JS,IS)
              ENDDO
            ENDDO
          ENDIF
C
          CALL HDIAG(NSUB,NEIG,EIGG,DU,ISXDK,DVECL,DVECV,NF,INFO)
C
          IF(NF.LE.0)GO TO 2000
C
CL          IF(INFO.GT.0)THEN   ! LAPACK FAILURE, SO TRY DIAG    !LAPACK
CL            WRITE(6,*)                                         !LAPACK
CL     X              ' RE-RUNNING THIS MATRIX ONLY WITH SR.DIAG'!LAPACK
CL            GO TO 700                                          !LAPACK
CL          ENDIF                                                !LAPACK
C
          IF(NSUB.EQ.0)THEN     ! DIAG FAILURE, SO RELOAD AND USE JACORD
            WRITE(6,*)' RE-RUNNING THIS MATRIX ONLY WITH SR.JACORD'
            NSUB=NSUB0
            IDIAG=1
            GO TO 700
          ENDIF
C
          IDIAG=IDIAG0
C
C STORE E-ENERGIES IN DVU AND E-VECTORS IN TFUJ
C
          N1=NVEC(1)+LL
          NN=NADRUJ(N1)
          DO IS=1,NSUB
            NI=NVEC(IS)
            DVU(NI)=DVECL(IS)
            DO JS=1,NSUB
              TFUJ(NN+JS)=DU(JS,IS)
            ENDDO
            NN=NN+NSUB
          ENDDO
c
  677    continue
C
        ENDDO
C
      ENDIF
C
  428 CONTINUE
c
          if(btime)then
            call cpu_time(timef)
            timeh=timeh+timef-timei
          endif
C
C*****************************************************************
C
C PRINT LEVEL ENERGIES, TRANSFORMATION MATRICES AND H-SUBMATRICES.
C
C*****************************************************************
C
      M2=0
C
      DO 525 I=1,NCJ
C
C     J IS THE ARRAY INDEX OF THE WHOLE H-MATRIX, WHEREAS I IS THE
C     POSITION IN THE APPROPRIATE SUBMATRIX
C
      J=I+LL                                   !+NCI
      IT=NRR(J)
      IWRK3(J)=0
      M=NFK(IT)
      JJ=ABS(M)
C      IF(IDY(I).GE.0)NFK(IT)=-JJ
C
        DD=DVU(I)
        IF(DD.NE.DZERO)THEN                      !E-STATE EXISTS
c
      if(qed.eq.99)then                        !post-process as grasp0
        nn=nadruj(j)
        coeff=dzero
        do l=1,ncj
          nj=naj(l+ll)
          coeff=coeff+tfuj(nn+nj)**2
        enddo
        mm1=abs(nfk(it))
        dq=dzero
        mm2=0
        do k=nf,1,-1
          if(qcg(k,mm1).ne.mm2)then
            mm2=qcg(k,mm1)
            if(qn(mm2).gt.0)dq=coeff*(vpint(mm2)+slfint(mm2))
          endif
          dvu(i)=dvu(i)+dq
        enddo
        dd=dvu(i)
      endif
C
C REMOVE ENERGY OF CONTINUUM ELECTRON FROM ENERGY LEVEL LIST
      IF(IDY(I).GE.0)THEN
        IF(MODE.LT.3)DD=DD-DYY(NREL)
        DD=MOD(DD,TSHFT)
        dionmn=min(dionmn,dd)
      ENDIF
C
C POST SHIFT FOR AUGERS
      IF(ISHFTIC.LT.0)THEN
        if(eflgj0*deleic(j,2).lt.dzero)then
          DD=deleic(j,2)+eflgj0-decore         !ABSOLUTE
        endif
      ENDIF
C
      IF(DD.LT.DMIN)THEN
        DMIN=DD
        JTMIN=J
      ENDIF
      IF(DD.GT.DMAX)DMAX=DD
C
          IF(IDIAG.GE.0.AND.JJ.GT.NCUT)THEN      !CORRELATION
            IWRK4(J)=-J
          ELSE
            IWRK4(J)=J
          ENDIF
        ELSE                                     !E-STATE DOES NOT EXIST
          IWRK4(J)=0
        ENDIF
C
      DENERG(J)=DD
C
      IF(BTEC)GO TO 525
C
      IF(BPRNT0)THEN
        NN=NADRUJ(J)
        IF((MODE.NE.2.OR.ICC.LE.0).AND..NOT.BKUTLS)THEN
          DO L=1,NCJ
            DVECL(L)=TFUJ(NN+L)
          ENDDO
        ELSE
          DO L=1,NCJ
            DVECL(L)=DZERO
            if(idy(i)*idy(l).gt.0)then
              if(bkutls.and.nfk(it).eq.nfk(nrr(l+ll)).or.
     x      .not.bkutls.and.(idy(i).lt.0.or.idy(i).eq.idy(l)))then
                nj=naj(l+ll)
                dvecl(l)=tfuj(nn+nj)
              endif
            endif
          ENDDO
        ENDIF
        M1=M2
        M2=M1+I
        M12=M1
        M1=M1+1
        L2=MIN(NCJ,10_SP)
        M12=M12+MIN(I,10-L2)
        IP=NFQ(IT)
        WRITE(6,183)J,IT,JN(J),QSI(IP)+1,QLI(IP)/2,QPI(IP)/2
     X             ,DE(I),DVU(I),NFK(IT),I,(DVECL(L),L=1,L2)
     X             ,(DVP(L),L=M1,M12)
        IF(M2.GT.M12)WRITE(6,184)(DVECL(L),L=L2+1,NCJ)
     X                          ,(DVP(L),L=M12+1,M2)
      ENDIF
C
C  CALCULATE 'TERM-COUPLING COEFFICIENTS' FOR TRANSFORMING
C  LS-COUPLING CONFIGURATION-MIXING K-MATRICES TO INTERMEDIATE-COUPLING
C  K-MATRICES:
C
C  BEWARE PHASE CONVENTIONS! HERE CONDON & SHORTLEY
C    (DEFAULT, ALTHOUGH THERE IS A FANO EXPERIMENT).
C
C  NOTE: IF BLMOD=.FALSE. PHASES OF TERM-COUPLING COEFFICIENTS MAY NOT
C  BE CONSISTENT WITH K-MATRIX DATA PRODUCED BY DISTORTED WAVE PROGRAM
C  OF W. EISSNER.
C
      IF(BTCC)THEN
C
        II=NADRUJ(J)
        NTRAN0=NTRAN
        M=IEORD(IT)                             !SO -> EO
        DO IB=1,NCJ
          IP=NRR(IB+NCI)
          IF(IP.NE.1.AND.NADRU(IP).EQ.0)BAUXE=.TRUE.
          IF(.NOT.BAUXE)THEN
            MP=IEORD(IP)                        !SO -> EO
            IF(MP.LE.MTCC.AND.M.LE.MTCC)THEN
              DS=DZERO
              DO L=1,NCJ
                ITP=NRR(L+NCI)
                IF(NFQ(ITP).EQ.NFQ(IP))THEN
                  NN=NADRU(IP)+NAI(ITP)
                  DS=DS+TFUJ(II+L)*TFU(NN)
                ENDIF
              ENDDO
              IF(ABS(DS).GT.TOLTCC)THEN
                NTRAN=NTRAN+1
                IF(NTRAN.LE.IAXTR)THEN
                  DT(NTRAN)=DS
                  MMIKE(NTRAN)=MP
                  IF(KTCC.LT.0)NMIKE(NTRAN)=M                     !JAJOM
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDDO
        IF(KTCC.GT.0)THEN                                        !STGICF
          IF(MPNCH.LT.0)ID(J)=NTRAN
          IF(BPRNT0.AND..NOT.BAUXE)THEN
            NTRR=MIN(NTRAN,IAXTR)
            N1=NTRR-NTRAN0
            L2=MIN(N1,IFOUR)
            L2=L2+NTRAN0
            NTRAN0=NTRAN0+1
            WRITE(6,740)M,N1,(MMIKE(L),DT(L),L=NTRAN0,L2)
            IF(N1.GT.4)WRITE(6,741)(MMIKE(L),DT(L),L=L2+1,NTRR)
          ENDIF
        ENDIF
      ENDIF
C
  525 CONTINUE
C
      NCI=NCI+NCJ
C
C RE-SET ABSOLUTE GROUND STATE BY MODIFYING CORE ENERGY (VIA SHFTIC)
C
C      IF(ISHFTIC.LT.0.AND.EFLGJ0.LT.DZERO)DECORE=EFLGJ0-DMIN
C
c       write(6,*)'dionmn=',2*(dionmn+decore),eimxic
c
      if(eimxic.gt.0)etest=eimxic+2*(dionmn+decore) !relative to ground
C
C  TCC: IN THIS SECTION (KTCC.LT.0) CARDS F1 AND F2, REQUIRED
C  AS INPUT TO SARAPH'S PROGRAM 'JAJOM', ARE PUNCHED -- SEE MPNCH
C  (REF. H.E.SARAPH, COMPUTER PHYS. COMMUN. 3(1972)256-68).
C
      IF(BTCC.AND.KTCC.LT.0)THEN                                  !JAJOM
        IF(.NOT.BAUXE.AND..NOT.BTEC)THEN
          NTRR=MIN(NTRAN,IAXTR)
          IF(BPRNT0)WRITE(6,742)JN(J),NTRAN,(MMIKE(L),NMIKE(L)
     X                         ,DT(L),L=1,NTRR)
          IF(MPNCH.LT.0)THEN
            IF(BFANO)THEN
              WRITE(1,743)JN(J),NTRAN,NZION,MION
            ELSE
              WRITE(1,744)JN(J),NTRAN,NZION,MION
            ENDIF
            IF(MTCC.LT.100.AND.MPNCH.GT.-4)THEN
              WRITE(1,753)(MMIKE(L),NMIKE(L),DT(L),L=1,NTRR)
            ELSE
              WRITE(1,754)(MMIKE(L),NMIKE(L),DT(L),L=1,NTRR)
            ENDIF
          ENDIF
        ENDIF
        MJX=MAX(MJX,NTRAN)
        NTRAN=0                                                  !RE-SET
      ENDIF
C
C********************************************
C
C     ***COMPUTE AUTOIONIZATION RATES***
C
C     EVALUATE <ic!tc><tc!H!tb><tb!ib>
C                              __
C          I.E. DV(I,J)*H(J,K)*DV(K,L)
C
C********************************************
C
C
      IF(ICC.EQ.0.OR.BTEC)GO TO 528          !BAIL OUT TO NEXT SYM GROUP
C
      IF(BUNA)THEN                         !INDEX CONTINUUM ENERGY ORDER
C
        I1=LL+1
        CALL HPSRTI(NCJ,DENERG(I1),IWRK2)
C
        M=0
        DECMIN=-D1P20
C
        DO J=1,NCJ
          NVEC(J)=0
          I=IWRK2(J)
          II=I+LL
          IT=NRR(II)
          IF(IDY(I).GT.0)THEN
            DRY=DENERG(II)+DECORE
            DRY=DRY+DRY
            IF(DRY.LE.etest.and.iwrk4(ii).ne.0)THEN            !RESOLVED
              IF(DENERG(II).GT.(DECMIN+TOLB2))THEN                 !A.U.
                M=M+1
                DE(M)=DENERG(II)
              ENDIF
              IF(NVEC(M).GT.0)THEN
                NSKP=NSKP+1
                IWRK3(II)=-M
C              ELSEIF(IDIAG.GE.0.AND.-NFK(IT).GT.NCUT)THEN  !CORR FOR AA
              ELSEIF(IWRK4(II).LE.0)THEN                    !CORR FOR AA
                NSKP=NSKP+1
                IWRK3(II)=-M
              ELSE
                NVEC(M)=II
                IWRK3(II)=M
              ENDIF
              DECMIN=DENERG(II)                !ALLOW FOR ANY DRIFT<TOLB
            ELSE
              NSKP=NSKP+1
              IWRK3(II)=-1
            ENDIF
          ELSE                                                    !BOUND
C            IF(IDIAG.GE.0.AND.NFK(IT).GT.NCUT)THEN    !ONLY CORR FOR AA
            IF(IWRK4(II).LE.0)THEN                     !ONLY CORR FOR AA
              NSKP=NSKP+1
              IWRK3(II)=-1   !will not write level info to rate file
            ELSE
              IWRK3(II)=0    !dummy
            ENDIF
          ENDIF
          IWRK2(J)=1                           !keep all for now...
        ENDDO
C
        MSUM=M
      ELSE
        MSUM=0
      ENDIF
C
      IF(ICB.EQ.0)GO TO 5288                 !BAIL OUT TO NEXT SYM GROUP
      IF(BNOAUG)GO TO 5288
C
C LOOP OVER INITIAL AUTOIONIZING LEVELS
C
            if(btime)call cpu_time(timei)
c
      m00=0
      n00=n0
      nfkjt=0
C
      if(.not.b2fs.and..not.bkutls)then      !SLs must match
        mp0=0
        mx=0
        DO M=1,NCJ
          IF(IDY(M).LT.0)THEN
            mm=m+ll
            mt=nrr(mm)
            mp=nfq(mt)
            if(mp.ne.mp0)then
              iwrks(mp)=mx                   !mark slp boundary
              mp0=mp
            endif
            mx=mx+1
          ENDIF
        ENDDO
      endif
c
      DO J=1,NCJ
C
        IF(IDY(J).GT.0)GO TO 423
C
        JJ=J+LL
        if(denerg(jj).lt.dionmn)go to 423                    !true bound
        JT=NRR(JJ)
C        IF(IDIAG.GE.0.AND.NFK(JT).GT.NCUT)GO TO 423        !CORRELATION
        IF(.NOT.BAUX.AND.IWRK4(JJ).LE.0)GO TO 423           !CORRELATION
C
        IF(BMULT)THEN
          KK=NFQ(JT)
          MNS=QSI(KK)
          IF(MNS.NE.MULTSM)GO TO 423
        ENDIF
C
        DO M=0,MMM                              !=0 IF NMETARJ .GE. 0
          SUMA(M)=DZERO
        ENDDO
        DO M=1,MSUM                             !=0 IF .NOT. BUNA
          DVU(M)=DZERO
        ENDDO
C
        if(bkutls)then
          if(b2fs)then
            m2=nfk(jt)
            luj(0)=iwrkn(m2)
            n00=ncf(m2)
          elseif(nfk(jt).ne.nfkjt)then
            do is=1,maxsl
              nslb(is)=0
            enddo
          endif
        endif
C
C FIND MAX INTERP ENERGY NEEDED FOR THIS INITIAL STATE
C
        IF(BLAG)THEN
C
          DM0=DENERG(JJ)+DSHFT0-dionmn
          DM=-DM0                              ! - AS DON'T NEED COEFFS
C
          CALL LAGINT(DM,DDY,NP1JJ,NP2JJ)
C
        ELSE
C
          NP2JJ=MENG                           !=1 THEN
C
        ENDIF
C
c
            if(btimet)call cpu_time(timeia)
C
C APPLY INITIAL STATE MIXING FOR EACH UNMIXED FINAL STATE
C
        J0=NADRUJ(JJ)
C
        if(.not.b2fs.and.bkutls.and.nfk(jt).ne.nfkjt)then!SLs must match
          nfkjt=nfk(jt)
          mp0=0
          DO M=1,NCJ
            IF(IDY(M).LT.0)THEN
              mm=m+ll
              mt=nrr(mm)
              mp=nfq(mt)
              if(nfk(mt).eq.nfkjt)then
                nslb(mp)=nslb(mp)+1       !no of each SL for cf=nfk(jt)
                if(mp.ne.mp0)then
                  iwrks(mp)=naj(mm)-1     !mark slp boundary for nfk(jt)
                  luj(mp)=nal(mm)-1
                  mp0=mp
                endif
              endif
            ENDIF
          ENDDO
        endif
C
        DO I=1,NCJ
          IF(IDY(I).GT.0)THEN
c
            ii=i+ll
            it=nrr(ii)
            m1=naj(ii)
            if(bkutls)then
              m2=-nfk(it)
              m1=m1-iwrkn(kmax1)
            else
              m2=idy(i)
            endif
            ig=iwrkn(m2)+m1                     !old ig=i
c
ccorr              bcorr=idiag.ge.0.and.-nfk(nrr(ii)).gt.ncut      !corr
ccorr              if(.not.bcorr)then                              !corr
c
            if(b2fs)then
              if(bposu)then                     !new pos
                lu=(ig-1)*n0
              else                              !old pos
                lu=nadlu(i)
              endif
             if(bkutls)lu=lu+luj(0)
            else
              lu=nadlu(i)                       !old/new pos
              ip=nfq(it)
              n00=nslb(ip)                      !bound LS symm
              m00=iwrks(ip)                     !start
              if(bkutls)lu=lu+luj(ip)
            endif
C
            J00=J0+M00
C
CL            IF(LAPAK.GT.0)THEN                                 !LAPACK
CL              IF(N00.GT.0)THEN                                 !LAPACK
CL                DO L1=1,NP2JJ                                  !LAPACK
CL                  DVI(IG,L1)=                                  !LAPACK
CL     X             DDOT(N00,TFUJ(J00+1),IONE,DUI(LU+1,L1),IONE)!LAPACK
CL                ENDDO                                          !LAPACK
CL              ELSE                                             !LAPACK
CL                DO L1=1,NP2JJ                                  !LAPACK
CL                  DVI(IG,L1)=DZERO                             !LAPACK
CL                ENDDO                                          !LAPACK
CL              ENDIF                                            !LAPACK
CL            ELSE                                               !LAPACK
              DO L1=1,NP2JJ
                DD=DZERO
                DO M=1,N00
c                  if(abs(tfuj(j00+m)*dui(lu+m,1)).gt.tola1)then    !old
cc                  if(abs(tfuj(j00+m)).gt.cmxica)then             !orig
                  DD=DD+TFUJ(J00+M)*DUI(LU+M,L1)
c                  endif
                ENDDO
                DVI(IG,L1)=DD
              ENDDO
CL            ENDIF                                              !LAPACK
ccorr                endif                                         !corr
          ENDIF
        ENDDO
c
          if(btimet)then
            call cpu_time(timefa)
            timea1=timea1+timefa-timeia
            timeia=timefa
          endif
C
C LOOP OVER FINAL CONTINUUM TERMS
C
        DO I=1,NCJ
C
          IF(IDY(I).LT. 0)GO TO 425
          II=I+LL
          IT=NRR(II)
C          IF(IDIAG.GE.0.AND.-NFK(IT).GT.NCUT)GO TO 425     !CORRELATION
          IF(.NOT.BAUX.AND.IWRK4(II).LE.0)GO TO 425         !CORRELATION
C
          IF(ABS(DENERG(II)+DYY(NREL)-DENERG(JJ)).GT.ACE)GO TO 425
C
          DRY=DENERG(II)
          DS=DENERG(JJ)-DRY
C
          IF(DS.LT.DZERO         )GO TO 425   !NOT ENERGETICALLY ALLOWED
C                       .AND.BLAG
C SET-UP INTERPOLATION
C
          IF(BLAG)THEN
C
            M2=-IDY(J)
            DM=DS+DSHIFT(M2)
C
            CALL LAGINT(DM,DDY,NP1,NP2)
C
          ENDIF
C
          if(np2.gt.np2jj)then
            write(0,*)j,np2jj,i,np2,dm0,dm
c          dm0=denerg(jj)+dshft0-dionmn
c           dm=denerg(jj)-denerg(ii)+dshift(m2)
            write(0,*)denerg(jj),dshft0,dionmn,denerg(ii),dshift(m2)
            stop 'diagfs np2jj error'
          endif
C
C APPLY FINAL-STATE MIXING TO INTERPOLATED MATRIX ELEMENTS
C
          IF(BKUTLS)THEN
            M2=-NFK(IT)
            NCC=NCF(M2)
            L1=IWRKN(M2)-iwrkn(kmax1)
          ELSE
            M2=IDY(I)
            NCC=NCC0(M2)
            L1=IWRKN(M2)
          ENDIF
C
          I0=NADRUJ(II)
          DSJ=DZERO
C
          DO N=NP1,NP2
CL            IF(LAPAK.GT.0)THEN                                 !LAPACK
CL              DD=DDOT(NCC,TFUJ(I0+1),IONE,DVI(L1+1,N),IONE)    !LAPACK
CL            ELSE                                               !LAPACK
              DD=DZERO
              DO M=1,NCC
c                if(abs(tfuj(i0+m)*dvi(l1+m,np1)).gt.tola2)then     !old
cc                if(abs(tfuj(i0+m)).gt.cmxica)then                !orig
                DD=DD+TFUJ(I0+M)*DVI(L1+M,N)
c                endif
              ENDDO
CL            ENDIF                                              !LAPACK
            DSJ=DSJ+DDY(N)*DD
          ENDDO
C
C FORM AUTOIONIZATION RATE
C
          DSJ=ABS(DSJ)*DSJ*DKON
          IF(ABS(DSJ).GT.WLG)THEN
            MWJ=JN(JJ)+1
            IF(BPRNT0)WRITE(6,502)MWJ,II,JJ,DSJ,DS,DRY
            DS=DS+DS
            DRY=DRY+DECORE
            DRY=DRY+DRY
            IF(DRY.LT.EIONMN)EIONMN=DRY
C
            IF(BUNA)THEN                                   !BUNDLE CONT
              IF(DRY.LE.etest )THEN                        !RESOLVED
                M=IWRK3(II)
                M=ABS(M)
                DVU(M)=DVU(M)+ABS(DSJ)
              ELSE                                         !BUNDLED
                M=0
                IF(NMETARJ.LT.0)M=ICF(-NFK(IT))            !BY TARGET CF
                SUMA(M)=SUMA(M)+ABS(DSJ)
              ENDIF
            ELSE
              IF(BPRNT0)WRITE(MW,506)NFK(JT),JJ,MWJ,NFK(IT),II,DSJ,DS
     X                              ,DRY
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JT)),int(JJ),int(MWJ)
     X                                ,int(NFK(IT)),int(II),DSJ,DS,DRY
            ENDIF
          ENDIF
C
  425   ENDDO                    !END LOOP OVER FINAL LEVELS
C
        IF(BUNA)THEN
          DO M=1,MSUM
            IF(DVU(M).GT.WLG)THEN
              IWRK2(M)=1                                    !FLAG EXISTS
              DS=DENERG(JJ)-DE(M)
              DS=DS+DS
              DRY=DE(M)+DECORE
              DRY=DRY+DRY
              II=NVEC(M)
              IT=NRR(II)
              IF(BPRNT0)WRITE(MW,506)NFK(JT),JJ,MWJ,NFK(IT),II,DVU(M)
     X                              ,DS,DRY
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JT)),int(JJ),int(MWJ)
     X                           ,int(NFK(IT)),int(II),DVU(M),DS,DRY
            ENDIF
          ENDDO
          IF(SUMA(0).GT.WLG)THEN
            IF(BPRNT0)WRITE(MW,506)NFK(JT),JJ,MWJ,IZERO,IZERO,SUMA(0)
     X                            ,EINF,DZERO
            IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JT)),int(JJ),int(MWJ)
     X                   ,int(IZERO),int(IZERO),SUMA(0),EINF,DZERO
          ENDIF
          DO M=1,MMM
            IF(SUMA(M).GT.WLG)THEN
              IF(BPRNT0)WRITE(MW,506)NFK(JT),JJ,MWJ,-M,IZERO,SUMA(M)
     X                              ,EINF,DZERO
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JT)),int(JJ),int(MWJ)
     X                        ,int(-M),int(IZERO),SUMA(M),EINF,DZERO
            ENDIF
          ENDDO
        ENDIF
c
          if(btimet)then
            call cpu_time(timefa)
            timea2=timea2+timefa-timeia
          endif
C
  423 ENDDO                     !END LOOP OVER INITIAL LEVELS
C
      IF(BCONT.AND.BPRNT0)WRITE(6,897)LUX
C
          if(btime)then
            call cpu_time(timef)
            timea=timea+timef-timei
          endif
C
 5288 CONTINUE
C
      IF(BUNPA)THEN             !RE-INDEX FOR PI CONT SUM
        IF(BUNPR)THEN
          DO I=1,NCJ
            IF(IDY(I).GT.0)THEN
              II=I+LL
              MM=IWRK3(II)
              M=ABS(MM)
              IF(NVEC(M).GT.0)IWRK3(II)=SIGN(NVEC(M),MM)
            ENDIF
          ENDDO
        ELSE                    !NO CONT SUM SO CAN NO LONGER DROP TERMS
          DO I=1,NCJ
            IF(IDY(I).GT.0)THEN
              II=I+LL
              IF(IWRK3(II).LT.0)THEN
                IWRK3(II)=-IWRK3(II)
                NSKP=NSKP-1
              ENDIF
            ENDIF
          ENDDO
        ENDIF
      ELSE                              !CAN DROP UNUSED LEVELS
        DO M=1,MSUM                     !MSUM=0 IF .NOT.BUNA
          IF(IWRK2(M).EQ.0)THEN
            II=NVEC(M)
            IWRK3(II)=-IWRK3(II)
            NSKP=NSKP+1
          ENDIF
        ENDDO
      ENDIF
C
  528 CONTINUE
C
C ******* END LOOP OVER SYMMTERY BLOCKS FOR H DIAGONALIZATION AND AUGERS
C
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagfs:'                 !par
cpar          write(iwp,*)'    H diag time=',nint(timeh),'sec'      !par
cpar          if(mode.eq.2)write(iwp,*)                             !par
cpar     x                '    auger time=',nint(timea),'sec'       !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          if(btimet)write(iw,*)'H form time=',nint(timefh),'sec'
          write(iw,*)'H diag time=',nint(timeh),'sec'
          if(btimet.and.mode.eq.2)then
            write(iw,*)'auger timea1=',nint(timea1),'sec'
            write(iw,*)'auger timea2=',nint(timea2),'sec'
          endif
          if(mode.eq.2)write(iw,*)'auger time=',nint(timea),'sec'
cpar        endif                                                   !par
      endif
C
      IF(IADJ8.NE.NP8)THEN                   !REMOVE EVNTLY
         WRITE(0,*)'SR.DIAGFS GLOBAL INDEX ERROR:',IADJ8,NP8
         NF=-1
         GO TO 7500
      ENDIF
C
      NENERG=NCI
c      write(0,*)nctot
      jupe=nenerg
      if(idw.eq.0)jupe=min(jupe,jupmx)
C
      DD00=DMIN                              !HOLD FS VALUE
      DG00=DECORE+DD00                       !GROUND LEVEL ENERGY (A.U.)
c
      j0=0
      if(ishftic.lt.0.and.itec.le.1)j0=2
C
      IF(j0.ne.0.and.nobsj.gt.0)THEN               !DETERMINE POST LEC
        DO I=1,NENERG
          IF(DELEIC(I,2).Ge.DZERO)THEN             !.NE.
            TC=DELEIC(I,2)-DENERG(I)+DMIN
            DENERG(I)=DELEIC(I,2)+DMIN
            DELEIC(I,1)=TC
          ENDIF
        ENDDO
      ENDIF
C
C SORT ENERGIES: JORIG(J) MAPS ENERGY ORDER BACK TO SYMMETRY ORDER
C
      IF(DMAX.GT.DZERO)THEN                        !UNLIKELY
        DO L=1,NENERG
          DENERG(L)=DENERG(L)-DMAX
        ENDDO
      ENDIF
C
C
      CALL HPSRTI(NENERG,DENERG,JORIG)
C
C
      IF(DMAX.GT.DZERO)THEN                        !UNLIKELY
        DO L=1,NENERG
          DENERG(L)=DENERG(L)+DMAX
        ENDDO
      ENDIF
C
c      if(ishftic.gt.1)j0=2          !currently, no iteration if nobsj<0
      IF(j0.ne.0.and.nobsj.lt.0)then            !need to convert from cf
c
        do k=1,kmax
          iharry(k)=1
        enddo
        do l=1,nenerg                           !find lowest term of cf
          i=jorig(l)
          m1=nrr(i)
          k=nfk(m1)
          k=abs(k)
          if(iharry(k).gt.0.and.delecf(k,2).ge.dzero
     x                     .and.iwrk4(i).ne.0)then
            t=delecf(k,2)-denerg(i)+dmin
            delecf(k,1)=t
            iharry(k)=0                         !flag cf found
          endif
        enddo
c
        do i=1,nenerg
          m1=nrr(i)
          k=nfk(m1)
          k=abs(k)
          t=delecf(k,1)
          if(t.ne.dzero.and.iwrk4(i).ne.0)then
            denerg(i)=denerg(i)+t
            deleic(i,2)=denerg(i)-dmin
            deleic(i,1)=t
          endif
        enddo
c
        if(dmax.gt.dzero)then                   !unlikely
          do l=1,nenerg
            denerg(l)=denerg(l)-dmax
          enddo
        endif
c
        call hpsrti(nenerg,denerg,jorig)        !re-sort
c
        if(dmax.gt.dzero)then                   !unlikely
          do l=1,nenerg
            denerg(l)=denerg(l)+dmax
          enddo
        endif
c
      endif
C
      IF(BTEC)GO TO 527
C
      DO K=1,KMAX
        IHARRY(K)=ABS(QN(QCG(NF,K)))
      ENDDO
C                                                  !SUMMED AND NO B-B
      IF(BUNA.AND.BUNR
     X       .AND.(JRAD.EQ.2.OR.JRAD.EQ.3.OR.JRAD.EQ.5))THEN
        ITESTN=ABS(NRSLMX)
        DO J=1,NENERG
          I=JORIG(J)
          IF(IWRK4(I).NE.0)THEN
            DRY=DENERG(I)+DECORE
            DRY=DRY+DRY
            IF(DRY.LT.EIONMN)THEN                    !BOUND
              IT=NRR(I)
              K=NFK(IT)
              IF(NRSLMX.GE.0)THEN      !N-VALUE
                ITESTH=IHARRY(K)
              ELSE                     !CFG NO.
                ITESTH=K
              ENDIF
              IF(J.GT.JLOWMX.OR.ITESTH.GT.ITESTN)THEN!UNRESOLVED
                IF(IWRK3(I).GE.0)THEN
                  NSKP=NSKP+1
                  IWRK3(I)=-1
c                else
c                  write(6,*)'correlation, already flagged'
                ENDIF
              ENDIF
            ELSE
              GO TO 529                              !WE ARE DONE
            ENDIF
c          else
c            write(6,*)'iwrk3, already flagged'
          ENDIF
        ENDDO
      ENDIF
C
C PRELIMINARY WRITES
C
  529 IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,514)MENG,NZION,MION,EIONMN
          WRITE(MWW,515)(DTWO*DYY(M8),M8=1,MENG)
          IF(BDOWN.and.BUNPR)THEN
            WRITE(MWW,513)NZION,MION
          ELSE
            WRITE(MWW,516)NZION,MION
          ENDIF
        ELSE
          WRITE(MWWU)int(MENG),int(NZION),int(MION),EIONMN
          WRITE(MWWU)(DTWO*DYY(M8),M8=1,MENG)
          WRITE(MWWU)int(NZION),int(MION)
          WRITE(MWWU)MBLK
        ENDIF
      ENDIF
      IF(.NOT.BMODE)THEN
        IF(BPRNT0)THEN
           WRITE(MW,503)EIONMN
        ELSE
          WRITE(MWU)int(IZERO),int(IZERO),int(IZERO),int(IZERO)
     X             ,int(IZERO),DZERO,DZERO,EIONMN
        ENDIF
      ENDIF
C
      IF(BPRNT0)WRITE(6,901)DCR1,DECORE,DR12
      IF(BCONT.AND.BPRNT0)WRITE(6,898)LUMAX,MXAAK
      if(lumax.ne.ixaak)write(0,*)'lumax,ixaak:',lumax,ixaak
      IF(.NOT.BRAD.AND.BJUMP)GO TO 7500
C
      IF(.NOT.BMODE)THEN
        IF(BPRNT0)THEN
          WRITE(MW,510)NENERG-NSKP,2*DG00
        ELSE
          WRITE(MWU)int(NENERG-NSKP),2*DG00
          WRITE(MWU)MBP             !ANY NON-BLANK FLAG
        ENDIF
      ENDIF
C
      IF(BTCC)THEN
        IF(BAUXE)WRITE(6,110)
        IF(.NOT.BLMOD)WRITE(6,7395)
        MJX=MAX(MJX,NTRAN)
        IF(MJX.GT.IAXTR)THEN
          WRITE(6,7393)MJX
          WRITE(0,*)'*** TOO MANY TCCs, INCREASE MAXTR ***'
        ENDIF
        CALL DIMUSE('MAXTR',MJX)
      ENDIF
C
      IF(BPRNT0)THEN
        KO=0
        IF(ISHFTIC.GT.1)KO=ISHFTIC
        IF(IOPTIM.GT.0)KO=NOBSJ
        IF(KO.NE.0)THEN
          WRITE(6,996)LABW,2*DG00,NTEC,KO,MOBS
        ELSE
          WRITE(6,996)LABW,2*DG00,NTEC
        ENDIF
        IF(ABS(ISHFTIC).EQ.1)WRITE(6,998)
        IF(MODE.EQ.1.AND.IUNIT(15).GT.0)WRITE(15,185)
      ENDIF
C
      IF(IUNIT(22).GT.0)WRITE(22,537)            !NENERG need NSPECE now
C
      IF(MENGB.GE.-1)THEN
        ELEM=CELMNT(NZION)
        NZAM=NZA-1
        FIP=ADASIP(ELEM,NZAM)
        if(badas)then
          lab4='    '
        else
          lab4='(0Y)'
        endif
        WRITE(26,541)ELEM,NZAM,NZION,NZA,FIP,lab4
        ISMX=0
        DO K=1,KMAX                             !CHECK MAX STRING LENGTH
          IS=4*LMX(K)
          IF(IS.GT.MXSTRG)THEN
            WRITE(6,536)IS
            WRITE(6,*)'***SR.DIAGFS: INCREASE INTERNAL DIMENSION MXSTRG'
            GO TO 2000
          ENDIF
          ISMX=MAX(ISMX,IS)
        ENDDO
      ENDIF
C
  527 CONTINUE
C
C********************************************
C
C WRITE ENERGY-ORDERED LEVEL LIST
C
C********************************************
C
      TIMXIC=etest -2*DG00                           !RYD REL. TO GROUND
C
      IF(JTEC.GT.0)THEN
        JTEC=JTEC-1                               !DECREMENT LEC COUNTER
        IF(BPRNT0)THEN
         JC=ISHFTIC-JTEC
         IF(JTEC.GT.0)THEN
           WRITE(6,996)LABW,2*DG00,NTEC,JC
           IF(JTEC.EQ.1)NTEC=' FINAL LEC'
         ENDIF
        ENDIF
      ENDIF
C
      IF(INCLUD.GT.NENERG)INCLUD=NENERG
C
      DFFS=DZERO                                  !INITIALIZE FUNCTIONAL
      IF(IOPTIM.NE.0)THEN
        DS0=DONE
        DAU0=DZERO
      ELSE                                              !.OR.INCLUD.EQ.0
        DS0=DZERO
        DAU0=DD00
      ENDIF
C
      IF(IOPTIM.EQ.2)THEN
        DFC=DZERO
        J=JTMIN
        IF(DELEIC(J,2).NE.DZERO)THEN                         !NOT GROUND
          DO J=1,NENERG
            IF(DELEIC(J,2).EQ.DZERO)GO TO 41
          ENDDO
          WRITE(6,*)'***SR.DIAGFS: GROUND LEVEL NOT FOUND IN SHFTIC'
          WRITE(0,*)'***SR.DIAGFS: GROUND LEVEL NOT FOUND IN SHFTIC'
          GO TO 2000
   41     WRITE(6,*)'***SR.DIAGFS: GROUND LEVEL MIS-MATCH:',J,JTMIN
          WRITE(0,*)'***SR.DIAGFS: GROUND LEVEL MIS-MATCH'
          GO TO 2000
        ENDIF
        IF(DG00.GT.EFLGJ0)DFC=DG00-EFLGJ0                          !A.U.
      ENDIF
C
      DO I=1,NTT
        WGT(I)=DZERO
        ETM(I)=DZERO
      ENDDO
c
      if(nmetaj/maxlv.gt.0)then
        nmetaj=0
        m10=nrr(jtmin)
      else
        m10=0
      endif
C
C LIST DEGENERATE LEVELS BY ASCENDING LV INDEX
C (NEEDED FOR BUNDLED PI CONTINUUM SUM WITHIN SYMMETRY GROUP,
C  SINCE RADIATIVE LOOP IS EO NOT SO. ELSE COSMETIC)
C
      IF(BCONT.AND.(BPRNT0.OR.BUNPA))THEN
        J0=1
        m1p=0
        DECMIN=-D1P20
  131   MSUM=1
        DO J=J0,NENERG
          I=JORIG(J)
          M1=NRR(I)                                                !A.U.
          IF(NFK(M1).LT.0.AND.DENERG(I).LT.DECMIN+TOLB2
     X                                    .and.m1p.lt.0)THEN
            MSUM=MSUM+1
            m1p=nfk(m1)
          ELSE
            m1p=nfk(m1)
            IF(MSUM.GT.1)GO TO 132
          ENDIF
          DECMIN=DENERG(I)
        ENDDO
        J=NENERG+1
C
  132   DECMIN=DENERG(I)
        if(bunpa)t=denerg(jorig(j-msum))       !-msum = first; -1 = last
        DO M=MSUM,1,-1
          I=JORIG(J-M)
          DWRK(M)=I
          if(bunpa)denerg(i)=t
        ENDDO
C
        CALL HPSRTI(MSUM,DWRK,IWRK2)
C
        DO M=1,MSUM
          I=IWRK2(M)
          I=NINT(DWRK(I))
          JORIG(J-M)=I
        ENDDO
        IF(J.LT.NENERG)THEN
          J0=J+1
          GO TO 131
        ENDIF
      ENDIF
C
C BEGIN LEVEL ENERGY LOOP
C
      M2=0
      IPP=0
      JSP=0
      LSP=0
      IE0=0
      NSPECE=0
      EMIN=EIONPOT
      IF(EMIN.GT.DZERO)THEN
        IAUTO=0
      ELSE
        IAUTO=-1
      ENDIF
      DECMIN=-D1P20
      m1p=0
      NMM=0
C
      DO J=1,NENERG
C
        I=JORIG(J)                              !J=EO -> I=SO
        M1=NRR(I)
        M2=MAX(M1,M2)                          !=NNRGLS EVNTLY
        II=NFQ(M1)
        LP2=QLI(II)/2
        ISS=(QSI(II)+1)
        IP=ISS*(1-QPI(II))
C
        DENERG(I)=DENERG(I)-DD00                !RELATIVE TO GROUND
        DRY=DENERG(I)*DTWO
        DEM=DRY*DKCM
        DS=JN(I)+1
        ETM(M1)=DRY*DS+ETM(M1)
        WGT(M1)=WGT(M1)+DS
C
        IF(JTEC.GT.0)THEN                       !DETERMINE LEC
          IF(DELEIC(I,2).Ge.DZERO)THEN          !.NE.
            TC=DELEIC(I,2)-DENERG(I)
            DELEIC(I,1)=DELEIC(I,1)+TC
          ELSE
            TC=DZERO
          ENDIF
          IF(BPRNT0)WRITE(6,997)J,I,M1,DEM,IP,LP2,JN(I)
     X                                     ,NFK(M1),MBLK,DRY,2*TC
        ENDIF
C
        IF(BTEC)GO TO 526
C
        IF(NFK(M1).GT.0)NMM=NMM+1
C
        IF(IWRK3(I).LT.0)THEN
          MWR=-I
        ELSE
          MWR=I
        ENDIF
        IP2=QPI(II)/2
c                                   default to levels of the ground term
        if(m1.eq.m10)nmetaj=nmetaj+1
C
C        IF(IDIAG.GE.0.AND.ABS(NFK(M1)).GT.NCUT             !CORRELATION
        IF(IWRK4(I).LE.0.OR.BECOR.AND.(DRY*ECORRJ.GT.ECORRJ*ECORRJ.OR.
     X          DRY.GT.ESKPL.AND.DRY.LT.ESKPH))THEN         !CORRELATION
          JORIG(J)=-I
          IF(IWRK4(I).EQ.0)THEN
            MBCOR=MSCOR
          ELSE
            MBCOR=MCOR
          ENDIF
        ELSE
          JORIG(J)=I
          MBCOR=MBLK
          if(j.le.jupe)NSPECE=NSPECE+1
        ENDIF
C
        DO K=1,J
          IK=ABS(JORIG(K))
          IF(JN(IK).EQ.JN(I))THEN
            M3=NFQ(NRR(IK))
            IF(QPI(M3).EQ.QPI(II))THEN          !OVERWRITE IWRK4(I) WITH
              IWRK4(I)=K !ENERGY ORDER POSN OF FIRST OCCURRENCE OF SYM I
              GO TO 83
            ENDIF
          ENDIF
        ENDDO
C
   83   IF(IAUTO.Ge.0.AND.DENERG(I)-EMIN.LE.TOLE)IAUTO=J+1
        IF(NFK(M1).LT.0.AND.IAUTO.LT.0)THEN
          IAUTO=J
          EMIN=DENERG(I)
        ENDIF
C
        IF(IOPTIM.EQ.2)THEN                    !ADD TO ENERGY FUNCTIONAL
          IF(DELEIC(I,2).GT.DZERO.AND.JORIG(J).GT.0)THEN
            IF(IWGHT.NE.1)DD=JN(I)+1       !STATISTICAL WEIGHTED
            IF(IWGHT.EQ.1)DD=DONE                !EQUAL WEIGHTED
            DF0=(ABS(DELEIC(I,2)-DENERG(I))+DFC)/DELEIC(I,2)
            DFFS=DFFS+DF0*DD                         !*DF0
          ELSE                             !IF(DELEIC(I,2).EQ.DZERO)THEN
            DD=DZERO
          ENDIF
        ENDIF
C
        IWRK2(I)=0
        MYRGE=MBLK
        IF(NFK(M1).LT.0)THEN
          IF(DRY.GT.DECMIN+TOLB.or.m1p.gt.0)IE0=IE0+1    !.or.prev bound
          IF(DRY.LE.TIMXIC)JIMXIC=IE0
          IWRK2(I)=IE0                             !CONT ENERGY INDEX
        ELSEif(m1p.gt.0)then                             !both bound
          IF(DRY.LT.DECMIN+TOLB.and.idw.eq.0.and.mrad.ge.0)THEN
C              LSP.EQ.LP2.AND.                !NOT GOOD QU.NO. - REMOVE?
            IF(LSP.EQ.LP2.AND.IPP.EQ.IP2)THEN !NOT ACTIVATED IN PRACTICE
              MYRGE='****'
              IF(IUNIT(15).GT.0)BACKSPACE(15)
              JSP=JSP+JN(I)
              ISP=ISP+IP-1
            ENDIF
          ENDIF
        ENDIF
        IF(MYRGE.EQ.MBLK)THEN
          ISP=IP
          JSP=JN(I)
        ENDIF
        IPP=IP2
        LSP=LP2
        m1p=nfk(m1)
        IF(MBCOR.EQ.MBLK)DECMIN=DRY
        IF(BUNA.AND.IWRK2(I).GT.JIMXIC)IP=0
C
        IF(.NOT.BMODE.AND.MWR.GT.0)THEN
          IF(BPRNT0)THEN
            if(nfk(m1).gt.0)then
              WRITE(MW,511)J,JORIG(J),M1,IP,LSP,JN(I),NFK(M1),DRY
            else
              WRITE(MW,511)J,JORIG(J),M1,IP,LSP,JN(I),NFK(M1),DRY
     x                      ,iwrk2(i)
            endif
          ELSE
            WRITE(MWU)int(JORIG(J)),int(M1),int(IP),int(LSP),int(JN(I))
     X               ,int(NFK(M1)),DRY,int(iwrk2(i))
          ENDIF
        ENDIF
C
        IF(BPRNT0)THEN
          IF(ISHFTIC.GT.1)THEN
            WRITE(6,997)J,I,M1,DEM,IP,LSP,JN(I),NFK(M1),MBCOR,DRY
     X                 ,2*DELEIC(I,1)
          ELSE
            IF(IOPTIM.EQ.2.AND.DELEIC(I,2).Ge.DZERO)THEN           !.NE.
              T=DELEIC(I,2)
              TC=T-DENERG(I)
              IF(J.EQ.1)THEN
                T=EFLGJ0
                TC=TC-DG00+T
              ENDIF
              IWD=MAX(NINT(DD),1)
              WRITE(6,990)J,I,M1,DEM,IP,LSP,JN(I),NFK(M1),MBCOR,IWD,DRY
     X                   ,2*TC,2*T
            ELSE
              if(nfk(m1).gt.0)then
                WRITE(6,997) J,I,M1,DEM,IP,LSP,JN(I),NFK(M1),MBCOR,DRY
              else
                WRITE(6,1997)J,I,M1,DEM,IP,LSP,JN(I),NFK(M1),MBCOR,DRY
     x                        ,iwrk2(i)
              endif
            ENDIF                                               !NO CORR
            IF(MODE.EQ.1.AND.JORIG(J).GT.0.AND.IUNIT(15).GT.0)
     X      WRITE(15,992)JSP,IPP,ISP,LSP,NFK(M1),NFJ(I),DRY,MYRGE
          ENDIF
c        else
c          write(6,997)j,i,m1,dem,ip,lsp,jn(i),nfk(m1),mbcor,dry !unsort
        ENDIF
C
        IF(MENGB.GE.-1.AND.JORIG(J).GT.0.and.j.le.jupe)THEN     !NO CORR
          LSP=MIN(LSP,MXLAB2)
          ISS=MIN(ISS,MXLAB2)
          FJT=JN(I)
          FJT=FJT/DTWO
          IS=0
          K=ABS(NFK(M1))
          DO L=1,LMX(K)
            IS=IS+1
            JJK=ABS(QN(QLB(L,K)))
            IF(JJK.GT.9)THEN
              STRING(IS)=NUMB(JJK/10)
            ELSE
              STRING(IS)=' '
            ENDIF
            IS=IS+1
            STRING(IS)=NUMB(MOD(JJK,ITEN))
            IS=IS+1
            JJK=MIN(INT(QL(QLB(L,K))/2,SP),MXLAB1)
            STRING(IS)=BIGL(JJK)
            IS=IS+1
            N=MOD(INT(QSB(L,K),SP),I50)
            STRING(IS)=NUMB(N)
          ENDDO
          DO L=IS+1,MXSTRG
            STRING(L)=' '
          ENDDO
          if(badas)then                                      !adf04 only
            if(iunit(26).gt.0)then
              cstan=' '
              ceiss=' '
              if(ismx.le.mstrgh)then
                f542="(i5,1x,1a15,2x,' (',i1,')',i1,'(',f4.1,')',f21.4)"
                write(cstan(1:15),'(15a1)')(string(l),l=2,mstrgh)
                call xxcftr(itwo,cstan,ceiss)
                write(26,f542)nspece,ceiss(1:15),iss,lsp,fjt,dem
              else
                f543="(i5,1x,1a31,2x,' (',i1,')',i1,'(',f4.1,')',f21.4)"
                write(cstan(1:31),'(31a1)')(string(l),l=2,mxstrg)
                call xxcftr(itwo,cstan,ceiss)
                write(26,f543)nspece,ceiss(1:31),iss,lsp,fjt,dem
              endif
            endif
          else                                 !adf04 or adasexj.in.form
            IF(ISMX.LE.MSTRGH)THEN
              F542="(I5,1X,15(A1),2X,' (',A1,')',A1,'(',F4.1,')',F21.4)"
              IF(IUNIT(22).GT.0)WRITE(22,F542)NSPECE
     X               ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),FJT,DEM
              IF(IUNIT(26).GT.0)WRITE(26,F542)NSPECE
     X               ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),FJT,DEM
            ELSE
              F543="(I5,1X,31(A1),2X,' (',A1,')',A1,'(',F4.1,')',F21.4)"
              IF(IUNIT(22).GT.0)WRITE(22,F543)NSPECE
     X               ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),FJT,DEM
              IF(IUNIT(26).GT.0)WRITE(26,F543)NSPECE
     X               ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),FJT,DEM
          ENDIF
          endif
        ENDIF
C
 526    IF(BPRNT0.AND.ISHFTIC.LT.2.AND.DELEIC(I,1).NE.DZERO)THEN
          DRY=DELEIC(I,1)*DTWO
          DEM=DRY*DKCM
          WRITE(6,994)I,DEM,DRY
        ENDIF
C
      ENDDO
C
C  *** END ENERGY WRITE LOOP
C
      IF(BTEC)GO TO 33
C
C DE-ALLOCATE LOCAL
C
      DEALLOCATE (LMX,QSB,QLB,ICF)
c
      deallocate (nal)
      if(allocated(iwrk5))deallocate (iwrk5)                 !iwrk5=test
c
      if(allocated(nadlu))then
        deallocate (nadlu)
      endif
      if(allocated(iwrkn))then
        deallocate (iwrkn)
      endif
      if(allocated(ncf))then
        deallocate (ncf,kmap,iwrk1,luj)
      endif
      if(allocated(decorn))then
        deallocate (decorn)
      endif
      if(allocated(iwrks))then
        deallocate (iwrks,nslb)
      endif
C
      IF(MODE.EQ.1.AND.BPRNT0.AND.IUNIT(15).GT.0)
     X                  WRITE(15,992)0,0,0,0,0,0,2*DG00
      IF(IUNIT(22).GT.0)WRITE(22,540)
      IF(IDW.NE.0)THEN
        WRITE(MR)NMETAJ
        WRITE(MR)(NMETGJ(I),I=1,NJO)
        NNN=NENERG
        IF(BECOR)NNN=-NNN                              !FLAG ENERGY CORR
        WRITE(MR)NNN,KCUT
        WRITE(MR)(JORIG(I),I=1,NENERG)
        WRITE(MR)(DENERG(abs(JORIG(I)))*DTWO,I=1,NENERG)
        WRITE(MR)NCTOT
        WRITE(MR)(TFUJ(I),I=1,NCTOT)
      ENDIF
C
      IF(IAUTO.Le.0)IAUTO=NENERG+1
C
C GET ANY CF'S PARTITION ABOUT IONIZATION LIMIT (ENERGIES AND WEIGHTS)
C
      IF(NMETAPJ.GT.0)THEN
        NMM=MIN(NMM,NMETAPJ)
      ELSE
        NMM=MIN(-NRSLMX,KMAX)
      ENDIF
C
C LOCAL
      IF(NMM.GT.0)THEN
        ALLOCATE (JCP(NMM),JTP(NMM),JWRN(NMM),JWRD(NMM)
     X           ,ERN(NMM),ERD(NMM))
      ENDIF
C
      IF(NMETAPJ.GT.0)THEN
C
        ALLOCATE (JRP(NENERG))
C
        J=0
        DO J0=1,NMETAPJ
          I=JORIG(J0)
          I=ABS(I)                                    !CASE CORR.
          M1=NRR(I)
          IF(NFK(M1).GT.0)THEN
            J=J+1
            JTP(J)=I
            JCP(J)=NFK(M1)
            JWRN(J)=JN(I)+1
            JWRD(J)=JWRN(J)
            ERN(J)=DENERG(I)+DG00
            ERN(J)=ERN(J)*2
            ERD(J)=ERN(J)
            NLASTP=J0
            IF(J.EQ.NMM)THEN                           !WE ARE DONE
              DO K=J0,NENERG
                JRP(K)=J
              ENDDO
              GO TO 177
            ENDIF
          ENDIF
          JRP(J0)=J
        ENDDO
 177    NMM=J                                          !ACTUAL FOUND
      ENDIF
C
      NMM0=NMM
C
      IF(NRSLMX.LT.0)THEN
        DO K=1,NMM
          JTP(K)=0
          JCP(K)=K
          ERN(K)=DZERO
          ERD(K)=DZERO
          JWRN(K)=0
          JWRD(K)=0
        ENDDO
        DO J=1,NENERG
          I=JORIG(J)
          I=ABS(I)                                    !CASE CORR
          M1=NRR(I)
          K=NFK(M1)
          IF(K*K.LE.NMM*K)THEN                         !OMITS K<0: CONT
            JW=JN(I)+1
            IF(DENERG(I).LT.EMIN)THEN
              ERN(K)=ERN(K)+DENERG(I)*JW
              JWRN(K)=JWRN(K)+JW
            ELSE
              ERD(K)=ERD(K)+DENERG(I)*JW
              JWRD(K)=JWRD(K)+JW
            ENDIF
          ENDIF
        ENDDO
        DO K=1,NMM
          IF(JWRN(K).GT.0)THEN
            ERN(K)=ERN(K)/JWRN(K)
            ERN(K)=ERN(K)+DG00
            ERN(K)=ERN(K)*2
          ENDIF
          IF(JWRD(K).GT.0)THEN
            ERD(K)=ERD(K)/JWRD(K)
            ERD(K)=ERD(K)+DG00
            ERD(K)=ERD(K)*2
          ENDIF
c          m=jwrn(k)+jwrd(k)
c          if(m.gt.0.and.k.le.ncut)then             !also needs nast=0
c            if(m.ne.mstat(k))then                     !checksum error
c              write(6,*)'cf=',k,' s.w. checksum error:',mstat(k),m
c              go to 2000
c            endif
c          endif
        ENDDO
      ENDIF
C
C WRITE TCCDW.DAT FILE
C
      IF(BTCC.AND.KTCC.GT.0.AND.MPNCH.LT.0.AND..NOT.BAUXE)THEN
C
        WRITE(4,757)NSPECE,NENERG              !SPEC, TOT LEVEL ENERGIES
        J0=0
        DO J=1,NENERG                                       !IC PROLOGUE
          I0=JORIG(J)
          IF(I0.GT.0)THEN                              !SKIP CORRELATION
            I=ABS(I0)
            M1=NRR(I)
            II=NFQ(M1)
            J0=J0+1
C            J0=J
C            IF(I0.LT.0)J0=-J                          !FLAG CORRELATION
            WRITE(4,756)J0,JN(I),QPI(II)/2,DTWO*DENERG(I),I,M1
          ENDIF
        ENDDO
c
        if(j0.ne.nspece)then
          write(6,*)'tcc index error',j0,nspece
          write(0,*)'tcc index error'
          go to 2000
        endif
C
        WRITE(4,752)                      !NOW ENERGY LEVEL ORDERED TCCS
        J0=0
        DO J=1,NENERG
          I0=JORIG(J)
          IF(I0.GT.0)THEN                              !SKIP CORRELATION
            I=ABS(I0)
            NTRAN=ID(I)
            NTRR=MIN(NTRAN,IAXTR)
            NTRAN0=ID(I-1)
            N1=NTRR-NTRAN0
            L2=MIN(N1,IFOUR)
            L2=L2+NTRAN0
            NTRAN0=NTRAN0+1
            DO KK=NTRAN0,NTRR        !GET ASCENDING ENERGY ORDERED TERMS
              JK=KK
              J1=JK-1
              IE=MMIKE(JK)
              DO IK=NTRAN0,J1
                IF(JK.GE.KK)THEN
                  NK=NMIKE(IK)
                  IF(IE.GT.MMIKE(NK))GO TO 20
                ENDIF
                NMIKE(JK)=NMIKE(JK-1)
                JK=JK-1
   20         ENDDO
              NMIKE(JK)=KK
            ENDDO
            J0=J0+1
C            J0=J
C            IF(I0.LT.0)J0=-J                          !FLAG CORRELATION
            WRITE(4,*)' '
            WRITE(4,750)J0,N1,(MMIKE(NMIKE(L)),DT(NMIKE(L))
     X                 ,L=NTRAN0,L2)
            IF(N1.GT.4)WRITE(4,751)(MMIKE(NMIKE(L)),DT(NMIKE(L))
     X                 ,L=L2+1,NTRR)
          ENDIF
        ENDDO
      ENDIF
C
C FORM WEIGHTED MEAN OF FS-LEVELS TO YIELD TERM ENERGIES
C
   33 IF(.NOT.BMODE.AND.(.NOT.BCONT.OR.BPRNT0))THEN         !.AND.BPRNT5
C
        ITEC=ITEC-1                               !DECREMENT TEC COUNTER
        DMIN=D1P20
        LL=-INCLUD
        ITMIN=0
C
        DO IT=1,M2
          IF(WGT(IT).GT.DZERO)THEN
            ETM(IT)=ETM(IT)/WGT(IT)
c          write(6,*)it,etm(it),wgt(it)
c          if(nint(wgt(it)).ne.(qli(it)+1)*abs(qsi(it)+1))then
c           write(6,*)'*** sr./diagfs: mis-match of level/term weights:'
c     x                ,it,nint(wgt(it)),(qli(it)+1)*abs(qsi(it)+1)
c          endif
            IF(DMIN.GT.ETM(IT))THEN
              DMIN=ETM(IT)
              ITMIN=IT
            ENDIF
          ELSE
            ETM(IT)=D1P20
          ENDIF
        ENDDO
C
        DMIN=DMIN/DTWO
        DG0=DG00+DMIN                         !GROUND TERM ENERGY (A.U.)
C
        IF(IOPTIM.EQ.-2)THEN
          DFC=DZERO
          J=ITMIN
          IF(DELELS(J,2).NE.DZERO)THEN                       !NOT GROUND
            DO J=1,M2
              IF(DELELS(J,2).EQ.DZERO)GO TO 31
            ENDDO
            WRITE(6,*)'***SR.DIAGFS: GROUND TERM NOT FOUND IN SHFTLS'
            WRITE(0,*)'***SR.DIAGFS: GROUND TERM NOT FOUND IN SHFTLS'
            GO TO 2000
   31       WRITE(6,*)'***SR.DIAGFS: GROUND TERM MIS-MATCH:',J,ITMIN
            WRITE(0,*)'***SR.DIAGFS: GROUND TERM MIS-MATCH'
            GO TO 2000
          ENDIF
          IF(DG0.GT.EFLG0)DFC=DG0-EFLG0
        ENDIF
C
        IF(BPRNT0)THEN
          IF(ITEC.EQ.0.AND.ISHFTLS.GT.1)MTEC=' FINAL TEC'
          IC=0
          IF(ITEC.GE.0)IC=ISHFTLS-ITEC
          IF(IOPTIM.LT.0)IC=NOBS
          IF(IC.GT.0)THEN
            WRITE(6,991)2*DG0,MTEC,IC,MOBS
          ELSE
            WRITE(6,991)2*DG0,MTEC
          ENDIF
        ENDIF
C
C WRITE TERM ENERGIES IN ENERGY ORDER
C
        DO I=1,M2
C
          DRY=D1P20
          DO II=1,M2
            IF(ETM(II).LT.DRY)THEN
              IT=II
              DRY=ETM(II)
            ENDIF
          ENDDO
          IF(DRY.EQ.D1P20)GO TO 32                          !NONE LEFT
C
          II=NFQ(IT)
          IP=(1-QPI(II))*(QSI(II)+1)
          DAU=DRY/DTWO                                      !RYD -> A.U.
          ETM(IT)=D1P20
          L=QLI(II)/2
          MBCOR=MBLK
          MWJ=ABS(NFK(IT))
          IF(MWJ.GT.NCUT.OR.BECOR.AND.(DRY*ECORRJ.GT.ECORRJ*ECORRJ.OR.
     X          DRY.GT.ESKPL.AND.DRY.LT.ESKPH))MBCOR=MCOR
C
C ADD TO ENERGY FUNCTIONAL  *** USER MUST SET INCLUD SO AS TO AVOID ANY
C                           CORRELATION THAT IS NOT FLAGGED BY KCUT ***
C
          DD=DZERO
          IF(LL.EQ.0)GO TO 30
          IF(LL.GT.0)THEN
            DO K=1,LL
              IF(INDEXW(K).EQ.IT)THEN
                DD=WGHT(K)
                GO TO 65
              ENDIF
            ENDDO
            IF(IOPTIM.EQ.0)GO TO 30
          ENDIF
          IF(I.GT.INCLUD.AND.IOPTIM.EQ.0)GO TO 30
C
          IF(MBCOR.EQ.MCOR)GO TO 30     !OMIT CORR. FROM DF FOR INCLUD>0
C
          IF(IWGHT.EQ.1)DD=DONE
          IF(IWGHT.NE.1)DD=WGT(IT)
C
   65     IF(IOPTIM.EQ.0)THEN                        !STANDARD
            DFFS=DAU*DD+DFFS
            DS0=DS0+DD
          ELSE                                       !DIFF WITH OBS
            IF(IOPTIM.EQ.-2)THEN                     !TERMS
              IF(DELELS(IT,2).GT.DZERO)THEN
                DF0=(ABS(DELELS(IT,2)-DAU+DMIN)+DFC)/DELELS(IT,2)
                DFFS=DFFS+DF0*DD                         !*DF0
              ELSEIF(DELELS(IT,2).EQ.DZERO)THEN
                DD=DZERO
              ENDIF
            ELSE
              DD=DZERO
            ENDIF
          ENDIF
C
   30     DRY=(DAU-DMIN)*DTWO
          DEM=DRY*DKCM
          IF(ITEC.GT.0.OR.IOPTIM.LT.0)THEN
            IF(DELELS(IT,2).Ge.DZERO)THEN            !UPDATE TEC
              T=DELELS(IT,2)
              TC=T-DAU
              IF(IOPTIM.EQ.0)THEN
                DELELS(IT,1)=DELELS(IT,1)+TC
                IF(BPRNT0)WRITE(6,995)I,IT,DEM,IP,L,NFK(IT),MBCOR,DD,DRY
     X                               ,2*TC
              ELSE
                IF(I.EQ.1)THEN
                  T=EFLG0
                  TC=TC-DG0+T
                ENDIF
                IF(BPRNT0)WRITE(6,995)I,IT,DEM,IP,L,NFK(IT),MBCOR,DD,DRY
     X                               ,2*TC,2*T
              ENDIF
            ELSE
              IF(BPRNT0)WRITE(6,995)I,IT,DEM,IP,L,NFK(IT),MBCOR,DD,DRY
            ENDIF
          ELSE
            IF(BPRNT0)THEN
              IF(ISHFTLS.GT.1)THEN
                WRITE(6,995)I,IT,DEM,IP,L,NFK(IT),MBCOR,DD,DRY,
     X                      DELELS(IT,1)*2
              ELSE
                WRITE(6,995)I,IT,DEM,IP,L,NFK(IT),MBCOR,DD,DRY
              ENDIF
            ENDIF
          ENDIF
C
        ENDDO
C
      ENDIF
C
   32 IF(ITEC.GT.0.OR.JTEC.GT.0)GO TO 5000             !NEXT ITERATION
C
      IF(DS0.NE.DZERO)THEN                        !FINALIZE FUNCTIONAL
        DFFS=DAU0+DFFS/DS0
      ELSE
        DECORE=DZERO
      ENDIF
C
      IF(BCPRNT.AND.MPNCH.LT.0)THEN                     !CLOSE TCC FILES
        IF(KTCC.LT.0)THEN
          WRITE(1,"(9X,'0    0',5X,'TCC END')")
          CLOSE(1,STATUS='KEEP')
        ELSEIF(KTCC.GT.0)THEN
          CLOSE(4,STATUS='KEEP')
        ENDIF
      ENDIF
C
C DE-ALLOCATE
C
 7600 CONTINUE
C
      IF(BALLH)THEN
        DEALLOCATE (DU,DVU,DE,IDY,NVEC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)
     X         'DIAGFS: DE-ALLOCATION FAILS FOR DU,DVU,DE,IDY,NVEC'
          NF=MIN(NF,IZERO)
        ENDIF
        IF(BPRNT0.AND.ALLOCATED(DVP))THEN
          DEALLOCATE (DVP,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR DVP'
            NF=MIN(NF,IZERO)
          ENDIF
        ENDIF
        BALLH=.FALSE.
      ENDIF
C
      IF(BALLA)THEN
        DEALLOCATE (DUI,DVI,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR DUI,DVI'
          NF=MIN(NF,IZERO)
        ENDIF
        DEALLOCATE (DDY)
        BALLA=.FALSE.
      ENDIF
C LOCAL
      IF(BTCC)THEN
        DEALLOCATE (DT,MMIKE,NMIKE,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DEALLOCATION FAILS FOR DT,MMIKE,NMIKE'
          NF=0
          GO TO 7500
        ENDIF
      ENDIF
C
      IF(NF.LE.0)GO TO 7500                                      !RETURN
C
C
C********************************************
C
C   ***COMPUTE MULTIPOLE RADIATIVE DATA***
C
C********************************************
CNRB: RE-WRITTEN FOR N^3 MULT. AND TO USE THE
C LOOP OVER ALG STORAGE AS ONE OF THESE LOOPS.
C********************************************
C
C
      BRADAT=BPRINT.OR.JPRINT.EQ.3.AND.INCLUD.EQ.0
C      IF(.NOT.BPRINT)BRADAT=JPRINT.LT.0.AND.NPRNT5.GT.-2 !EVAL G FUNCTL
C
      MLAM=0
      IF(.NOT.BRADAT.OR.NPRNT5.EQ.-2)GO TO 745
      IF(.NOT.BINT)GO TO 106
C
      NPOSX=(IOS-IRK)
      if(nposx.le.0)go to 745
      BPOS=.TRUE.                                         !FORCE FOR NOW
      BOMRC=.FALSE.
C
      MXORB2=MXORBR*MXORBR                                        !FLAGX
C
      MX=MPOLX
      MX=MX-MPOL0                                                 !FLAGX
      MXPOL=MAX(IONE,MX/2+1)
C
      IF(BPOS)THEN                           !PRE-DECODE ADDRESS
C
        ALLOCATE (NPOS(4,NPOSX),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS:    ALLOCATION FAILS FOR NPOS'
          NF=0
          GO TO 7500                                    !RETURN
        ENDIF
C
        i1=mb+1                                                   !FLAGX
        i2=i1
        NPOS0=IRK
        MCI=0
        DO NC=1,NSL0
          MC=NSL(NC)
          DO ND=1,NC
            N1=NED(1,ND,MCI+1)
            IF(N1.GT.0)THEN
              DO MD1=1,MC
                ND1=MD1+MCI
                N1=NED(1,ND,ND1)
                N2=NED(2,ND,ND1)
                if(irlx.lt.0)then
                  kf=abs(nfk(nd1))
                  i1=icfgp(kf)*mb+1
                endif
                DO M=N1,N2
                  NS=M-NPOS0
                  n8=MXORB2*MXPOL
                  M1=INT(NRK(M)/n8)
                  M2=M1+1
                  NPOS(1,NS)=M2                     !TERM
                  if(irlx.lt.0)then
                    kg=abs(nfk(m2))
                    i2=icfgp(kg)*mb+1
                  endif
                  n8=M1*n8
                  MX=INT((NRK(M)-n8)/MXORB2)
                  MK=MX
                  MK=MK+MPOL0/2                                   !FLAGX
                  NPOS(2,NS)=MK                     !MULTIPOLE
                  n8=n8+MX*MXORB2
                  n8=NRK(M)-n8
                  M0=INT(n8/MXORBR)
                  M1=M0+I1
                  MM=INT(n8-M0*MXORBR+I2)
                  M2=MIN(M1,MM)
                  NPOS(3,NS)=M2                     !ORBITAL
                  M1=M1+MM-M2
                  IF(MM.NE.M1)M1=-M1
                  NPOS(4,NS)=M1                     !ORBITAL
                ENDDO
              ENDDO
            ENDIF
          ENDDO
          MCI=MCI+MC
        ENDDO
      ELSE
        NPOS0=0
        WRITE(6,1605)NPOSX
        WRITE(0,1605)NPOSX
      ENDIF
C
      IF(.NOT.BFOTJ)THEN
C        ALLOCATE (DVECF(MENG,NENERG),STAT=IERR)
        ALLOCATE (DVECF(NENERG,MENG),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS:    ALLOCATION FAILS FOR DVECF'
          NF=0
          GO TO 7450
        ENDIF
        IF(MPOLE.GT.2)THEN
C          ALLOCATE (DVECM(MENG,NENERG),STAT=IERR)
          ALLOCATE (DVECM(NENERG,MENG),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'DIAGFS:    ALLOCATION FAILS FOR DVECM'
            NF=0
            GO TO 7450
          ENDIF
        ENDIF
      ENDIF
C
      ALLOCATE (IDY(IAXDK),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGFS:    ALLOCATION FAILS FOR IDY'
        NF=0
        GO TO 7450
      ENDIF
C LOCAL
      K0=MAX(IZERO,NMM)
      ALLOCATE (SUMRN(0:K0),SUMRD(0:K0))
C
      IF(BUNPR)THEN
        ALLOCATE (SUMPN(MENG,0:K0),SUMPD(MENG,0:K0))
      ENDIF
C
      BAUX=JPRINT.EQ.1.OR.JPRINT.GT.4      !.NOT.BAUX IGNORE CORRELATION
C
      BDEL=MDEL.GT.0
      IF(IDIAG.LT.0)WLG0=DTEN**MDEL
C
C      BJSEL=MULTS.EQ.0
C      IF(IDIAG.LT.0)BJSEL=.TRUE.
      IF(.NOT.BJSEL)THEN
        WRITE(0,936)                !PRINT WARNING IF LS SELECTION RULES
        WRITE(6,936)                !PRINT WARNING IF LS SELECTION RULES
      ENDIF
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      BMPRNT=.NOT.BBORN.OR.(BBORN.AND.ABS(MBP2MX).GT.0)
C
      BCPRNT=JPRINT.EQ.2.OR.JPRINT.GT.4
      NTRAN=0
      IORT=ABS(MORT)
      DEM=2*DG00                              !GROUND ENERGY (RYD)
      IF(EIONMN.EQ.DZERO)EIONMN=etest         !ENABLE B-C SPLIT
      IF(NMETAPJ.GT.0)etest=dzero             !no rad bundle for upward
C
      IF(.NOT.BMODE.AND.BPRNT0)WRITE(MW,508)NZION,MION
      IF(.NOT.BMODE.AND..NOT.BPRNT0)WRITE(MWU)int(NZION),int(MION)
C
      STOL=STOLB
      IF(MENGB.NE.1)STOL=100*STOL
      WLGO=100*STOL/DZA2
C
      IF(MENGB.GE.-1)THEN            !INITIALIZE OMEGA BORN
C
        WRITE(6,989)
        TOLO=D1M10
c
        if(nmetaj.gt.0)then
          nmin=min(NMETAJ,NSPECE)
          ixr=irow(nmin,nspece,ione1,nspece)
          ixc=0
          if(idw.eq.0.and.ABS(MENGB).EQ.1)ixc=icol(nmin,nspece,ione1)
          nomwrt=max(ixr,ixc)
        else
          NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
        endif
C
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY ONLY
C
          BSCRO=.TRUE.       !(REMOVE "ELSE" TO USE INTERNAL - WASTEFUL)
C
          ALLOCATE (OMR(NOMWRT),OMC(NOMWRT),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'DIAGFS: ALLOCATION FAILS FOR OMR,OMC'
            NF=0
            GO TO 7450
          ENDIF
          BOMRC=.TRUE.
          NOMWRX=NOMWRT
C
          IF(NOMWRT.GT.NOMWRX)THEN            !NO LONGER POSSIBLE
            NNN=2*NOMWRT/MENG+1
            WRITE(6,993)NNN
            WRITE(0,*)'*** WORKING ARRAYS TOO SMALL IN SR.DIAGFS'
            GO TO 3000
          ENDIF
          DO I=1,NOMWRX
            OMR(I)=DZERO
            OMC(I)=DZERO
          ENDDO
C
        ELSE                                  !FINITE ENERGY
C
          BSCRO=.TRUE.       !.T. USE SCRATCH FILE, .F. STORE INTERNALLY
C
          IF(.NOT.BSCRO)THEN
            ALLOCATE (OMEGA(0:MXNXB1,NOMWRT),STAT=IERR)
            IF(IERR.NE.0)THEN
              BSCRO=.TRUE.
            ELSE
              BSCRO=.FALSE.
            ENDIF
          ENDIF
          NOMWRY=NOMWRT
C
C
          IF(BSCRO)THEN
C            WRITE(0,*)'DIAGFS: USING SCRATCH FOR BORN MULTIPOLE SUM'
C            WRITE(6,*)'DIAGFS: USING SCRATCH FOR BORN MULTIPOLE SUM'
          ELSE
            DO N=1,NOMWRT
              DO NX=0,MXNXB1
                OMEGA(NX,N)=0
              ENDDO
            ENDDO
          ENDIF
C
          DO NX=1,MXNXB
            XS(NX)=SQRT(DONE-DONE/XB(NX))   !CASE ICR NOT DONE IN DIAGON
          ENDDO
C
        ENDIF
C
        MSC0=80
        MSC=MSC0-1
        IBOMX=0
c        ibifmx=0
C
      ENDIF
C                 INITIALIZE GEOMETRIC COEFFICIENTS
      ALLOCATE (DG(0:IXBLM))
C
      DG(0)=DZERO
      IF(MPOLE.LE.8)THEN
        IP=1
        DO I=2,MPOLE,2
          IP=IP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*REAL(IP,WP)*REAL(IP,WP))
        ENDDO
      ELSE
        TIP=1
        DO I=2,MPOLE,2
          TIP=TIP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*TIP*TIP)
c          write(0,*)im,tip,2*(i+1)*(im+1),im*tip*tip,dg(im)
        ENDDO
      ENDIF
c
               if(btime)call cpu_time(timei)
C
      MLAM=MPOL00-2
  737 MLAM=MLAM+2
      NGROUP=MLAM/2
C
      BCASC=BCASC.AND.NGROUP.EQ.1
      BBORN=MENGB.GT.1.OR.(MENGB.EQ.1.AND.NGROUP.NE.1)
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG
C      BFOTJ=BFOTJ.OR.NGROUP.NE.1            !UNCOMMENT TO WRITE E1 ONLY
      BFAST=.NOT.BBORN.AND..NOT.BPRNT0.AND.BJSEL.AND.BELONG
c      bfast=.true.
C
      IF(BSCRO)THEN                                         !MENGB.GE.-1
        MSC=MSC0+NGROUP
        OPEN(MSC,STATUS='SCRATCH',FORM='UNFORMATTED')
      ENDIF
c
c      if(bborn)then       !initialize flag to count Born usage
c        do i=1,mb4(0)
c          iflagb(i)=-1
c        enddo
c      endif
C
      BEKVEL=NGROUP.EQ.1.OR..NOT.BMPRNT.OR..NOT.BELONG  !I.E. VEL=.TRUE.
      IF(MPOLM.GT.0)THEN
      BM1BP=NGROUP.EQ.2.AND.ABS(MBP2MX).GT.0    ! 1/2-BODY M1+BP EXISTS
      BM1NBP=NGROUP.EQ.2.AND.MBP2MX.EQ.0.AND.MBP1MX.LT.0.and.mpolm.le.2
c     x      .and.mpole.lt.6          !M1 NON-REL - NB: SYNC WITH ALGEB4
      ELSE
        BM1BP=.FALSE.
        BM1NBP=.FALSE.
      ENDIF
C
      ISB=1+ione1
C
      IF(NGROUP.EQ.1)THEN
        MP=0
        IF(IORT.GT.20)ISB=IORT
        IF(BPRNT0)THEN
          WRITE(6,*)' '
          IF(.NOT.BELONG)WRITE(6,610)
          IF(NGROUP.LT.0)THEN
            WRITE(6,600)NGROUP
          ELSE
            WRITE(6,601)NGROUP
          ENDIF
          IF(ISB.GT.2)WRITE(6,640)ISB,JORIG(ISB)
        ENDIF
        IF(WLG1.LT.DZERO)THEN
          WLG=D1M2
          IF(IDIAG.LT.0.AND.BDEL)WLG=WLG0
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG1)
        WLGS=DKON
        IF(NPRNT5.GE.0)WLGS=D1M20
      ELSE
        IF(WLG2.LT.DZERO)THEN
          WLG=D1M7
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG2)
        WLGS=DKON
        IF(BPRNT0)WRITE(6,*)' '
        IF(NGROUP.gt.1.AND.BMPRNT)THEN
          MP=5
          MBCOR=MBLK
          IF(BM1BP)MBCOR=MBP
          IF(BPRNT0)THEN
            IF(.NOT.BELONG)WRITE(6,801)
            if(ngroup.eq.2.and..not.bborn)then                    !lande
              LAB9='GK(LANDE)'
            else
              LAB9='OMG(BORN)'
            endif
            IF(NGROUP.LT.10)THEN
              WRITE(6,650)NGROUP,NGROUP-1,MBCOR,LAB9
            ELSE
              WRITE(6,651)NGROUP,NGROUP-1,MBCOR,LAB9
            ENDIF
          ENDIF
        ELSE
          MP=5
          IF(BPRNT0)THEN
            IF(.NOT.BELONG)WRITE(6,802)
            IF(NGROUP.LT.10)THEN
              WRITE(6,660)NGROUP,MP
            ELSE
              WRITE(6,661)NGROUP,MP
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      ISGNN=1-2*mod(abs(NGROUP),ITWO)                   !(-1)**NGROUP
C
      JOS=0
      KTRAN=0
      JPOLD=-1
      IIMN=1                                          !case jjmn.gt.jjmx
      ILF=ione1
      JJMN=1+ione1
      JJMN=max(JJMN,ISB)
      JJMX=NENERG
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.2.OR.JRAD.EQ.3.OR.JRAD.EQ.5)JJMN=MAX(JJMN,IAUTO)
        IF(JRAD.EQ.1)JJMX=MIN(IAUTO-1,NENERG)
      ENDIF
      JJMN=MAX(JJMN,JUPMN)
      JJMX=MIN(JJMX,JUPMX)
C
C************************************
C START LOOP OVER UPPER ENERGY LEVELS
C************************************
C
      DO 732 IAB=JJMN,JJMX
C
      IF(.NOT.BAUX.AND.JORIG(IAB).LT.0)GO TO 732            !CORRELATION
      KTRAN=ABS(KTRAN)
      IF(JORIG(IAB).GT.0)THEN
        ILF=ILF+1
      ELSE
        KTRAN=-KTRAN
      ENDIF
      I=ABS(JORIG(IAB))
      IT=NRR(I)
C
      IF(NFK(IT).LT.0)THEN                    !CONT
        IF(.NOT.BFOT)GO TO 732                !BUT NO PI
        IF(BDOWN.AND.BUNPA.AND.IWRK2(I).GT.JIMXIC)GO TO 732      !FOR RR
      ENDIF
C
      ND=NFQ(IT)
      MNS=QSI(ND)
      IF(BMULT.AND.MNS.NE.MULTSM)GO TO 732
      MNL=QLI(ND)
      MQJ=JN(I)
      DZ9=MQJ+1
      NDJ=NGR(I)
      NCJ=NGRPJ(NDJ)                          !=I-NAJ(I)
c
            if(btime)call cpu_time(timeir)
c
c flag if mixing coefficient exists
c
      if(mode.ne.2)then                       !b-b only
        if(bkutls)then
          do n=1,nt(ndj)
            j=ncj+n
            jt=nrr(j)
            if(nfk(jt).eq.nfk(it))then
              idy(n)=-1
            else
              idy(n)=0
            endif
          enddo
        else
          do n=1,nt(ndj)
            idy(n)=-1
          enddo
        ENDIF
      elseif(nfk(it).gt.0)then                !i is bound
        do n=1,nt(ndj)
          j=ncj+n
          jt=nrr(j)
          if(bkutls)then
            btest=nfk(jt).eq.nfk(it)          !scf
          else
            btest=nfk(jt).gt.0                !b-b
          endif
          if(btest)then
            idy(n)=-1
          else                                !b-c/kf.ne.kg
            idy(n)=0
          endif
        enddo
      else                                    !j is continuum
        if(.not.bkutls)then
          m=-nfk(it)
          m=qcg(nf,m)
          ij=ieq(m)
        endif
        do n=1,nt(ndj)
          j=ncj+n
          jt=nrr(j)
          if(nfk(jt).gt.0)then                !c-b
            idy(n)=0
          else
            if(bkutls)then
              btest=nfk(jt).eq.nfk(it)        !c-c
            else
              m=-nfk(jt)
              m=qcg(nf,m)
              btest=ieq(m).eq.ij              !c-c
            endif
            if(btest)then
              idy(n)=1
            else                              !c-c'
              idy(n)=0
            endif
          endif
        enddo
      endif
C
      IIMN=1
      IIMX=IAB-ione1
      if(nmetaj.gt.0)iimx=min(iimx,nmetaj)
      IF(NMETAPJ.GT.0)IIMX=MIN(IIMX,NLASTP)
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.3)IIMN=MAX(IONE,IAUTO)
        IF(JRAD.EQ.1.OR.JRAD.EQ.2.OR.JRAD.EQ.4)IIMX=MIN(IAUTO-1,IIMX)
      ENDIF
      IF(.NOT.BUNA)THEN                 !OUTWITH DROPPED, NOT BUNDLED
        IIMN=MAX(IIMN,JLOWMN)
        IIMX=MIN(IIMX,JLOWMX)
      ENDIF
C
C INITIALIZE/ZEROIZE
C
      DO J=1,NENERG
        IWRK4(J)=ABS(IWRK4(J))
        DVECL(J)=DZERO
        DVECV(J)=DZERO
        DVECA(J)=DZERO
      ENDDO
C
      IF(.NOT.BFOTJ.AND.NFK(IT).LT.0)THEN
        DO J=1,NENERG
          DO M8=1,MENG
C            DVECF(M8,J)=DZERO
            DVECF(J,M8)=DZERO
          ENDDO
        ENDDO
        IF(MPOLE.GT.2)THEN
          DO J=1,NENERG
            DO M8=1,MENG
C              DVECM(M8,J)=DZERO
              DVECM(J,M8)=DZERO
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C PRE-DETERMINE (MAXIMAL) BORN USAGE (IXBIF):
C
      IF(BBORN)THEN
C
        IBO=0                              !INITIALIZE
        DO J=1,NENERG
          ID(J)=0
        ENDDO
C
        NCJP=0
        DO KK=1,NJO                   !BEGIN LOOP OVER "LOWER" JP GROUPS
C
        NC=NSLJ(1,KK)
        M=QPI(NC)+QPI(ND)
        IF(MOD(M+MLAM,IFOUR).NE.0)GO TO 2334
        MQJP=JN(NCJP+1)
        M=ABS(MQJ-MQJP)
        IF(M.GT.MLAM)GO TO 2334
        M=MQJ+MQJP
        IF(M.LT.MLAM)GO TO 2334
c        DZ8=MQJP+1
c        DSJ=SQRT(DZ8*DZ9)
C
        NCJP0=0
        DO NGJP=1,NGSLJ(KK)          !BEGIN LOOP OVER "LOWER" SLP GROUPS
C
        NC=NSLJ(NGJP,KK)
        IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 2333
C
        MQSP=QSI(NC)                           !=MNSP
        MQLP=QLI(NC)                           !=MNLP
C
c        IF(.NOT.BJSEL)THEN                  !LS SELECTION RULES APPLIED
c          IF(MNS.NE.MQSP)GO TO 2333
c          IF(ABS(MNL-MQLP).GT.MLAM)GO TO 2333
c          IF(MNL+MQLP.LT.MLAM)GO TO 2333
c        ENDIF
C
        DO NJP1=1,NSL(NC)
          J=NCJP+NCJP0+NJP1                   !=NCJ+POSITION IN JP GROUP
          LSL=NRR(J)
          IF(IWRK4(J).Le.IAB-ione1.AND.IWRK4(J).LE.IIMX.AND.
     X       NFK(LSL).GT.0)THEN
C            .AND.IWRKX(J).GT.IIMN            !IWRKX NOT SET-UP YET
            IWRK4(J)=-ABS(IWRK4(J))          !FLAG EXISTS
          ENDIF
        ENDDO
C
        NCJ0=0
        DO NGJ=1,NGSLJ(NDJ)         !BEGIN LOOP OVER UPPER CI SLP GROUPS
C
        ND=NSLJ(NGJ,NDJ)
        MQS=QSI(ND)
        MQL=QLI(ND)
C
c        IF(.NOT.BJSEL)THEN            !LS SELECTION RULES IMPOSED ON CI
c          IF(MQS.NE.MNS)GO TO 2340
c          IF(MQL.NE.MNL)GO TO 2340
c        ENDIF
C
        IF(MQSP.NE.MQS)GO TO 2340
        IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 2340
        IF(ABS(MQL-MQLP).GT.MLAM)GO TO 2340
        IF(MQL+MQLP.LT.MLAM)GO TO 2340
C
c        DRACL=SJS(MQL,MQJ,MQS,MQJP,MQLP,MLAM,DFS)*DSJ*   !SJS slow, and
c     X           (1-MOD(MQS+MQL+MQJP+MLAM,4))
c        IF(ABS(DRACL).LT.D1M7)GO TO 2340        !possibly safer to skip
C
        BEQGRP=ND.EQ.NC
        BING=ND.LE.NC
        IF(BING)THEN
          NU=NC
          NL=ND
cn          ngl=ndj
          NNNU=NCJP+NCJP0
          NNNL=NCJ+NCJ0
        ELSE
          NU=ND
          NL=NC
cn          ngl=kk
          NNNU=NCJ+NCJ0
          NNNL=NCJP+NCJP0
        ENDIF
C
        J0=NNNU+1
        I0=NRR(J0)
        IF(NED(1,NL,I0).EQ.0)GO TO 2340
C
        DO 2330 N=1,NSL(NU)           !BEGIN LOOP OVER UPPER SYM. LEVELS
C
        J0=NNNU+N                             !UPPER LEVEL INDEX
        I0=NRR(J0)                            !UPPER TERM INDEX
C
  230   IF(BING)THEN
          LSL=I0
          J=J0
          IF(IWRK4(J).GT.0)GO TO 2320
        ELSE
          KSL=I0
          K=J0
          if(idy(k-ncj).eq.0)go to 2320
c          NI=NADRUJ(I)+NAJ(K)
c          DD1=TFUJ(NI)
c          IF(ABS(DD1).LT.CMXICR)GO TO 2320      !possibly safer to skip
        ENDIF
C
        N1=NED(1,NL,I0)-NPOS0
        N2=NED(2,NL,I0)-NPOS0
C
        DO 236 M=N1,N2                !BEGIN LOOP OVER LOWER SYM. LEVELS
C
        IF(BPOS)THEN                         !M2=LOWER TERM INDEX
          M2=NPOS(1,M)
        ELSE
          n8=MXORB2*MXPOL
          M1=INT(NRK(M)/n8)
          M2=M1+1
        ENDIF
C
        K0=NNNL+M2-NRR(NNNL+1)+1             !LOWER LEVEL INDEX
C
        IF(BING)THEN
          KSL=M2
          K=K0
          if(idy(k-ncj).eq.0)go to 236
c          NI=NADRUJ(I)+NAJ(K)
c          DD1=TFUJ(NI)
c          IF(ABS(DD1).LT.CMXICR)GO TO 236       !possibly safer to skip
        ELSE
          IF(I0.EQ.M2)GO TO 236  !AVOID DOUBLE COUNTING
          LSL=M2
          J=K0
          IF(IWRK4(J).GT.0)GO TO 236
        ENDIF
C
        IF(BPOS)THEN                         !M2=LOWER TERM INDEX
          MK=NPOS(2,M)
          IF(MK.NE.NGROUP)GO TO 236
        ELSE
          n8=M1*n8
          MX=INT((NRK(M)-n8)/MXORB2)
          MK=MX
          MK=MK+MPOL0/2                                           !FLAGX
          IF(MK.NE.NGROUP)GO TO 236
        ENDIF
C
COLD        JG=J                            !STORE IN ORGINAL GROUP POSN
        jg=jwrkg(kk-1)+naj(j)            !store in e-vector posn as tfuj
        if(bkutls)jg=jg+jwrkb(1,nfk(nrr(j)),kk)
C
        IF(ID(JG).EQ.0)THEN
          IBO=IBO+1
          ID(JG)=IBO
        ENDIF
C
  236   CONTINUE                  !END LOOP OVER LOWER SYM. LEVELS
C
 2320   IF(BEQGRP)THEN                           !PICK-UP OTHER HALF
          IF(BING)THEN
            BING=.FALSE.
            J0=NNNL-NRR(NNNL+1)+I0+1
            NNNL=NCJP+NCJP0
            GO TO 230
          ELSE
            BING=.TRUE.
cn            ngl=ndj
            NNNL=NCJ+NCJ0
          ENDIF
        ENDIF
C
 2330   CONTINUE                  !END LOOP OVER UPPER SYM. LEVELS
C
 2340   NCJ0=NCJ0+NSL(ND)
        ENDDO                     !END LOOP OVER UPPER CI SLP GROUPS
C
 2333   NCJP0=NCJP0+NSL(NC)
        ENDDO                     !END LOOP OVER "LOWER" SLP GROUPS
C
 2334   NCJP=NCJP+NT(KK)
        ENDDO                     !END LOOP OVER "LOWER" JP GROUPS
C
        IXBIF=IBO
C
        IF(IXBIF.GT.MXIBF)THEN
          IF(MXIBF.GT.0)WRITE(6,1137)IXBIF,MXBIF
        ENDIF
c        write(0,*)ixbif
c        ibifmx=max(ibifmx,ixbif)
C
        ALLOCATE (DBL(IXD33,IXBIF),STAT=IERR)    !MXBIF
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.DIAGFS: ALLOCATION FAILS FOR DBL'
          NF=0
          GO TO 7450
        ENDIF
C                                                !RE-INITIALIZE
        IBO=0
        DO J=1,NENERG
          ID(J)=0
        ENDDO
C
      ENDIF
C
C**********************************************************************
C PRE-MULTIPLY UPPER MIXING MATRIX BY MULTIPOLE MATRIX FOR ALL "LOWER"
C STATES (ALL, BECAUSE THE "LOWER" STATES ARE TO BE MIXED SUBSEQUENTLY)
C**********************************************************************
C
C                ***** ELECTRIC *****
C
C**********************************************************************
C      DVECL(J)=                                       !EK LENGTH
C      IF(NGROUP.NE.2.OR.BBORN)DVECV(J)=               !EK VELOCITY
C**********************************************************************
C
C
      NCJP=0
      DO KK=1,NJO                    !BEGIN LOOP OVER "LOWER" JP GROUPS
C
C FOR SPEED PRE-SELECT ACCORDING TO PARITY, TOTAL J:
C
      NC=NSLJ(1,KK)
      M=QPI(NC)+QPI(ND)
      IF(MOD(M+MLAM,IFOUR).NE.0)GO TO 7334
      MQJP=JN(NCJP+1)
      M=ABS(MQJ-MQJP)
      IF(M.GT.MLAM)GO TO 7334
      M=MQJ+MQJP
      IF(M.LT.MLAM)GO TO 7334
      DZ8=MQJP+1
      DSJ=SQRT(DZ8*DZ9)
C
      NCJP0=0
      DO NGJP=1,NGSLJ(KK)            !BEGIN LOOP OVER "LOWER" SLP GROUPS
C
      NC=NSLJ(NGJP,KK)
      IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 7333
C
      MQSP=QSI(NC)                           !=MNSP
      MQLP=QLI(NC)                           !=MNLP
C
      IF(.NOT.BJSEL)THEN  !LS SELECTION RULES APPLIED
        IF(MNS.NE.MQSP)GO TO 7333
        IF(ABS(MNL-MQLP).GT.MLAM)GO TO 7333
        IF(MNL+MQLP.LT.MLAM)GO TO 7333
      ENDIF
C
      DO NJP1=1,NSL(NC)
        J=NCJP+NCJP0+NJP1                    !=NCJ+POSITION IN JP GROUP
        LSL=NRR(J)
        IF(IWRK4(J).Le.IAB-ione1.AND.IWRK4(J).LE.IIMX.AND.
     X     NFK(LSL).GT.0)THEN
C          .AND.IWRKX(J).GT.IIMN             !IWRKX NOT SET-UP YET
          IWRK4(J)=-ABS(IWRK4(J))           !FLAG EXISTS
        ENDIF
      ENDDO
C
      NCJ0=0
      DO NGJ=1,NGSLJ(NDJ)           !BEGIN LOOP OVER UPPER CI SLP GROUPS
C
      ND=NSLJ(NGJ,NDJ)
      MQS=QSI(ND)
      MQL=QLI(ND)
C
      IF(.NOT.BJSEL)THEN             !LS SELECTION RULES IMPOSED ON CI
        IF(MQS.NE.MNS)GO TO 7340
        IF(MQL.NE.MNL)GO TO 7340
      ENDIF
C
C IC REDUCED MATRIX ELEMENT IS ZERO IF LS SELECTION RULES NOT SATISFIED
C IT IS JUST A TRANSFORMATION OF LS REDUCED MATRIX ELEMENT (EJN EQU 116)
C
      IF(MQSP.NE.MQS)GO TO 7340
      IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 7340
      IF(ABS(MQL-MQLP).GT.MLAM)GO TO 7340
      IF(MQL+MQLP.LT.MLAM)GO TO 7340
C
      MMM=(MQL-MQLP)/2
      DS=1-2*mod(abs(MMM),ITWO)         !(-1)**MMM
      IF(BFANO)DS=DS*ISGNN
C
      DRACL=SJS(MQL,MQJ,MQS,MQJP,MQLP,MLAM,DFS)*DSJ*
     X        (1-MOD(MQS+MQL+MQJP+MLAM,IFOUR))
      IF(ABS(DRACL).LT.D1M7)GO TO 7340
C
      BEQGRP=ND.EQ.NC
      BING=ND.LE.NC
      IF(BING)THEN
        NU=NC
        NL=ND
cn        ngl=ndj
        NNNU=NCJP+NCJP0
        NNNL=NCJ+NCJ0
      ELSE
        NU=ND
        NL=NC
cn        ngl=kk
        NNNU=NCJ+NCJ0
        NNNL=NCJP+NCJP0
      ENDIF
C
      J0=NNNU+1
      I0=NRR(J0)
      IF(NED(1,NL,I0).EQ.0)GO TO 7340
C
      DO 7330 N=1,NSL(NU)             !BEGIN LOOP OVER UPPER SYM. LEVELS
C
      J0=NNNU+N                             !UPPER LEVEL INDEX
      I0=NRR(J0)                            !UPPER TERM INDEX
C
  332 IF(BING)THEN
        LSL=I0
        J=J0
        IF(IWRK4(J).GT.0)GO TO 7320
      ELSE
        KSL=I0
        K=J0
        if(idy(k-ncj).eq.0)go to 7320
        NI=NADRUJ(I)+NAJ(K)
        DD1=TFUJ(NI)
        IF(ABS(DD1).LT.CMXICR)GO TO 7320
      ENDIF
C
      N1=NED(1,NL,I0)-NPOS0
      N2=NED(2,NL,I0)-NPOS0
C
      DO 736 M=N1,N2                !BEGIN LOOP OVER LOWER SYM. LEVELS
C
      IF(BPOS)THEN                         !M2=LOWER TERM INDEX
        M2=NPOS(1,M)
      ELSE
        n8=MXORB2*MXPOL
        M1=INT(NRK(M)/n8)
        M2=M1+1
      ENDIF
C
      K0=NNNL+M2-NRR(NNNL+1)+1             !LOWER LEVEL INDEX
C
      IF(BING)THEN
        KSL=M2
        K=K0
        if(idy(k-ncj).eq.0)go to 736
        NI=NADRUJ(I)+NAJ(K)
        DD1=TFUJ(NI)
        IF(ABS(DD1).LT.CMXICR)GO TO 736
      ELSE
        IF(I0.EQ.M2)GO TO 736  !AVOID DOUBLE COUNTING
        LSL=M2
        J=K0
        IF(IWRK4(J).GT.0)GO TO 736
      ENDIF
C
      IF(BPOS)THEN                         !M2=LOWER TERM INDEX
        MK=NPOS(2,M)
        IF(MK.NE.NGROUP)GO TO 736
      ELSE
        n8=M1*n8
        MX=INT((NRK(M)-n8)/MXORB2)
        MK=MX
        MK=MK+MPOL0/2                                             !FLAGX
        IF(MK.NE.NGROUP)GO TO 736
      ENDIF
C
COLD      JG=J                            !STORE IN ORGINAL GROUP POSN
      jg=jwrkg(kk-1)+naj(j)              !store in e-vector posn as tfuj
      if(bkutls)jg=jg+jwrkb(1,nfk(nrr(j)),kk)
C
      IF(BPOS)THEN
        M2=NPOS(3,M)
        MM=NPOS(4,M)
        M1=ABS(MM)
      ELSE
        n8=n8+MX*MXORB2
        n8=NRK(M)-n8
        I1=1
        I1=I1+MB                                                  !FLAGX
        M0=INT(n8/MXORBR)
        M1=M0+I1
        MM=INT(n8-M0*MXORBR+I1)
        M2=MIN(M1,MM)
        M1=M1+MM-M2
      ENDIF
C
      DRY=DD1*DRK(M+NPOS0)*DRACL
      BINT=LSL.LE.KSL
      IF(.NOT.BINT)DRY=DRY*DS
      DSC=DOSC(NGROUP,M1,M2)
C
      DVECL(JG)=DVECL(JG)+DRY*DSC               !LENGTH
C
      IF(BREL.AND.NFK(IT).GT.0.and.irtard.gt.0)THEN!RETARD ALREADY ON PI
        DDD=DENERG(J)-DENERG(K)
        DDD=4*DDD*DDD*DRY
        DVECL(JG)=DVECL(JG)-DALF4*DDD*DOSC(NGROUP+2,M1,M2)/(4*NGROUP+6)
      ENDIF
c
c      write(6,899)i,k,j,jg,m+npos0,dd1,drk(m+npos0)
c     x           ,dracl,dry,dsc,dvecl(jg)
c 899  format(4i5,6(1pe12.3))
C
      IF(.NOT.BFOTJ.AND.NFK(IT).LT.0)THEN        !PHOTO
        M7=NFOSS(ngroup/2,M1,M2)
        IF(M7.GT.0)THEN
          ISYGN=1
          IF(MM.NE.M1) ISYGN=-ISYGN
          IF(.NOT.BINT) ISYGN=-ISYGN
          IF(ISYGN.LT.0)THEN
            DO M8=1,MENG
              DSC=DRY                      !LENGTH/ACCELERATION
              IF(IGAG(M8).EQ.0)DSC=-DSC    !VELOCITY
C              DVECF(M8,JG)=DVECF(M8,JG)+DFOSS(M7,M8,1)*DSC
              DVECF(JG,M8)=DVECF(JG,M8)+DFOSS(M7,M8,1)*DSC
            ENDDO
          ELSE
            DO M8=1,MENG
C              DVECF(M8,JG)=DVECF(M8,JG)+DFOSS(M7,M8,1)*DRY
              DVECF(JG,M8)=DVECF(JG,M8)+DFOSS(M7,M8,1)*DRY
            ENDDO
          ENDIF
        ENDIF
      ENDIF
C
      IF(BFAST)GO TO 736
C
      IF(BEKVEL)THEN
        DSC=DZERO            !CHANGE OF ORBITAL TO TERM ORDER (VEL)
        IF(M1.NE.M2)THEN
          DSC=DOSC(NGROUP,M2,M1)
        ELSE
          IF(NGROUP.GT.0)DSC=DOSC(NGROUP-1,M2,M1)
        ENDIF
        IF(MM.NE.M1)  DSC=-DSC
        IF(.NOT.BINT) DSC=-DSC
        DVECV(JG)=DVECV(JG)+DRY*DSC        !VELOCITY
      ENDIF
C
      IF(BBORN)THEN         !BORN
        IF(ID(JG).EQ.0)THEN
          IBO=IBO+1
          IF(IBO.LE.IXBIF)THEN
            ID(JG)=IBO
            DO IX=1,MB3(0)
              DBL(IX,IBO)=DZERO
            ENDDO
          ELSE
            ID(JG)=-IBO
          ENDIF
        ENDIF
        IF(ID(JG).GT.0)THEN
          IB=ID(JG)
          IN=ICOL(M2,M1,IZERO)
          IF(BINDB(IN,NGROUP/2))THEN
            IX=INDX(IN)
            DBL(IX,IB)=DBL(IX,IB)+DRY
          ELSE
            JAB=ABS(IEORD(J))
            WRITE(6,*)IAB,JAB,K,M,NGROUP,M2,M1
            WRITE(0,*)'DIAGFS: BORN M1 M2 NOT FOUND'
            GO TO 3000
          ENDIF
        ENDIF
      ENDIF
C
  736 CONTINUE                  !END LOOP OVER LOWER SYM. LEVELS
C
 7320 IF(BEQGRP)THEN                           !PICK-UP OTHER HALF
        IF(BING)THEN
          BING=.FALSE.
          J0=NNNL-NRR(NNNL+1)+I0+1
          NNNL=NCJP+NCJP0
          GO TO 332
        ELSE
          BING=.TRUE.
cn          ngl=ndj
          NNNL=NCJ+NCJ0
        ENDIF
      ENDIF
C
 7330 CONTINUE                  !END LOOP OVER UPPER SYM. LEVELS
C
 7340 NCJ0=NCJ0+NSL(ND)
      ENDDO                     !END LOOP OVER UPPER CI SLP GROUPS
C
 7333 NCJP0=NCJP0+NSL(NC)
      ENDDO                     !END LOOP OVER "LOWER" SLP GROUPS
C
 7334 NCJP=NCJP+NT(KK)
      ENDDO                     !END LOOP OVER "LOWER" JP GROUPS
C
      IF(BBORN)THEN
        IBOMX=MAX(IBOMX,IBO)
        IF(IBO.GT.IXBIF)THEN                       !SHOULDN'T HAPPEN
          WRITE(6,*)'SR.DIAGFS: DIMENSION ERROR, INCREASE MXBIF TO '
     X              ,IBO
          WRITE(0,*)'SR.DIAGFS: DIMENSION ERROR, INCREASE MXBIF'
          GO TO 3000
        ENDIF
      ENDIF
C
C
C**********************************************************************
C
C                ***** MAGNETIC *****
C
C**********************************************************************
C
C M1 (NON-REL)
C      DVECA(J)=                                       !M1
C**********************************************************************
C
      IF(BM1NBP)THEN
C
      MLAMM=MLAM-2                                     !MLAMM=2 FOR M1
C
      NCJP=0
      DO KK=1,NJO                   !BEGIN LOOP OVER "LOWER" JP GROUPS
C
      IF(NMETGJ(KK)+NMETGJ(NDJ).GT.1)GO TO 6334
C
C FOR SPEED PRE-SELECT ACCORDING TO PARITY, TOTAL J:
C
      NC=NSLJ(1,KK)
      M=QPI(NC)+QPI(ND)
      IF(MOD(M+MLAM,IFOUR).NE.0)GO TO 6334
      MQJP=JN(NCJP+1)
      M=ABS(MQJ-MQJP)
      IF(M.GT.MLAMM)GO TO 6334
      M=MQJ+MQJP
      IF(M.LT.MLAMM)GO TO 6334
C
      NCJP0=0
      DO NGJP=1,NGSLJ(KK)           !BEGIN LOOP OVER "LOWER" SLP GROUPS
      NC=NSLJ(NGJP,KK)
C
      IF(.NOT.BJSEL)THEN  !LS SELECTION RULES APPLIED
        MNSP=QSI(NC)
        MNLP=QLI(NC)
        IF(MNS.NE.MNSP)GO TO 6333
        IF(ABS(MNL-MNLP).GT.MLAMM)GO TO 6333
        IF(MNL+MNLP.LT.MLAMM)GO TO 6333
      ENDIF
C
      NPP=NSL(NC)
      DO 6330 NJP1=1,NPP            !BEGIN LOOP OVER "LOWER" SLJP LEVELS
C
        J=NCJP+NCJP0+NJP1                     !=NCJ+POSITION IN JP GROUP
C
        IF(IWRK4(J).Gt.IAB-ione1)GO TO 6330
        IF(IWRK4(J).GT.IIMX)GO TO 6330
C       IF(IWRKX(J).LT.IIMN)GO TO 6330    !IWRKX NOT SET-UP YET
        LSL=NRR(J)
        IF(NFK(LSL).LT.0)GO TO 6330
        IWRK4(J)=-ABS(IWRK4(J))                   !FLAG EXISTS
C
COLD        JG=J                          !STORE IN ORIGINAL GROUP POSN
        jg=jwrkg(kk-1)+naj(j)            !store in e-vector posn as tfuj
        if(bkutls)jg=jg+jwrkb(1,nfk(nrr(j)),kk)
C
        NCJ0=0
        DO NGJ=1,NGSLJ(NDJ)               !LOOP OVER UPPER CI SLP GROUPS
C
          ND=NSLJ(NGJ,NDJ)
          IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 6340
          IF(NC.NE.ND)GO TO 6340                   !NC=ND FOR NON-REL M1
          MQS=QSI(ND)
          MQL=QLI(ND)
C
          IF(.NOT.BJSEL)THEN                 !LS SELECTION IMPOSED ON CI
            IF(MQS.NE.MNS)GO TO 6340
            IF(MQL.NE.MNL)GO TO 6340
          ENDIF
C
          NP=NSL(ND)
          DO NJP=1,NP                  !LOOP OVER UPPER CI SLJP LEVELS
C
            K=NCJ+NCJ0+NJP
            if(idy(k-ncj).eq.0)go to 634
            M=NADRUJ(I)+NAJ(K)
            DD1=TFUJ(M)
C
            IF(ABS(DD1).LT.CMXICR)GO TO 634
C
            KSL=NRR(K)
c          write(0,*)njp1,lsl,nc,njp,ksl,nd
            IF(KSL.EQ.LSL.AND.ABS(MQJ-MQJP).LE.2)THEN
              IF(MQJ.EQ.MQJP)THEN
                MJ=(MQJ+2)*MQJ
                DSC=(MQS+2)*MQS-(MQL+2)*MQL+3*MJ
                DD8=(MQJ+1)*MJ
              ELSE
                MJ=MAX(MQJ,MQJP)
                DD8=REAL(((MJ-MQS+MQL)*(MJ+MQS-MQL)*MJ*(MJ+MQS+MQL+2)
     X                   *(MQS+MQL+2-MJ))/2,WP)
                DSC=1
                IF(K.GT.J)THEN
                  DSC=-DSC                    !OVERALL PHASE - EJN (123)
                  IF(BFANO)DSC=-DSC
                ENDIF
c           write(0,*)k,j,mqj,mqjp !k.gt.j iff mqj.lt.mqjp (mqj.ne.mqjp)
              ENDIF
C
              DVECA(JG)=DVECA(JG)+DD1*DSC*SQRT(DD8)/(DFOUR*MJ)!NONREL M1
C
            ENDIF
C
  634     ENDDO                 !END LOOP OVER UPPER CI SLJP LEVELS
C
 6340     NCJ0=NCJ0+NSL(ND)
        ENDDO                   !END LOOP OVER UPPER CI SLP GROUPS
C
 6330 CONTINUE                  !END LOOP OVER "LOWER" SLJP LEVELS
C
 6333 NCJP0=NCJP0+NPP
      ENDDO                     !END LOOP OVER "LOWER" SLP GROUPS
C
 6334 NCJP=NCJP+NT(KK)
      ENDDO                     !END LOOP OVER "LOWER" JP GROUPS
C
      GO TO 450
C
      ENDIF                     !END NON-REL M1
C
C**********************************************************************
C
C M1BP AND MK>1
C
C      IF(NGROUP.EQ.2.AND..NOT.BBORN)DVECV(J)=         !MK0/E1 REL VEL
C      DVECA(J)=                                       !MK1
C**********************************************************************
C
C
      IF(NGROUP.EQ.0)GO TO 450                   !ALLOW MK (K=NGROUP-1)
      IF(NGROUP.EQ.1.AND.MEKVMX.LT.2)GO TO 450          !NO E1 REL VEL
      IF(NMD1(1,1,1).LT.0.AND.NMD2(1,1,1).LT.0)GO TO 450!NO MK
      IF(NGROUP.GT.2.AND.NMD1(1,1,1).LT.0)GO TO 450     !NO MK
      MLAMM=MLAM-2                                   !TEST MLAM-2 FOR MK
      IF(NGROUP.EQ.1)MLAMM=MLAM
C
      NCJP=0
      DO KK=1,NJO                   !BEGIN LOOP OVER "LOWER" JP GROUPS
C
      IF(NMETGJ(KK)+NMETGJ(NDJ).GT.1)GO TO 8334
C
C FOR SPEED PRE-SELECT ACCORDING TO PARITY, TOTAL J:
C
      NC=NSLJ(1,KK)
      M=QPI(NC)+QPI(ND)
      IF(MOD(M+MLAM,IFOUR).NE.0)GO TO 8334
      MQJP=JN(NCJP+1)
      M=ABS(MQJ-MQJP)
      IF(M.GT.MLAMM)GO TO 8334
      M=MQJ+MQJP
      IF(M.LT.MLAMM)GO TO 8334
C
      NPP=NT(KK)
      DO NJP1=1,NPP
C
        J=NCJP+NJP1
        IF(IWRK4(J).Gt.IAB-ione1)GO TO 833
        IF(IWRK4(J).GT.IIMX)GO TO 833
C       IF(IWRKX(J).LT.IIMN)GO TO 833    !IWRKX NOT SET-UP YET
        LSL=NRR(J)
        IF(NFK(LSL).LT.0)GO TO 833
        IWRK4(J)=-ABS(IWRK4(J))               !FLAG EXISTS
C
  833 ENDDO
C
      BEQGRP=KK.EQ.NDJ
      BING=NDJ.LE.KK
      IF(BING)THEN
        NU=KK
        NL=NDJ
        NNN=NCJP
        DS=1-MOD(ABS(MQJ-MQJP),IFOUR)
        IF(BFANO)DS=DS*(1-MOD(MLAMM,IFOUR))
      ELSE
        NU=NDJ
        NL=KK
        NNN=NCJ
        DS=1
      ENDIF
C
      NP=NT(NU)
      DO 8340 NJP=1,NP                   !LOOP OVER UPPER CI JP LEVELS
C
      J0=NNN+NJP
C
  430 IF(BING)THEN
        J=J0
        IF(IWRK4(J).GT.0)GO TO 834
      ELSE
        K=J0
        IF(.NOT.BJSEL)THEN                 !LS SELECTION IMPOSED ON CI
          KSL=NRR(K)
          ND=NFQ(KSL)
          MQS=QSI(ND)
          MQL=QLI(ND)
          IF(MQS.NE.MNS)GO TO 834
          IF(MQL.NE.MNL)GO TO 834
        ENDIF
        if(idy(k-ncj).eq.0)go to 834
        M=NADRUJ(I)+NAJ(K)
        DD1=TFUJ(M)
        IF(ABS(DD1).LT.CMXICR)GO TO 834
        DD8=DD1*DS
      ENDIF
C
C 2-BODY
C
      IF(NGROUP.EQ.2.and.NMD2(1,1,1).GE.0)THEN
        N1=NMD2(1,NL,J0)
        N2=NMD2(2,NL,J0)
c        write(6,*)n1,n2,j,nl,j0
        DO N=N1,N2           !BEGIN 2-BODY LOOP OVER LOWER JP LEVELS
          N82=(MSS(N)-1)/IPLANT_MI                                !MAXMI
          MJ=INT(MSS(N)-N82*IPLANT_MI)                            !MAXMI
          K0=INT(N82)+1
C
          IF(BING)THEN
            K=K0
            IF(.NOT.BJSEL)THEN  !LS SELECTION RULES APPLIED
              LSL=NRR(K)
              NC=NFQ(LSL)
              MNSP=QSI(NC)
              MNLP=QLI(NC)
              IF(MNS.NE.MNSP)GO TO 435
              IF(ABS(MNL-MNLP).GT.MLAMM)GO TO 435
              IF(MNL+MNLP.LT.MLAMM)GO TO 435
            ENDIF
            if(idy(k-ncj).eq.0)go to 435
            M=NADRUJ(I)+NAJ(K)
            DD1=TFUJ(M)
            IF(ABS(DD1).LT.CMXICR)GO TO 435
            DD8=DD1*DS
          ELSE
            IF(J0.EQ.K0)GO TO 435                 !AVOID DOUBLE COUNTING
            J=K0
            IF(IWRK4(J).GT.0)GO TO 435
          ENDIF
C
COLD          JG=J                       !STORE IN ORIGINAL GROUP POSITN
          jg=jwrkg(kk-1)+naj(j)         !store in bound-bound c.f. tfuj
          if(bkutls)jg=jg+jwrkb(1,nfk(nrr(j)),kk)
C
          DVECA(JG)=DVECA(JG)+DNL(MJ)*DSS(N)*DD8                 !REL M1
c          write(6,*)n,j,dveca(j)
  435   ENDDO                      !END 2-BODY LOOP OVER LOWER JP LEVELS
      ENDIF
C
C 1-BODY (REL)
C
      IF(NMD1(1,1,1).LT.0)GO TO 834
      N1=NMD1(1,NL,J0)
      N2=NMD1(2,NL,J0)
c
c      write(6,*)nl,j0,n1,n2
c      if(n1.eq.0)go to 834
C
      DO N=N1,N2             !BEGIN 1-BODY LOOP OVER LOWER JP LEVELS
      N81=(NRKP(N)-1)/IPLANT_SOI                                  !MXSOI
      MJ=INT(NRKP(N)-N81*IPLANT_SOI)                              !MXSOI
      KX=QRLP(4,MJ)
      K0=INT(N81)+1
C
      IF(BING)THEN
        K=K0
        IF(.NOT.BJSEL)THEN  !LS SELECTION RULES APPLIED
          LSL=NRR(K)
          NC=NFQ(LSL)
          MNSP=QSI(NC)
          MNLP=QLI(NC)
          IF(MNS.NE.MNSP)GO TO 436
          IF(ABS(MNL-MNLP).GT.MLAMM)GO TO 436
          IF(MNL+MNLP.LT.MLAMM)GO TO 436
        ENDIF
        if(idy(k-ncj).eq.0)go to 436
        M=NADRUJ(I)+NAJ(K)
        DD1=TFUJ(M)
        IF(ABS(DD1).LT.CMXICR)GO TO 436
        DD8=DD1*DS
      ELSE
        IF(J0.EQ.K0)GO TO 436                     !AVOID DOUBLE COUNTING
        J=K0
        IF(IWRK4(J).GT.0)GO TO 436
      ENDIF
C
COLD      JG=J                            !STORE IN ORGINAL GROUP POSITN
      jg=jwrkg(kk-1)+naj(j)              !store in bound-bound c.f. tfuj
      if(bkutls)jg=jg+jwrkb(1,nfk(nrr(j)),kk)
C
      DRY=(DENERG(K)-DENERG(J))*2                      !TEST K->I
c      write(6,*)n,kx,k,j,dry
      M1=QRLP(1,MJ)
      M2=QRLP(2,MJ)
C
      dry0=dey(m1)-duy(m1,m1)-(dey(m2)-duy(m2,m2)) ! a.u.
      dry0=abs(dry0+dry0)                          !abs <- falling order
c      if(nfk(it).lt.0)dry=dry+dyy(nrel)*2
      if(nfk(it).lt.0)dry=dry0
c      dry=dry0                                    !test use of orb ener
      IF(KX.GT.8)THEN                                 !1-BODY MK
        IF(QRLP(3,MJ).NE.MLAMM)GO TO 436              !WRONG MULTIPOLE
        DSC=DRLP1(MJ)
        IF(KX.EQ.9.AND.BREL)THEN
c         write(6,*)dsc
          IF(.NOT.BEKVEL)DVECV(JG)=DVECV(JG)+DRKP(N)*DD8*DSC        !MK0
          if(nfk(it).gt.0.and.irtard.ge.0)then    !else already retarded
            IF(.NOT.BREL2)THEN
c                     2* for spin
              DSC=DSC-2*DALF4*DRY*DRY*DOSC(NGROUP,M1,M2)/(4*NGROUP-2)
c           write(6,*)m1,m2,ngroup,dsc,dry,dosc(ngroup,m1,m2)
            ELSEIF(.NOT.BEKVEL)THEN
              IF(NGROUP.GT.2)THEN
                DSC0=DOSC(NGROUP-2,M1,M2)
              ELSE
                IF(M1.EQ.M2)THEN
                  DSC0=DONE
                ELSE
                  DSC0=DZERO
                ENDIF
              ENDIF
              DVECV(JG)=DVECV(JG)+DRKP(N)*DD8*(DSC0-DSC)            !MK0
            ENDIF
          endif
        ENDIF
        DSC=DRKP(N)*DD8*DSC                       !DD1->DD8
        IF(KX.EQ.10)DSC=DSC*DRY*DRY             !*DALF4 sync with radbp1
c
c        write(6,*)
c     x  ngroup,i,j,k,kx,qrlp(1,mj),qrlp(2,mj),dsc,drkp(n),drlp1(mj),dry
c
        DVECA(JG)=DVECA(JG)+DSC                                     !MK1
c
c        if(kx.eq.10)write(6,*)dry,drlp1(mj),DRKP(N)*DD8,j,jg,dveca(jg)
c        write(6,*)j,jg,dveca(jg)
c
C qrlp -> m1.gt.m2
        IF(.NOT.BFOTJ.AND.NFK(IT).LT.0)THEN       !PHOTO
          IF(KX.EQ.9)THEN
            M7=NFOSS((ngroup-2)/2,M2,M1)
            IF(M7.GT.0)THEN
              DSC=DRKP(N)*DD8
              DO M8=1,MENG
C                DVECM(M8,JG)=DVECM(M8,JG)+DFOSS(M7,M8,1)*DSC
                DVECM(JG,M8)=DVECM(JG,M8)+DFOSS(M7,M8,1)*DSC
c                write(6,*)m8,m7,DFOSS(M7,M8,1),dsc,j,jg,dvecm(jg,m8)
              ENDDO
            ENDIF
          ELSE                                    !KX.EQ.10
            M7=NFOSS(ngroup/2,M2,M1)
            IF(M7.GT.0)THEN
              DSC=DRKP(N)*DD8*DALF4
              dry0=-(dey(m2)-duy(m2,m2))          !a.u.
c              dry0=abs(denerg(k)-denerg(j))
              DO M8=1,MENG
                DRY2=(dry0+DYY(M8))*2
C                DVECM(M8,JG)=DVECM(M8,JG)+DFOSS(M7,M8,1)*DSC*DRY2*DRY2
                DVECM(JG,M8)=DVECM(JG,M8)+DFOSS(M7,M8,1)*DSC*DRY2*DRY2
c        write(6,*)m8,dry2,m7,DFOSS(M7,M8,1),dsc/DALF4,j,jg,dvecm(jg,m8)
              ENDDO
            ENDIF
          ENDIF
        ENDIF
        GO TO 436
      ENDIF
C
      IF(NGROUP.GT.2)GO TO 436         !ORIGINAL REL PERT IS DIPOLE ONLY
C
      DSC=DRLP1(MJ)
c      write(6,*)'kx=',kx,m1,m2,dsc
c       dry0=dry                                 !test use of level ener
      if(igagr.gt.0.and.(kx.eq.4.or.kx.eq.6.or.kx.eq.7.or.kx.eq.8)
     x  .and.ql(m1).eq.ql(m2))then                     !check rad/radial
        if(qn(m1).ne.qn(m2))then
          mx=max(m1,m2)
          mn=min(m1,m2)
          tt=dry0*dry0*dosc(ngroup,mx,mn)/4
c      write(6,*)'kx=',kx,mx,mn,dry0,dosc(ngroup,mx,mn)
c case l1=n1-1, l2.lt.l1 only                          !check rad/radial
          if(ql(m1).ne.ql(m2))tt=-tt*
     x    real(min(ql(m1),ql(m2))/2+1,wp)/real(max(ql(m1),ql(m2))+1,wp)
        else
          tt=2*(dey(m1)-duy(m1,m1))+2*(dey(m2)-duy(m2,m2))
c case l1=n1-1, l2.lt.l1 only                          !check rad/radial
          if(ql(m1).ne.ql(m2))tt=tt/sqrt(
     x    real(min(ql(m1),ql(m2))/2+2,wp)*real(max(ql(m1),ql(m2))+1,wp))
        endif
      else
        tt=dzero
      endif
      IF(KX.EQ.8)THEN
        DSC=(tt-D2LL(M1,M2)-DSC*DRY*DRY/D2P1)*DALF4*DTWO
        IF(M2.EQ.M1)THEN
          DSC=DSC+1
          IF(.NOT.BEKVEL)DVECV(JG)=DVECV(JG)+DD8*DRKP(N)         !REL M0
        ENDIF
      ELSEIF(KX.EQ.7)THEN
        if(igagr.gt.0.and.ql(m1).eq.ql(m2))then        !check rad/radial
          dsc=tt*DALF4*nzion/nza
        else
          DSC=-NZION*DSC
        endif
      ELSEIF(KX.EQ.5)THEN
        DSC=DRY*DRY*DSC/D2P1
      ELSEIF(KX.EQ.6)THEN
        DSC=DRY*DSC+(tt-D2LL(M1,M2))*DALF4
      elseif(kx.eq.4)then
        dsc=dsc-tt*DALF4
      ENDIF
C
      DRAC=DD8*DRKP(N)*DSC
c      write(6,*)'kx=',kx,m1,m2,tt,dsc,drkp(n),drac,dveca(jg),j,jg
C
      IF(QPI(NC).NE.QPI(ND))THEN
c        write(6,*)dvecv(jg),drac
        DVECV(JG)=DVECV(JG)+2*NZION*DRAC/DRY   !REL E1(VEL)
      ELSE
        DVECA(JG)=DVECA(JG)+DRAC               !REL M1
c        write(6,*)j,jg,kx,dveca(jg)-drac,dveca(jg),dvecv(jg)
      ENDIF
c        write(6,*)qrlp(1,mj),qrlp(2,mj),kx,drkp(m),dsc
C
  436 ENDDO                        !END 1-BODY LOOP OVER LOWER JP LEVELS
C
  834 IF(BEQGRP)THEN            !PICK-UP OTHER HALF
        IF(BING)THEN
          BING=.FALSE.
          GO TO 430
        ELSE
          BING=.TRUE.
        ENDIF
      ENDIF
C
 8340 CONTINUE                  !END LOOP OVER UPPER CI JP LEVELS
C
 8334 NCJP=NCJP+NT(KK)
      ENDDO                     !END LOOP OVER "LOWER" JP GROUPS
C
C END M1BP AND MK>1
C
C**********************************************************************
C
C END LOOPS OVER EK, MK CONNECTION TO UPPER ENERGY LEVELS
C
C**********************************************************************
C
 450  CONTINUE
c
          if(btime)then
            call cpu_time(timefr)
            timer1=timer1+timefr-timeir
            timeir=timefr
          endif
C
C *********************************************
C
C START LOOP OVER LOWER ENERGY LEVELS (EK & MK)
C
C**********************************************
C
      SUMRN(0)=DZERO
      SUMRD(0)=DZERO
      IF(NMM.GT.0)THEN
        NMM=NMM0
        IF(NMETAPJ.GT.0)NMM=MIN(NMM,JRP(IIMX))
        DO K=1,NMM
          SUMRN(K)=DZERO
          SUMRD(K)=DZERO
        ENDDO
      ENDIF
C
      IF(BUNPR.AND.NFK(IT).LT.0)THEN
        I3P=ABS(IWRK3(I))
        IF(I3P.NE.JPOLD)THEN                   !NEW UPPER PI STATE
          DO M8=1,MENG
            SUMPN(M8,0)=DZERO
            SUMPD(M8,0)=DZERO
          ENDDO
          DO K=1,NMM
            DO M8=1,MENG
              SUMPN(M8,K)=DZERO
              SUMPD(M8,K)=DZERO
            ENDDO
          ENDDO
          IF(BUNA)JPOLD=I3P                    !SUM OVER NMETA CONT
        ENDIF
      ENDIF
C
      ILI=0
      DO 733 JAB=IIMN,IIMX
C
      IF(.NOT.BAUX.AND.JORIG(JAB).LT.0)GO TO 733
      IF(JORIG(JAB).GT.0)THEN
        ILI=ILI+1
        IF(KTRAN.GE.0)KTRAN=KTRAN+1
      ENDIF
      J=ABS(JORIG(JAB))
      IF(IWRK4(J).GT.0)GO TO 733
      IF(ABS(MENGB).EQ.1.AND.MOD(NGROUP,ITWO).EQ.1)THEN
        IX=IROW(ILI,ILF,ione1,NSPECE)
        IF(OMR(IX).LT.-TOLO)GO TO 733   !****DIPOLE ALREADY COMPUTED****
      ENDIF
      ITP=NRR(J)
c      if(dvecl(j).eq.dzero)
c     x write(133,*)NFK(IT),iab,i,' - ',nfk(itp),jab,j
C
      IF(IDIAG.GE.0.AND.BDEL)THEN
        MRD=0
        I5=0
        M3=NFK(IT)
        M3=ABS(M3)
        M4=NFK(ITP)
        DO I3=1,MXORB
          I4=NEL(I3,M3)-NEL(I3,M4)
          IF(I4.NE.0)THEN
            I5=I5+1
            MRDP=MRD
            MRD=ABS(QN(I3))
            ISGN=1-2*mod(abs(I5),ITWO)             !(-1)**I5
            IF(ISGN.GT.0.AND.ABS(MRD-MRDP).GE.MDEL)GO TO 693
          ENDIF
        ENDDO
        GO TO 733
  693   CONTINUE
      ENDIF
C
C START LOOP (L1,L2) OVER LOWER ENERGY LEVEL MIXING
C
      DLEN=DZERO                                !EK_L
      DVEL=DZERO                                !EK_V OR MK0
      DMK1=DZERO                                !MK1
      IF(.NOT.BFOTJ.AND.NFK(IT).LT.0)THEN       !PHOTO
        DO M8=1,MENG
          DFOT(M8)=DZERO
          DFOTm(M8)=DZERO
        ENDDO
      ENDIF
C
      II=NFQ(ITP)
      MNSP=QSI(II)
      MNLP=QLI(II)
      DZ8=JN(J)+1
      NN=NGR(J)
c
c e-vector storage posn
C
      if(bkutls)then                      !could do better...?
        l1=jwrkg(nn-1)+jwrkb(1,nfk(itp),nn)
        l2=l1+jwrkb(2,nfk(itp),nn)
      else
        L1=JWRKG(NN-1)
        L2=JWRKG(NN)
      endif
      M0=L2-L1
C
      N1=NADRUJ(J)                               !START OF MIXING VECTOR
C
      IF(BFAST)THEN
        IF(BFOTJ.OR.NFK(IT).GT.0)THEN
CL          IF(LAPAK.GT.0)THEN                                   !LAPACK
CL            DLEN=DDOT(M0,TFUJ(N1+1),IONE,DVECL(L1+1),IONE)     !LAPACK
CL          ELSE                                                 !LAPACK
            DO M=1,M0
              DLEN=DLEN+TFUJ(N1+M)*DVECL(L1+M)
            ENDDO
CL          ENDIF                                                !LAPACK
        ELSE
CL          IF(LAPAK.GT.0)THEN                                   !LAPACK
CL            DLEN=DDOT(M0,TFUJ(N1+1),IONE,DVECL(L1+1),IONE)     !LAPACK
CL            DO M8=1,MENG                                       !LAPACK
CL          DFOT(M8)=DDOT(M0,TFUJ(N1+1),IONE,DVECF(L1+1,M8),IONE)!LAPACK
CL              IF(NGROUP.GT.1)                                  !LAPACK
CL     X   DFOTM(M8)=DDOT(M0,TFUJ(N1+1),IONE,DVECM(L1+1,M8),IONE)!LAPACK
CL            ENDDO                                              !LAPACK
CL          ELSE                                                 !LAPACK
            DO M=1,M0
              DLEN=DLEN+TFUJ(N1+M)*DVECL(L1+M)
            ENDDO
            DO M8=1,MENG
              DO M=1,M0
                DFOT(M8)=DFOT(M8)+TFUJ(N1+M)*DVECF(L1+M,M8)
              ENDDO
              IF(NGROUP.GT.1)THEN
                DO M=1,M0
                  DFOTM(M8)=DFOTM(M8)+TFUJ(N1+M)*DVECM(L1+M,M8)
                ENDDO
              ENDIF
            ENDDO
CL          ENDIF                                                !LAPACK
        ENDIF
      ELSE
        IF(BBORN)THEN                            !BORN
          DO K=1,MB3(0)
            SBL(K)=DZERO
          ENDDO
        ENDIF
        L1=L1+1
        DO L=L1,L2
          N1=N1+1                               !NADRUJ(J)+NAJ(L)
          DD2=TFUJ(N1)
          IF(ABS(DD2).LT.CMXICR)GO TO 735
          IF(.NOT.BJSEL)THEN !LS SELECTION RULES IMPOSED ON CI
            lb=iwrkj(l)                         !lb=l mode.ne.2
            LSL=NRR(lb)
            IB=NFQ(LSL)
            MQSP=QSI(IB)
            MQLP=QLI(IB)
            IF(MQLP.NE.MNLP)GO TO 735
            IF(MQSP.NE.MNSP)GO TO 735
          ENDIF
          DLEN=DLEN+DD2*DVECL(L)
          DVEL=DVEL+DD2*DVECV(L)
          DMK1=DMK1+DD2*DVECA(L)
          IF(BBORN)THEN                          !BORN
            IBO=ID(L)
            IF(IBO.GT.0)THEN
              DO M=1,MB3(0)
                SBL(M)=SBL(M)+DD2*DBL(M,IBO)
              ENDDO
            ENDIF
          ENDIF
          IF(.NOT.BFOTJ.AND.NFK(IT).LT.0)THEN    !PHOTO
            DO M8=1,MENG
C              DFOT(M8)=DFOT(M8)+DD2*DVECF(M8,L)
              DFOT(M8)=DFOT(M8)+DD2*DVECF(L,M8)
            ENDDO
            IF(NGROUP.GT.1)THEN
              DO M8=1,MENG
C                DFOTm(M8)=DFOTm(M8)+DD2*DVECM(M8,L)   !merge with ek?
                DFOTm(M8)=DFOTm(M8)+DD2*DVECM(L,M8)   !merge with ek?
              ENDDO
            ENDIF
          ENDIF
  735   ENDDO
      ENDIF
C
C END LOOP OVER LOWER LEVEL MIXING
C
c      if(dlen.eq.dzero)write(134,*)NFK(IT),iab,i,' - ',nfk(itp),jab,j
      OBOX=DZERO
      IF(MENGB.EQ.-1.AND.ABS(DLEN).GT.WLGO)OBOX=D1P30
      IF(NGROUP.EQ.0)DLEN=DZERO
      IF(NGROUP.GT.0.AND.ABS(DLEN).LT.DEPS
     X              .AND.ABS(DMK1).LT.DEPS.and.nfk(it).gt.0)GO TO 733
C
C BORN MULTIPOLES
C
      IF(BBORN)THEN     !BORN
        DO IE=1,MENGB
          OBO(IE)=DZERO
        ENDDO
        OMG1=DZERO
        DLAM=2*NGROUP+1
        NH=NGROUP/2
        DO N=1,MB4(0)
          L=INDL(N)
          K=INDK(N)
          SSB=SBL(K)*SBL(L)
          IF(ABS(SSB).GT.STOL)THEN
            DO IE=1,MENGB
              DB=SSB*BL(IE,N,NH)
c              if(db.ne.dzero)iflagb(n)=abs(iflagb(n))   !flag used
              OBO(IE)=OBO(IE)+DB+DB
              IF(L.EQ.K)OBO(IE)=OBO(IE)-DB
            ENDDO
            IF(NGROUP.EQ.1)THEN
              DB=SSB*TM2(N)
              OMG1=OMG1+DB+DB
              IF(L.EQ.K)OMG1=OMG1-DB
            ENDIF
          ENDIF
        ENDDO
        DB=DEIGHT*DLAM
        DO IE=1,MENGB
          OBO(IE)=DB*OBO(IE)
        ENDDO
        OBOX=OBO(MINFB)
        OMG1=DB*OMG1
      ENDIF
C
C ELECTRIC AND MAGNETIC MULTIPOLES
C
      JOS=JOS+1
      DRY=DENERG(I)-DENERG(J)
      IF(DRY.EQ.DZERO)then
        if(iab.ne.jab.and.mengb.lt.-1)GO TO 733   !CASE M1/E2 DEGENERATE
        dry=d1m10
      endif
c
      IF(NFK(IT).LT.0)DRY=DRY+DYY(NREL)
      DRY=DRY+DRY
      MI=IAB
      MJ=JAB
      IF(NFK(IT).LT.0)MI=-MI
C     IF(NFK(ITP).LT.0)MJ=-MJ
      MWJ=JN(J)+1
      MWI=JN(I)+1
      MBCOR=MBLK
      IF(JORIG(IAB).LT.0.OR.JORIG(JAB).LT.0)MBCOR=MCOR
      WLG=ABS(WLG)
      IF(NFK(IT).LT.0)WLG=-WLG
C      ISGNJ=1-2*mod(abs((JN(I)-JN(J))/2),2)   !(-1)**((JN(I)-JN(J))/2)
C      ISGN=ISGNJ                                !SWITCH DOWN TO UP ON F
C      IF(BFANO)ISGN=ISGN*ISGNN
      ISGN=1                                     !ALL DOWN
      DB=ISGN*(DRY*DFSC)**(MLAM-1)/DFSC
      if(db.eq.dzero)then                        !avoids overflow*zero
        dlen=dzero
        dvel=dzero
        dmk1=dzero
      endif
      SEK=ABS(DLEN)*DLEN                             !SEK_L
      GFL=DG(NGROUP)*DB*SEK                          !GF_L
      IF(NFK(IT).GT.0)AEK=C1*GFL*DRY*DRY/DZ9         !AEK
      IF(NFK(IT).LT.0)AEK=C2*GFL/DZ8
      WLEN=D1P8/(DRY*DKCM)                           !WAVELENGTH(A)
C
      IF(NGROUP.GT.1.AND.BMPRNT)THEN                 !MAGNETIC
        IF(BEKVEL)THEN
          SMK0=DZERO                                 !SMK0
          GFV=DG(NGROUP)*DB*ABS(DVEL)*DVEL/(DRY*DRY) !GF_V
          GFLV=GFV
        ELSE
          SMK0=ABS(DVEL)*DVEL                        !SMK0
          GFLV=GFL
        ENDIF
        SMK1=ABS(DMK1)*DMK1                          !SMK1
        AMK=DG(NGROUP-1)*ABS(SMK1)*DB/4
        if(ngroup.eq.2.and..not.bborn)then           !lande
          if(iab.eq.jab.and.jn(i).ne.0)then
            t=jn(i)*(jn(i)+2)*(jn(i)+1)
            glande=abs(dmk1)*dtwo/sqrt(t)
          else
            glande=dzero
          endif
          obox=glande                                !print transfer
        endif
      ELSE
        IF(NGROUP.GT.1.AND..NOT.BMPRNT)THEN
          SMK=ABS(DMK1)*DMK1                         !SMK
          AMK=DG(NGROUP-1)*ABS(SMK)*DB/4
        ELSE
          AMK=DZERO
        ENDIF                                        !omit dry if orb de
        GFV=DG(NGROUP)*DB*ABS(DVEL)*DVEL/(DRY*DRY)   !GF_V
        FAB=DTEN**MP*GFL/DZ8                         !F(UP)_L
        FEM=DTEN**MP*GFL/DZ9                         !F(DOWN)_L
      ENDIF
      IF(NFK(IT).GT.0)AMK=C1*AMK/DZ9                 !AMK
      IF(NFK(IT).LT.0)AMK=C2*AMK/(DZ8*DRY*DRY)
C
C                Lt. for PI underflow at low-E (but not at high-E)
      IF(AEK*AEK.Lt.ABS(AEK)*WLG.AND.ABS(OBOX).LT.WLGO
     X                          .AND.GFL*GFL.LT.WLGS
     X                          .AND.AMK*AMK.Lt.ABS(AMK)*WLG)GO TO 733
C                but amk=0 for E1, so no drop. need to add .and.wlg.gt.0
C
      IF(.NOT.BELONG.AND.ABS(AEK).GT.WLG)THEN        !USE VEL AEK,SEK
        AEK=GFV*AEK/GFL
        SEK=GFV*SEK/GFL
      ENDIF
C
      IF(NGROUP.EQ.1)THEN
        APOL=DFOUR*ABS(FAB)/(DRY*DRY)            !POLARIZABILITY (a_0^3)
        IF(.NOT.BELONG)APOL=APOL*ABS(GFV/GFL)
        OMG=DFOUR*GFL/DRY
        IF(ABS(MENGB).EQ.1)THEN
          OMGINF=-ABS(OMG)
          OMG=OMG*LOG(EINF*DZ2)
          OMG=-ABS(OMG)                             !TAG DIPOLE NEGATIVE
          IF(OMG.GE.-TOLO)OMG=DZERO          !ZERO VANISHINGLY SMALL CPT
        ELSEIF(MENGB.GT.1)THEN
          OMG=-ABS(OMG)                              !4S/3
          if(nmetaj.eq.0)nmetaj=iimx                 !pwb
        ENDIF
        if(idw.eq.0)then
          if(nmetaj.eq.0)nmetaj=nenerg               !for RM
        else
          if(nmetaj.eq.0)nmetaj=iimx
        endif
      ELSE
        APOL=OBOX                                    !COPY BORN IN
        OMG=OBOX
        IF(OMG.LT.DZERO)OMG=D1M30                    !keep non-negative
        OMGINF=OMG
      ENDIF
C
C DETERMINE BORN OMEGAS
C
      BPRNTO=.FALSE.
      IF(MPOL00.EQ.0.AND.MBCOR.EQ.MBLK)THEN   !MPOL0 CATCHES E1
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY BORN ONLY
          BPRNTO=.TRUE.
          IXC=ICOL(ILI,ILF,ione1)
          IF(IXC.LE.NOMWRX)OMC(IXC)=OMC(IXC)+OMG
          IXR=IROW(ILI,ILF,ione1,NSPECE)
          IF(IXR.LE.NOMWRX)OMR(IXR)=OMR(IXR)+OMG
          OMEGAB(MXNXB1)=OMGINF
        ELSEIF(MENGB.GT.1)THEN                              !FINITE BORN
          IF(ABS(OBO(MINFB)).GT.WLGO)THEN
            BPRNTO=.TRUE.
            CALL BRNINT(BPRNT0,NLAGB,MXNXB,MV0,MV1,DRY,V0,V1,XB,XS
     X                 ,DB0,DB1,OMG1,OBO,OMEGAB)
            OMEGAB(MXNXB1)=OMG                       !INFINITE ENERGY
c            if(nlagb.lt.0)go to 3000                !brnint failure
          ELSEIF(ABS(AMK).GT.WLG)THEN                !ONLY M_K HERE
            BPRNTO=.TRUE.
            DO K=1,MXNXB1
              OMEGAB(K)=DZERO
            ENDDO
          ENDIF
        ENDIF
      ENDIF
C
C OUTPUT ELECTRIC AND MAGNETIC MULTIPOLE DATA.
C
c          aek=dzero                          !***test output mk only***
c          amk=dzero                          !***test output ek only***
      IF(BPRNT0)THEN
        IF(NGROUP.GT.1.AND.BMPRNT)
     X    WRITE(6,710)JOS,MBCOR,MI,MJ,AEK,AMK,SEK,SMK1,SMK0,GFLV,WLEN
     X               ,OBOX
        IF(NGROUP.LT.2.OR..NOT.BMPRNT)
     X    WRITE(6,709)JOS,MBCOR,MI,MJ,AEK,SEK,GFL,FAB,FEM,WLEN,GFV,APOL
      ENDIF
      IF(BPRNTO)THEN
        T=ABS(AEK)+ABS(AMK)
        IF(BSCRO)THEN
          WRITE(MSC)MI,MJ,T,(OMEGAB(K),K=1,MXNXB1)
        ELSE
          OMEGA(0,KTRAN)=OMEGA(0,KTRAN)+REAL(T,RP)
          T=REAL(OMEGA(MXNXB1,KTRAN),WP)
          KMX=MXNXB1
          IF(MOD(NGROUP,ITWO).EQ.1.AND.T.LT.-TOLO)KMX=MXNXB  !OLD DIPOLE
          DO K=1,KMX
            OMEGA(K,KTRAN)=OMEGA(K,KTRAN)+REAL(OMEGAB(K),RP)
          ENDDO
        ENDIF
      ENDIF
C
      IF(MODE.LT.1)GO TO 429
      DB=DENERG(J)+DENERG(J)+DEM
      IF(NFK(IT)*NFK(ITP).LT.0)GO TO 335
C
      IF(JAB.LE.JLOWMX.AND.DB.LE.etest .AND.
     X                     IHARRY(NFK(ITP)).LE.NRSLMX)THEN     !RESOLVED
        IF(NGROUP.GT.1)AEK=ABS(AEK)+ABS(AMK)                !OUT MK + EK
        IF(ABS(AEK).LT.WLG)GO TO 733
        IF(BPRNT0)WRITE(MW,501)NFK(IT),I,MWI,NFK(ITP),J,MWJ,AEK,DRY,DB
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(IT)),int(I),int(MWI)
     X                         ,int(NFK(ITP)),int(J),int(MWJ),AEK,DRY,DB
      ELSEIF(BUNR)THEN                                          !BUNDLED
        T=ABS(AEK)+ABS(AMK)
        IF(BDOWN)THEN                           !USED BY ADASDR & ADASPE
          M=0
          IF(NFK(ITP).LE.-NRSLMX)M=NFK(ITP)
        ELSE                                    !NOT USED BY PP'S....
          T=T*MWI
          T=T/MWJ
          M=JAB
        ENDIF
        IF(DB.LT.EIONMN)THEN
          SUMRN(M)=SUMRN(M)+T
        ELSE
          SUMRD(M)=SUMRD(M)+T
        ENDIF
      ENDIF
      GO TO 429
C
  335 IF(BFOTJ)GO TO 733
      DTEST=ABS(DFOT(MENG))
      IF(NGROUP.GT.1)DTEST=DTEST+ABS(DFOTm(MENG))
      IF(DTEST.EQ.DZERO)GO TO 733
C
C N.B. SIGN OF REDUCED MATRIX ELEMENT IS FOR DOWNWARD TRANSITION.
C TO GET SIGN FOR UPWARD TRANSITION, UNCOMMENT NEXT DO-LOOP.
C      DO  M8=1,MENG
C        DFOT(M8)=DFOT(M8)*ISGN
C        IF(NGROUP.GT.1)THEN
C          DFOTm(M8)=DFOTm(M8)*ISGN
C        ENDIF
C      ENDDO
C
      DC0=C2*DG(NGROUP)/(DZ8*DFSC)
      T=DENERG(I)-DENERG(J)
      DO M8=1,MENG
        DRY=T+DYY(M8)
        DRY=DRY+DRY
        T1=DRY*DFSC
        TT=T1**NGROUP
        TT=TT*DFOT(M8)
        DFOT(M8)=DC0*TT*ABS(TT)/T1
        IF(BPRNT0.AND.ABS(DFOT(M8)).LT.D1M99)DFOT(M8)=DZERO
ctest
c      dfot(m8)=0     !***** LOOK AT MAGNETIC OUTPUT  ONLY *****
ctest
      ENDDO
      IF(NGROUP.GT.1)THEN
        DC0=C2*DG(NGROUP-1)*DFSC/(4*DZ8)
        DO M8=1,MENG
          DRY=T+DYY(M8)
          DRY=DRY+DRY
          T1=DRY*DFSC
          TT=T1**NGROUP
          TT=TT*DFOTm(M8)
          DFOTm(M8)=DC0*TT*ABS(TT)/T1**3
          IF(BPRNT0.AND.ABS(DFOTm(M8)).LT.D1M99)DFOTm(M8)=DZERO
ctest
c      dfotm(m8)=0     !***** LOOK AT ELECTRIC OUTPUT  ONLY *****
ctest
        ENDDO
      ENDIF
C
C AEK IS GIVEN BY RADIATIVE IGAUGE, DFOT IS GIVEN BY PI GAUGE.
C
      IF(JAB.LE.JLOWMX.AND.DB.LE.etest .AND.IWRK2(I).LE.JIMXIC
     X                .AND.IHARRY(NFK(ITP)).LE.-NMM)THEN       !RESOLVED
        DRY=DENERG(I)+DENERG(I)+DEM
        IF(NGROUP.GT.1)THEN                                 !OUT MK + EK
          AEK=ABS(AEK)+ABS(AMK)
          DO M8=1,MENG
            DFOT(M8)=ABS(DFOT(M8))+ABS(DFOTm(M8))
          ENDDO
        ENDIF
        IF(BPRNT0)THEN
          WRITE(MWW,501)NFK(ITP),J,MWJ,NFK(IT),I,IWRK2(I),AEK,DB,DRY
          WRITE(MWW,515)(DFOT(M8),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(NFK(ITP)),int(J),int(MWJ),int(NFK(IT)),
     X                             int(I),int(IWRK2(I)),AEK,DB,DRY
          WRITE(MWWU)(DFOT(M8),M8=1,MENG)
        ENDIF
      ELSEIF(BUNPR)THEN                                         !BUNDLED
        DO M8=1,MENG
          DFOT(M8)=ABS(DFOT(M8))
        ENDDO
        IF(NGROUP.GT.1)THEN                                 !OUT MK + EK
          DO M8=1,MENG
            DFOT(M8)=DFOT(M8)+ABS(DFOTm(M8))
          ENDDO
        ENDIF
        IF(BDOWN)THEN                              !AS RESOLVED PI IS UP
          M=0
          IF(NFK(ITP).LE.-NRSLMX)M=NFK(ITP)
          TW=MWJ
          TWW=DALF4*TW/MWI
          DO M8=1,MENG
            DRY=T+DYY(M8)
            DRY=DRY+DRY
            DFOT(M8)=DFOT(M8)*DRY*DRY*TWW
          ENDDO
        ELSE                                    !AS ONLY CONT IS BUNDLED
          M=JRP(JAB)
        ENDIF
        IF(DB.LT.EIONMN)THEN
          DO M8=1,MENG
            SUMPN(M8,M)=SUMPN(M8,M)+DFOT(M8)
          ENDDO
        ELSE
          DO M8=1,MENG
            SUMPD(M8,M)=SUMPD(M8,M)+DFOT(M8)
          ENDDO
        ENDIF
      ENDIF
      GO TO 733
C
C SET UP ARRAY CONTAINING DIPOLE TRANSITION RATES FOR USE BY CASC
C
  429 IF(BCASC)THEN
        NTRAN=NTRAN+1
        IF(NTRAN.GT.IXNOR)THEN
            IXXX=7*(IXNOR/5+1)
C
            WRITE(6,*)'*** DIAGFS: increasing MXNOR from ',IXNOR,' to: '
     X                ,IXXX
            WRITE(0,*)'*** DIAGFS: increasing MXNOR from ',IXNOR,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(AP,IONE,IXNOR,IXXX,IERR)
            CALL RE_ALLOC(MADD,IZERO,IXNOR,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'DIAGFS: REALLOCATION FAILS FOR AP,MADD'
              NF=0
              GO TO 7450
            ENDIF
            IXNOR=IXXX
        ENDIF
        AP(NTRAN)=ABS(AEK)
        MADD(NTRAN)=(IAB-1)*NENERG+JAB-1
      ENDIF
C
C
  733 CONTINUE                               !END LOOP OVER LOWER LEVELS
C
      IF(ALLOCATED(DBL))DEALLOCATE (DBL,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'SR.DIAGFS: DE-ALLOCATION FAILS FOR DBL'
        NF=0
        GO TO 7450
      ENDIF
c
          if(btime)then
            call cpu_time(timefr)
            timer2=timer2+timefr-timeir
          endif
C
C                                                           !UNRESOLVED
      WLG=ABS(WLG)
      IF(SUMRN(0).GT.WLG)THEN
        IF(BPRNT0)WRITE(MW,501)NFK(IT),I,MWI,IZERO,IZERO,IZERO,
     X                         SUMRN(0),DZERO,DEM
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(IT)),int(I),int(MWI),int(IZERO)
     X                         ,int(IZERO),int(IZERO),SUMRN(0),DZERO,DEM
      ENDIF
      IF(SUMRD(0).GT.WLG)THEN
        IF(BPRNT0)WRITE(MW,501)NFK(IT),I,MWI,IZERO,IZERO,IZERO,
     X                         SUMRD(0),DZERO,DZERO
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(IT)),int(I),int(MWI),int(IZERO)
     X                       ,int(IZERO),int(IZERO),SUMRD(0),DZERO,DZERO
      ENDIF
C                                                           !CF RESOLVED
      DO M=1,NMM
        IF(SUMRN(M).GT.WLG)THEN
          IF(BPRNT0)WRITE(MW,501)NFK(IT),I,MWI,JCP(M),JTP(M),JWRN(M),
     X                           SUMRN(M),DZERO,ERN(M)
          IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(IT)),int(I),int(MWI)
     X       ,int(JCP(M)),int(JTP(M)),int(JWRN(M)),SUMRN(M),DZERO,ERN(M)
        ENDIF
        IF(SUMRD(M).GT.WLG)THEN
          IF(BPRNT0)WRITE(MW,501)NFK(IT),I,MWI,JCP(M),JTP(M),JWRD(M),
     X                           SUMRD(M),DZERO,ERD(M)
          IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(IT)),int(I),int(MWI)
     X       ,int(JCP(M)),int(JTP(M)),int(JWRD(M)),SUMRD(M),DZERO,ERD(M)
        ENDIF
      ENDDO
C
      IF(.NOT.BUNPR.OR.NFK(IT).GT.0)GO TO 732
C
      IF(JPOLD.LE.0)THEN
        JP=I
      ELSE
        IF(IAB.LT.JJMX)THEN
          JP=ABS(JORIG(IAB+1))
          JPNEW=ABS(IWRK3(JP))
          IF(IWRK2(I).GT.JIMXIC)JPOLD=JPNEW
        ELSE
          JPNEW=-1
          IF(IWRK2(I).GT.JIMXIC)THEN
            JPOLD=NENERG+1
            jpt=NNRGLS+1
            nrr(JPOLD)=jpt
            NFK(jpt)=0
            IWRK2(JPOLD)=0
            DENERG(JPOLD)=DZERO
            DEM=DZERO
          ENDIF
        ENDIF
        IF(JPNEW.EQ.JPOLD)GO TO 732            !SUM OVER CONT DEGENERACY
        JP=JPOLD
      ENDIF
c
      jpt=nrr(jp)
C
      DRY=DENERG(JP)+DENERG(JP)+DEM
C                                                            !UNRESOLVED
      IF(SUMPN(1,0).GT.DZERO)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,501)IZERO,IZERO,IZERO,NFK(JPt),JP,IWRK2(JP)
     X                 ,DZERO,DEM,DRY
          WRITE(MWW,515)(SUMPN(M8,0),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO),int(NFK(JPt))
     X                         ,int(JP),int(IWRK2(JP)),DZERO,DEM,DRY
          WRITE(MWWU)(SUMPN(M8,0),M8=1,MENG)
        ENDIF
      ENDIF
      IF(SUMPD(1,0).GT.DZERO)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,501)IZERO,IZERO,IZERO,NFK(JPt),JP,IWRK2(JP)
     X                 ,DZERO,DZERO,DRY
          WRITE(MWW,515)(SUMPD(M8,0),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO),int(NFK(JPt))
     X                         ,int(JP),int(IWRK2(JP)),DZERO,DZERO,DRY
          WRITE(MWWU)(SUMPD(M8,0),M8=1,MENG)
        ENDIF
      ENDIF
C                                                               !BUNDLED
      DO M=1,NMM
        IF(SUMPN(1,M).GT.DZERO)THEN
          IF(BPRNT0)THEN
            WRITE(MWW,501)JCP(M),JTP(M),JWRN(M),NFK(JPt),JP,IWRK2(JP)
     X                   ,DZERO,ERN(M),DRY
            WRITE(MWW,515)(SUMPN(M8,M),M8=1,MENG)
          ELSE
            WRITE(MWWU)int(JCP(M)),int(JTP(M)),int(JWRN(M))
     X            ,int(NFK(JPt)),int(JP),int(IWRK2(JP)),DZERO,ERN(M),DRY
            WRITE(MWWU)(SUMPN(M8,M),M8=1,MENG)
          ENDIF
        ENDIF
        IF(SUMPD(1,M).GT.DZERO)THEN
          IF(BPRNT0)THEN
            WRITE(MWW,501)JCP(M),JTP(M),JWRD(M),NFK(JPt),JP,IWRK2(JP)
     X                   ,DZERO,ERD(M),DRY
            WRITE(MWW,515)(SUMPD(M8,M),M8=1,MENG)
          ELSE
            WRITE(MWWU)int(JCP(M)),int(JTP(M)),int(JWRD(M)),
     X             int(NFK(JPt)),int(JP),int(IWRK2(JP)),DZERO,ERD(M),DRY
            WRITE(MWWU)(SUMPD(M8,M),M8=1,MENG)
          ENDIF
        ENDIF
      ENDDO
C
C
  732 CONTINUE                               !END LOOP OVER UPPER LEVELS
C
C
c determine usage of Born integrals
c
c      if(bborn)then
c      nh=ngroup/2
c      icount=0
c      icountb=0
c      do i=1,mb4(0)
c      if(bl(i,nh).ne.dzero)then
c      nc=indl(i)
c      j=mb4(nc)
c      k=mb3(nc)
c      if(mod(ngroup,2).eq.mod((ql(j)+ql(k))/2,2))then
c      icount=icount+1
c      if(iflagb(i).gt.0)icountb=icountb+1
cc      write(777,6999)i,indl(i),iflagb(i),icountb
cc 6999 format(i7,i5,i3,i6)
c      endif
c      endif
c      enddo
c      p=icountb
c      if(icount.gt.0)p=100*p/icount
c      npp=nint(p)
c      write(0,*)'BORN INTEGRALS: CALC=',icount,'USED=',icountb,npp,'%'
c      write(6,777)icount,icountb,npp
c  777 FORMAT(/'BORN INTEGRALS: CALC=',I7,'  USED=',I7,I5,'%'/)
c      endif
C
C END MULTIPOLE LOOP OVER RADIATIVE TRANSITIONS
C
      IF(MLAM.LT.MPOLE)GO TO 737
C
      DEALLOCATE (DG)
c
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagfs:'                 !par
cpar          write(iwp,*)'    radiative time=',nint(times),'sec'   !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'radiative timer1=',nint(timer1),'sec'
          write(iw,*)'radiative timer2=',nint(timer2),'sec'
          write(iw,*)'radiative time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C WRITE AN ADF04 (AND, MAYBE, INFINITE ENERGY OMEGA) FILE
C
      IF(MENGB.GE.-1)THEN                   !BBORN
c
        if(btime)timei=timef
C
C WRITE DATA TO OMGINF FILE
C
        WRITE(6,*)' '
        WRITE(6,*)'IBOMX=',IBOMX
c        write(0,*)ibifmx,ibomx
C
        CALL DIMUSE('MXBIF',IBOMX)
c
        do j=jupe,1,-1                               !nenerg
          if(jorig(j).gt.0)go to 645
        enddo
        j=jupe                                       !shouldn't get here
  645   jupe=j
C
        IF(ABS(MENGB).EQ.1)THEN            !INF ENG BORN, ROW *AND* COL
C
          IF(MENGB.EQ.-1)THEN
            DO I=1,NOMWRT
              OMR(I)=MIN(OMR(I),D1P30)
              OMC(I)=MIN(OMC(I),D1P30)
            ENDDO
          ENDIF
C
          K=0
          DO J=1,jupe                       !NENERG
            I=JORIG(J)
            IF(I.GT.0)THEN
              K=K+1
              II=NFQ(NRR(I))
              IWRK3(K)=(JN(I)+1)*(1-QPI(II))
              DWRK(K)=DENERG(I)*DTWO/DZ2
            ENDIF
          ENDDO
C
          IF(K.NE.NSPECE)THEN
            WRITE(6,*)'DIAGFS: ENERGY MISMATCH',K,NSPECE     !,jupe
            WRITE(0,*)'DIAGFS: ENERGY MISMATCH'
            GO TO 3000
          ENDIF
c
          if(nmetaj.eq.0)nmetaj=nspece                       !case no E1
          if(nmetaj.lt.nspece)then
            ixr=irow(nmetaj,nspece,ione1,nspece)
            if(ixr.lt.nomwrt)nomwrt=ixr
            ixc=icol(nmetaj,nspece,ione1)
          else
            ixc=nomwrt
          endif
          if(nmetj0.eq.0)nmetaj=-nmetaj
C
          WRITE(24,*)NZION,MION
          WRITE(24,*)NSPECE,ABS(MENGB),NOMWRT
          WRITE(24,*)('  0',IWRK3(I),I=1,NSPECE)
          WRITE(24,711)(DWRK(I),I=1,NSPECE)
          WRITE(24,713)EINF,(OMR(I),I=1,NOMWRT)
C
          IF(IDW.EQ.0)THEN                           !COLUMNWISE AS WELL
            NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
            if(ixc.lt.nomwrt)nomwrt=ixc
C
            WRITE(24,*)NZION,MION
            WRITE(24,*)NSPECE,ABS(MENGB),-NOMWRT
            WRITE(24,*)('  0',IWRK3(I),I=1,NSPECE)
            WRITE(24,711)(DWRK(I),I=1,NSPECE)
            WRITE(24,713)EINF,(OMC(I),I=1,NOMWRT)
          ENDIF
C
        ENDIF                                 !SUM BORN MULTIPOLES
C
C WRITE DATA TO ADF04 FILE
C
        BEXP=.FALSE.                          !TRUE=1.0E+0, FALSE=1.0+0
        IF(NSPECE.LT.1000)THEN
          i1=0
          IF(BEXP)THEN
            F761='(F5.2,4X,"1", 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
          ENDIF
        ELSE
          i1=1
          IF(BEXP)THEN
            F761='(F5.2,4X,"1",10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
          ENDIF
        ENDIF
C
       if(ieq(0).ne.0)then
C
        WRITE(26,F542)-1               !OLD TERMINATOR
c
       else
c                                      !now write orbital energy in s.o.
        cardx=' '
        cardx(4:5)='-1'
        orbfmt='(1x,f7.?)'
c
c truncate to spectroscopic orbitals
        if(bort)then
          isob=0
          inx=0
          do i=1,mxorb
            if(dey(i).ne.dzero)then
              if(dadjus(i).lt.dzero)go to 646
              isob=i
              in=abs(qn(i))
              inx=max(inx,in)
            endif
          enddo
        else
          isob=mxorb
          inx=abs(qn(isob))
        endif
c re-map
 646    isox=0
        inx=(inx*(inx+1))/2
c
        allocate (isorb(0:inx))
c
        do i=1,inx
          isorb(i)=0
        enddo
        do i=1,isob
          in=abs(qn(i))
          il=ql(i)/2
          iso=(in*(in-1))/2+il+1
c          if(iso.le.maxgr)
          isorb(iso)=i
          isox=max(isox,iso)
        enddo
c
c        if(isox.gt.maxgr)then
c          write(6,*)'***sr.diagfs: maxgr buffer too short, need ',isox
c          isox=-maxgr
c        endif
        is=9+2*i1
        ie=is+abs(isox)*8
        if(ie.gt.mxlenx)then!note, >200(=7d) not passed by dwxbp,adasexj
          write(6,*)'***sr.diagfs: cardx too short, need mxlenx=',ie
          isox=-(mxlenx-is)/8
        endif
        if(isox.lt.0)then
          write(6,*)'***adf04ic note: truncated orbital energy list'
c          write(0,*)'***adf04ic note: truncated orbital energy list'
          isox=-isox
        endif
c print
        do ix=1,isox
          ie=is+7
          i=isorb(ix)
          t=dzero
          if(i.gt.0)then                !break into two for bounds check
            if(dey(i).ne.dzero)then
              t=dey(i)-duy(i,i)
              if(bmvd)t=t+dmass(i,i)+dcd(i,i)
              t=-2*t
            endif
          endif
          write(orbfmt(8:8),'(i1)')
     x          max(2,5-max(0,int(log10(max(t,d1m30)))))
          write(cardx(is:ie),orbfmt)t
          is=ie+1
        enddo
c
        orbfmt=' '
        orbfmt(1:7)='(a    )'
        write(orbfmt(3:6),'(i4)')ie
        write(26,orbfmt)cardx(1:ie)
c
        deallocate (isorb)
c
       endif
C
        IF(BEXP)THEN
          WRITE(26,F761)REAL(NZA),(XB(K),K=1,MXNXB)
        ELSE
          MSCP=MSC+1
          OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
          WRITE(MSCP,764)(XB(K),K=1,MXNXB)
          BACKSPACE(MSCP)
          READ(MSCP,765)(XMANT(K),IEXP(K),K=1,MXNXB)
          WRITE(26,F761)REAL(NZA),(XMANT(K),IEXP(K),K=1,MXNXB)
        ENDIF
C
        DO M=MSC0,MSC                     !RE-POINT BORN MULTIPOLE FILES
          REWIND(M)
        ENDDO
C
        IOLD=JJMN               !1+ione1
        JOLD=IIMN               !1
C
        if(nenerg-ione1.eq.0)go to 373
c
        if(jorig(iold).lt.0.or.jorig(jold).lt.0)then
          write(6,*)'Lowest two levels cannot be correlation!'
          write(0,*)'Lowest two levels cannot be correlation!'
          go to 3000
        endif
        INEW=IOLD                         !FIRST 2 LEVELS CANNOT BE CORR
        JNEW=JOLD
        KTRAN=0
C
  371   IF(BSCRO)THEN
C
          BBORN=.FALSE.
          DO K=0,MXNXB1
            OMEGAB(K)=DZERO
          ENDDO
C
          IP=JORIG(IOLD)
          IP=NFQ(NRR(IP))
          IP=QPI(IP)
          JP=JORIG(JOLD)
          JP=NFQ(NRR(JP))
          JP=QPI(JP)
          IF(IP.NE.JP)THEN
            MMN=MSC0+1                      !ODD MULTIPOLES
            MMX=MSC+MOD(MSC,ITWO)-1
          ELSE
            MMN=MSC0
            MMX=MSC-MOD(MSC,ITWO)
          ENDIF
C
          IFLAGO=999
          DO M=MMN,MMX,2
            READ(M,END=370,ERR=370)I,J,(XS(K),K=0,MXNXB1)
            IF(I.GT.IOLD.OR.J.GT.JOLD)THEN
              BACKSPACE(M)
              GO TO 370
            ELSE
              if(jold.gt.iimx)then
                if(nmetj0.eq.0)then
                  go to 370          !unfortunate interchange of i,j use
                else
                  stop '370'
                endif
              endif
              BBORN=.TRUE.
              KMX=MXNXB1
              IF(IP.NE.JP)THEN
                LAM=MOD(M,I80)
                IF(LAM.EQ.1.AND.ABS(XS(MXNXB1)).GT.TOLO)IFLAGO=1 !E1 LIM
                IF(LAM.GT.IFLAGO)KMX=MXNXB     !DON'T OVERWRITE E1 LIMIT
              ENDIF
              DO K=0,KMX
                OMEGAB(K)=OMEGAB(K)+XS(K)
              ENDDO
            ENDIF
  370     ENDDO
C
        ELSE
          KTRAN=KTRAN+1
          DO K=0,MXNXB1
            OMEGAB(K)=REAL(OMEGA(K,KTRAN),WP)
          ENDDO
        ENDIF
C
        IF(BBORN)THEN
          DO K=0,MXNXB
            OMEGAB(K)=ABS(OMEGAB(K))
            IF(OMEGAB(K).LT.D1M99)OMEGAB(K)=DZERO
          ENDDO
          IF(OMEGAB(0).LT.D1M30)OMEGAB(0)=D1M30
          IF(OMEGAB(MXNXB1).GT.D1P30)OMEGAB(MXNXB1)=D1P30
          IF(BEXP)THEN
            WRITE(26,F762)INEW,JNEW,(OMEGAB(K),K=0,MXNXB1) !IOLD,JOLD
          ELSE
            BACKSPACE(MSCP)
            WRITE(MSCP,764)(OMEGAB(K),K=0,MXNXB1)
            BACKSPACE(MSCP)
            READ(MSCP,765)(XMANT(K),IEXP(K),K=0,MXNXB1)
            WRITE(26,F762)INEW,JNEW
     X                  ,(XMANT(K),IEXP(K),K=0,MXNXB1)     !IOLD,JOLD
          ENDIF
        ENDIF
C
  373   JOLD=JOLD+1
        IF(JOLD.Gt.IOLD-ione1.or.JOLD.GT.IIMX.and.nmetj0.ne.0)THEN
  372     IOLD=IOLD+1
          IF(IOLD.GT.jupe)THEN           !NENERG              !TERMINATE
            WRITE(26,F762)-1
            WRITE(26,F762)-1,-1
           if(.not.badas)then                       !adas skip comments
            WRITE(26,758)
            NREC=1
  121       NREC=NREC+1
            BACKSPACE(5)
            BACKSPACE(5)
            READ(5,766)CARD4
            IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
            REWIND(5)
            DO N=1,NREC
              READ(5,760)CARD
              WRITE(26,759)CARD
            ENDDO
            DATE='        '
            CALL DATE_AND_TIME(DATE)
            WRITE(26,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X                  ,DATE(3:3),DATE(4:4)
           endif
            DO M=MSC0,MSC
              CLOSE(M)
            ENDDO
            IF(.NOT.BEXP)CLOSE(MSCP)
          ELSE
            IF(JORIG(IOLD).LT.0)GO TO 372
            JOLD=IIMN          !1
            JNEW=IIMN          !1
            INEW=INEW+1
            GO TO 371
          ENDIF
        ELSE
          IF(JORIG(JOLD).LT.0)GO TO 373
          JNEW=JNEW+1
          GO TO 371
        ENDIF
c
        if(btime)then
          call cpu_time(timef)
          timew=timef-timei
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'proc',iam,' for diagfs:'               !par
cpar            write(iwp,*)'    radiative time=',nint(times),'sec' !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
            write(iw,*)'adf04/omginf time=',nint(timew),'sec'
cpar          endif                                                 !par
        endif
C
      ENDIF                               !END ADF04/OMGINF WRITES
C
C CHECK TO SEE IF SIZE OF ARRAYS MADD AND AP HAS BEEN EXCEEDED
C (TBD: COULD STORE NTRAN IN MADD(0) THEN USE AP(IXNOR), MADD(IXNOR) AS
C       "NORMAL".)
C
      IF(NTRAN.GT.0.AND.MOD(ABS(MPNCH),IFOUR)/2.EQ.1)THEN
        IF(NTRAN.LE.IXNOR)THEN
          MADD(0)=NTRAN
        ELSE                              !SHOULD NOT HAPPEN NOW
          WRITE(6,3449)NTRAN
          WRITE(0,*)'***SR.DIAGFS: CASCADE DIMENSION MXNOR EXCEEDED'
          GO TO 3000
        ENDIF
        CALL DIMUSE('MXNOR',NTRAN+1)
      ENDIF
C
C DE-ALLOCATE
C
 7450 CONTINUE
C
      IF(BOMRC)THEN
        DEALLOCATE (OMR,OMC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR OMR,OMC'
          NF=MIN(NF,IZERO)
        ENDIF
        BOMRC=.FALSE.
      ENDIF
C
      IF(ALLOCATED(IDY))THEN
        DEALLOCATE (IDY,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR IDY'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(ALLOCATED(OMEGA))THEN
        DEALLOCATE (OMEGA,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR OMEGA'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(.NOT.BFOTJ.AND.ALLOCATED(DVECF))THEN
        DEALLOCATE (DVECF,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR DVECF'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(.NOT.BFOTJ.AND.ALLOCATED(DVECM))THEN
        DEALLOCATE (DVECM,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR DVECM'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(BPOS)THEN
        DEALLOCATE (NPOS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR NPOS'
          NF=MIN(NF,IZERO)
        ENDIF
        BPOS=.FALSE.
      ENDIF
C
      IF(NF.LE.0)GO TO 7500                                      !RETURN
C
C UPDATE FUNCTIONAL (RE-ENTRY POINT IF NO RADIATION)
C
  745 DRY=DFFS
      IF(IOPTIM.EQ.0)DRY=DRY+DECORE
      DRY=DRY*DTWO
      IF(BPRNT0)WRITE(6,999)INCLUD,DRY,JPRINT  !.AND.INCLUD.NE.0
C
C FINISH-UP
C
 7500 NL=NL0                                                    !RESTORE
C
      IF(ALLOCATED(TFUJ))THEN
        DEALLOCATE (TFUJ,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGFS: DE-ALLOCATION FAILS FOR TFUJ'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
C LOCAL DEALLOCATE
C
      IF(ALLOCATED(IHARRY))THEN
        DEALLOCATE (IHARRY,E1BCF,SUMA)
      ENDIF
      IF(ALLOCATED(DENERG))THEN
        DEALLOCATE (DENERG,IWRK2,ID,NADRUJ,NAJ,DVECL,DVECV,DVECA)
      ENDIF
      IF(ALLOCATED(ETM))THEN
        DEALLOCATE (ETM,WGT)
      ENDIF
      IF(ALLOCATED(DWRK))THEN
        DEALLOCATE (DWRK,IWRK3,IWRK4)
      ENDIF
      IF(ALLOCATED(JCP))THEN
        DEALLOCATE (JCP,JTP,JWRN,JWRD,ERN,ERD)
      ENDIF
      IF(ALLOCATED(JRP))DEALLOCATE (JRP)
      IF(ALLOCATED(SUMRN))THEN
        DEALLOCATE (SUMRN,SUMRD)
      ENDIF
      IF(ALLOCATED(SUMPN))THEN
        DEALLOCATE (SUMPN,SUMPD)
      ENDIF
      if(allocated(iwrkj))then
        deallocate (iwrkj)
      endif
      if(allocated(jwrkb))then
        deallocate (jwrkb)
      endif
      if(allocated(jwrkg))then
        deallocate (jwrkg,NGRPJ)
      endif
      IF(ALLOCATED(ITMP))DEALLOCATE (ITMP)
C
C WRITE TERMINATORS
C
      IF(.NOT.BMODE)THEN
        IF(BPRNT0)WRITE(MW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWU)int(IZERO),int(IZERO),int(IZERO)
     X    ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
      IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)WRITE(MWW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO)
     X     ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
C
C CLOSE SOME FILES
C
      IF(IUNIT(22).GT.1)THEN
        CLOSE(22)
        IUNIT(22)=-1
      ENDIF
      IF(IUNIT(24).GT.1)THEN                  !so par scratch not closed
        CLOSE(24)
        IUNIT(24)=-1
      ENDIF
      IF(IUNIT(26).GT.1)THEN
        CLOSE(26)
        IUNIT(26)=-1
      ENDIF
C
C
      RETURN
C
C
 2000 IF(NF.GT.0)NF=-1
      GO TO 7600                                            !DE-ALLOCATE
C
 3000 IF(NF.GT.0)NF=-1
      GO TO 7450                                            !DE-ALLOCATE
C
C DIMENSION EXCEEDED, ABORT.
C
  106 WRITE(6,108)MC,MAXJU
      WRITE(0,*)'SR.DIAGFS: DIMENSION EXCEEDED'
      GO TO 2000
  190 WRITE(6,980)MAXDK,NCJ,MAXJU,MLAM
      WRITE(0,*)'SR.DIAGFS: DIMENSION EXCEEDED'
      GO TO 2000
C
C***********************************************************************
C
  108 FORMAT(/' SR.DIAGFS WILL NOT COMPUTE RADIATIVE TRANSITION'
     X,' PROBABILITIES BECAUSE IT REQUIRES',I9,'.GT.MAXJU=',I9
     X,' FOR ARRAY TFUJ')
  110 FORMAT(//  ' *****WARNING*****--- IF SR. DIAGFS HAS PUNCHED TERM'
     X,' COUPLING COEFFICIENTS, THE SET WILL BE INCOMPLETE'/ ' BECAUSE'
     X,' NOT ENOUGH STORAGE WAS ALLOWED FOR STORING TRANSFORMATION'
     X,' COEFFICIENTS IN DIAGON :  INCREASE MAXUC')
  180 FORMAT(//5X,'ZETA(   A    B ) = SPIN-ORBIT PARAMETERS')
  181 FORMAT(I5,4X,2I5,8X,E14.7)
  183 FORMAT(I5,I4,4I3,F14.5,F14.6,I3,I4,10F8.4)
  184 FORMAT((56X,10F8.4))
  185 FORMAT('2J P',2X,' S L',3X,'CF',3X,'NI',7X,'ENERGY(RYD)')
  200 FORMAT(/  ' ONE-BODY RELATIVISTIC INTEGRALS'/ ' I(R)  I(  A,  C )'
     X,' = ',6X,'MASS',9X,'DARWIN',24X,'<P**2>')
  201 FORMAT(I5,3X,2I4,3X,2F14.7,16X,F14.7)
  301 FORMAT(22X,'2MXLBD=',I3)
 3449 FORMAT(/5X,10('*'), ' IF YOU REQUIRE CASCADE COEFFICIENTS AUGMENT'
     X,' MXNOR TO A VALUE GREATER THAN',I8)
  400 FORMAT(//'   LV   T 2J 2S+1L  P',5X,'H(ZZ)/2RY EIGEN-HBP/2RY CF '
     X,' NO',8X,'TF-MATRIX AND HZ/2RY-TRIANGLE      E(CORE)/2RY=',F10.5
     X,F11.4)
  501 FORMAT(    6I5,1PE15.5   ,2(0PF15.6))
  502 FORMAT(11X,I4,2I5,1PE15.3,   2(0PF15.4))
  503 FORMAT(60X,F15.6)
  504 FORMAT(4X,'NA',8X,'W',3X,'LV',2X,'LVP',8X,'AA*SEC',6X
     X,'ECONT(A.U)',7X,'E-I(A.U)')
  505 FORMAT(8X,'I-S',12X,'C-S',11X,'AUTO-IONIZATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',3X,'LV',4X,'W',3X,'CF',3X,'LV',4X,'W',6X
     X,'AA*SEC',9X,'E-C(RYD)',6X,'E-I(RYD)')
  506 FORMAT(5I5,4X,'X',1PE15.5,2(0PF15.6))
  507 FORMAT(I3,'CFIC',2X,'G',3X,'Z=',I2,4X,'N=',I2,2X,'NL',62(I3,I2))
  508 FORMAT(8X,'I-S',12X,'G-S',15X,'RADIATIVE DATA',9X,'Z=',I2,3X,'N='
     X,I2/3X,'CF',3X,'LV',4X,'W',3X,'CF',3X,'LV',4X,'W',6X,'AR*SEC', 9X
     X,'DEL(RYD)',6X,'E-G(RYD)')
  509 FORMAT('+',67X, '(AA DATA INCLUDES TERM/LEVEL ENERGY CORRECTION)')
  510 FORMAT(3X,'NLEVEL=',I5,39X,'E1/RY=',F15.6/4X,'K',3X,'LV',4X,'T'
     X,' 2S+1',4X,'L',3X,'2J',3X,'CF',5X,'(EK-E1)/RY')
  511 FORMAT(7I5,F15.6,I10)
  512 FORMAT(A2)
  513 FORMAT(8X,'I-S',12X,'C-S',7X,'PHOTO-RECOMBINATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',3X,'LV',4X,'W',3X,'CF',3X,'LV',3X,'EO',6X
     X,' P/CM2',9X,'E-I(RYD)',6X,'E-C(RYD)')
  514 FORMAT(I3,' E(RYD) ',2X,'Z=',I2,4X,'N=',I2,5X, 'Intermediate-'
     X,'Coupling',1X,'EIONMIN=',F15.6)
  515 FORMAT(5(1PE15.5))
  516 FORMAT(8X,'I-S',12X,'C-S',10X,'PHOTO-IONIZATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',3X,'LV',4X,'W',3X,'CF',3X,'LV',3X,'EO',6X
     X,' P/CM2',9X,'E-I(RYD)',6X,'E-C(RYD)')
  517 FORMAT(2I5,4X,I1,I2,1X,10(I2,A1))
  536 FORMAT('*** SR.DIAGFS: INCREASE INTERNAL DIMENSION MXSTRG TO',I3)
  537 FORMAT(' &ADASEX NLEVS= XXX',' &END')                    !,I4
  540 FORMAT('NAME:'/'DATE:'/'.')
  541 FORMAT(A2,'+',I2,2I10,F15.4,A4)
  600 FORMAT(7X,'E',I1,'-DATA',3X,'K  KP',11X,'A(EK)*SEC'
     X,11X,'S',15X,'G*F',10X,'F(ABS)   -F(EMI)',4X,'WAVEL/AE'
     X,6X,'GF(VEL)',6X,'ALPHA(POL)')
  601 FORMAT(6X,'E',I2,'-DATA',3X,'K  KP',11X,'A(EK)*SEC'
     X,11X,'S',15X,'G*F',10X,'F(ABS)   -F(EMI)',4X,'WAVEL/AE'
     X,6X,'GF(VEL)',6X,'ALPHA(POL)')
  610 FORMAT(34X,'VELOCITY',7X,'VELOCITY',74X,'VELOCITY')
  640 FORMAT(' RESTARTED FROM K=',I5,3X,'LV=',I5)
  650 FORMAT(4X,'E',I1,'/M',I1,'-DATA',3X,'K  KP',11X,'A(EK)*SEC'
     X,6X,'A(MK)*SEC',A4,7X,'SE',11X,'SM',11X,'SM0'
     X,12X,'G*F',6X,'WAVEL/AE',4X,A9)
  651 FORMAT(2X,'E',I2,'/M',I2,'-DATA',3X,'K  KP',11X,'A(EK)*SEC'
     X,6X,'A(MK)*SEC',A4,7X,'SE',11X,'SM',11X,'SM0'
     X,12X,'G*F',6X,'WAVEL/AE',4X,A9)
  660 FORMAT(7X,'E',I1,'-DATA',3X,'K  KP',11X,'A(EK)*SEC',11X,'S'
     X,15X,'G*F',3X,'10**',I1,'* ','F(ABS)   -F(EMI)',4X,'WAVEL/AE'
     X,6X,'GF(VEL)',7X,'OMG(BORN)')
  661 FORMAT(6X,'E',I2,'-DATA',3X,'K  KP',11X,'A(EK)*SEC',11X,'S'
     X,15X,'G*F',3X,'10**',I1,'* ','F(ABS)   -F(EMI)',4X,'WAVEL/AE'
     X,6X,'GF(VEL)',7X,'OMG(BORN)')
  709 FORMAT(I9,A4,I5,I4,5X,1PE15.3,5X,0PF10.6,3X,1PE15.3,3X
     X,2(0PF10.5),2X,F11.4,3X,1PE10.2,3X,E12.3)
  710 FORMAT(I9,A4,I5,I4,5X,2(1PE15.3),4X,3E13.3,E15.3,0PF11.2,1PE13.3)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
 7393 FORMAT(/' *****WARNING*****  IF SR.DIAGFS HAS PUNCHED TERM '
     X,'COUPLING COEFFICIENTS THE SET WILL BE INCOMPLETE,'/20X
     X,'BECAUSE MAXTR.GE.',I9,'  IS REQUIRED')
 7395 FORMAT(' NO TERM-COUPLING COEFFICIENTS CALCULATED BECAUSE OF '
     X,'INCORRECT CHOICE OF MOD : CHOOSE MOD =0 OR -1')
  740 FORMAT(41X,2I5,4(I5,F12.8))
  741 FORMAT((51X,4(I5,F12.8)))
  742 FORMAT(43X,'....',9X,I3,I5,12X,'HEADING CARD FOR TERM COUPLING '
     X,'COEFFICIENTS'/(43X,'...',5(2I3,F9.6)))
  743 FORMAT(5X,2I5,5X,"TCC'S BASED ON FANO-AS","  Z =",I3,",  N =",I3)
  744 FORMAT(5X,2I5,5X,"TCC'S BASED ON C&S -AS","  Z =",I3,",  N =",I3)
  746 FORMAT(40X,'HEADING CARD FOR TERM COUPLING COEFFICIENTS')
  750 FORMAT(2I5,4(I5,F18.14))
  751 FORMAT((10X,4(I5,F18.14)))
  752 FORMAT(/'  RECOUPLING MATRIX: ROWS ARE J LEVELS, COLUMNS ARE'
     X,' LS TERMS'//' LEVEL   #         LS TERM #S/COEFFICIENTS')
  753 FORMAT(5(I3,I2,F9.6))
  754 FORMAT(1P,(4(2I4,E12.4E1)))
  755 FORMAT(/'*** TCC WARNING: HIGHEST SPECTROSCOPIC TERM BELOW'
     X,' ALL CORRELATION IS AT ',I5,' BUT THERE ARE',I5,' OTHERS HIGHER'
     X)
  756 FORMAT(3I7,F16.7,I15,I7)
  757 FORMAT(/I5,' J LEVELS',I5//'  LEVEL     2J     PI     ENERGY(RYD)'
     X,'  ORIG. LEVEL # TERM #')
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE PLANE-WAVE BORN'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  801 FORMAT(34X,'VELOCITY',24X,'VELOCITY',33X,'VELOCITY')
  802 FORMAT(34X,'VELOCITY',7X,'VELOCITY')
  891 FORMAT(/' GAM  ONE-BODY MASS-VELOCITY INTEGRALS')
  892 FORMAT(/' GAM  ONE-BODY DARWIN INTEGRALS')
  893 FORMAT(/' GAM  ONE-BODY <P**2> INTEGRALS')
  895 FORMAT(1X,I3,9F14.7/(4X,9F14.7))
  896 FORMAT('*****STORAGE EXCEEDED IN SR.DIAGFS, INCREASE MXAAK TO',I9)
  897 FORMAT(I6)
  898 FORMAT(' ',I9,' USED, MXAAK=',I9)
  899 FORMAT(7X,3I5,F14.6,3X,2F12.6,F13.7,20X,F12.6)
  900 FORMAT(//9X,'ONE-BODY RELATIVISTIC CORRECTIONS TO INDIVIDUAL '
     X,'ORBITALS IN UNITS OF 2*RY',35X,'IC.JPRINT =',I4
     X/9X,'GAM    N    L    E(NON.REL)',8X,'E(MASS)',6X,'E(DAR)'
     X,7X,'E(TOT)',23X,'<P**2/RY>')
  901 FORMAT(' PLUS CORE CONTRIBUTION',F13.4,2X,F12.5,9X,'RELATIVISTIC'
     X,' CORE CONTRIBUTION ALONE' ,F13.4)
  936 FORMAT(' ******WARNING LS SELECTION RULES APPLIED TO RADIATIVE'
     X,' TRANSITIONS IN SR.DIAGFS'/)
  980 FORMAT(/' SR.DIAGFS:  IF MAXDK=',I5,'.LT.',I5,' INCREASE'
     X,' MAXDK'/' *********   IF MAXJU=',I9,'.LT.',I9
     X,' INCREASE  MAXJU')
  989 FORMAT(//'*** ATTN: BECAUSE BORN MULTIPOLES ARE BEING COMPUTED'
     X,' FOR NON-E1 TRANSITIONS, RADIATIVE DATA IS NOT COMPUTED FOR'
     X,' THOSE E3/M2 ETC TRANSITIONS'/10X,'FOR WHICH E1 DATA ALREADY'
     X,' EXISTS (SO AS NOT TO OVERWRITE THE E1-LIMIT)'/)
  990 FORMAT(I11,2I10,F13.0,I7,3I5,A4,I2,F13.8,27X,F15.8,2X,F15.8)
  991 FORMAT(/' LIST OF TERMS WITH A WEIGHTED MEAN OVER THE FINE '
     X,'STRUCTURE'        /9X,'I',8X,' T',8X,'K*CM',2X, '2S+1 L   CF',5X
     X,'WEIGHTS',8X,  '(EI-E1)/RY     E1/RY =',F13.6,3X,A10,I5,1X,A8)
  992 FORMAT(2I2,1X,I3,I2,2I5,F18.8,3X,A4)
  993 FORMAT(/' *** WORKING ARRAYS TOO SMALL IN SR.DIAGFS, INCREASE'
     X,' MXAAK TO:',I9/' *** OR REDUCE NUMBER OF SPECTROSCOPIC TERMS')
  994 FORMAT(96X,I5,F10.0,F11.6)
  995 FORMAT(2I10,F13.0,I5,I2,I5,A4,F8.3,F18.6,24X,2F14.6)
  996 FORMAT(//9X,' K',8X,'LV',8X,' T',8X,'K*CM',5X,'2*S+1  L   2J   CF'
     X,4X,A2,3X,'(EK-E1)/RY     E1/RY =',F15.8,5X,A10,I5,4X,A8)
  997 FORMAT(I11,2I10,F13.0,I7,3I5,A4,F15.8,27X,F15.8,2X,F15.8)
 1997 FORMAT(I11,2I10,F13.0,I7,3I5,A4,F15.8,I10)
  998 FORMAT(' ',98X,'LEVEL ENERGY CORRECTION')
  999 FORMAT(//9X,'INCLUD =',I5,9X, 'FUNCTIONAL F =',1PE14.7
     X        ,9X, 'IC.JPRINT=',I2//)
 1137 FORMAT('SR.DIAGFS: ALLOCATION INCREASES NO. OF BORN INTERACTIONS'
     X       ,'IXBIF=',I10,' .GT. MXBIF=',I10)
 1605 FORMAT('*** SR.DIAGFS: COULD ACCESS MEMORY FASTER IF MXD30=',I7)
 3005 FORMAT (/25X,' Q.E.D. CONTRIBUTIONS /2RY'/8X,'  GAM    N    L'
     X,3X,'VACUUM POLARIZ.',6X,'SELF ENERGY',9X,'TOTAL')
 3010 FORMAT(8X,3I5,3(2X,F15.7),2F10.5)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION ICOL(ILI,ILF,IONE1)
C
      ICOL=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      END FUNCTION ICOL
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DIAGFS
C
C                             *******************
C
      SUBROUTINE DIAGON(DECORE,DF)
C
C-----------------------------------------------------------------------
C
C            N.R. BADNELL  D.A.M.T.P.  CAMBRIDGE
C
C  SR.DIAGON CALCULATES TERM ENERGIES AND DATA FOR ELECTRIC RADIATIVE
C  TRANSITIONS.
C  IT ALSO CALCULATES LS COUPLING AUTOIONIZATION RATES AND PHOTO-
C  IONIZATION CROSS SECTIONS - SEE ALSO NOTES IN SR.RADCON.
C
C  IT CALLS:
C    SR.BRNINT
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.DIMUSE
C    SR.HDIAG
C    SR.HPSRTI
C    SR.LAGINT
C    SR.RKINT
C    SR.SLATR
C    SR.WEDDLE
C
C  IT CONTAINS:
C    FN.ICOL
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CACC,   ONLY: ACC
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD,n8
      USE COMMON_INTS,   ONLY: DRL,DOSC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_TRANS,  ONLY: TFU,IAXUC
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBEKP, ONLY: NED
      USE COMMON_NRBIAD, ONLY: IADD
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
      USE COMMON_NRBNF2, ONLY: DETA,DXSI,DZL,DXTWO
      USE COMMON_NRBNFI, ONLY: DZLI,DXTWOI,DETAI,FRI,GRI
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
      USE COMMON_NRBORN, ONLY: BL,OBO,TM2,IXBLM
      USE COMMON_NRBRN1, ONLY: SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK,IXD33
      USE COMMON_NRBRN2, ONLY: BINDB,MENGB
      USE COMMON_NRBRN3, ONLY: V0,V1,XB,XS,DB0,DB1,OMEGAB
     X                        ,MV0,MV1,MINFB,MXNXB,MXNXB1,NLAGB
     X                        ,IEXP,XMANT
      USE COMMON_NRBTS1, ONLY: DFOT,DFOSS,PMIN,NFOSS,IPIG,IGAG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLIT=62)
      PARAMETER (MXSTRG=32)                            !MAX STRING WRITE
      PARAMETER (MSTRGH=16)                          !SHORT STRING WRITE
      PARAMETER (MXLAB1=29)                                    !0:MXLAB1
      PARAMETER (MXLAB2=29)                                    !0:MXLAB2
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
      parameter (mxlenx=2000)                               !card length
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
C
      PARAMETER (D0PT9=0.9D0)
      PARAMETER (D1PT1=1.1D0)
COLD      PARAMETER (D1PT5=1.5D0)
      PARAMETER (DKON=1.653656D17)
      PARAMETER (C1=DFSC**3/HBAR)
      PARAMETER (C2=2.567895D-18)    !4*pi*a_0**2*alpha
C      PARAMETER (C3=C2/DTHREE)
      PARAMETER (EINF=1.0D6)
C
      PARAMETER (MW=7)               !INITIALIZE UNIT NOS
      PARAMETER (MWW=MW+10)
      PARAMETER (MWU=MW+20)
      PARAMETER (MWWU=MWU+2)
C
      INTEGER QLB,LIT     !HISTORIC DEFAULT KIND TO SYNC WITH POST PROCS
C
      REAL(RP) OMEGA
C
      CHARACTER(LEN=1) BIGL,NUMB,STRING,CLIT,CMBLK1
CHAR  X,LIT,MBLK1  !USE OF CHAR REQUIRES CHANGES TO PP'S FOR UNFORM I/O
      CHARACTER(LEN=2) CELMNT,ELEM
      CHARACTER(LEN=4) MBCOR,MCOR,MSCOR,MBLK,CODE,MYRGE,LAB4,CARD4,MOUT
      CHARACTER(LEN=8) DATE
      character(len=9) orbfmt
      CHARACTER(LEN=24) MOBS
      character(len=31) ceiss,cstan
      CHARACTER(LEN=17) F762
      CHARACTER(LEN=29) F761
      character(len=51) f542,f543
      character(len=mxlenx) cardx
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: DU(:,:),NPOS(:,:),DUI(:,:),DVI(:,:),DDY(:)
     X              ,DVP(:),OMR(:),OMC(:),OMEGA(:,:)
     X              ,DE(:),IDY(:),DVU(:),NVEC(:)
     X              ,DVECF(:,:)
     X              ,ITMP(:)
     x              ,nadlu(:)
     x              ,ncf(:),iwrkb(:,:,:),kmap(:),iwrkn(:),iwrkg(:)
     x              ,isorb(:),iwrk1(:),decorn(:)
c
cbu      allocatable :: iflagb(:)                            !born usage
C
      ALLOCATABLE :: IHARRY(:),E1BCF(:),SUMA(:)
     X              ,JCP(:),JTP(:),JRP(:),JWRN(:),JWRD(:),ERN(:),ERD(:)
     X              ,SUMRN(:),SUMRD(:)
     X              ,SUMPN(:,:),SUMPD(:,:)
C
      ALLOCATABLE :: LMX(:),QSB(:,:),QLB(:,:),ICF(:),DG(:)
C
      ALLOCATABLE :: NCFBIG(:,:),NX1(:),LX1(:)
C
      ALLOCATABLE :: DENERG(:),IWRK2(:),ID(:),IORIG(:)
     X              ,DVECL(:),DVECV(:),DVECA(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
     X              ,IWRK5(:)
C
      DIMENSION BIGL(0:MXLAB1),NUMB(0:MXLAB2)
     X         ,STRING(MXSTRG),CLIT(MXLIT),LIT(MXLIT)
C
      COMMON /BASIC/NF,MGAP(10),IGAUGE
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCL0,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /TRANLS/NADRU(MAXTM),NAI(MAXTM),NC0,IEORD(MAXTM)
      COMMON /WEIGHT/WGHT(MAXTM),INDEXW(MAXTM)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBFAN/BFANO
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLIM/ECNTRA,JTANAL,BANAL(MAXCF) !ALGEB SO USE ONLY BANAL
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBRNG/DSTRNG(6,MAXGR)
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBTAR/ETAR(MAXTM),ISTAR(MAXTM),LTAR(MAXTM),JTAR(MAXTM)
     X              ,NTAR,IGAPE
      COMMON /NRBTCC/TOLTCC,KTCC,MTCC,NTCC,NENERG
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
      COMMON /PJSLIM/ECNTRB,ITANAL
C      COMMON /WORKLS/DWRK(MAXTM),IWRK3(MAXTM),IWRK4(MAXTM)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
      common /hps/badas
C
      DATA CMBLK1/' '/,MBLK/'    '/,MCOR/' COR'/,MSCOR/'*COR'/
     X    ,MOUT/'  X '/,BSCRO/.FALSE./
C
      DATA CLIT( 1),CLIT( 2),CLIT( 3),CLIT( 4)  /'1','2','3','4'/,
     X     CLIT( 5),CLIT( 6),CLIT( 7),CLIT( 8)  /'5','6','7','8'/,
     X     CLIT( 9),CLIT(10),CLIT(11),CLIT(12)  /'9','A','B','C'/,
     X     CLIT(13),CLIT(14),CLIT(15),CLIT(16)  /'D','E','F','G'/,
     X     CLIT(17),CLIT(18),CLIT(19),CLIT(20)  /'H','I','J','K'/,
     X     CLIT(21),CLIT(22),CLIT(23),CLIT(24)  /'L','M','N','O'/,
     X     CLIT(25),CLIT(26),CLIT(27),CLIT(28)  /'P','Q','R','S'/,
     X     CLIT(29),CLIT(30),CLIT(31),CLIT(32)  /'T','U','V','W'/,
     X     CLIT(33),CLIT(34),CLIT(35),CLIT(36)  /'X','Y','Z','a'/,
     X     CLIT(37),CLIT(38),CLIT(39),CLIT(40)  /'b','c','d','e'/,
     X     CLIT(41),CLIT(42),CLIT(43),CLIT(44)  /'f','g','h','i'/,
     X     CLIT(45),CLIT(46),CLIT(47),CLIT(48)  /'j','k','l','m'/,
     X     CLIT(49),CLIT(50),CLIT(51),CLIT(52)  /'n','o','p','q'/,
     X     CLIT(53),CLIT(54),CLIT(55),CLIT(56)  /'r','s','t','u'/,
     X     CLIT(57),CLIT(58),CLIT(59),CLIT(60)  /'v','w','x','y'/,
     X     CLIT(61),CLIT(62)  /'z','*'/
      DATA (BIGL(I),I=0,MXLAB1)/'S','P','D','F','G','H','I','K','L','M'
     X                         ,'N','O','P','Q','R','S','T','U','V','W'
     X                         ,'X','Y','Z','a','b','c','d','e','f','*'/
      DATA (NUMB(I),I=0,MXLAB2)/'0','1','2','3','4','5','6','7','8','9'
     X                         ,'A','B','C','D','E','F','G','H','I','J'
     X                         ,'K','L','M','N','O','P','Q','R','S','*'/
C      DATA (XB0(I),I=1,MXNXB)/1.001D0,1.1D0,1.2D0,1.3D0,1.55D0,2.D0
C     X   ,3.D0,5.5D0,1.D1,2.D1,3.D1,5.5D1,1.D2,2.D2,3.D2,5.5D2,1.D3/
C                                                               !17-vals
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DIAGON
c      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      IF(IEQ(0).NE.0)THEN
        ALLOCATE (ITMP(2*MXORB),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR ITMP'
          NF=0
          GO TO 750
        ENDIF
      ENDIF
C
C FIX FOR FORTRAN 90 COMPILERS THAT DON'T ALLOW ASSIGNMENT OF CHARACTERS
C TO INTEGER VARIABLES, REQUIRED FOR HISTORIC BACKWARDS COMPATIBILITY
C
      OPEN(80,STATUS='SCRATCH',FORM='FORMATTED')
      WRITE(80,1111)CMBLK1,(CLIT(I),I=1,MXLIT)
 1111 FORMAT(80A1)
      BACKSPACE(80)
      READ(80,1111)MBLK1,(LIT(I),I=1,MXLIT)
      CLOSE(80)
c
      if(btime)then
        btimet=.true.                            !.t. gives more details
        timefh=dzero
        timeh=dzero
        timea=dzero
        timea1=dzero
        timea2=dzero
        timer1=dzero
        timer2=dzero
      else
        btimet=.false.
      endif
C
C INITIALIZE LOGICALS ETC
C
      BCONT=MODE.EQ.2.OR.MODE.EQ.3                  !FOR BOUND-CONTINUUM
C
      BKUTLS=KUTLS.LT.0                           !.T. FOR SINGLE CF MIX
      bposu=.false.             !.T. uses new e-evec dui pos, old is sym
C
      BREL2=ABS(IREL).EQ.2                           !SMALL CPT PRESENT
      BDR=IDR.NE.0                                         !RYDBERG LOOP
      BBORN=MENGB.GE.0                                         !PWB DATA
C
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG                         !JUMP OVER PI
      IF(.NOT.BFOTJ.AND.PMIN.GT.DZERO)IPIG=1
C
      BNOAUG=.false. !NMETAP.GT.0                           !OMIT AUGERS
C                               !RESTRICT CAPTURES AND BUNDLE AUGER LOSS
      BUNA=EIMXLS.ne.DZERO.OR.NMETAP.GT.0
C
      IF(NMETAR.LT.0)THEN                             !RESOLVE BY CONFIG
        MMM=KMAX
      ELSE                                                   !UNRESOLVED
        MMM=0
      ENDIF
      TOLB2=TOLB/DTWO                                         !RYD->A.U.
C
      BUNR=NRSLMX.LT.0
     X .OR.NRSLMX.GE.0.AND.NNEW.GT.NRSLMX         !BUNDLE LOWER RAD RATE
C
      BUNPA=.NOT.BFOTJ.AND.BUNA                   !BUNDLE PI ELECTN CONT
      BUNPR=.NOT.BFOTJ.AND.(BUNR.OR.NMETAP.GT.0)  !BUNDLE PI PHOTON CONT
C
      BDOWN=NMETAP.LE.0                  !SO BUNDLED PI IS WEIGTHED DOWN
C
      BELONG=IGAUGE.EQ.0                 !IGAG(0)  !AEK/SEK LENGTH GAUGE
      BKUTOO=KUTOO.NE.0
COLD      BNJO=NJO.LE.0.AND.ISHFTLS.EQ.1    !ALLOWED PRIOR SHIFT IF TECS
C
      NPRNT5=MOD(NPRINT,IFIVE)
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
      BORT=MORT.LT.0                              !FOR EXPECTATION PRINT
      BCPRNT=(MOD(MPNCH,ITWO).NE.0)                         !PRINT TCC'S
C
      nmeta0=nmeta
COLD      MRP=MR+1                                  !UNIT NO OF TFU FILE
C
CL      LAPAK=1                                                  !LAPACK
C
C DETERMINE DIMENSIONS REQUIRED TO ALLOCATE
C (SEE ALGEB2 SET-UP.)
C
      ISXDI=1
      IAXDI=1
      IXAAI=0
      IAXUC=0
      NCI=0
      NCTOT=0
C
      IF(IDW.EQ.0.AND.NPRNT5.EQ.-2.AND.ISHFTLS.EQ.0.AND.
     X                 ITANAL.EQ.0.AND..NOT.BCPRNT)THEN
        IFLAG=-1
      ELSE
        IFLAG=1
      ENDIF
c local
      if(bkutls)allocate (iwrkn(kmax))
C
      DO KGROUP=1,NSL0
C
        NC=NSL(KGROUP)
        IAXDI=MAX(IAXDI,NC)
C
        N0=0
        NCC=0
C
       if(bkutls)then
c
        do k=1,kmax
          iwrkn(k)=0
        enddo
C
        DO J=1,NC
          I=NCI+J
          K=ABS(NFK(I))
          II=QCG(NF,K)
          ii=ieq(ii)
          IF(IYY(II).GT.0)then
            NCC=NCC+1
c          else
c            N0=N0+1
          endif
          iwrkn(k)=iwrkn(k)+1
        ENDDO
c
        ncft0=0
        ncft=0
        do k=1,kmax
          ncf0=iwrkn(k)
          isxdi=max(isxdi,ncf0)
          ncft=ncft+ncf0*ncf0
          if(.not.bfot)then
            II=QCG(NF,K)
            ii=ieq(ii)
            if(iyy(ii).lt.0)ncft0=ncft0+ncf0*ncf0
          endif
        enddo
c
        if(mode.eq.2)then
          if(bfot)then                          !need c-c e-vectors
            nctot=nctot+ncft
          else                                  !only b-b
            iaxuc=max(iaxuc,nctot+ncft)         !need buffer
            nctot=nctot+ncft0                   !so can overwite c-c
          endif
        else                                    !need full block
          if(mode.eq.4)then                     !bound only
            ncc=0
          endif
c          isxdi=iaxdi
          nctot=nctot+ncft
        endif
c
       else
c
        do i=1,mxorb
          ncc0(i)=0
        enddo
        mx0=mxorb+1
C
        DO J=1,NC
          I=NCI+J
          K=ABS(NFK(I))
          II=QCG(NF,K)
          ii=ieq(ii)
          IF(IYY(II).GT.0)then
            NCC=NCC+1
            ncc0(ii)=ncc0(ii)+1
            mx0=min(mx0,ii)
          else
            N0=N0+1
          endif
        ENDDO
C
        if(mode.eq.2)then
          isxdi=max(isxdi,n0)
          iorb(mx0-1)=n0*n0
          do i=mx0,mxorb
            n=ncc0(i)
            iorb(i)=iorb(i-1)+n*n
            isxdi=max(isxdi,n)
          enddo
c
          if(bfot)then                          !need c-c e-vectors
            nctot=nctot+iorb(mxorb)
          else                                  !only need b-b
            iaxuc=max(iaxuc,nctot+iorb(mxorb))  !but need c-c buffer
            nctot=nctot+n0*n0                   !so can overwite c-c
          endif
        else                                    !need full block
          if(mode.eq.4)then                     !bound only
            ncc=0
          endif
          isxdi=iaxdi
          NCTOT=NCTOT+NC*NC
        endif
c
       endif
C
        IXAAI=MAX(IXAAI,NCC*(NC-NCC))
        NCI=NCI+NC
C
      ENDDO
C
      IF(BNOAUG)IXAAI=0
c
c      write(0,*)ixaai,iaxuc
c      write(0,*)isxdi,iaxdi
C
      IF(IFLAG.LT.0)THEN
        if(mode.ne.2)IAXUC=IAXDI*IAXDI
      ELSE
        if(mode.ne.2.or.bfot)IAXUC=NCTOT
      ENDIF
c      write(0,*)nctot,iaxuc
C
      CALL DIMUSE('MAXUC',IAXUC)
      CALL DIMUSE('MAXDI',IAXDI)
      CALL DIMUSE('MXAAI',IXAAI)
C
C LOCAL (LARGE)
C
      BALLH=.FALSE.
      BALLA=.FALSE.
C
      ALLOCATE (DU(ISXDI,ISXDI)
     X         ,DVU(IAXDI),DE(IAXDI),IDY(IAXDI),NVEC(IAXDI)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR DU,DVU,DE,IDY,NVEC'
        NF=0
        GO TO 750
      ENDIF
      BALLH=.TRUE.
C
      IF(BPRNT0)THEN
        IM=(IAXDI*(IAXDI+1))/2
        ALLOCATE (DVP(IM),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR DVP'
          NF=0
          GO TO 7600
        ENDIF
      ENDIF
C
      ALLOCATE (TFU(IAXUC),STAT=IERR)                  !PASSED TO DIAGFS
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 7600                                               !RETURN
      ENDIF
      IAXUC=IFLAG*IAXUC
C
      IF(MENG*IXAAI.GT.0)THEN
C        ALLOCATE (DUI(MENG,IXAAI),DVI(MENG,IAXDI),STAT=IERR)
        ALLOCATE (DUI(IXAAI,MENG),DVI(IAXDI,MENG),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR DUI,DVI'
          NF=0
          GO TO 7600
        ENDIF
        BALLA=.TRUE.
        IF(BLAG)THEN
          ALLOCATE (DDY(MENG))
        ELSE
          ALLOCATE (DDY(1))
          DDY(1)=DONE
          NP1=1
          NP2=1
        ENDIF
      ENDIF
C
C LOCAL (SMALL)
C
      ALLOCATE (IHARRY(KMAX),E1BCF(KMAX),SUMA(0:MMM))
C
      ALLOCATE (LMX(KMAX),QSB(10,KMAX),QLB(10,KMAX),ICF(0:KMAX))
C
      NC1=NCI+1
      ALLOCATE (DENERG(NC1),IWRK2(NC1),ID(NCI),IORIG(NCI)
     X         ,DVECL(NCI),DVECV(NCI),DVECA(NCI))
C
      ALLOCATE (DWRK(NCI),IWRK3(NCI),IWRK4(NCI))
C
      allocate (iwrkg(0:nsl0))
c
      if(bcont)allocate (nadlu(iaxdi))
c
      if(bkutls)then
        allocate (iwrkb(2,kmax,nsl0),ncf(kmax),kmap(kmax),iwrk1(kmax))
      elseif(bcont)then
        allocate (iwrkn(mxorb))
      endif
c
      ngrp=1
      mxborb=0
      if(irlx.lt.0)then
        ngrp=-irlx/100000             !until /nrborb/ in a module
        mxborb=-irlx-100000*ngrp
      endif
      allocate (decorn(ngrp))
C
C SET-UP TCC'S
C
      MTCC=0
      NTCC=0
      IF(BCPRNT.AND.MPNCH.LT.0)THEN                         !AND TO DISC
        IF(KTCC.LT.0)THEN
          IF(IUNIT(1).LT.0)THEN
            WRITE(6,*)"TRYING TO RE-OPEN FILE='TCC.DAT'..."
            WRITE(0,*)'TRYING TO RE-OPEN UNIT=1'
            GO TO 2000
          ENDIF
          IUNIT(1)=1
          OPEN(1,FILE='TCC.DAT',STATUS='REPLACE')             !JAJOM
        ELSE
          IF(IUNIT(4).LT.0)THEN
            WRITE(6,*)"TRYING TO RE-OPEN FILE='TCCDW.DAT'..."
            WRITE(0,*)'TRYING TO RE-OPEN UNIT=4'
            GO TO 2000
          ENDIF
          IUNIT(4)=1
          OPEN(4,FILE='TCCDW.DAT',STATUS='REPLACE')           !STGICF
        ENDIF
      ENDIF
C
C RESET INCLUD IF IC OPTIMIZATION
C
      INCLUD=MOD(INCL0,I1000000)
      IF(NJO.GT.0)INCLUD=0
C
C SET CHARGES ETC.
C
      NZA=NZION-MION+1
      DZA2=NZA*NZA
      DZA=-NZA
c      DZM=-NZION
      DZ2=NZION-MION
      IF(NZION.EQ.MION)DZ2=DONE
      DZ2=DZ2*DZ2
      TSHFT=MSHIFT+MSHIFT
C
C RE-SCALE ONE-BODY TERMS INVOLVING RYDBERG ORBITAL IN DR OPERATION
C
      DSHFT0=DZERO
      IF(BJUMP2)THEN
        DO K=1,MXORB                    !1/N**3 SCALING
          IF(DEY(K).EQ.DZERO)GO TO 115
C         IF(K.LE.ABS(MPSEUD))GO TO 115
          IF(IVAL(K).NE.0)THEN
            TM=NNEW
            IF(KSHIFT.LE.0)TM=TM-SCREEN(K)                  !NEEDS Q.D.
            TN=DZA/TM
            TN=TN*TN                    !COULOMB
            IF(BREL)THEN
              T=DTWO*TM/(QL(K)+1)-DTHREE/DFOUR
              TMV=T*TN*TN               !M-V
              IF(QL(K).EQ.0)THEN        !DARWIN
                TT=dza/TM               !DZM->dza since large n
                TT=TT*TT
                TD=-TT*TT*TM
              ELSE
                TD=DZERO
              ENDIF
              T=(TMV+TD)*DFSC*DFSC
              if(tn+t.lt.dzero)t=dzero  !use non.rel.
              TN=TN+T
            ENDIF
            DSHIFT(K)=TN/DTWO
            DSHFT0=MAX(DSHFT0,DSHIFT(K))
            TN=NNOLD
            IF(KSHIFT.LE.0)TN=TN-SCREEN(K)                  !NEEDS Q.D.
            TN=TN/TM
            FACT(K)=TN**3
            DUY(K,K)=DUY(K,K)*FACT(K)
            DEY(K)=DUY(K,K)-DSHIFT(K)
            IF(KSHIFT.GT.0)DSHIFT(K)=DZERO
            IF(QED.LT.0.AND.IYY(K).LT.0)THEN
              VPINT(K)=FACT(K)*VPINT(K)
              SLFINT(K)=FACT(K)*SLFINT(K)
            ENDIF
            FACT(K)=SQRT(FACT(K))
          ENDIF
          IF(K.EQ.1)GO TO 115
          I=K-1
          DO J=1,I
            DUY(K,J)=DUY(K,J)*FACT(K)*FACT(J)
          ENDDO
          IF(BMVD)THEN
            DO J=1,K
              IF(DEY(J).NE.DZERO.AND.QL(K).EQ.QL(J))THEN
                DD=FACT(J)*FACT(K)
                DMASS(K,J)=DMASS(K,J)*DD
                DCD(K,J)=DCD(K,J)*DD
                D2LL(K,J)=D2LL(K,J)*DD
                IF(KUTOO.EQ.98)DXSI(K,J)=DXSI(K,J)*DD
              ENDIF
            ENDDO
          ENDIF
  115   ENDDO
        GO TO 114
      ELSEIF(NNEW.GE.NSW)THEN
        DO K=1,MXORB
          IF(IVAL(K).NE.0)DSHFT0=MAX(DSHFT0,DSHIFT(K))
        ENDDO
      ENDIF
C
C DETERMINE CONFIGURATION OVERLAP MATRIX
C (FOR USE WITH RELAXED ORBITALS, IRLX=2 ONLY.)
C
      IF(IRLX.EQ.2)THEN      !DETERMINE OVERLAPS BETWEEN CF'S
C
        ALLOCATE (IWRK5(NF))
C
        KK=0
        DO KF=2,KMAX
          DO KG=1,KF-1
            KK=KK+1
            DO I=1,NF
              IWRK5(I)=QCG(I,KG)
            ENDDO
            K=0
            OVL=DONE
            DO I=1,NF
              DO L=1,NF
                IF(IEQ(IWRK5(L)).EQ.IEQ(QCG(I,KF)))THEN
                  IWRK5(L)=0
                  I1=MIN(QCG(I,KF),QCG(L,KG))
                  I2=MAX(QCG(I,KF),QCG(L,KG))
                  II=((I2-1)*(I2-2))/2+I1
                  OVL=OVL*OVLPGR(II)
                  GO TO 51
                ENDIF
              ENDDO
              K=K+1
              IPAIR(KK)=K
              IF(K.GT.2)GO TO 52
  51        ENDDO
            OVLPCF(KK)=OVL
  52      ENDDO
        ENDDO
C
        DEALLOCATE (IWRK5)
C
        IF(BPRINT)THEN
          WRITE(6,768)(K,K=1,KMAX-1)
          K2=0
          DO KF=2,KMAX
            K1=K2+1
            K2=K2+KF-1
            WRITE(6,767)KF,(OVLPCF(K),K=K1,K2)
          ENDDO
        ENDIF
C
C MULTIPLY ONE-BODY INTEGRALS BY OVERLAPS
C
        DO J=2,MXORB
          KF=IGRCF(J)
          IF(DEY(J).EQ.DZERO.OR.KF.EQ.0)GO TO 78
          DO I=1,J-1
            KG=IGRCF(I)
            IF(DEY(I).EQ.DZERO.OR.KG.EQ.0)GO TO 77
            IF(BJUMP.AND.IVAL(I)+IVAL(J).EQ.0)GO TO 77
            IF(QL(I).NE.QL(J))GO TO 77
            IF(KF.NE.KG)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              IF(IPAIR(KK).EQ.1)THEN
                OVL=OVLPCF(KK)
                DUY(I,J)=DUY(I,J)*OVL
                DUY(J,I)=DUY(J,I)*OVL         !NEEDED?
                IF(BMVD.OR.NJO.GT.0)THEN
                  DMASS(I,J)=DMASS(I,J)*OVL
                  DCD(I,J)=DCD(I,J)*OVL
                  D2LL(I,J)=D2LL(I,J)*OVL
                  DMASS(J,I)=DMASS(J,I)*OVL   !DITTO
                  DCD(J,I)=DCD(J,I)*OVL
                  D2LL(J,I)=D2LL(J,I)*OVL
                ENDIF
              ENDIF
            ENDIF
   77     ENDDO
   78   ENDDO
C
      ENDIF
C
C GENERATE AND PRINT SOME EXPECTATION VALUES
C (NOT USED SUBSEQUENTLY, SO CAN SKIP IF PRINTING SUPPRESSED.)
C
  114 IF(.NOT.BPRNT0)GO TO 805
C
      IF(MGRP.GE.0)WRITE(6,200)MAXRS
      IF(MGRP.LT.0)WRITE(6,201)MAXRS
      L=MAXRS-2
C
      DO K=1,MXORB
C
        IF(DEY(K).EQ.DZERO)GO TO 816
C       IF(K.LE.ABS(MPSEUD))GO TO 816
        K17=K
        N1=QL(K)/2
        N3=N1
        IF(BORT)N3=K-1
        IF(BJUMP.AND.IVAL(K).EQ.0)GO TO 613
        DO J=1,6
          DSTRNG(J,K)=DZERO
        ENDDO
        DSTRNG(3,K)=-DUY(K,K)
        DSTRNG(1,K)=(DEY(K)+DSTRNG(3,K))*DTWO
        IF(.NOT.BDR)DSTRNG(1,K)=DSTRNG(1,K)+DTWO*DSHIFT(K)
        IF(MODE.LT.6.AND.QN(K).LT.0)GO TO 613    !MODE=1-4, CURRENTLY...
C
        DO J=2,6
          M=J-3
          IF(M.NE.0)THEN
            IF(BREL2)THEN
              DO I=1,MAXRS
                DD=DPNL(I,K)*DPNL(I,K)+DQNL(I,K)*DQNL(I,K)
                DPA(I)=DD*DX(I)**M
              ENDDO
            ELSE
              DO I=1,MAXRS
                DPA(I)=DPNL(I,K)*DPNL(I,K)*DX(I)**M
              ENDDO
            ENDIF
            CALL WEDDLE(DZERO,DPA,DC,MNH,DHNS,MJH,MAXRS)
            DSTRNG(J,K)=DC
          ENDIF
        ENDDO
C
  613   N2=JEND(N3+1)
        IF(N2.EQ.0)N2=MAXRS
C
        WRITE(6,250)K,QN(K),N1,MION,NZION,SCREEN(K),(DSTRNG(J,K),J=1,6),
     X              DADJUS(N3+1),DX(N2),(DPNL(I,K)*FACT(K),I=L,MAXRS)
C
  816 ENDDO
C
      WRITE(6,100)(DX(I),I=L,MAXRS)
C
C  DETAILED PRINTOUT OF MASS-VELOCITY PLUS DARWIN INTEGRALS
C (SKIPPED IF PRINTING SUPPRESSED.)
C
      IF(BMVD.AND.BPRNT0)THEN
        WRITE(6,900)JPRINT
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            DD1=DMASS(K,K)
            DD2=DCD(K,K)
            DD=DD1+DD2
            L=QL(K)/2
            WRITE(6,902)K,QN(K),L,DEY(K),DD1,DD2,DD,D2LL(K,K)
          ENDIF
        ENDDO
C
        WRITE(6,903)
        DO L=1,IRL
          IF(QRL(5,L).EQ.-1)THEN
            L1=QRL(1,L)
            L2=QRL(3,L)
            WRITE(6,904)L,L1,L2,DMASS(L1,L2),DCD(L1,L2),D2LL(L1,L2)
          ENDIF
        ENDDO
      ENDIF
C
C  DETAILED PRINTOUT OF ONE-BODY INTEGRALS I(A,C)
C
      IF(IRL.LT.0)THEN            !.LT.0 SUPRESSES PRINTOUT
        WRITE(6,701)
        DO K=1,K17
          I=K
          IF(DEY(K).EQ.DZERO)I=10000
          WRITE(6,702)I,(DUY(K,J),J=1,K)
        ENDDO
      ENDIF
C
C DETAILED PRINTOUT OF ANY QED CONTRIBUTIONS
C
      IF(QED.LT.0.AND.BPRNT0)THEN
        WRITE(6,3005)
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            IF(IYY(K).GT.0)GO TO 805                !WE ARE DONE
            DD=VPINT(K)+SLFINT(K)
            WRITE(6,3010)K,QN(K),QL(K)/2,VPINT(K),SLFINT(K),DD
          ENDIF
        ENDDO
      ENDIF
C
  805 CONTINUE
C----------------------------------------------------------
C  *** CALCULATE SLATER INTEGRALS:  DRL(L)  (AND 2-NFS) ***
C----------------------------------------------------------
C
            if(btimet)call cpu_time(timei)
c
      IF(IRL.GT.0)THEN
C
        CALL SLATR(BPRNT0)
C
        IF(NF.LE.0)GO TO 2000
      ENDIF
C
C
      IF(BPRNT0.AND.MAXLAM.NE.1000)WRITE(6,301)2*MAXLAM
C
      BRADAT=BPRINT.OR.JPRINT.EQ.3.AND.INCL0.EQ.0       !ORIGINAL INCLUD
      IF(.NOT.BPRINT)BRADAT=JPRINT.LT.0.AND.NPRNT5.GT.-2 !EVAL G FUNCTNL
C
      BTFU=BRADAT.OR.ISHFTLS.NE.0.OR.ITANAL.NE.0!ONLY PRINT CONTROL HERE
C
      IF(.NOT.BRADAT)GO TO 830
      IF(BJUMP.AND..NOT.BRAD)GO TO 830
C
C-----------------------------------------------------
C *** CALCULATE R^K MULTIPOLE INTERGALS (INC BORN) ***
C-----------------------------------------------------
C
      CALL RKINT(BPRNT0)
C
      IF(NF.LE.0)GO TO 2000
C
  830 CONTINUE
C
      if(btimet)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagon:'                 !par
cpar          write(iwp,*)'    integral time=',nint(times),'sec'    !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'integral time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C***********************************************************************
C
C  CONSTRUCT AND DIAGONALIZE ENERGY (SUB-)MATRICES.
C
C***********************************************************************
C
C
      IF(.NOT.BREL)GO TO 831                               !NPRINT.GT.-5
C
      if(brel)go to 831                                    !allow LSR
c
      IF(BPRNT0)WRITE(6,1000)NPRINT
      DF=DZERO
      DECORE=DZERO
      NC0=0
      DO K=1,NSL0
        NC=NSL(K)
        NC0=NC0+(NC*(NC+1))/2
      ENDDO
      NCOR=NC0                                       !HISTORIC MAX MAXUC
C
C N.B. MDEL.GE.0 FIXED NOW BACK IN SR.MINIM.
C
      IF(MDELE.EQ.0)GO TO 7500
      IF(MDELE.LT.0)THEN
        IF(BDR)THEN
          WRITE(6,1001)
C
C  IF REQUIRE THIS THEN NEED TO SET UP DISTINCT FILES FOR TFU AND THE
C  INTERPOLATION ORBITALS OF SR.RADCON.
C
          NF=-1
          GO TO 7500
        ENDIF
COLD        READ(MRP)TFU
        GO TO 7500
      ENDIF
      ISHFTLS=0
      GO TO 7500
C
  831 DO I=1,KMAX
        IHARRY(I)=0
      ENDDO
C
C  CALCULATE ENERGY CONTRIBUTION DECORE OF THE NW CORE ELECTRONS
C  (MAYBE GROUP DEPENDENT)
C
        do n=1,ngrp
c
          n1=n-1
          decor0=dzero
C
C 1-BODY (INC. NFS IF LSM/ICM)
C
      DC1=DZERO                                      ! 1-BODY
      DO L=1,NW
        J=NNL(L,1)            +mxborb*n1
        DC1=DC1+DEY(J)
        IF(BMVD)THEN
          DC1=DC1+DCD(J,J)+DMASS(J,J)
          IF(QED.LT.0)DC1=DC1+VPINT(J)+SLFINT(J)
          IF(KUTOO.EQ.98)DC1=DC1+DXSI(J,J)
        ENDIF
      ENDDO
C
C 2-BODY (INC. NFS IF LSM/ICM)
C
      DC2=DZERO                                      ! 2-BODY
      DO I=1,NAD(0)
        J=INT(NRK(I))          +n1
        DC2=DC2+DRL(J)*DRK(I)
        IF(BKUTOO.AND.BMVD)THEN
          IF(BFALL(I))THEN
            DC2=DC2-DRK(I)*DZL(J)
          ELSE
            DC2=DC2+DRK(I)*DZL(J)
          ENDIF
          DC2=DC2+DRK(I)*DXTWO(J)+DEK(I)*DETA(J)
C                                -              (MINUS) JONES
        ENDIF
      ENDDO
C
      DECORE=DC1+DC2                        ! 1-BODY + 2-BODY
C
      IF(BPRNT0)THEN
        WRITE(6,400)DC2,DC1
        IF(BCONT)THEN
          WRITE(6,504)
          IF(ISHFTLS.NE.0)WRITE(6,509)
        ENDIF
      ENDIF
c
          decorn(n)=decore
          decor0=min(decor0,decore)
c
        enddo
c
        decore=decor0
c
        do n=1,ngrp
          decorn(n)=decorn(n)-decore
        enddo
C
C  CALCULATE 1-BODY CF ENERGY CONTRIBUTION OF THE NF VALENCE ELECTRONS
C
      M2=0
      DO M1=1,KMAX
        E1BCF(M1)=DZERO
        DO L=1,NF
          IF(QCG(L,M1).NE.M2)THEN
            M2=QCG(L,M1)
            DD=DEY(M2)
            IF(BMVD)DD=DD+DCD(M2,M2)+DMASS(M2,M2)
            IF(QED.LT.0.AND.QN(M2).GT.0)DD=DD+VPINT(M2)+SLFINT(M2)
          ENDIF
          E1BCF(M1)=E1BCF(M1)+DD
        ENDDO
        IF(ICAV.NE.0)E1BCF(M1)=E1BCF(M1)+ECAVX(M1)-ECAV(M1) !CA CORRECTN
      ENDDO
C
C  COLLAPSE BACK RELAXED ORBITAL LIST
C
      IF(IEQ(0).LT.0)THEN
        MXBORB=-IEQ(0)
        KF=MB+MXBORB
        DO K=1,KF
          K2=2*K
          ITMP(K2-1)=QN(K)
          ITMP(K2)=QL(K)/2
          IORB(K)=K2
        ENDDO
        KP=2*KF
        KF=MB+MXBORB*KMAX
        IF(BDR)THEN
          DO K=1,KMAX
            KF=KF+1
            IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN         !FIRST OCC.
              KP=KP+1
              ITMP(KP)=QN(KF)
              KP=KP+1
              ITMP(KP)=QL(KF)/2
              IORB(KF)=KP
            ENDIF
          ENDDO
        ENDIF
        DO K=1,KMAX
          KF=KF+1
          IF(IGRCF(KF).GT.0.AND.KF.EQ.IEQ(KF))THEN           !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(KF)
            KP=KP+1
            ITMP(KP)=QL(KF)/2
            IORB(KF)=KP
          ENDIF
        ENDDO
      ELSEIF(IEQ(0).GT.0)THEN
        KP=0
        DO K=1,MXORB
          IF(K.EQ.IEQ(K))THEN                                !FIRST OCC.
            KP=KP+1
            ITMP(KP)=QN(K)
            KP=KP+1
            ITMP(KP)=QL(K)/2
            IORB(K)=KP
          ENDIF
        ENDDO
      ENDIF
C
      IF(MODE.GT.0)THEN
        EIONMN=DZERO
        IF(IEQ(0).EQ.0)THEN
          KF=MIN(MXLIT,MXORB)
          IF(BPRNT0)WRITE(MW,507)KMAX,NZION,MION,(ABS(QN(K)),QL(K)/2
     X                          ,K=1,KF)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                           ,(int(ABS(QN(K))),int(QL(K)/2),K=1,KF)
        ELSE
          KF=MIN(KP,MXLIT)
          IF(BPRNT0)WRITE(MW,507)KMAX,NZION,MION,(ABS(ITMP(K))
     X                          ,ITMP(K+1),K=1,KF,2)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KMAX),int(NZION),int(MION)
     X                   ,(int(ABS(ITMP(K))),int(ITMP(K+1)),K=1,KF,2)
        ENDIF
      ENDIF
C
      DO K=1,KMAX
        LM=0
C
        DO J=1,MXORB
          IF(NEL(J,K).GT.0)THEN
            LM=LM+1
            QSB(LM,K)=NEL(J,K)
            IF(LM.GT.1)QSB(LM,K)=QSB(LM,K)+50
            IF(IEQ(0).NE.0)THEN
              JQ=IEQ(J)
              JM=MIN(IORB(JQ)/2,MXLIT)
            ELSE
              JQ=J
              JM=MIN(J,MXLIT)
            ENDIF
            QLB(LM,K)=LIT(JM)
CHAR        QLB(LM,K)=ICHAR(CLIT(JM))
            NCC0(LM)=JQ
          ENDIF
        ENDDO
        LMX(K)=LM
C
        IF(LM.LT.10)THEN
          LP=LM+1
          DO J=LP,10
            QSB(J,K)=0
            QLB(J,K)=MBLK1
CHAR        QLB(J,K)=ICHAR(CMBLK1)
          ENDDO
        ENDIF
        M2=QCG(NF,K)
        KW=K
        MST=MSTAT(K)
        IF(IYY(M2).GT.0)THEN
          M1=QL(M2)+1
          KW=-K
          MST=MSTAT(K)/(M1+M1)
        ENDIF
        IF(MODE.GT.0)THEN
          IF(BPRNT0)WRITE(MW,517)KW,MST,MA,MB,(QSB(L,K)
     X             ,QLB(L,K),L=1,LM)
CHAR  X            ,CHAR(QLB(L,K)),L=1,LM)
          IF(.NOT.BPRNT0)WRITE(MWU)int(KW),int(MST),int(MA),int(MB)
     X                           ,(int(QSB(L,K)),int(QLB(L,K)),L=1,10)
        ENDIF
        DO L=1,LM
          QLB(L,K)=NCC0(L)
        ENDDO
      ENDDO
C
      IF(NMETAR.LT.0)THEN                        !MAP SUM OVER CHANNEL L
        ICF(0)=0
        DO K=1,KMAX
          I=QCG(NF,K)
          IF(IYY(I).GT.0)THEN
            ICF(K)=K
            K1=K-1
            IF(ICF(K1).NE.0)THEN                 !CHECK LAST FOR A MATCH
              IF(LMX(K).NE.LMX(K1))GO TO 841
              DO L=LMX(K)-1,1,-1
                IF(QLB(L,K).NE.QLB(L,K1))GO TO 841
                IF(QSB(L,K).NE.QSB(L,K1))GO TO 841
              ENDDO
              ICF(K)=ICF(K1)
            ENDIF
          ELSE
            ICF(K)=0
          ENDIF
 841    ENDDO
      ENDIF
C
      IF(MODE.GT.0)THEN
        IF(BPRNT0)WRITE(MW,505)NZION,MION
        IF(.NOT.BPRNT0)WRITE(MWU)int(NZION),int(MION)
      ENDIF
C
C***********************************************************************
C     SUBMATRICES 2S, 2L=QSI(K), QLI(K) (NF=NUMBER OF VALENCE ELECTRONS)
C     LOOP 728 CORRESPONDS TO LOOP 61 (WITH N=0) IN SR ALGEB2
C***********************************************************************
C
      NENERG=0
      NCOR=0
c      MC=0
      NCI=0
      LUMAX=0
      NCUT=KCUT
      IF(KCUT.LE.0)NCUT=10000
      NCTOT=0
      BINT=IAXUC.GT.0
      DMIN=D1P20
      DMAX=-D1P20
      ITMIN=0
      NSKP=0
      BAUX=JPRINT.EQ.1.OR.JPRINT.GT.4      !.NOT.BAUX IGNORE CORRELATION
      NEIG=NEIGEN                                !USER SETS NO. E-STATES
      IF(ECORR.LT.DZERO)THEN
        EEIG=ECORR/DTWO-DECORE                    !AS ECORR ABSOLUTE RYD
        if(eeig.ge.dzero)stop 'diagon, eigg reset .ge. zero...'
      ELSE
        EEIG=DZERO
      ENDIF
c
      dionmn=dzero
      etest=eimxls
c
C - no longer in use (unless uncommented for testing)
      TOLA=CMXLSA*D1M4                           !MAX B-F MATRIX ELEMENT
      IF(NNEW.GT.1)THEN
        T=NNEW
        T=T/DTWO
        TOLA=TOLA/(T*SQRT(T))
      ENDIF
      tola1=tola
      tola2=tola1/100
C
      IF(WLG1.LT.DZERO)THEN                      !MAX AUGER RATE
        WLG=D1M2
      ELSE
        WLG=DZERO
      ENDIF
      WLG=MAX(WLG,WLG1)
c
      if(bkutls)then                   !map configs: all bound then cont
        kb=0
        do k=1,kmax
          if(iyy(qcg(nf,k)).lt.0)then
            kb=kb+1
            kmap(kb)=k
          endif
        enddo
        kc=kb
        do k=1,kmax
          if(iyy(qcg(nf,k)).gt.0)then
            kc=kc+1
            kmap(kc)=k
          endif
        enddo
        kmax0=kb
        if(kc.gt.kb)then
          kmax1=kmap(kmax0+1)
        else
          kmax1=-1                        !should not be used as no cont
        endif
      endif
c
      iwrkg(0)=0
C
C START SLP LOOP
C
      DO 728 KGROUP=1,NSL0
C
C
      NC=NSL(KGROUP)
      MM=NC*NC
C
C
      IF(.NOT.BINT)NCTOT=0
C
      NGRPI(KGROUP)=NCI
      NCI=NCI+NC
C
      LL=NENERG
C
      MPW=QPI(KGROUP)/2
      MSW=QSI(KGROUP)+1
      MLW=QLI(KGROUP)/2
      MWJ=MSW*(QLI(KGROUP)+1)
C
      IF(NAST.GT.0)THEN                           !MAY RESTRICT E-STATES
        LSP=10000*MSW+10*MLW+MPW
        DO N=1,NAST
          IF(LSPI(N).EQ.LSP)THEN                  !WE HAVE A WINNER
            IF(NLSPI(N).GT.0)NEIG=NLSPI(N)        !THEN USER SET
            GO TO 851
          ENDIF
        ENDDO
        NEIG=NEIGEN                               !SHOULDN'T GET HERE
 851    CONTINUE
      ENDIF
C
C INDEX E-VECTORS AND, MAYBE, BOUND-CONT INTERACTIONS
C                                     !don't use parallel flag "par"!!
      if(bkutls)then                  !Partition by config (scf)
c
        do k=1,kmax
          ncf(k)=0
        enddo
c
        n0=0
        DO I=1,NC
          II=I+LL                     !+NENERG
          M1=NFK(II)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)then
            IDY(I)=-IDY(I)
            n0=n0+1                   !total bound still for B-C
          ELSE
            NFK(II)=-M1
          ENDIF
          ncf(m1)=ncf(m1)+1
          NAI(II)=ncf(m1)             !REL POSITION OF ABS TERM IN GROUP
        ENDDO
c
c        if(.not.bcont)n0=nc           !is *always* explicitly flagged
        iwrkg(kgroup)=iwrkg(kgroup-1)+n0
c
        k1=kmap(1)
        iwrk1(k1)=0
        iwrkb(1,k1,kgroup)=0
        iwrkb(2,k1,kgroup)=ncf(k1)
        iwrkn(k1)=0
        k0=k1
c
c      write(6,*)'kgroup=',kgroup
        do k=2,kmax
          k1=kmap(k)
          nn=ncf(k0)
          iwrk1(k1)=iwrk1(k0)+nn*nn
          iwrkn(k1)=iwrkn(k0)+nn
c       write(6,*)k,k1,ncf(k1),iwrkn(k1)
          if(k.le.kmax0)then          !not used if no radiation...
            iwrkb(1,k1,kgroup)=iwrkb(1,k0,kgroup)+nn
            iwrkb(2,k1,kgroup)=ncf(k1)
          endif
          k0=k1
        enddo
C
        DO I=1,NC
          II=I+LL                     !+NENERG
          M1=NFK(II)
          M1=ABS(M1)
          nadru(ii)=nctot+iwrk1(m1)+ncf(m1)*(nai(ii)-1)
        ENDDO
C
        if(bfot)then                         !need c-c e-vectors
          k=kmap(kmax)
        elseif(kmax0.gt.0)then               !only b-b, so overwrite c-c
          k=kmap(kmax0)
        else
          k=0
        endif
        if(k.gt.0)nctot=nctot+iwrk1(k)+ncf(k)*ncf(k)
c
      elseif(mode.eq.2)then           !NEED B-C PARTITIONING
c
        do i=1,mxorb
          ncc0(i)=0
        enddo
        mx0=mxorb   !+1
C
        n0=0
        DO I=1,NC
          II=I+LL                     !+NENERG
          M1=NFK(II)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)then
            IDY(I)=-IDY(I)
            n0=n0+1
            NAI(II)=n0                !REL POSITION OF ABS TERM IN GROUP
          ELSE
            NFK(II)=-M1
            ncc0(m2)=ncc0(m2)+1
            NAI(II)=ncc0(m2)          !REL POSITION OF ABS TERM IN GROUP
            mx0=min(mx0,m2)
          ENDIF
        ENDDO
c
        iwrkg(kgroup)=iwrkg(kgroup-1)+n0
        iorb(mx0)=n0*n0
        iwrkn(mx0)=0                  !only need index cont
c
        do i=mx0+1,mxorb
          nn=ncc0(i-1)
          iorb(i)=iorb(i-1)+nn*nn
          iwrkn(i)=iwrkn(i-1)+nn
        enddo
C
        DO I=1,NC
          II=I+LL                     !+NENERG
          IF(IDY(I).GT.0)THEN
            m2=idy(i)
            nadru(ii)=nctot+iorb(m2)+ncc0(m2)*(nai(ii)-1)
          else
            nadru(ii)=nctot+n0*(nai(ii)-1)
          ENDIF
        ENDDO
c
        if(bfot)then                            !need c-c e-vectors
          nctot=nctot+iorb(mxorb)+ncc0(mxorb)*ncc0(mxorb)
        else                                    !only b-b
          nctot=nctot+n0*n0                     !so can overwrite c-c
        endif
C
      ELSE                            !B-B
C
        n0=0
        DO I=1,NC
          II=I+LL                     !+NENERG
          NAI(II)=I
          M1=NFK(II)
          M1=ABS(M1)
          M2=QCG(NF,M1)
          M2=IEQ(M2)
          IDY(I)=M2
          IF(IYY(M2).LT.0)THEN
            IDY(I)=-IDY(I)
            n0=n0+1
          ELSE
            NFK(II)=-M1
          ENDIF
          NADRU(II)=NCTOT                 !END POSITION OF E-VECTOR II-1
          NCTOT=NCTOT+NC
        ENDDO
c
        iwrkg(kgroup)=iwrkg(kgroup-1)+nc        !=ngrpi(kgroup)?
C
      ENDIF
C
      IF(BPRNT0)THEN                      !INITIALIZE FOR PRINTING
        IM=(NC*(NC+1))/2
        DO IP=1,IM
          DVP(IP)=DZERO
        ENDDO
      ENDIF
c
            if(btimet)call cpu_time(timei)
C
C SET-UP BOUND-CONTINUUM PROBLEM
C
      IF(BCONT)THEN
C
        NHOLD=NCOR
C                                         !CHECK B-C INDEXING
        LU=0
        DO L=1,NC
          IF(IDY(L).GT.0)THEN
            nadlu(l)=lu                   !old pos, not used by new
            lu=lu+n0
          ENDIF
        ENDDO
C
        IF(LU.GT.LUMAX)LUMAX=LU
        IF(LU.GT.IXAAI)THEN               !SHOULD NOT HAPPEN NOW
          WRITE(6,899)LU
          WRITE(0,*)'***INCREASE MXAAI'
          GO TO 2000
        ENDIF
        LUX=LU
C
C STORE BOUND-CONTINUUM (SLATER & NFS)
C
        DO I=1,NC
C
          DO J=1,I
c
           if(bkutls)then
           if(idy(i)*idy(j).gt.0.and.nfk(i+ll).ne.nfk(j+ll))go to 315
           else
           if(idy(i).gt.0.and.idy(j).gt.0.and.idy(i).ne.idy(j))go to 315
           endif
C
            NCOR=NCOR+1
C
            IF(IDY(I)*IDY(J).GT.0)GO TO 315
            IF(BNOAUG)GO TO 315
C
C INDEX & INITIALIZE
C
              if(idy(i).gt.0)then
                lc=i
                lb=j
              else
                lc=j
                lb=i
              endif
              llb=ll+lb
              llc=ll+lc
              if(bposu)then                             !new pos
                m1=nai(llc)
                if(bkutls)then
                  m2=-nfk(llc)
                  m1=m1-iwrkn(kmax1)
                else
                  m2=idy(lc)
                endif
                lu=(iwrkn(m2)+m1-1)*n0+nai(llb)
              else                                      !old pos
                lu=nadlu(lc)+nai(llb)
              endif
              if(bkutls)then
                m2=nfk(llb)
                lu=lu+iwrkn(m2)
              endif
C
              DO M=1,MENG
C                DUI(M,LU)=DZERO
                DUI(LU,M)=DZERO
              ENDDO
C
              N1=NAD(NCOR-1)+1
              N2=NAD(NCOR)
C
              DO L=N1,N2
                M1=INT(NRK(L))
                KK=NRLI(M1)
                IF(KK.GT.0)THEN
C SLATER
                  DO M=1,MENG
C                     DUI(M,LU)=DUI(M,LU)+DRLI(M,KK)*DRK(L)
                   DUI(LU,M)=DUI(LU,M)+DRLI(M,KK)*DRK(L)
                  ENDDO
C NFS
                  IF(BKUTOO.AND.BMVD)THEN
                    DO M=1,MENG
                      DS=DZLI(M,KK)*DRK(L)
                      IF(BFALL(L))DS=-DS
                      DS=DS+DXTWOI(M,KK)*DRK(L)+DETAI(M,KK)*DEK(L)!-JONS
C                      DUI(M,LU)=DUI(M,LU)+DS
                      DUI(LU,M)=DUI(LU,M)+DS
                    ENDDO
                  ENDIF
C
                ENDIF
              ENDDO
C
              IF(BPRNT0)THEN
                IP=ICOL(J,I,IZERO)           !GLOBAL
C                DVP(IP)=DUI(NREL,LU)         !STORE FOR PRINTING
                DVP(IP)=DUI(LU,NREL)         !STORE FOR PRINTING
              ENDIF
C
  315       CONTINUE
C
          ENDDO
C
        ENDDO
C
        NCOR=NHOLD
C
      ENDIF
C
C FORM H-MATRIX FOR DIAGONALIZATION
C
      ICB=0
      ICC=0
C
      DO I=1,NC                                           !START SL LOOP
C
        II=I+LL                      !+NENERG
        NN=NADRU(II)
C
        M1=NFK(II)
        M1=ABS(M1)
C
        DE(I)=E1BCF(M1)
COLD        IF(BNJO)DE(I)=DELELS(II,1)       !NO SHIFT PRIOR TO DIAG NOW
CADD  DE(I)=DE(I)+DC1
c
        if(irlx.lt.0)then
          n=icfgp(m1)
          de(i)=de(i)+decorn(n)
        endif
C
        M2=QCG(NF,M1)
       if(bkutls)then
        IF(IYY(M2).GT.0)DE(I)=DE(I)+ECOR1
       else
        IF(IYY(M2).LT.0)THEN
          ICB=ICB+1
        ELSE
          DE(I)=DE(I)+ECOR1
          M2=IEQ(M2)
          DO M=1,ICC
            IF(M2.EQ.IORB(M))GO TO 316
          ENDDO
          ICC=ICC+1
          IORB(ICC)=M2
        ENDIF
       endif
C
  316   CONTINUE
C
C LOOP OVER SECOND INDEX OF H-MATRIX
C
        DO J=1,I                             !START SL LOOP
C
          DD=DZERO
C
          JJ=J+LL
c
          if(bcont)then
            if(idy(i)*idy(j).le.0)then       !b-c, already formed
              if(mode.eq.2)then              !else mode.eq.3
                ncor=ncor+1
                go to 317
              endif
            endif
           if(bkutls)then
           if(idy(i)*idy(j).gt.0.and.nfk(ii).ne.nfk(jj))go to 317
           else
           if(idy(i).gt.0.and.idy(j).gt.0.and.idy(i).ne.idy(j))go to 317
           endif
          else
           if(bkutls.and.nfk(ii).ne.nfk(jj))go to 317
          endif
c
          if(bnobv.and.idy(i).lt.0.and.idy(j).lt.0)then
            ivi=abs(idy(i))
            ivj=abs(idy(j))
            if(ival(ivi).ne.ival(ivj))then             !zero ryd-N+1 int
              ncor=ncor+1
              go to 318
            endif
          endif
C
          N1=NAD(NCOR)+1
          NCOR=NCOR+1
          N2=NAD(NCOR)
c
c check for bkutls (just zero-out usual multi-config interactions)
         if(kutls.ge.0.and.nfk(ii).ne.nfk(jj))then
           if(abs(nfk(ii)).gt.kutls)go to 318
           if(abs(nfk(jj)).gt.kutls)go to 318
         endif
C
C 2-BODY NON-REL (SLATER)
C
          DO  L=N1,N2
            M1=INT(NRK(L))
            DD=DD+DRL(M1)*DRK(L)
          ENDDO
CADD      DD=DE(I)
C
C CASE LSM/ICM; ADD-IN 1- AND 2-BODY NFS
C
          IF(BMVD)THEN
            DO L=N1,N2
              M1=INT(NRK(L))
C 1-BODY
              IF(QRL(5,M1).LT.0)THEN  !DZL(KX)=DXTWO(KX)=DETA(KX)=0 HERE
                L1=QRL(1,M1)          !FALLING ORDER L1.GE.L2
                L2=QRL(3,M1)
                DS=DCD(L1,L2)+DMASS(L1,L2)
                IF(KUTOO.EQ.98)DS=DS+DXSI(L1,L2)
                DS=DS*DRK(L)
                DD=DD+DS
              ENDIF
C 2-BODY
              IF(BKUTOO)THEN
                DS=DZL(M1)*DRK(L)
                IF(BFALL(L))DS=-DS
                DS=DS+DXTWO(M1)*DRK(L)+DETA(M1)*DEK(L)    !- JONES
                DD=DD+DS
              ENDIF
            ENDDO
          ENDIF
C
C STORE H-MATRIX
C
 318      NI=NAI(JJ)
C
          TFU(NI+NN)=DD                            !STORE H FOR DIAG
C
          IF(BPRNT0)THEN
            IP=ICOL(J,I,IZERO)                     !GLOBAL
            DVP(IP)=DD                             !STORE H FOR PRINTING
          ENDIF
C
 317      CONTINUE
C
        ENDDO                                !END SL LOOP
C
        TFU(NI+NN)=TFU(NI+NN)+DE(I)                     !ADD DIAG E HERE
C
      ENDDO                                                 !END SL LOOP
c
          if(btimet)then
            call cpu_time(timef)
            timefh=timefh+timef-timei
          endif
C
C*****************************************************************
C
C     DIAGONALIZE HAMILTONIAN
C
C*****************************************************************
C
            if(btime)call cpu_time(timei)
c
      INFO=0
C
      IF((MODE.NE.2.OR.ICC.LE.0).and..NOT.BKUTLS)THEN
C                           !DU IS LOWER, TFU UPPER (SIGH)
        NN=NADRU(LL+1)
        DO I=1,NC
          DO J=1,I
            DU(I,J)=TFU(NN+J)                !NAI(I+LL)=I HERE (ALL B-B)
          ENDDO
CD          DU(I,I)=DU(I,I)+DE(I)
          NN=NN+NC
        ENDDO
C                           !BOTH UPPER HERE
        IF(IDIAG.GT.0)THEN
          NN=NADRU(LL+1)
          DO I=1,NC
            DO J=1,I-1
              DU(J,I)=TFU(NN+J)
            ENDDO
            NN=NN+NC
          ENDDO
        ENDIF
C
        CALL HDIAG(NC,NEIG,EEIG,DU,ISXDI,DVU,DVECV,NF,INFO)
C
        IF(NC*NF.LE.0.OR.INFO.GT.0)GO TO 2000
C
        IF(MODE.GE.4)THEN
          icc=0
          DO I=1,NC
            DO L=1,NC
              IF(IDY(L)*IDY(I).LE.0)DU(L,I)=DZERO
            ENDDO
          ENDDO
        ENDIF
C
        NN=NADRU(LL+1)
        DO J=1,NC
          DO I=1,NC
            TFU(NN+I)=DU(I,J)                !NAI(I+LL)=I HERE (ALL B-B)
          ENDDO
          NN=NN+NC
        ENDDO
C
      ELSE
C
C DIAGONALIZE SEPARATELY THE ICC C-C BLOCKS PLUS THE B-B BLOCK
C
        IF(BKUTLS)THEN
          icb=0
          icc=0
          m0=1
          m1=kmax
        ELSE
          IF(ICB.GT.0)THEN
            M0=0
            IORB(0)=-1000
          ELSE
            M0=1
          ENDIF
          M1=ICC
        ENDIF
C
        DO M=M0,M1
C
          NSUB=0
          DO M7=1,NC
C
            IF(BKUTLS)THEN
              if(abs(nfk(m7+ll)).eq.m)then
                if(idy(m7).lt.0)then
                  icb=icb+1           !just flags existence
                else
                  icc=icc+1           !just flags existence
                endif
              else
                go to 675
              endif
            ELSE
              IF(IORB(M).LT.0.AND.IDY(M7).LT.0)GO TO 676
              IF(IORB(M).NE.IDY(M7))GO TO 675
            ENDIF
C
  676       NSUB=NSUB+1
            NVEC(NSUB)=M7
  675     ENDDO
c
         if(bkutls)then
          if(nsub.eq.0)go to 677                !only if bkutls=.t.
         else
c - to be removed
          if(m.gt.0)then
            if(nsub.ne.ncc0(iorb(m)))then
              write(0,*)'icc=',m,'iorb=',iorb(m),'ncc0=',ncc0(iorb(m))
     x                 ,'nsub=',nsub
              stop 'cont orb index error...'
            endif
          else
            if(nsub.ne.n0)stop 'bound orb index error...'
          endif
         endif
C HOLD
          NSUB0=NSUB
          IDIAG0=IDIAG
C
  700     CONTINUE
C
          N1=NVEC(1)+LL
          NN=NADRU(N1)
          DO IS=1,NSUB
            DO JS=1,IS                !LOWER
              DU(IS,JS)=TFU(NN+JS)
c              if(abs(du(is,js)).lt.d1m10)du(is,js)=dzero
            ENDDO
CD            NI=NVEC(IS)
CD            DU(IS,IS)=DU(IS,IS)+DE(NI)
            NN=NN+NSUB
          ENDDO
C
          IF(IDIAG.GT.0)THEN
            DO IS=1,NSUB
              DO JS=IS+1,NSUB
                DU(IS,JS)=DU(JS,IS)
              ENDDO
            ENDDO
          ENDIF
C
          CALL HDIAG(NSUB,NEIG,EEIG,DU,ISXDI,DVECL,DVECV,NF,INFO)
C
          IF(NF.LE.0)GO TO 2000
C
CL          IF(INFO.GT.0)THEN   ! LAPACK FAILURE, SO TRY DIAG    !LAPACK
CL            WRITE(6,*)                                         !LAPACK
CL     X              ' RE-RUNNING THIS MATRIX ONLY WITH SR.DIAG'!LAPACK
CL            GO TO 700                                          !LAPACK
CL          ENDIF                                                !LAPACK
C
          IF(NSUB.EQ.0)THEN     ! DIAG FAILURE, SO RELOAD AND USE JACORD
            WRITE(6,*)' RE-RUNNING THIS MATRIX ONLY WITH SR.JACORD'
            NSUB=NSUB0
            IDIAG=1
            GO TO 700
          ENDIF
C
          IDIAG=IDIAG0
C
C STORE E-ENERGIES IN DVU AND E-VECTORS IN TFU
C
          N1=NVEC(1)+LL
          NN=NADRU(N1)
          DO IS=1,NSUB
            NI=NVEC(IS)
            DVU(NI)=DVECL(IS)
            DO JS=1,NSUB
              TFU(NN+JS)=DU(JS,IS)
            ENDDO
            NN=NN+NSUB
          ENDDO
c
  677    continue
C
        ENDDO
C
      ENDIF
c
          if(btime)then
            call cpu_time(timef)
            timeh=timeh+timef-timei
          endif
C
C*****************************************************************
C
C PRINT TERM ENERGIES, TRANSFORMATION MATRICES AND H-SUBMATRICES.
C
C*****************************************************************
C
c test set corr-corr mixing to zero.
c No real time saving, better not to generate it in the first place.
c
c      do i=1,nc
c        ii=i+ll
c        dry=2*dvu(i)
c        nn=abs(nfk(ii))
c        if(idiag.ge.0.and.nn.gt.ncut.or.dry*ecorr.gt.ecorr*ecorr
c     x                .or.dry.gt.eskpl.and.dry.lt.eskph)then
c          iwrk3(ii)=-1
c        else
c          iwrk3(ii)=1
c        endif
c      enddo
c      do i=1,nc
c        ii=i+ll
c        if(iwrk3(ii).lt.0)then
c          do j=1,nc
c            jj=j+ll
c            if(iwrk3(jj).lt.0.and.idy(i)*idy(j).gt.0)then
c              if(idy(i).lt.0.or.idy(i).eq.idy(j))then
c                nn=nadru(ii)
c                ni=nai(jj)
c                tfu(nn+ni)=dzero
c              endif
c            endif
c          enddo
c        endif
c      enddo
c
      M2=0
C
      DO I=1,NC
C
C     J IS THE ARRAY INDEX OF THE WHOLE H-MATRIX, WHEREAS I IS THE
C     POSITION IN THE APPROPRIATE SUBMATRIX
C
        J=I+LL                                    !+NENERG
        IWRK3(J)=0
        M=NFK(J)
        JJ=ABS(M)
C        IF(IDY(I).GE.0)NFK(J)=-JJ
C
        DD=DVU(I)
        IF(DD.NE.DZERO)THEN                       !E-STATE EXISTS
C
COLD        IF(BNJO)DD=DD-DELELS(J,1)             !AS NO PRIOR SHIFT NOW
C
C REMOVE ENERGY OF CONTINUUM ELECTRON FROM ENERGY TERM LIST
          IF(IDY(I).GE.0)THEN
            IF(MODE.LT.3)DD=DD-DYY(NREL)
            DD=MOD(DD,TSHFT)
            dionmn=min(dionmn,dd)
          ENDIF
C
C POST SHIFT FOR AUGERS
          IF(ISHFTLS.EQ.1)THEN
             DD=DD+DELELS(J,1)                    !CORRECTION
          ELSEIF(ISHFTLS.NE.0)THEN
            if(eflg0*delels(j,2).lt.dzero)then
              DD=delels(j,2)+eflg0-decore         !ABSOLUTE
            endif
          ENDIF
C
          IF(DD.LT.DMIN)THEN
            DMIN=DD
            ITMIN=J
          ENDIF
          IF(DD.GT.DMAX)DMAX=DD
C
          IF(IDIAG.GE.0.AND.JJ.GT.NCUT)THEN      !CORRELATION
            IWRK4(J)=-J
          ELSE
            IWRK4(J)=J
          ENDIF
        ELSE                                     !E-STATE DOES NOT EXIST
          IWRK4(J)=0
        ENDIF
C
        DENERG(J)=DD
C
        IF(BTFU)THEN
          IHARRY(JJ)=IHARRY(JJ)+1
C
          IF(BPRNT0)THEN
            NN=NADRU(J)
            IF((MODE.NE.2.OR.ICC.LE.0).AND..NOT.BKUTLS)THEN
              DO L=1,NC
                DVECL(L)=TFU(NN+L)
              ENDDO
            ELSE
              DO L=1,NC
                DVECL(L)=DZERO
                if(idy(i)*idy(l).gt.0)then
                  if(bkutls.and.nfk(j).eq.nfk(l+ll).or.
     x          .not.bkutls.and.(idy(i).lt.0.or.idy(i).eq.idy(l)))then
                    ni=nai(l+ll)
                    dvecl(l)=tfu(nn+ni)
                  endif
                endif
              ENDDO
            ENDIF
            M1=M2
            M2=M1+I
            M12=M1
            M1=M1+1
            L2=MIN(NC,ITEN)
            M12=M12+MIN(I,10-L2)
            WRITE(6,181)J,MSW,MLW,MPW,DE(I),DVU(I),NFK(J)
     X                 ,IHARRY(JJ),I,(DVECL(L),L=1,L2),(DVP(L),L=M1,M12)
            IF(M2.GT.M12)WRITE(6,182)(DVECL(L),L=L2+1,NC)
     X                              ,(DVP(L),L=M12+1,M2)
          ENDIF
C
        ENDIF
C
      ENDDO
c
       if(eimxls.gt.0)etest=eimxls+2*(dionmn+decore) !relative to ground
C
      NENERG=NENERG+NC
C
C RE-SET ABSOLUTE GROUND STATE BY MODIFYING CORE ENERGY (VIA SHFTLS)
C
C      IF(ISHFTLS.LT.0.AND.EFLG0.LT.DZERO)DECORE=EFLG0-DMIN
C
C
C********************************************
C
C     ***COMPUTE AUTOIONIZATION RATES***
C
C     EVALUATE <ic!tc><tc!H!tb><tb!ib>
C                               __
C           I.E. DV(I,J)*H(J,K)*DV(K,L)
C
C********************************************
C
C
      IF(ICC.EQ.0)GO TO 728             !BAIL OUT TO NEXT SYMMETRY GROUP
C
      IF(BUNA)THEN                         !INDEX CONTINUUM ENERGY ORDER
C
        I1=LL+1
        CALL HPSRTI(NC,DENERG(I1),IWRK2)
C
        M=0
        DECMIN=-D1P20
C
        DO J=1,NC
          NVEC(J)=0
          I=IWRK2(J)
          II=I+LL
          IF(IDY(I).GT.0)THEN
            DRY=DENERG(II)+DECORE
            DRY=DRY+DRY
            IF(DRY.LE.etest.and.iwrk4(ii).ne.0)THEN            !RESOLVED
              IF(DENERG(II).GT.(DECMIN+TOLB2))THEN                 !A.U.
                M=M+1
                DE(M)=DENERG(II)
              ENDIF
              IF(NVEC(M).GT.0)THEN
                NSKP=NSKP+1
                IWRK3(II)=-M
C              ELSEIF(IDIAG.GE.0.AND.-NFK(II).GT.NCUT)THEN  !CORR FOR AA
              ELSEIF(IWRK4(II).LE.0)THEN                    !CORR FOR AA
                NSKP=NSKP+1
                IWRK3(II)=-M
              ELSE
                NVEC(M)=II
                IWRK3(II)=M
              ENDIF
              DECMIN=DENERG(II)                !ALLOW FOR ANY DRIFT<TOLB
            ELSE
              NSKP=NSKP+1
              IWRK3(II)=-1
            ENDIF
          ELSE
C            IF(IDIAG.GE.0.AND.NFK(II).GT.NCUT)THEN    !ONLY CORR FOR AA
            IF(IWRK4(II).LE.0)THEN                     !ONLY CORR FOR AA
              NSKP=NSKP+1
              IWRK3(II)=-1   !will not write term info to rate file
            ELSE
              IWRK3(II)=0    !dummy
            ENDIF
          ENDIF
          IWRK2(J)=1                           !keep all for now...
        ENDDO
C
        MSUM=M
      ELSE
        MSUM=0
      ENDIF
C
      IF(ICB.EQ.0)GO TO 7288            !BAIL OUT TO NEXT SYMMETRY GROUP
      IF(BNOAUG)GO TO 7288
C
C LOOP OVER INITIAL AUTOIONIZING TERMS
C
            if(btime)call cpu_time(timei)
c
      n00=n0
      DO J=1,NC
C
        IF(IDY(J).GT.0)GO TO 603
C
        JJ=J+LL
        if(denerg(jj).lt.dionmn)go to 603                   !true bound!
C        IF(IDIAG.GE.0.AND.NFK(JJ).GT.NCUT)GO TO 603        !CORRELATION
        IF(.NOT.BAUX.AND.IWRK4(JJ).LE.0)GO TO 603           !CORRELATION
C
        DO M=0,MMM                              !=0 IF NMETAR .GE. 0
          SUMA(M)=DZERO
        ENDDO
        DO M=1,MSUM                             !=0 IF .NOT. BUNA
          DVU(M)=DZERO
        ENDDO
C
        if(bkutls)then
          m2=nfk(jj)
          luj=iwrkn(m2)
          n00=ncf(m2)
        endif
C
C FIND MAX INTERP ENERGY NEEDED FOR THIS INITIAL STATE
C
        IF(BLAG)THEN
C
          DM0=DENERG(JJ)+DSHFT0-dionmn
          DM=-DM0                              ! - AS DON'T NEED COEFFS
C
          CALL LAGINT(DM,DDY,NP1JJ,NP2JJ)
C
        ELSE
C
          NP2JJ=MENG                           !=1 THEN
C
        ENDIF
c
            if(btimet)call cpu_time(timeia)
C
C APPLY INITIAL STATE MIXING FOR EACH UNMIXED FINAL CONTINUUM STATE
C
        J0=NADRU(JJ)
C
        DO I=1,NC
          IF(IDY(I).GT.0)THEN
c
            ii=i+ll
            m1=nai(ii)
            if(bkutls)then
              m2=-nfk(ii)
              m1=m1-iwrkn(kmax1)
            else
              m2=idy(i)
            endif
            ig=iwrkn(m2)+m1                     !old ig=i
c
ccorr            bcorr=idiag.ge.0.and.-nfk(i+ll).gt.ncut)          !corr
ccorr            if(.not.bcorr)then                                !corr
c
            if(bposu)then                       !new pos
              lu=(ig-1)*n0
            else
              lu=nadlu(i)                       !old pos
            endif
            if(bkutls)lu=lu+luj
C
CL            IF(LAPAK.GT.0)THEN                                 !LAPACK
CL              DO L1=1,NP2JJ                                    !LAPACK
CL                DVI(IG,L1)=                                    !LAPACK
CL     X            DDOT(N00,TFU(J0+1),IONE,DUI(LU+1,L1),IONE)   !LAPACK
CL              ENDDO                                            !LAPACK
CL            ELSE                                               !LAPACK
              DO L1=1,NP2JJ
                DD=DZERO
                DO M=1,N00
c                  if(abs(TFU(J0+m)*dui(lu+m,1)).gt.tola1)then      !old
cc                    if(abs(TFU(J0+m)).gt.cmxlsa)then             !orig
                  DD=DD+TFU(J0+M)*DUI(LU+M,L1)
c                  endif
                ENDDO
                DVI(IG,L1)=DD
              ENDDO
CL            ENDIF                                              !LAPACK
ccorr            endif                                             !corr
          ENDIF
        ENDDO
c
          if(btimet)then
            call cpu_time(timefa)
            timea1=timea1+timefa-timeia
            timeia=timefa
          endif
C
C LOOP OVER FINAL CONTINUUM TERMS
C
        DO I=1,NC
C
          IF(IDY(I).LT.0)GO TO 605
          II=I+LL
C          IF(IDIAG.GE.0.AND.-NFK(II).GT.NCUT)GO TO 605     !CORRELATION
          IF(.NOT.BAUX.AND.IWRK4(II).LE.0)GO TO 605         !CORRELATION
C
          IF(ABS(DENERG(II)+DYY(NREL)-DENERG(JJ)).GT.ACE)GO TO 605
C
          DRY=DENERG(II)
          DS=DENERG(JJ)-DRY
C
          IF(DS.LT.DZERO         )GO TO 605   !NOT ENERGETICALLY ALLOWED
C                       .AND.BLAG
c      if(ds.lt.dyy(1).or.ds.gt.dyy(meng))then
c        write(6,*)'***extrapolating augers1'
c        write(6,*)2*dyy(1),2*ds,2*dyy(meng)
c        if(ds.lt.0.9*dyy(1).or.ds.gt.1.1*dyy(meng))
c     x     stop '***extrapolating augers1'
c      endif
c
          IF(IGAPE.GT.0)THEN
            IF(DS.LT.DYY(IGAPE).AND.DS.GT.DYY(IGAPE-1))THEN
              WRITE(6,*)'***EXTRAPOLATING AUGERS2'
              WRITE(6,*)IGAPE,2*DYY(IGAPE-1),2*DS,2*DYY(IGAPE)
              IF(DS.LT.D0PT9*DYY(IGAPE).AND.DS.GT.D1PT1*DYY(IGAPE-1))
     X                                                           THEN
                WRITE(0,*)'***EXTRAPOLATING AUGERS2'
C                GO TO 2000
              ENDIF
            ENDIF
          ENDIF
C
C SET-UP INTERPOLATION
C
          IF(BLAG)THEN
C
            M2=-IDY(J)
            DM=DS+DSHIFT(M2)
C
            CALL LAGINT(DM,DDY,NP1,NP2)
C
          ENDIF
c
          if(np2.gt.np2jj)then
            write(0,*)j,np2jj,i,np2,dm0,dm
c          dm0=denerg(jj)+dshft0-dionmn
c           dm=denerg(jj)-denerg(ii)+dshift(m2)
            write(0,*)denerg(jj),dshft0,dionmn,denerg(ii),dshift(m2)
            stop 'diagon np2jj error'
          endif
C
C APPLY FINAL-STATE MIXING TO INTERPOLATED MATRIX ELEMENTS
C
          IF(BKUTLS)THEN
            M2=-NFK(I+LL)
            M0=NCF(M2)
            L1=IWRKN(M2)-iwrkn(kmax1)
          ELSE
            M2=IDY(I)
            M0=NCC0(M2)
            L1=IWRKN(M2)
          ENDIF
C
          I0=NADRU(II)
          DAS=DZERO
C
          DO N=NP1,NP2
CL            IF(LAPAK.GT.0)THEN                                 !LAPACK
CL              DD=DDOT(M0,TFU(I0+1),IONE,DVI(L1+1,N),IONE)      !LAPACK
CL            ELSE                                               !LAPACK
              DD=DZERO
              DO M=1,M0
c                if(abs(tfu(i0+m)*dvi(l1+m,np1)).gt.tola2)then      !old
cc                if(abs(tfu(i0+m)).gt.cmxlsa)then                 !orig
                DD=DD+TFU(I0+M)*DVI(L1+M,N)
c                endif
              ENDDO
CL            ENDIF                                              !LAPACK
            DAS=DAS+DDY(N)*DD
          ENDDO
C
C FORM AUTOIONIZATION RATE
C
          DAS=ABS(DAS)*DAS*DKON
          IF(ABS(DAS).GT.WLG)THEN
            IF(BPRNT0)WRITE(6,502)MWJ,II,JJ,DAS,DS,DRY
            DS=DS+DS
            DRY=DRY+DECORE
            DRY=DRY+DRY
            IF(DRY.LT.EIONMN)EIONMN=DRY
C
            IF(BUNA)THEN                                   !BUNDLE CONT
              IF(DRY.LE.etest )THEN                        !RESOLVED
                M=IWRK3(II)
                M=ABS(M)
                DVU(M)=DVU(M)+ABS(DAS)
              ELSE                                         !BUNDLED
                M=0
                IF(NMETAR.LT.0)M=ICF(-NFK(II))             !BY TARGET CF
                SUMA(M)=SUMA(M)+ABS(DAS)
              ENDIF
            ELSE
              IF(BPRNT0)WRITE(MW,506)NFK(JJ),JJ,MWJ,NFK(II),II,DAS,DS
     X                              ,DRY
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JJ)),int(JJ),int(MWJ)
     X                                ,int(NFK(II)),int(II),DAS,DS,DRY
            ENDIF
          ENDIF
C
  605   ENDDO                    !END LOOP OVER FINAL TERMS
C
        IF(BUNA)THEN
          DO M=1,MSUM
            IF(DVU(M).GT.WLG)THEN
              IWRK2(M)=1                                    !FLAG EXISTS
              DS=DENERG(JJ)-DE(M)
              DS=DS+DS
              DRY=DE(M)+DECORE
              DRY=DRY+DRY
              II=NVEC(M)
              IF(BPRNT0)WRITE(MW,506)NFK(JJ),JJ,MWJ,NFK(II),II,DVU(M)
     X                              ,DS,DRY
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JJ)),int(JJ),int(MWJ)
     X                               ,int(NFK(II)),int(II),DVU(M),DS,DRY
            ENDIF
          ENDDO
          IF(SUMA(0).GT.WLG)THEN
            IF(BPRNT0)WRITE(MW,506)NFK(JJ),JJ,MWJ,IZERO,IZERO,SUMA(0)
     X                            ,EINF,DZERO
            IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JJ)),int(JJ),int(MWJ)
     X                   ,int(IZERO),int(IZERO),SUMA(0),EINF,DZERO
          ENDIF
          DO M=1,MMM
            IF(SUMA(M).GT.WLG)THEN
              IF(BPRNT0)WRITE(MW,506)NFK(JJ),JJ,MWJ,-M,IZERO,SUMA(M)
     X                              ,EINF,DZERO
              IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(JJ)),int(JJ),int(MWJ)
     X                        ,int(-M),int(IZERO),SUMA(M),EINF,DZERO
            ENDIF
          ENDDO
        ENDIF
c
          if(btimet)then
            call cpu_time(timefa)
            timea2=timea2+timefa-timeia
          endif
C
  603 ENDDO                     !END LOOP OVER INIITAL TERMS
C
      IF(BCONT.AND.BPRNT0)WRITE(6,897)LUX
C
          if(btime)then
            call cpu_time(timef)
            timea=timea+timef-timei
          endif
C
 7288 CONTINUE
C
      IF(BUNPA)THEN             !RE-INDEX FOR PI CONT SUM
        IF(BUNPR)THEN
          DO I=1,NC
            IF(IDY(I).GT.0)THEN
              II=I+LL
              MM=IWRK3(II)
              M=ABS(MM)
              IF(NVEC(M).GT.0)IWRK3(II)=SIGN(NVEC(M),MM)
            ENDIF
          ENDDO
        ELSE                    !NO CONT SUM SO CAN NO LONGER DROP TERMS
          DO I=1,NC
            IF(IDY(I).GT.0)THEN
              II=I+LL
              IF(IWRK3(II).LT.0)THEN
                IWRK3(II)=-IWRK3(II)
                NSKP=NSKP-1
              ENDIF
            ENDIF
          ENDDO
        ENDIF
      ELSE                              !CAN DROP UNUSED TERMS
        DO M=1,MSUM                     !MSUM=0 IF .NOT.BUNA
          IF(IWRK2(M).EQ.0)THEN
            II=NVEC(M)
            IWRK3(II)=-IWRK3(II)
            NSKP=NSKP+1
          ENDIF
        ENDDO
      ENDIF
C
C
  728 CONTINUE                                             !END SLP LOOP
C
C ******* END LOOP OVER SYMMTERY BLOCKS FOR H DIAGONALIZATION AND AUGERS
C
 7500 NC0=NCOR
c
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagon:'                 !par
cpar          write(iwp,*)'    H diag time=',nint(timeh),'sec'      !par
cpar          if(mode.eq.2)write(iwp,*)                             !par
cpar     x                '    auger time=',nint(timea),'sec'       !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          if(btimet)write(iw,*)'H form time=',nint(timefh),'sec'
          write(iw,*)'H diag time=',nint(timeh),'sec'
          if(btimet.and.mode.eq.2)then
            write(iw,*)'auger timea1=',nint(timea1),'sec'
            write(iw,*)'auger timea2=',nint(timea2),'sec'
          endif
          if(mode.eq.2)write(iw,*)'auger time=',nint(timea),'sec'
cpar        endif                                                   !par
      endif
C
      IF(IADD.NE.NC0)THEN
         WRITE(6,*)'SR.DIAGON GLOBAL INDEX ERROR:',IADD,NC0
         NF=-1
         GO TO 750
      ENDIF
C
      lupe=nenerg
      if(idw.eq.0)lupe=min(lupe,lupmx)
C
      DG0=DECORE+DMIN                !GROUND ENERGY (A.U.)
c
      i0=0
      if(ishftls.lt.0.or.ishftls.gt.1)i0=2
      ishftls=abs(ishftls)
C
      IF(i0.ne.0.and.nobs.gt.0)THEN                !DETERMINE TEC
        DO I=1,NENERG
          IF(DELELS(I,2).Ge.DZERO.and.iwrk4(i).ne.0)THEN     !.NE.
            T=DELELS(I,2)-DENERG(I)+DMIN
            DENERG(I)=DELELS(I,2)+DMIN
            DELELS(I,1)=T
          ENDIF
        ENDDO
      ENDIF
C
C SORT ENERGIES: IORIG(I) MAPS ENERGY ORDER BACK TO SYMMETRY ORDER
C
      IF(DMAX.GT.DZERO)THEN                        !UNLIKELY
        DO L=1,NENERG
          DENERG(L)=DENERG(L)-DMAX
        ENDDO
      ENDIF
C
C
      CALL HPSRTI(NENERG,DENERG,IORIG)
C
C
      IF(DMAX.GT.DZERO)THEN                        !UNLIKELY
        DO L=1,NENERG
          DENERG(L)=DENERG(L)+DMAX
        ENDDO
      ENDIF
C
      IF(i0.ne.0.and.nobs.lt.0)then             !need to convert from cf
c
        do k=1,kmax
          iharry(k)=1
        enddo
        do l=1,nenerg                           !find lowest term of cf
          i=iorig(l)
          k=nfk(i)
          k=abs(k)
          if(iharry(k).gt.0.and.delecf(k,2).ge.dzero
     x                     .and.iwrk4(i).ne.0)then
            t=delecf(k,2)-denerg(i)+dmin
            delecf(k,1)=t
            iharry(k)=0                         !flag cf found
          endif
        enddo
c
        do i=1,nenerg
          k=nfk(i)
          k=abs(k)
          t=delecf(k,1)
          if(t.ne.dzero.and.iwrk4(i).ne.0)then
            denerg(i)=denerg(i)+t
            delels(i,2)=denerg(i)-dmin
            delels(i,1)=t
          endif
        enddo
c
        if(dmax.gt.dzero)then                   !unlikely
          do l=1,nenerg
            denerg(l)=denerg(l)-dmax
          enddo
        endif
c
        call hpsrti(nenerg,denerg,iorig)        !re-sort
c
        if(dmax.gt.dzero)then                   !unlikely
          do l=1,nenerg
            denerg(l)=denerg(l)+dmax
          enddo
        endif
c
      endif
C
      DO K=1,KMAX
        IHARRY(K)=ABS(QN(QCG(NF,K)))
      ENDDO
C                                                  !SUMMED AND NO B-B
      IF(BUNA.AND.BUNR
     X       .AND.(JRAD.EQ.2.OR.JRAD.EQ.3.OR.JRAD.EQ.5))THEN
        ITESTN=ABS(NRSLMX)
        DO L=1,NENERG
          I=IORIG(L)
          IF(IWRK4(I).NE.0)THEN
            DRY=DENERG(I)+DECORE
            DRY=DRY+DRY
            IF(DRY.LT.EIONMN)THEN                  !BOUND
              K=NFK(I)
              IF(NRSLMX.GE.0)THEN      !N-VALUE
                ITESTH=IHARRY(K)
              ELSE                     !CFG NO.
                ITESTH=K
              ENDIF
              IF(L.GT.LLOWMX.OR.ITESTH.GT.ITESTN)THEN!UNRESOLVED
                IF(IWRK3(I).GE.0)THEN
                  NSKP=NSKP+1
                  IWRK3(I)=-1
c                else
c                  write(6,*)'correlation, already flagged'
                ENDIF
              ENDIF
            ELSE
              GO TO 529                            !WE ARE DONE
            ENDIF
c          else
c            write(6,*)'iwrk3, already flagged'
          ENDIF
        ENDDO
      ENDIF
C
C PRELIMINARY WRITES
C
  529 IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,514)MENG,NZION,MION,EIONMN
          WRITE(MWW,515)(DTWO*DYY(M8),M8=1,MENG)
          IF(BDOWN.and.BUNPR)THEN
            WRITE(MWW,513)NZION,MION
          ELSE
            WRITE(MWW,516)NZION,MION
          ENDIF
        ELSE
          WRITE(MWWU)int(MENG),int(NZION),int(MION),EIONMN
          WRITE(MWWU)(DTWO*DYY(M8),M8=1,MENG)
          WRITE(MWWU)int(NZION),int(MION)
          WRITE(MWWU)MBLK
        ENDIF
      ENDIF
      IF(MODE.GT.0)THEN
        IF(BPRNT0)THEN
          WRITE(MW,503)EIONMN
        ELSE
          WRITE(MWU)int(IZERO),int(IZERO),int(IZERO),int(IZERO)
     X             ,int(IZERO),DZERO,DZERO,EIONMN
        ENDIF
      ENDIF
C
      IF(BPRNT0)WRITE(6,901)DC1,DECORE
      IF(BCONT.AND.BPRNT0)WRITE(6,898)LUMAX,MXAAI
      if(lumax.ne.ixaai)write(0,*)'lumax,ixaai:',lumax,ixaai
COLD      IF(MDELE.LT.0)WRITE(MRP)TFU
      IF(.NOT.BRAD.AND.BJUMP)GO TO 750
C
      IF(MODE.GT.0)THEN
        IF(BPRNT0)THEN
          WRITE(MW,510)NENERG-NSKP,2*DG0
        ELSE
          WRITE(MWU)int(NENERG-NSKP),2*DG0
          WRITE(MWU)MBLK
        ENDIF
      ENDIF
C                                    !FOR TECS
      JTCC=1
      IF(ISHFTLS.EQ.0)JTCC=0
      IF(ISHFTLS.GT.1.OR.IOPTIM.EQ.1)JTCC=2
C
      IF(INCLUD.GT.NENERG)INCLUD=NENERG
C
      BAUX=JPRINT.GE.4.OR.BPRINT
      IF(BAUX.AND.BPRNT0)THEN
        WRITE(6,997)INCLUD,(DADJUS(I),I=1,NPARAM)
        IF(IPOLFN.LT.0)THEN
          NP0=-IPOLFN
          DO N=1,NP0
            N0=N*NPARAM
            WRITE(6,1002)N,(DADJUS(N0+I)-DONE,I=1,NPARAM)  !DADJUS(N0+I)
          ENDDO
        ENDIF
C
        WRITE(6,996)2*DG0
C
        IF(ISHFTLS.NE.0.OR.IOPTIM.EQ.1)THEN
          IF(JTCC.EQ.2)THEN
            IF(IOPTIM.EQ.0)THEN
              MOBS='CORRECTION      OBSERVED'
            ELSE
              MOBS='DIFFERENCE      OBSERVED'
            ENDIF
          ELSE
            MOBS='CORRECTION'
          ENDIF
          WRITE(6,993)MOBS
        ENDIF
        IF(MODE.EQ.1.AND.IUNIT(14).GT.0)WRITE(14,981)
      ENDIF
C
      IF(IUNIT(21).GT.0)WRITE(21,537)            !NENERG need NSPECE now
C
      IF(MENGB.GE.-1)THEN
        ELEM=CELMNT(NZION)
        NZAM=NZA-1
        FIP=ADASIP(ELEM,NZAM)
        if(badas)then
          lab4='    '
        else
          lab4='(0Y)'
        endif
        WRITE(25,541)ELEM,NZAM,NZION,NZA,FIP,lab4
        ISMX=0
        DO K=1,KMAX                             !CHECK MAX STRING LENGTH
          IS=4*LMX(K)
          IF(IS.GT.MXSTRG)THEN
            WRITE(6,536)MXSTRG
            WRITE(6,*)'***SR.DIAGON: INCREASE INTERNAL DIMENSION MXSTRG'
            GO TO 2000
          ENDIF
          ISMX=MAX(ISMX,IS)
        ENDDO
      ENDIF
C
C********************************************
C
C WRITE ENERGY-ORDERED TERM LIST
C
C********************************************
C
      DF=DZERO
      DS=DZERO
      IF(IOPTIM.NE.0)DS=DONE
      LL=-INCLUD
      TIMXLS=etest -2*DG0                          !RYD REL. TO GROUND
C
      IF(IOPTIM.EQ.1)THEN
        DFC=DZERO
        J=ITMIN
        IF(DELELS(J,2).NE.DZERO)THEN                       !NOT GROUND
          DO J=1,NENERG
            IF(DELELS(J,2).EQ.DZERO)GO TO 31
          ENDDO
          WRITE(6,*)'***SR.DIAGON: GROUND TERM NOT FOUND IN SHFTLS'
          WRITE(0,*)'***SR.DIAGON: GROUND TERM NOT FOUND IN SHFTLS'
          GO TO 2000
   31     WRITE(6,*)'***SR.DIAGON: GROUND TERM MIS-MATCH:',J,ITMIN
          WRITE(0,*)'***SR.DIAGON: GROUND TERM MIS-MATCH'
          GO TO 2000
        ENDIF
        IF(DG0.GT.EFLG0)DFC=DG0-EFLG0                              !A.U.
      ENDIF
C
C LIST DEGENERATE TERMS BY ASCENDING T INDEX
C (NEEDED FOR BUNDLED PI CONTINUUM SUM WITHIN SYMMETRY GROUP,
C  SINCE RADIATIVE LOOP IS EO NOT SO. ELSE COSMETIC)
C
      IF(BCONT.AND.(BPRNT0.OR.BUNPA))THEN
        J0=1
        m1p=0
        DECMIN=-D1P20
  131   MSUM=1
        DO J=J0,NENERG
          I=IORIG(J)                                               !A.U.
          IF(NFK(I).LT.0.AND.DENERG(I).LT.DECMIN+TOLB2
     X                                   .and.m1p.lt.0)THEN
            MSUM=MSUM+1
            m1p=nfk(i)
          ELSE
            m1p=nfk(i)
            IF(MSUM.GT.1)GO TO 132
          ENDIF
          DECMIN=DENERG(I)
        ENDDO
        J=NENERG+1
C
  132   DECMIN=DENERG(I)
        if(bunpa)t=denerg(iorig(j-msum))       !-msum = first; -1 = last
        DO M=MSUM,1,-1
          I=IORIG(J-M)
          DWRK(M)=I
          if(bunpa)denerg(i)=t
        ENDDO
C
        CALL HPSRTI(MSUM,DWRK,IWRK2)
C
        DO M=1,MSUM
          I=IWRK2(M)
          I=NINT(DWRK(I))
          IORIG(J-M)=I
        ENDDO
        IF(J.LT.NENERG)THEN
          J0=J+1
          GO TO 131
        ENDIF
      ENDIF
C
C BEGIN TERM ENERGY LOOP
C
      IPP=0
      ISP=0
      LSP=0
      IE0=0
      NSPECE=0
      EMIN=EIONPOT
      IF(EMIN.GT.DZERO)THEN
        IAUTO=0
      ELSE
        IAUTO=-1
      ENDIF
      DECMIN=-D1P20
      m1p=0
      NMM=0
C
      DO J=1,NENERG
C
        I=IORIG(J)                              !J=EO -> I=SO
        IEORD(I)=J                              !I=SO -> J=EO
C
        IF(NFK(I).GT.0)NMM=NMM+1
C
        IF(IWRK3(I).LT.0)THEN
          MWR=-I
        ELSE
          MWR=I
        ENDIF
C
        DAU=DENERG(I)
        DENERG(I)=DENERG(I)-DMIN
        DRY=DENERG(I)*DTWO
C
C        IF(IDIAG.GE.0.AND.ABS(NFK(I)).GT.NCUT              !CORRELATION
        IF(IWRK4(I).LE.0.OR.BECOR.AND.(DRY*ECORR.GT.ECORR*ECORR.OR.
     X          DRY.GT.ESKPL.AND.DRY.LT.ESKPH))THEN         !CORRELATION
          IORIG(J)=-I
          IF(IWRK4(I).EQ.0)THEN
            MBCOR=MSCOR
          ELSE
            MBCOR=MCOR
          ENDIF
        ELSE
          IORIG(J)=I
          MBCOR=MBLK
          if(j.le.lupe)NSPECE=NSPECE+1
        ENDIF
C
        JJ=NFQ(I)
        ISS=QSI(JJ)+1
        IP2=QPI(JJ)/2
C
        DO K=1,J
          IK=NFQ(ABS(IORIG(K)))
          IF(QSI(IK).EQ.QSI(JJ).AND.
     X       QLI(IK).EQ.QLI(JJ).AND.
     X       QPI(IK).EQ.QPI(JJ))THEN            !OVERWRITE IWRK4(I) WITH
             IWRK4(I)=K  !ENERGY ORDER POSN OF FIRST OCCURRENCE OF SYM I
             GO TO 62
          ENDIF
        ENDDO
C
COLD  IF(J.GT.INCLUD.AND.I.NE.-INCLUD)GO TO 30
   62   DD=DZERO
        IF(LL.EQ.0)GO TO 30
        IF(LL.GT.0)THEN
          DO K=1,LL
            IF(INDEXW(K).EQ.I)THEN
              DD=WGHT(K)
              GO TO 65
            ENDIF
          ENDDO
          IF(IOPTIM.EQ.0)GO TO 30
        ENDIF
        IF(J.GT.INCLUD.AND.IOPTIM.EQ.0)GO TO 30
C
        IF(IORIG(J).LT.0)GO TO 30       !OMIT CORR. FROM DF FOR INCLUD>0
C
C STATISTICAL WEIGHTED AVERAGE
C
        IF(IWGHT.NE.1)DD=(QLI(JJ)+1)*ISS
C
C EQUAL WEIGHTED AVERAGE
C
        IF(IWGHT.EQ.1)DD=DONE
C
C ADD TO ENERGY FUNCTIONAL (HERE, ANY AND ALL CORRELATION IS OMITTED)
C
   65   IF(IOPTIM.EQ.0)THEN                        !STANDARD
          DF=DAU*DD+DF
          DS=DS+DD
        ELSE                                       !DIFF WITH OBS
          IF(IOPTIM.EQ.1)THEN                      !TERMS
            IF(DELELS(I,2).GT.DZERO)THEN
              DF0=(ABS(DELELS(I,2)-DENERG(I))+DFC)/DELELS(I,2)
              DF=DF+DF0*DD                         !*DF0
            ELSEIF(DELELS(I,2).EQ.DZERO)THEN
              DD=DZERO
            ENDIF
          ENDIF
        ENDIF
C
   30   DEM=DRY*DKCM
        DWRK(I)=DEM
C       ENR(I)=DRY
C
        IWRK2(I)=0
        MYRGE=MBLK
        IF(NFK(I).LT.0)THEN
          IF(DRY.GT.DECMIN+TOLB.or.m1p.gt.0)IE0=IE0+1    !.or.prev bound
          IF(DRY.LE.TIMXLS)JIMXLS=IE0
          IWRK2(I)=IE0                             !CONT ENERGY INDEX
        ELSEif(m1p.gt.0)then                             !both bound
          IF(DRY.LT.DECMIN+TOLB.and.idw.eq.0.and.mrad.ge.0)THEN
            IF(LSP.EQ.QLI(JJ)/2.AND.IPP.EQ.IP2)THEN
              MYRGE='****'
              IF(IUNIT(14).GT.0)BACKSPACE(14)
              ISP=ISP+ISS-1
            ENDIF
          ENDIF
        ENDIF
        IF(MYRGE.EQ.MBLK)ISP=ISS
        IPP=IP2
        LSP=QLI(JJ)/2
        m1p=nfk(i)
        IF(MBCOR.EQ.MBLK)DECMIN=DRY
C
        IF(IAUTO.Ge.0.AND.DENERG(I)-EMIN.LE.TOLE)IAUTO=J+1
        IF(NFK(I).LT.0.AND.IAUTO.LT.0)THEN
          IAUTO=J
          EMIN=DENERG(I)
        ENDIF
C
        IF(BCPRNT.AND.IORIG(J).GT.0)THEN        !CHECK SPEC/CORR DISTRIB
          NTCC=NTCC+1                                  !NO OF SPEC TERMS
          IF(J-1.EQ.MTCC)MTCC=J             !HIGHEST SPEC BELOW ALL CORR
        ENDIF
C
        IF(.NOT.BAUX)GO TO 80
C
        II=(1-QPI(JJ))*ISS
        IF(BUNA.AND.IWRK2(I).GT.JIMXLS)II=0
        W=ISS*(QLI(JJ)+1)-1
        W=W/2
C
        IF(MODE.GT.0.AND.MWR.GT.0)THEN
          IF(BPRNT0)THEN
            if(nfk(i).gt.0)then
              WRITE(MW,511)J,IORIG(J),II,LSP,NFK(I),DRY
            else
              WRITE(MW,511)J,IORIG(J),II,LSP,NFK(I),DRY,iwrk2(i)
            endif
          ELSE
            WRITE(MWU)int(IORIG(J)),int(IZERO),int(II),int(LSP)
     X               ,int(IZERO),int(NFK(I)),DRY,int(iwrk2(i))
          ENDIF
        ENDIF
C
        IF(BPRNT0)THEN
          if(nfk(i).gt.0)then
            WRITE(6,995)J,I,DEM,II,LSP,NFK(I),MBCOR,DD,DRY
          else
            WRITE(6,995)J,I,DEM,II,LSP,NFK(I),MBCOR,DD,DRY,iwrk2(i)
          endif                                                 !NO CORR
          IF(MODE.EQ.1.AND.IORIG(J).GT.0.AND.IUNIT(14).GT.0)
     X    WRITE(14,992)ISP,LSP,IPP,NFK(I),NFI(I)-NTG(NFK(I)-1),DRY,MYRGE
        ENDIF
C
        IF(MENGB.GE.-1.AND.IORIG(J).GT.0.and.j.le.lupe)THEN     !NO CORR
          LSP=MIN(LSP,MXLAB2)
          ISS=MIN(ISS,MXLAB2)
          IS=0
          K=ABS(NFK(I))
          DO L=1,LMX(K)
            IS=IS+1
            JJK=ABS(QN(QLB(L,K)))
            IF(JJK.GT.9)THEN
              STRING(IS)=NUMB(JJK/10)
            ELSE
              STRING(IS)=' '
            ENDIF
            IS=IS+1
            STRING(IS)=NUMB(MOD(JJK,ITEN))
            IS=IS+1
            JJK=MIN(INT(QL(QLB(L,K))/2,SP),MXLAB1)
            STRING(IS)=BIGL(JJK)
            IS=IS+1
            N=MOD(INT(QSB(L,K),SP),I50)
            STRING(IS)=NUMB(N)
          ENDDO
          DO L=IS+1,MXSTRG
            STRING(L)=' '
          ENDDO
          if(badas)then                                      !adf04 only
            if(iunit(25).gt.0)then
              cstan=' '
              ceiss=' '
              if(ismx.le.mstrgh)then
                f542="(i5,1x,1a15,2x,' (',i1,')',i1,'(',f4.1,')',f21.4)"
                write(cstan(1:15),'(15a1)')(string(l),l=2,mstrgh)
                call xxcftr(itwo,cstan,ceiss)
                write(25,f542)nspece,ceiss(1:15),iss,lsp,w,dem
              else
                f543="(i5,1x,1a31,2x,' (',i1,')',i1,'(',f4.1,')',f21.4)"
                write(cstan(1:31),'(31a1)')(string(l),l=2,mxstrg)
                call xxcftr(itwo,cstan,ceiss)
                write(25,f543)nspece,ceiss(1:31),iss,lsp,w,dem
              endif
            endif
          else                                  !adf04 or adasex.in.form
            IF(ISMX.LE.MSTRGH)THEN
              F542="(I5,1X,15(A1),2X,' (',A1,')',A1,'(',F4.1,')',F21.4)"
              IF(IUNIT(21).GT.0)WRITE(21,F542)NSPECE
     X                 ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),W,DEM
              IF(IUNIT(25).GT.0)WRITE(25,F542)NSPECE
     X                 ,(STRING(L),L=2,MSTRGH),NUMB(ISS),NUMB(LSP),W,DEM
            ELSE
              F543="(I5,1X,31(A1),2X,' (',A1,')',A1,'(',F4.1,')',F21.4)"
              IF(IUNIT(21).GT.0)WRITE(21,F543)NSPECE
     X                 ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),W,DEM
              IF(IUNIT(25).GT.0)WRITE(25,F543)NSPECE
     X                 ,(STRING(L),L=2,MXSTRG),NUMB(ISS),NUMB(LSP),W,DEM
            ENDIF
          endif
        ENDIF
C
        IF(JTCC.NE.0.AND.BPRNT0)THEN
          IF(IOPTIM.EQ.0.AND.DELELS(I,1).NE.DZERO)THEN
            DD=2*DELELS(I,1)*DKCM
            WRITE(6,994)I,DD,(2*DELELS(I,L),L=1,JTCC)
          ELSEIF(IOPTIM.EQ.1.AND.DELELS(I,2).GE.DZERO)THEN
            T=DELELS(I,2)
            DD=DENERG(I)-T
            IF(J.EQ.1)THEN
              T=EFLG0
              DD=DD+DG0-T
            ENDIF
            DD=-DD*2
            DDD=DD*DKCM
            WRITE(6,994)I,DDD,DD,2*T
          ENDIF
        ENDIF
C
   80 ENDDO
C
C  *** END ENERGY WRITE LOOP
C
C DE-ALLOCATE LOCAL
C
      DEALLOCATE (LMX,QSB,QLB,ICF)
c
      if(allocated(nadlu))then
        deallocate (nadlu)
      endif
      if(allocated(iwrkn))then
        deallocate (iwrkn)
      endif
      if(allocated(ncf))then
        deallocate (ncf,kmap,iwrk1)
      endif
      if(allocated(decorn))then
        deallocate (decorn)
      endif
C
      IF(MODE.EQ.1.AND.BPRNT0.AND.IUNIT(14).GT.0)
     X                  WRITE(14,992)0,0,0,0,0,2*DG0
      IF(IUNIT(21).GT.0)WRITE(21,540)
      IF(IDW.NE.0)THEN
        WRITE(MR)NMETA
        WRITE(MR)(NMETAG(I),I=1,NSL0)
        NNN=NENERG
        IF(BECOR)NNN=-NNN                              !FLAG ENERGY CORR
        WRITE(MR)NNN,KCUT
        WRITE(MR)(IORIG(I),I=1,NENERG)
        WRITE(MR)(DENERG(abs(IORIG(I)))*DTWO,I=1,NENERG)
        WRITE(MR)NCTOT
        WRITE(MR)(TFU(I),I=1,NCTOT)
      ENDIF
      IF(IAUTO.Le.0)IAUTO=NENERG+1
C
C GET ANY CF'S PARTITION ABOUT IONIZATION LIMIT (ENERGIES AND WEIGHTS)
C
      IF(NMETAP.GT.0)THEN
        NMM=MIN(NMM,NMETAP)
      ELSE
        NMM=MIN(-NRSLMX,KMAX)
      ENDIF
C
C LOCAL
      IF(NMM.GT.0)THEN
        ALLOCATE (JCP(NMM),JTP(NMM),JWRN(NMM),JWRD(NMM)
     X          ,ERN(NMM),ERD(NMM))
      ENDIF
C
      IF(NMETAP.GT.0)THEN
C
        ALLOCATE (JRP(NENERG))
C
        J=0
        DO J0=1,NENERG
          I=IORIG(J0)
          I=ABS(I)                                    !CASE CORR.
          IF(NFK(I).GT.0)THEN
            J=J+1
            JTP(J)=I
            JCP(J)=NFK(I)
            JJ=NFQ(I)
            JWRN(J)=(QSI(JJ)+1)*(QLI(JJ)+1)
            JWRD(J)=JWRN(J)
            ERN(J)=DENERG(I)+DG0
            ERN(J)=ERN(J)*2
            ERD(J)=ERN(J)
            NLASTP=J0
            IF(J.EQ.NMM)THEN                           !WE ARE DONE
              DO K=J0,NENERG
                JRP(K)=J
              ENDDO
              GO TO 177
            ENDIF
          ENDIF
          JRP(J0)=J
        ENDDO
 177    NMM=J                                          !ACTUAL FOUND
      ENDIF
C
      NMM0=NMM
C
      IF(NRSLMX.LT.0)THEN
        DO K=1,NMM
          JTP(K)=0
          JCP(K)=K
          ERN(K)=DZERO
          ERD(K)=DZERO
          JWRN(K)=0
          JWRD(K)=0
        ENDDO
        DO J=1,NENERG
          I=IORIG(J)
          I=ABS(I)                                    !CASE CORR.
          K=NFK(I)
          IF(K*K.LE.NMM*K)THEN                         !OMITS K<0: CONT
            JJ=NFQ(I)
            JW=(QSI(JJ)+1)*(QLI(JJ)+1)
            IF(DENERG(I).LT.EMIN)THEN
              ERN(K)=ERN(K)+DENERG(I)*JW
              JWRN(K)=JWRN(K)+JW
            ELSE
              ERD(K)=ERD(K)+DENERG(I)*JW
              JWRD(K)=JWRD(K)+JW
            ENDIF
          ENDIF
        ENDDO
        DO K=1,NMM
          IF(JWRN(K).GT.0)THEN
            ERN(K)=ERN(K)/JWRN(K)
            ERN(K)=ERN(K)+DG0
            ERN(K)=ERN(K)*2
          ENDIF
          IF(JWRD(K).GT.0)THEN
            ERD(K)=ERD(K)/JWRD(K)
            ERD(K)=ERD(K)+DG0
            ERD(K)=ERD(K)*2
          ENDIF
c          m=jwrn(k)+jwrd(k)
c          if(m.gt.0.and.k.le.ncut)then             !also needs nast=0
c            if(m.ne.mstat(k))then                     !checksum error
c              write(6,*)'cf=',k,' s.w. checksum error:',mstat(k),m
c              go to 2000
c            endif
c          endif
        ENDDO
      ENDIF
C
C   PRINT OUT DETAILED INFORMATION ABOUT CI FOR LOWEST ITANAL TERMS
C
      IF(ITANAL.NE.0)THEN
C
        IF(ITANAL.LT.0)WRITE(6,1749)ITANAL,ECNTRB
C
        ALLOCATE (NCFBIG(KMAX,2))
        ALLOCATE (NX1(NF),LX1(NF))
C
        NBIGC=0
        NCFBIG(1,1)=0
        DO J=1,NENERG
          L=NFI(J)
          ID(L)=-J
          DVECA(J)=DZERO
        ENDDO
        ITAN=ABS(ITANAL)
        ITAN=MIN(ITAN,NENERG)
        DO II=1,ITAN
          I=IORIG(II)
          IF(I.LT.0)GO TO 530                     !CASE CORRELATION
          L=NFI(I)
          ID(L)=ABS(ID(L))
          LSG=NFQ(I)
          IJ=(QSI(LSG)+1)*(1-QPI(LSG))
          JJ=QLI(LSG)/2
          IF(ITANAL.GT.0)WRITE(6,1751)II,IJ,JJ,DWRK(I)
          K1=NGRPI(LSG)+1                         !=I-NAI(I)+1
          K2=K1+NSL(LSG)-1
C
          DO K=K1,K2
            N1=NADRU(I)+NAI(K)
            DD1=TFU(N1)
            DRY=DWRK(K)-DWRK(I)
            DD=DRY*DD1*DD1
            KK=NFK(K)
            KK=ABS(KK)                           !CASE CONTINUUM
            L=NFI(K)
C  Add this CF to list of those that contribute more than
C  ECNTRB wavenumbers to the energy of this state
            DDA=ABS(DD)
            IF(DDA.GT.ECNTRB)THEN
              ID(L)=ABS(ID(L))
              IF(ITANAL.GT.0)THEN
                DO IJ=1,NBIGC
                  IF(NCFBIG(IJ,1).EQ.KK)GO TO 1699
                ENDDO
                NBIGC=NBIGC+1
                NCFBIG(NBIGC,1)=KK
                NCFBIG(NBIGC,2)=QPI(LSG)
              ENDIF
            ELSE
              DVECA(L)=MAX(DDA,DVECA(L))
            ENDIF
 1699       IF(ITANAL.GT.0)THEN
              DO IJ=1,NF
                NN=QCG(IJ,KK)
                NX1(IJ)=QN(NN)
                LX1(IJ)=QL(NN)/2
              ENDDO
              WRITE(6,1750)K,KK,DD1,DRY,DD
     X                                ,(NX1(IJ),LX1(IJ),IJ=1,NF)
            ENDIF
          ENDDO
  530   ENDDO
C
        IF(NBIGC.GT.0)WRITE(6,1604)ECNTRB
        DO K1=1,NBIGC
          KK=NCFBIG(K1,1)
          DO IJ=1,NF
            NN=QCG(IJ,KK)
            NX1(IJ)=QN(NN)
            LX1(IJ)=QL(NN)/2
          ENDDO
          WRITE(6,1603)K1,KK,NCFBIG(K1,2),(NX1(IJ),LX1(IJ),IJ=1,NF)
        ENDDO
C
        DO K=1,KMAX
          IF(BANAL(K))GO TO 534                 !WAS RESTRICTED IN ALGEB
          ID0=0
          N1=NTG(K-1)+1
          N2=NTG(K)
          DO I=N1,N2
            IF(ID(I).LT.0)ID0=ID0+1
          ENDDO
          IF(ID0.GT.0)THEN
            DO IJ=1,NF
              NN=QCG(IJ,K)
              NX1(IJ)=QN(NN)
              LX1(IJ)=QL(NN)/2
            ENDDO
            KK=K
            IF(K.GT.NCUT)KK=-KK
            NT1=NTG(K)-NTG(K-1)
            WRITE(31,531)ID0,NT1,KK,NF,(NX1(IJ),LX1(IJ),IJ=1,NF)
            I0=0
            DO I=N1,N2
              I0=I0+1
              IF(ID(I).LT.0)WRITE(31,532)I0,-ID(I),DVECA(I)
            ENDDO
          ENDIF
  534   ENDDO
C
        DEALLOCATE (NCFBIG)
        DEALLOCATE (NX1,LX1)
C
      ENDIF
C
C WRITE LS PROLOGUE TO TCC FILES
C
      IF(BCPRNT.AND.KTCC.LT.0)THEN
C
C TCC.DAT JAJOM FORMAT
C   MTCC SPECTROSCOPIC TERMS LYING BELOW ALL CORRELATION
C
        WRITE(1,519)MTCC,NENERG,KCUT
        DO J=1,MTCC
          I=IORIG(J)
          JJ=NFQ(I)
          WRITE(1,518)J,QSI(JJ)+1,QLI(JJ)/2,QPI(JJ)/2,DENERG(I)*DTWO
        ENDDO
C
      ELSEIF(BCPRNT.AND.KTCC.GT.0)THEN
C
C TCCDW.DAT STGICF FORMAT
C   NTCC SPECTROSCOPIC TERMS WHICH MAYBE INTERSPERSED WITH CORRELATION
C   WRITE FULL TERM LIST AND FLAG CORRELATION FOR STGICF TO ELIMINATE
C   SAID COMPONENTS AND RE-ORTHOINORMALIZE THE TCCS.
C
        N0=NENERG
        IF(NTCC.NE.NENERG)N0=-N0
        LAB4=' C&S'
        IF(BFANO)LAB4='FANO'
        WRITE(4,520)NTCC,N0,LAB4
        DO J=1,NENERG
          I0=IORIG(J)
          I=ABS(I0)
          JJ=NFQ(I)
          J0=J
          IF(I0.LT.0)J0=-J
          WRITE(4,521)J0,QSI(JJ)+1,QLI(JJ)/2,QPI(JJ)/2,DENERG(I)*DTWO,I
        ENDDO
      ENDIF
C
C ALTERNATE FORM OF ENERGY FUNCTIONAL
C
      IF(DS.EQ.DZERO)THEN
        DS=DONE
        DECORE=DZERO
        DO I=1,LL
          II=-INDEXW(I)
          IF(II.EQ.0)II=IORIG(I)
          DO J=1,I
            JJ=-INDEXW(J)
            IF(JJ.EQ.0)JJ=IORIG(J)
            DF=(DWRK(II)-DWRK(JJ)-WGHT(I)+WGHT(J) )**2+DF
          ENDDO
          IF(BAUX)WRITE(6,70)I,DWRK(II),WGHT(I),DF
        ENDDO
      ENDIF
C
C FINALIZE ENERGY FUNCTIONAL DF
C
      DF=DF/DS
C
C DE-ALLOCATE
C
 7600 CONTINUE
C
      IF(BALLH)THEN
        DEALLOCATE (DU,DVU,DE,IDY,NVEC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)
     X         'DIAGON: DE-ALLOCATION FAILS FOR DU,DVU,DE,IDY,NVEC'
          NF=MIN(NF,IZERO)
        ENDIF
        IF(BPRNT0.AND.ALLOCATED(DVP))THEN
          DEALLOCATE (DVP,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR DVP'
            NF=MIN(NF,IZERO)
          ENDIF
        ENDIF
        BALLH=.FALSE.
      ENDIF
C
      IF(BALLA)THEN
        DEALLOCATE (DUI,DVI,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR DUI,DVI'
          NF=MIN(NF,IZERO)
        ENDIF
        DEALLOCATE (DDY)
        BALLA=.FALSE.
      ENDIF
C
      IF(NF.LE.0)GO TO 750                                       !RETURN
C
c      IF(BREL)GO TO 750         !Comment-out for LSR      !NPRINT.LE.-5
C
C
C********************************************
C
C   ***COMPUTE MULTIPOLE RADIATIVE DATA***
C
C********************************************
CNRB: RE-WRITTEN FOR N^3 MULT. AND TO USE THE
C LOOP OVER ALG STORAGE AS ONE OF THESE LOOPS.
C********************************************
C
C
      NGF=0
      SGF=DZERO
      IF(.NOT.BRADAT.OR.NPRNT5.EQ.-2)GO TO 745
      IF(.NOT.BINT)GO TO 710
C
      NPOSX=(IOS-IRK)
      if(nposx.le.0)go to 745
      BPOS=.TRUE.                                         !FORCE FOR NOW
      BOMRC=.FALSE.
C
      MXORB2=MXORBR*MXORBR                                        !FLAGX
C
      MX=MPOLX
      MX=MX-MPOL0                                                 !FLAGX
      MXPOL=MAX(IONE,MX/2+1)
C
      IF(BPOS)THEN                           !PRE-DECODE ADDRESS
C
        ALLOCATE (NPOS(4,NPOSX),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON:    ALLOCATION FAILS FOR NPOS'
          NF=0
          GO TO 750                                 !RETURN
        ENDIF
C
        i1=mb+1                                                   !FLAGX
        i2=i1
        NPOS0=IRK
        MCI=0
        DO NC=1,NSL0
          MC=NSL(NC)
          DO ND=1,NC
            N1=NED(1,ND,MCI+1)
            IF(N1.GT.0)THEN
              DO MD1=1,MC
                ND1=MD1+MCI
                N1=NED(1,ND,ND1)
                N2=NED(2,ND,ND1)
                if(irlx.lt.0)then
                  kf=abs(nfk(nd1))
                  i1=icfgp(kf)*mb+1
                endif
                DO M=N1,N2
                  NS=M-NPOS0
                  n8=MXORB2*MXPOL
                  M1=INT(NRK(M)/n8)
                  M2=M1+1
                  NPOS(1,NS)=M2                     !TERM
                  if(irlx.lt.0)then
                    kg=abs(nfk(m2))
                    i2=icfgp(kg)*mb+1
                  endif
                  n8=M1*n8
                  MX=INT((NRK(M)-n8)/MXORB2)
                  MK=MX
                  MK=MK+MPOL0/2                                   !FLAGX
                  NPOS(2,NS)=MK                     !MULTIPOLE
                  n8=n8+MX*MXORB2
                  n8=NRK(M)-n8
                  M0=INT(n8/MXORBR)
                  M1=M0+I1
                  MM=INT(n8-M0*MXORBR+I2)
                  M2=MIN(M1,MM)
                  NPOS(3,NS)=M2                     !ORBITAL
                  M1=M1+MM-M2
                  IF(MM.NE.M1)M1=-M1
                  NPOS(4,NS)=M1                     !ORBITAL
c         write(6,*)mxorb2*mxpol,npos(1,ns),mxorb2,mx,mxorbr,m1,i1,mm,i2
                ENDDO
              ENDDO
            ENDIF
          ENDDO
          MCI=MCI+MC
        ENDDO
      ELSE
        NPOS0=0
        WRITE(6,1605)NPOSX
        WRITE(0,1605)NPOSX
      ENDIF
C
      IF(.NOT.BFOTJ)THEN
C        ALLOCATE (DVECF(MENG,NENERG),STAT=IERR)
        ALLOCATE (DVECF(NENERG,MENG),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON:    ALLOCATION FAILS FOR DVECF'
          NF=0
          GO TO 7450
        ENDIF
      ENDIF
C
      ALLOCATE (IDY(IAXDI),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DIAGON:    ALLOCATION FAILS FOR IDY'
        NF=0
        GO TO 7450
      ENDIF
C LOCAL
      K0=MAX(IZERO,NMM)
      ALLOCATE (SUMRN(0:K0),SUMRD(0:K0))
C
      IF(BUNPR)THEN
        ALLOCATE (SUMPN(MENG,0:K0),SUMPD(MENG,0:K0))
      ENDIF
C
      BAUX=JPRINT.EQ.1.OR.JPRINT.GT.4      !.NOT.BAUX IGNORE CORRELATION
C
      BDEL=MDEL.GT.0
      IF(IDIAG.LT.0.AND.BDEL)WLG0=DTEN**MDEL
      DEM=2*DG0                               !GROUND ENERGY (RYD)
      IF(EIONMN.EQ.DZERO)EIONMN=etest         !ENABLE B-C SPLIT
      IF(NMETAP.GT.0)etest=dzero              !no rad bundle for upward
C
      IF(BPRNT0.AND.MODE.GT.0)WRITE(MW,508)NZION,MION
      IF(.NOT.BPRNT0.AND.MODE.GT.0)WRITE(MWU)int(NZION),int(MION)
C
      STOL=STOLB
      IF(MENGB.NE.1)STOL=100*STOL
      WLGO=100*STOL/DZA2
C
      IF(MENGB.GE.-1)THEN                     !INITIALIZE OMEGA BORN
C
        WRITE(6,989)
        TOLO=D1M10
c
        if(nmeta.gt.0)then
          nmin=min(NMETA,NSPECE)
          ixr=irow(nmin,nspece,ione1,nspece)
          ixc=0
          if(idw.eq.0.and.ABS(MENGB).EQ.1)ixc=icol(nmin,nspece,ione1)
          nomwrt=max(ixr,ixc)
        else
          NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
        endif
C
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY ONLY
C
          BSCRO=.TRUE.       !(REMOVE "ELSE" TO USE INTERNAL - WASTEFUL)
C
          ALLOCATE (OMR(NOMWRT),OMC(NOMWRT),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'DIAGON: ALLOCATION FAILS FOR OMR,OMC'
            NF=0
            GO TO 7450
          ENDIF
          BOMRC=.TRUE.
          NOMWRX=NOMWRT
C
          IF(NOMWRT.GT.NOMWRX)THEN            !NO LONGER POSSIBLE
            NNN=2*NOMWRT/MENG+1
            WRITE(6,991)NNN
            WRITE(0,*)'*** WORKING ARRAYS TOO SMALL IN SR.DIAGON'
            GO TO 3000
          ENDIF
          DO I=1,NOMWRX
            OMR(I)=DZERO
            OMC(I)=DZERO
          ENDDO
C
        ELSE                                  !FINITE ENERGY
C
          BSCRO=.TRUE.      !.T. USE SCRATCH FILE, .F. STORE INTERNALLY
C
          IF(.NOT.BSCRO)THEN
            ALLOCATE (OMEGA(0:MXNXB1,NOMWRT),STAT=IERR)
            IF(IERR.NE.0)THEN
              BSCRO=.TRUE.
            ELSE
              BSCRO=.FALSE.
            ENDIF
          ENDIF
          NOMWRY=NOMWRT
C
C
          IF(BSCRO)THEN
C            WRITE(0,*)'DIAGON: USING SCRATCH FOR BORN MULTIPOLE SUM'
C            WRITE(6,*)'DIAGON: USING SCRATCH FOR BORN MULTIPOLE SUM'
          ELSE
            DO N=1,NOMWRT
              DO NX=0,MXNXB1
                OMEGA(NX,N)=0
              ENDDO
            ENDDO
          ENDIF
C
          DO NX=1,MXNXB
            XS(NX)=SQRT(DONE-DONE/XB(NX))
          ENDDO
C
        ENDIF
C
        MSC0=80
        MSC=MSC0-1
        IBOMX=0
c        ibifmx=0
C
      ENDIF
C                 INITIALIZE GEOMETRIC COEFFICIENTS
      ALLOCATE (DG(0:IXBLM))
C
      DG(0)=DZERO
      IF(MPOLE.LE.8)THEN
        IP=1
        DO I=2,MPOLE,2
          IP=IP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*REAL(IP,WP)*REAL(IP,WP))
        ENDDO
      ELSE
        TIP=1
        DO I=2,MPOLE,2
          TIP=TIP*(I+1)*2
          IM=I/2
          DG(IM)=2*(I+1)*(IM+1)
          DG(IM)=DG(IM)/(IM*TIP*TIP)
c          write(0,*)im,tip,2*(i+1)*(im+1),im*tip*tip,dg(im)
        ENDDO
      ENDIF
c
c for born usage
c
cbu      ixd34=((ixd33+1)*ixd33)/2
cbu      allocate (iflagb(ixd34))
c
               if(btime)call cpu_time(timei)
C
      MLAM=MPOL00-2
  740 MLAM=MLAM+2
      NGROUP=MLAM/2
C
      BBORN=MENGB.GT.1.OR.(MENGB.EQ.1.AND.NGROUP.NE.1)
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG
C      BFOTJ=BFOTJ.OR.NGROUP.NE.1            !UNCOMMENT TO WRITE E1 ONLY
      BFAST=.NOT.BBORN.AND..NOT.BPRNT0.AND.BELONG.and.includ.eq.0
c      bfast=.false.
C
      IF(BSCRO)THEN                                         !MENGB.GE.-1
        MSC=MSC0+NGROUP
        OPEN(MSC,STATUS='SCRATCH',FORM='UNFORMATTED')
      ENDIF
c
cbu      if(bborn)then       !initialize flag to count Born usage
cbu        do i=1,mb4(0)
cbu          iflagb(i)=-1
cbu        enddo
cbu      endif
C
      IF(NGROUP.EQ.1)THEN
        MP=0
        IF(BPRNT0)THEN
          WRITE(6,*)' '
          IF(.NOT.BELONG)WRITE(6,601)
          WRITE(6,600)NGROUP
        ENDIF
        IF(WLG1.LT.DZERO)THEN
          WLG=D1M2
          IF(IDIAG.LT.0.AND.BDEL)WLG=WLG0
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG1)
        WLGS=DKON
        IF(NPRNT5.GE.0)WLGS=D1M20
      ELSE
        MP=5
        IF(BPRNT0)THEN
          WRITE(6,*)' '
          IF(.NOT.BELONG)WRITE(6,810)
          IF(NGROUP.LT.10)THEN
            WRITE(6,800)NGROUP,MP
          ELSE
            WRITE(6,801)NGROUP,MP
          ENDIF
        ENDIF
        IF(WLG2.LT.DZERO)THEN
          WLG=D1M7
        ELSE
          WLG=DZERO
        ENDIF
        WLG=MAX(WLG,WLG2)
        WLGS=DKON
      ENDIF
      ISGNN=1-2*mod(abs(NGROUP),ITWO)                   !(-1)**NGROUP
C
      JOS=0
      KTRAN=0
      JPOLD=-1
      IIMN=1                                          !case jjmn.gt.jjmx
      ILF=ione1
      JJMN=1+ione1
      JJMX=NENERG
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.2.OR.JRAD.EQ.3.OR.JRAD.EQ.5)JJMN=MAX(JJMN,IAUTO)
        IF(JRAD.EQ.1)JJMX=MIN(IAUTO-1,NENERG)
      ENDIF
      JJMN=MAX(JJMN,LUPMN)
      JJMX=MIN(JJMX,LUPMX)
C
C***********************************
C START LOOP OVER UPPER ENERGY TERMS
C***********************************
C
      DO 732 JJ=JJMN,JJMX
C
      IF(.NOT.BAUX.AND.IORIG(JJ).LT.0)GO TO 732             !CORRELATION
      IF(IORIG(JJ).GT.0)THEN
        ILF=ILF+1
      ELSE
        KTRAN=-KTRAN
      ENDIF
      J=ABS(IORIG(JJ))
C
      IF(NFK(J).LT.0)THEN                     !CONT
        IF(.NOT.BFOT)GO TO 732                !BUT NO PI
        IF(BDOWN.AND.BUNPA.AND.IWRK2(J).GT.JIMXLS)GO TO 732      !FOR RR
      ENDIF
C
      ND=NFQ(J)                               !INITIAL GROUP
      NCD=NGRPI(ND)                           !=J-NAI(J)
c
            if(btime)call cpu_time(timeir)
c
c flag if mixing coefficient exists
c
      if(mode.ne.2)then                       !b-b only
        if(bkutls)then
          do n=1,nsl(nd)
            i=ncd+n
            if(nfk(i).eq.nfk(j))then
              idy(n)=-1
            else
              idy(n)=0
            endif
          enddo
        else
          do n=1,nsl(nd)
            idy(n)=-1
          enddo
        endif
      elseif(nfk(j).gt.0)then                 !j is bound
        do n=1,nsl(nd)
          i=ncd+n
          if(bkutls)then
            btest=nfk(i).eq.nfk(j)            !scf
          else
            btest=nfk(i).gt.0                 !b-b
          endif
          if(btest)then
            idy(n)=-1
          else                                !b-c
            idy(n)=0
          endif
        enddo
      else                                    !j is continuum
        if(.not.bkutls)then
          m=-nfk(j)
          m=qcg(nf,m)
          ij=ieq(m)
        endif
        do n=1,nsl(nd)
          i=ncd+n
          if(nfk(i).gt.0)then                 !c-b
            idy(n)=0
          else
            if(bkutls)then
              btest=nfk(i).eq.nfk(j)          !c-c
            else
              m=-nfk(i)
              m=qcg(nf,m)
              btest=ieq(m).eq.ij              !c-c
            endif
            if(btest)then
              idy(n)=1
            else                              !c-c'
              idy(n)=0
            endif
          endif
        enddo
      endif
C
      IIMN=1
      IIMX=JJ-ione1
      if(nmeta.gt.0)iimx=min(iimx,nmeta)
      IF(NMETAP.GT.0)IIMX=MIN(IIMX,NLASTP)
      IF(JRAD.GT.0)THEN
        IF(JRAD.EQ.3)IIMN=MAX(IONE,IAUTO)
        IF(JRAD.EQ.1.OR.JRAD.EQ.2.OR.JRAD.EQ.4)IIMX=MIN(IAUTO-1,IIMX)
      ENDIF
      IF(.NOT.BUNA)THEN                 !OUTWITH DROPPED, NOT BUNDLED
        IIMN=MAX(IIMN,LLOWMN)
        IIMX=MIN(IIMX,LLOWMX)
      ENDIF
C
C INITIALIZE/ZEROIZE
C
      DO I=1,NENERG
        IWRK4(I)=ABS(IWRK4(I))
        DVECL(I)=DZERO
        DVECV(I)=DZERO
        DVECA(I)=DZERO
      ENDDO
C
      IF(.NOT.BFOTJ.AND.NFK(J).LT.0)THEN
        DO I=1,NENERG
          DO M8=1,MENG
C            DVECF(M8,I)=DZERO
            DVECF(I,M8)=DZERO
          ENDDO
        ENDDO
      ENDIF
C
C PRE-DETERMINE (MAXIMAL) BORN USAGE (IXBIF):
C
      IF(BBORN)THEN
C
        IBO=0                              !INITIALIZE
        DO I=1,NENERG
          ID(I)=0
        ENDDO
C
        NCC=0
        DO NC=1,NSL0                       !BEGIN LOOP OVER FINAL GROUPS
C
        IF(QSI(ND).NE.QSI(NC))GO TO 2333
        IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 2333
        ML=QPI(ND)+QPI(NC)
        IF(MOD(ML+MLAM,IFOUR).NE.0)GO TO 2333
        ML=QLI(ND)+QLI(NC)
        IF(ML.LT.MLAM)GO TO 2333
        ML=ABS(QLI(ND)-QLI(NC))
        IF(ML.GT.MLAM)GO TO 2333
C
        DO N=1,NSL(NC)
          I=NCC+N
          IF(IWRK4(I).Le.JJ-ione1.AND.IWRK4(I).LE.IIMX.AND.NFK(I).GT.0
     X                                                           )THEN
C     X     .AND.IWRKX(I).GE.IIMN       !IWRKX NOT SET-UP YET
            IWRK4(I)=-ABS(IWRK4(I))       !FLAG EXISTS
          ENDIF
        ENDDO

        BEQGRP=ND.EQ.NC
        BING=ND.LE.NC
        IF(BING)THEN
          NU=NC
          NL=ND
          NNN=NCC
        ELSE
          NU=ND
          NL=NC
          NNN=NCD
        ENDIF
C
        IF(NED(1,NL,NNN+1).EQ.0)GO TO 2333
C
        DO 2330 N=1,NSL(NU)                !BEGIN LOOP OVER UPPER
C                                          !SYMMETRY ORDER TERMS
        I0=NNN+N
C
  230   IF(BING)THEN
          I=I0
          IF(IWRK4(I).GT.0)GO TO 2320
        ELSE
          L=I0
          if(idy(l-ncd).eq.0)go to 2320
c          NI=NADRU(J)+NAI(L)
c          DD2=TFU(NI)
c          IF(ABS(DD2).LT.CMXLSR)GO TO 2320      !possibly safer to skip
        ENDIF
C
        N1=NED(1,NL,I0)-NPOS0
        N2=NED(2,NL,I0)-NPOS0
C
        DO 236 M=N1,N2
C
        IF(BPOS)THEN
          M2=NPOS(1,M)
        ELSE
          n8=MXORB2*MXPOL
          M1=INT(NRK(M)/n8)
          M2=M1+1
        ENDIF
C
        IF(BING)THEN
          L=M2
          if(idy(l-ncd).eq.0)go to 236
c          NI=NADRU(J)+NAI(L)
c          DD2=TFU(NI)
c          IF(ABS(DD2).LT.CMXLSR)GO TO 236       !possibly safer to skip
        ELSE
          IF(I0.EQ.M2)GO TO 236            !AVOID DOUBLE COUNTING
          I=M2
          IF(IWRK4(I).GT.0)GO TO 236
        ENDIF
C
        IF(BPOS)THEN
          MK=NPOS(2,M)
          IF(MK.NE.NGROUP)GO TO 236
        ELSE
          n8=M1*n8
          MX=INT((NRK(M)-n8)/MXORB2)
          MK=MX
          MK=MK+MPOL0/2                                           !FLAGX
          IF(MK.NE.NGROUP)GO TO 236
        ENDIF
C
COLD        IG=I                           !STORE IN ORIGINAL GROUP POSN
        ig=iwrkg(nc-1)+nai(i)             !store in e-vector posn as tfu
        if(bkutls)ig=ig+iwrkb(1,nfk(i),nc)
C
        IF(ID(IG).EQ.0)THEN
          IBO=IBO+1
          ID(IG)=IBO
        ENDIF
C
  236   CONTINUE
C
 2320   IF(BEQGRP)THEN                           !PICK-UP OTHER HALF
          IF(BING)THEN
            BING=.FALSE.
            GO TO 230
          ELSE
            BING=.TRUE.
          ENDIF
        ENDIF
C
 2330   CONTINUE                                 !END LOOP OVER TERMS
C
 2333   NCC=NCC+NSL(NC)
        ENDDO                                    !END LOOP OVER GROUPS
C
        IXBIF=IBO
C
        IF(IXBIF.GT.MXBIF)THEN
          IF(MXBIF.GT.0)WRITE(6,1137)IXBIF,MXBIF
        ENDIF
c        write(0,*)ixbif
c        ibifmx=max(ibifmx,ixbif)
C
        ALLOCATE (DBL(IXD33,IXBIF),STAT=IERR)    !MXBIF
        IF(IERR.NE.0)THEN
          WRITE(0,*)'SR.DIAGON: ALLOCATION FAILS FOR DBL'
          NF=0
          GO TO 7450
        ENDIF
C                                                !RE-INITIALIZE
        IBO=0
        DO I=1,NENERG
          ID(I)=0
        ENDDO
C
      ENDIF
C
C*********************************************************************
C PRE-MULTIPLY MULTIPOLE MATRIX FOR ALL FINAL STATES (NC) BY
C INITIAL MIXING MATRIX (ND)
C (ALL, BECAUSE THE FINAL STATES ARE TO BE MIXED SUBSEQUENTLY)
C*********************************************************************
C
      NCC=0
      DO NC=1,NSL0                      !BEGIN LOOP OVER FINAL GROUPS
C
C FOR SPEED PRE-SELECT ACCORDING TO MULTIPLICITY, PARITY, TOTAL L:
C
      IF(QSI(ND).NE.QSI(NC))GO TO 7333
      IF(NMETAG(NC)+NMETAG(ND).GT.1)GO TO 7333
      ML=QPI(ND)+QPI(NC)
      IF(MOD(ML+MLAM,IFOUR).NE.0)GO TO 7333
      ML=QLI(ND)+QLI(NC)
      IF(ML.LT.MLAM)GO TO 7333
      ML=ABS(QLI(ND)-QLI(NC))
      IF(ML.GT.MLAM)GO TO 7333
      DS=1-MOD(ML,IFOUR)
      IF(BFANO)DS=DS*ISGNN
C
      DO N=1,NSL(NC)
        I=NCC+N
        IF(IWRK4(I).Le.JJ-ione1.AND.IWRK4(I).LE.IIMX.AND.NFK(I).GT.0
     X                                                         )THEN
C     X   .AND.IWRKX(I).GE.IIMN       !IWRKX NOT SET-UP YET
          IWRK4(I)=-ABS(IWRK4(I))       !FLAG EXISTS
        ENDIF
      ENDDO

      BEQGRP=ND.EQ.NC
      BING=ND.LE.NC
      IF(BING)THEN
        NU=NC
        NL=ND
        NNN=NCC
      ELSE
        NU=ND
        NL=NC
        NNN=NCD
      ENDIF
C
      IF(NED(1,NL,NNN+1).EQ.0)GO TO 7333
C
      DO 7330 N=1,NSL(NU)                !BEGIN LOOP OVER UPPER
C                                        !SYMMETRY ORDER TERMS
      I0=NNN+N
C
  730 IF(BING)THEN
        I=I0
        IF(IWRK4(I).GT.0)GO TO 7320
      ELSE
        L=I0
        if(idy(l-ncd).eq.0)go to 7320
        NI=NADRU(J)+NAI(L)
        DD2=TFU(NI)
        IF(ABS(DD2).LT.CMXLSR)GO TO 7320
      ENDIF
C
      N1=NED(1,NL,I0)-NPOS0
      N2=NED(2,NL,I0)-NPOS0
C
      DO 736 M=N1,N2
C
      IF(BPOS)THEN
        M2=NPOS(1,M)
      ELSE
        n8=MXORB2*MXPOL
        M1=INT(NRK(M)/n8)
        M2=M1+1
      ENDIF
C
      IF(BING)THEN
        L=M2
        if(idy(l-ncd).eq.0)go to 736
        NI=NADRU(J)+NAI(L)
        DD2=TFU(NI)
        IF(ABS(DD2).LT.CMXLSR)GO TO 736
      ELSE
        IF(I0.EQ.M2)GO TO 736  !AVOID DOUBLE COUNTING
        I=M2
        IF(IWRK4(I).GT.0)GO TO 736
      ENDIF
C
      IF(BPOS)THEN
        MK=NPOS(2,M)
        IF(MK.NE.NGROUP)GO TO 736
        M2=NPOS(3,M)
        MM=NPOS(4,M)
        M1=ABS(MM)
      ELSE
        n8=M1*n8
        MX=INT((NRK(M)-n8)/MXORB2)
        MK=MX
        MK=MK+MPOL0/2                                             !FLAGX
        IF(MK.NE.NGROUP)GO TO 736
        n8=n8+MX*MXORB2
        n8=NRK(M)-n8
        I1=1
        I1=I1+MB                                                  !FLAGX
        M0=INT(n8/MXORBR)
        M1=M0+I1
        MM=INT(n8-M0*MXORBR+I1)
        M2=MIN(M1,MM)
        M1=M1+MM-M2
      ENDIF
C
      DRY=DD2*DRK(M+NPOS0)
      BINT=I.LE.L                         !DOWN TRUE
      IF(.NOT.BINT)DRY=DRY*DS             !UP->DOWN
      DB=DOSC(NGROUP,M1,M2)
C
COLD      IG=I                            !STORE IN ORIGINAL GROUP POSN
      ig=iwrkg(nc-1)+nai(i)               !store in e-vector posn as tfu
      if(bkutls)ig=ig+iwrkb(1,nfk(i),nc)
C
      DVECL(IG)=DVECL(IG)+DB*DRY          !LENGTH
C
      IF(BREL.AND.NFK(J).GT.0.and.irtard.gt.0)THEN !RETARD ALREADY ON PI
        DDD=DENERG(I)-DENERG(L)
        DDD=4*DDD*DDD*DRY
        DVECL(IG)=DVECL(IG)-DALF4*DDD*DOSC(NGROUP+2,M1,M2)/(4*NGROUP+6)
      ENDIF
C
      IF(.NOT.BFOTJ.AND.NFK(J).LT.0)THEN  !PHOTO
        M7=NFOSS(ngroup/2,M1,M2)
        IF(M7.GT.0)THEN
          ISYGN=1
          IF(MM.NE.M1)ISYGN=-ISYGN
          IF(.NOT.BINT)ISYGN=-ISYGN
          IF(ISYGN.LT.0)THEN
            DO M8=1,MENG
              DB=DRY                      !LENGTH/ACCELERATION
              IF(IGAG(M8).EQ.0)DB=-DB     !VELOCITY
C              DVECF(M8,IG)=DVECF(M8,IG)+DFOSS(M7,M8,1)*DB
              DVECF(IG,M8)=DVECF(IG,M8)+DFOSS(M7,M8,1)*DB
            ENDDO
          ELSE
            DO M8=1,MENG
C              DVECF(M8,IG)=DVECF(M8,IG)+DFOSS(M7,M8,1)*DRY
              DVECF(IG,M8)=DVECF(IG,M8)+DFOSS(M7,M8,1)*DRY
            ENDDO
          ENDIF
        ENDIF
      ENDIF
C
      IF(BFAST)GO TO 736
C
      DB=DZERO              !CHANGE OF ORBITAL TO TERM ORDER (VEL)
      IF(M2.NE.M1)THEN
        DB=DOSC(NGROUP,M2,M1)
      ELSE
        IF(NGROUP.GT.0)DB=DOSC(NGROUP-1,M2,M1)
      ENDIF
      IF(MM.NE.M1)DB=-DB
      IF(.NOT.BINT)DB=-DB
      DVECV(IG)=DVECV(IG)+DB*DRY            !VELOCITY
      DVECA(IG)=DVECA(IG)+DRY*ACC(M1,M2)    !ACCELERATION
C
      IF(BBORN)THEN         !BORN
        IF(ID(IG).EQ.0)THEN
          IBO=IBO+1
          IF(IBO.LE.IXBIF)THEN
            ID(IG)=IBO
            DO IX=1,MB3(0)
              DBL(IX,IBO)=DZERO
            ENDDO
          ELSE
            ID(IG)=-IBO
          ENDIF
        ENDIF
        IF(ID(IG).GT.0)THEN
          IB=ID(IG)
          IN=ICOL(M2,M1,IZERO)
          IF(BINDB(IN,NGROUP/2))THEN
            IX=INDX(IN)
            DBL(IX,IB)=DBL(IX,IB)+DRY
          ELSE
            II=IEORD(I)
            LL=IEORD(L)
            WRITE(0,*)'DIAGON: BORN M1 M2 NOT FOUND'
            WRITE(6,*)'DIAGON: BORN M1 M2 NOT FOUND:'
            WRITE(6,*)LL,II,L,I,M,NGROUP,M2,M1
            GO TO 3000
          ENDIF
        ENDIF
      ENDIF
C
  736 CONTINUE
C
 7320 IF(BEQGRP)THEN                           !PICK-UP OTHER HALF
        IF(BING)THEN
          BING=.FALSE.
          GO TO 730
        ELSE
          BING=.TRUE.
        ENDIF
      ENDIF
C
 7330 CONTINUE                                 !END LOOP OVER TERMS
C
 7333 NCC=NCC+NSL(NC)
      ENDDO                                    !END LOOP OVER GROUPS
C
      IF(BBORN)THEN
        IBOMX=MAX(IBOMX,IBO)
        IF(IBO.GT.IXBIF)THEN                   !SHOULDN'T HAPPEN
          WRITE(6,*)'SR.DIAGON: DIMENSION ERROR, INCREASE MXBIF TO '
     X              ,IBO
          WRITE(0,*)'SR.DIAGON: DIMENSION ERROR, INCREASE MXBIF'
          GO TO 3000
        ENDIF
      ENDIF
C
C***********************************
C START LOOP OVER LOWER ENERGY TERMS
C***********************************
C
      SUMRN(0)=DZERO
      SUMRD(0)=DZERO
      IF(NMM.GT.0)THEN
        NMM=NMM0
        IF(NMETAP.GT.0)NMM=MIN(NMM,JRP(IIMX))
        DO K=1,NMM
          SUMRN(K)=DZERO
          SUMRD(K)=DZERO
        ENDDO
      ENDIF
C
      IF(BUNPR.AND.NFK(J).LT.0)THEN
        I3P=ABS(IWRK3(J))
        IF(I3P.NE.JPOLD)THEN                   !NEW UPPER PI STATE
          DO M8=1,MENG
            SUMPN(M8,0)=DZERO
            SUMPD(M8,0)=DZERO
          ENDDO
          DO K=1,NMM
            DO M8=1,MENG
              SUMPN(M8,K)=DZERO
              SUMPD(M8,K)=DZERO
            ENDDO
          ENDDO
          IF(BUNA)JPOLD=I3P                    !SUM OVER NMETA CONT
        ENDIF
      ENDIF
C
      ILI=0
      DO 733 II=IIMN,IIMX
C
      IF(.NOT.BAUX.AND.IORIG(II).LT.0)GO TO 733
      IF(IORIG(II).GT.0)THEN
        ILI=ILI+1
        IF(KTRAN.GE.0)KTRAN=KTRAN+1
      ENDIF
      I=ABS(IORIG(II))
      IF(IWRK4(I).GT.0)GO TO 733
      IF(ABS(MENGB).EQ.1.AND.MOD(NGROUP,ITWO).EQ.1)THEN
        IX=IROW(ILI,ILF,ione1,NSPECE)
        IF(OMR(IX).LT.-TOLO)GO TO 733    !DIPOLE ALREADY COMPUTED
      ENDIF
c      if(dvecl(i).eq.dzero)write(131,*)nfk(j),jj,j,' - ',nfk(i),ii,i
C
      IF(IDIAG.GE.0.AND.BDEL)THEN
        MRD=0
        I5=0
        M3=NFK(J)
        M3=ABS(M3)
        M4=NFK(I)
        DO I3=1,MXORB
          I4=NEL(I3,M3)-NEL(I3,M4)
          IF(I4.NE.0)THEN
            I5=I5+1
            MRDP=MRD
            MRD=ABS(QN(I3))
            ISGN=1-2*mod(abs(I5),ITWO)             !(-1)**I5
            IF(ISGN.GT.0.AND.ABS(MRD-MRDP).GE.MDEL)GO TO 437
          ENDIF
        ENDDO
        GO TO 733
  437   CONTINUE
      ENDIF
C
C START LOOP (K1,K2) OVER LOWER ENERGY TERM MIXING
C
      DLEN=DZERO
      DVEL=DZERO
      DACC=DZERO
      IF(.NOT.BFOTJ.AND.NFK(J).LT.0)THEN         !PHOTO
        DO M8=1,MENG
          DFOT(M8)=DZERO
        ENDDO
      ENDIF
C
      NC=NFQ(I)
      ML=QLI(ND)-QLI(NC)
c
c e-vector storage posn
C
      if(bkutls)then                      !could do better...?
        k1=iwrkg(nc-1)+iwrkb(1,nfk(i),nc)
        k2=k1+iwrkb(2,nfk(i),nc)
      else
        K1=IWRKG(NC-1)
        K2=IWRKG(NC)
      endif
      M0=K2-K1
C
      N1=NADRU(I)                                !START OF MIXING VECTOR
C
      IF(BFAST)THEN
        IF(BFOTJ.OR.NFK(J).GT.0)THEN
CL          IF(LAPAK.GT.0)THEN                                   !LAPACK
CL            DLEN=DDOT(M0,TFU(N1+1),IONE,DVECL(K1+1),IONE)      !LAPACK
CL          ELSE                                                 !LAPACK
            DO M=1,M0
              DLEN=DLEN+TFU(N1+M)*DVECL(K1+M)
            ENDDO
CL          ENDIF                                                !LAPACK
        ELSE
CL          IF(LAPAK.GT.0)THEN                                   !LAPACK
CL            DLEN=DDOT(M0,TFU(N1+1),IONE,DVECL(K1+1),IONE)      !LAPACK
CL            DO M8=1,MENG                                       !LAPACK
CL              DFOT(M8)=                                        !LAPACK
CL     X           DDOT(M0,TFU(N1+1),IONE,DVECF(K1+1,M8),IONE)   !LAPACK
CL            ENDDO                                              !LAPACK
CL          ELSE                                                 !LAPACK
            DO M=1,M0
              DLEN=DLEN+TFU(N1+M)*DVECL(K1+M)
            ENDDO
            DO M8=1,MENG
              DO M=1,M0
                DFOT(M8)=DFOT(M8)+TFU(N1+M)*DVECF(K1+M,M8)
              ENDDO
            ENDDO
CL          ENDIF                                                !LAPACK
        ENDIF
      ELSE
        IF(BBORN)THEN                  !BORN
          DO K=1,MB3(0)
            SBL(K)=DZERO
          ENDDO
        ENDIF
        K1=K1+1
        DO K=K1,K2
          N1=N1+1                                !=NADRU(I)+NAI(K)
          DD1=TFU(N1)
          IF(ABS(DD1).LT.CMXLSR)GO TO 734
          DLEN=DLEN+DD1*DVECL(K)
          DVEL=DVEL+DD1*DVECV(K)
          DACC=DACC+DD1*DVECA(K)
          IF(BBORN)THEN                !BORN
            IBO=ID(K)
            IF(IBO.GT.0)THEN
              DO M=1,MB3(0)
                SBL(M)=SBL(M)+DD1*DBL(M,IBO)
              ENDDO
            ENDIF
          ENDIF
          IF(.NOT.BFOTJ.AND.NFK(J).LT.0)THEN
            DO M8=1,MENG
C              DFOT(M8)=DFOT(M8)+DD1*DVECF(M8,K)
              DFOT(M8)=DFOT(M8)+DD1*DVECF(K,M8)
            ENDDO
          ENDIF
  734   ENDDO
      ENDIF
C                                      END LOOP OVER LOWER ENERGY MIXING
C
c      if(dlen.eq.dzero)write(132,*)nfk(j),jj,j,' - ',nfk(i),ii,i
      OBOX=DZERO
      IF(MENGB.EQ.-1.AND.ABS(DLEN).GT.WLGO)OBOX=D1P30
      IF(NGROUP.EQ.0)DLEN=DZERO
      IF(NGROUP.GT.0.AND.DLEN.EQ.DZERO)GO TO 733
C
C EXCLUDE TRANSITIONS INVOLVING ZERO-WEIGHT TERMS FROM FUNCTIONAL G
C
      MBCOR=MBLK
      IF(LL.GT.0)THEN              !-INCLUDE
        NN=-1
        DO K=1,LL
          IF(INDEXW(K).EQ.I.OR.INDEXW(K).EQ.J)THEN
            NN=NN+1
            IF(NN.GT.0)GO TO 746
          ENDIF
        ENDDO
        MBCOR=MOUT
      ENDIF
  746 IF(IORIG(II).LT.0.OR.IORIG(JJ).LT.0)MBCOR=MCOR
C
C BORN MULTIPOLES
C
      IF(BBORN)THEN     !BORN
        DO IE=1,MENGB
          OBO(IE)=DZERO
        ENDDO
        OMG1=DZERO
        DLAM=2*NGROUP+1
        NH=NGROUP/2
        DO N=1,MB4(0)
          L=INDL(N)
          K=INDK(N)
          SSB=SBL(K)*SBL(L)
          IF(ABS(SSB).GT.STOL)THEN
            DO IE=1,MENGB
              DB=SSB*BL(IE,N,NH)
cbu              if(db.ne.dzero)iflagb(n)=abs(iflagb(n))!flag born usage
              OBO(IE)=OBO(IE)+DB+DB
              IF(L.EQ.K)OBO(IE)=OBO(IE)-DB
            ENDDO
            IF(NGROUP.EQ.1)THEN
              DB=SSB*TM2(N)
              OMG1=OMG1+DB+DB
              IF(L.EQ.K)OMG1=OMG1-DB
            ENDIF
          ENDIF
        ENDDO
        DB=DEIGHT*DLAM*(QSI(ND)+1)
        DO IE=1,MENGB
          OBO(IE)=DB*OBO(IE)
        ENDDO
        OBOX=OBO(MINFB)
        OMG1=DB*OMG1
      ENDIF
C
C ELECTRIC MULTIPOLE
C
      JOS=JOS+1
      DRY=DENERG(J)-DENERG(I)
      IF(DRY.EQ.DZERO)then
        if(mengb.lt.-1)GO TO 733                     !CASE E2 DEGENERATE
        dry=d1m10
      endif
c
      IF(NFK(J).LT.0)DRY=DRY+DYY(NREL)
      GFA=DACC/(DRY*DRY)                         !GF_A
c      gfa=dacc                                  !if orb ener. used
      DRY=DRY+DRY
      MI=II
      MJ=JJ
C     IF(NFK(I).LT.0)MI=-MI
      IF(NFK(J).LT.0)MJ=-MJ
      MWJ=(QSI(ND)+1)*(QLI(ND)+1)
      MWI=(QSI(NC)+1)*(QLI(NC)+1)
      WLG=ABS(WLG)
      IF(NFK(J).LT.0)WLG=-WLG
C
      DB=DG(NGROUP)*(DRY*DFSC)**(MLAM-1)/DFSC
      if(db.eq.dzero)then                        !avoids overflow*zero
        dlen=dzero
        dvel=dzero
        gfa=dzero
      endif
      SEK=ABS(DLEN)*DLEN*(QSI(ND)+1)             !SEK_L
      GFL=DB*SEK                                 !GF_L
      IF(NFK(J).GT.0)AEK=C1*GFL*DRY*DRY/MWJ      !AEK
      IF(NFK(J).LT.0)AEK=C2*GFL/MWI              !PI
C
C                Lt. for PI underflow at low-E (but not at high-E)
      IF(AEK*AEK.Lt.ABS(AEK)*WLG.AND.OBOX.LT.WLGO
     X                          .AND.GFL*GFL.LT.WLGS)GO TO 733
C                so zero will be written if not caught be selection rule
C
      BINT=(BAUX.OR.MBCOR.NE.MCOR).AND.BPRNT0
C      ISGNL=1-2*mod(abs(ML/2),2)               !(-1)**(ML/2)
C      ISGN=ISGNL                                !SWITCH DOWN TO UP ON F
C      IF(BFANO)ISGN=ISGN*ISGNN
      ISGN=1                                     !ALL DOWN
      DB=ISGN*DB*(QSI(ND)+1)*DTEN**MP
      DVEL=DVEL/DRY                              !skip if orb ener. used
      GFV=DB*DVEL*ABS(DVEL)                      !GF_V
      GFLV=DB*DVEL*DLEN                          !SQRT(GF_L*GF_V)
      GFA=DB*GFA*ABS(GFA)                        !GF_A
      WLEN=D1P8/(DRY*DKCM)                       !WAVELENGTH(A)
      GFL=ISGN*GFL*DTEN**MP                      !GF_L STILL
      IF(.NOT.BELONG.AND.ABS(AEK).GT.WLG)THEN    !USE VEL AEK,SEK
        AEK=GFV*AEK/GFL
        SEK=GFV*SEK/GFL
      ENDIF
      FAB=GFL/MWI                                !F(UP)_L
      FEM=GFL/MWJ                                !F(DOWN)_L
C
      IF(NGROUP.EQ.1)THEN
        APOL=DFOUR*ABS(FAB)/(DRY*DRY)            !POLARIZABILITY (a_0^3)
        IF(.NOT.BELONG)APOL=APOL*ABS(GFV/GFL)
        OMG=DFOUR*GFL/DRY                        !MP=0, NGROUP=1
        IF(ABS(MENGB).EQ.1)THEN
          OMGINF=-ABS(OMG)
          OMG=OMG*LOG(EINF*DZ2)
          OMG=-ABS(OMG)                          !TAG DIPOLE NEGATIVE
          IF(OMG.GE.-TOLO)OMG=DZERO          !ZERO VANISHINGLY SMALL CPT
        ELSEIF(MENGB.GT.1)THEN
          OMG=-ABS(OMG)                          !4S/3
          if(nmeta.eq.0)nmeta=iimx               !pwb
        ENDIF
        if(idw.eq.0)then
          if(nmeta.eq.0)nmeta=nenerg             !for RM
        else
          if(nmeta.eq.0)nmeta=iimx
        endif
      ELSE
        APOL=OBOX                                !COPY BORN IN
        OMG=OBOX
        IF(OMG.LT.DZERO)OMG=D1M30                !keep non-negative
        OMGINF=OMG
      ENDIF
C
C DETERMINE BORN OMEGAS
C
      BPRNTO=.FALSE.
      IF(MPOL00.EQ.0.AND.MBCOR.EQ.MBLK)THEN   !MPOL0 CATCHES E1
        IF(ABS(MENGB).EQ.1)THEN              !INFINITE ENERGY BORN ONLY
          BPRNTO=.TRUE.
          IXC=ICOL(ILI,ILF,ione1)
          IF(IXC.LE.NOMWRX)OMC(IXC)=OMC(IXC)+OMG
          IXR=IROW(ILI,ILF,ione1,NSPECE)
          IF(IXR.LE.NOMWRX)OMR(IXR)=OMR(IXR)+OMG
          OMEGAB(MXNXB1)=OMGINF
        ELSEIF(MENGB.GT.1.AND.abs(OBO(MINFB)).GT.WLGO)THEN  !FINITE BORN
          BPRNTO=.TRUE.
          CALL BRNINT(BPRNT0,NLAGB,MXNXB,MV0,MV1,DRY,V0,V1,XB,XS
     X               ,DB0,DB1,OMG1,OBO,OMEGAB)
          OMEGAB(MXNXB1)=OMG                       !INFINITE ENERGY
c          if(nlagb.lt.0)go to 3000                !brnint failure
        ENDIF
      ENDIF
C
C OUTPUT ELECTRIC MULTIPOLE DATA.
C
      IF(BINT)WRITE(6,500)JOS,MBCOR,MJ,MI,AEK,SEK,GFL,FAB,FEM,WLEN
     X                   ,GFV,GFLV,GFA,APOL
C
      IF(BPRNTO)THEN
        T=ABS(AEK)
        IF(BSCRO)THEN
          WRITE(MSC)MJ,MI,T,(OMEGAB(K),K=1,MXNXB1)
        ELSE
          OMEGA(0,KTRAN)=OMEGA(0,KTRAN)+REAL(T,RP)
          T=REAL(OMEGA(MXNXB1,KTRAN),WP)
          KMX=MXNXB1
          IF(MOD(NGROUP,ITWO).EQ.1.AND.T.LT.-TOLO)KMX=MXNXB  !OLD DIPOLE
          DO K=1,KMX
            OMEGA(K,KTRAN)=OMEGA(K,KTRAN)+REAL(OMEGAB(K),RP)
          ENDDO
        ENDIF
      ENDIF
C
      IF(MODE.LT.1)GO TO 615
      DB=DENERG(I)+DENERG(I)+DEM
      IF(NFK(I)*NFK(J).LT.0)GO TO 335
C
      IF(II.LE.LLOWMX.AND.DB.LE.etest .AND.
     X                  IHARRY(NFK(I)).LE.NRSLMX)THEN          !RESOLVED
        IF(BPRNT0)WRITE(MW,501)NFK(J),J,MWJ,NFK(I),I,MWI,AEK,DRY,DB
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(J)),int(J),int(MWJ),int(NFK(I))
     X                          ,int(I),int(MWI),AEK,DRY,DB
      ELSEIF(BUNR)THEN                                          !BUNDLED
        T=ABS(AEK)
        IF(BDOWN)THEN                           !USED BY ADASDR & ADASPE
          M=0
          IF(NFK(I).LE.-NRSLMX)M=NFK(I)
        ELSE                                    !NOT USED BY PP'S....
          T=T*MWJ
          T=T/MWI
          M=II
        ENDIF
        IF(DB.LT.EIONMN)THEN
          SUMRN(M)=SUMRN(M)+T
        ELSE
          SUMRD(M)=SUMRD(M)+T
        ENDIF
      ENDIF
      GO TO 615
C
  335 IF(BFOTJ)GO TO 733
      IF(DFOT(MENG).EQ.DZERO)GO TO 733
C
C N.B. SIGN OF REDUCED MATRIX ELEMENT IS STILL FOR DOWNWARD TRANSITION.
C TO GET SIGN FOR UPWARD TRANSITION, UNCOMMENT NEXT DO-LOOP.
C      DO  M8=1,MENG
C        DFOT(M8)=DFOT(M8)*ISGN
C      ENDDO
C
      DC0=C2*DG(NGROUP)/(REAL(QLI(NC)+1,WP)*DFSC)
      T=DENERG(J)-DENERG(I)
      DO M8=1,MENG
        DRY=T+DYY(M8)
        DRY=DRY+DRY
        T1=DRY*DFSC
        TT=T1**NGROUP
        TT=TT*DFOT(M8)
        DFOT(M8)=DC0*TT*ABS(TT)/T1
        IF(BPRNT0.AND.ABS(DFOT(M8)).LT.D1M99)DFOT(M8)=DZERO
      ENDDO
C
C AEK IS GIVEN BY RADIATIVE IGAUGE, DFOT IS GIVEN BY PI GAUGE.
C
      IF(II.LE.LLOWMX.AND.DB.LE.etest .AND.IWRK2(J).LE.JIMXLS
     X               .AND.IHARRY(NFK(I)).LE.-NMM)THEN          !RESOLVED
        DRY=DENERG(J)+DENERG(J)+DEM
        IF(BPRNT0)THEN
          WRITE(MWW,501)NFK(I),I,MWI,NFK(J),J,IWRK2(J),AEK,DB,DRY
          WRITE(MWW,515)(DFOT(M8),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(NFK(I)),int(I),int(MWI),int(NFK(J)),int(J)
     X              ,int(IWRK2(J)),AEK,DB,DRY
          WRITE(MWWU)(DFOT(M8),M8=1,MENG)
        ENDIF
      ELSEIF(BUNPR)THEN                                         !BUNDLED
        DO M8=1,MENG
          DFOT(M8)=ABS(DFOT(M8))
        ENDDO
        IF(BDOWN)THEN                              !AS RESOLVED PI IS UP
          M=0
          IF(NFK(I).LE.-NRSLMX)M=NFK(I)
          TW=MWI
          TWW=DALF4*TW/MWJ
          DO M8=1,MENG
            DRY=T+DYY(M8)
            DRY=DRY+DRY
            DFOT(M8)=DFOT(M8)*DRY*DRY*TWW
          ENDDO
        ELSE                                    !AS ONLY CONT IS BUNDLED
          M=JRP(II)
        ENDIF
        IF(DB.LT.EIONMN)THEN
          DO M8=1,MENG
            SUMPN(M8,M)=SUMPN(M8,M)+DFOT(M8)
          ENDDO
        ELSE
          DO M8=1,MENG
            SUMPD(M8,M)=SUMPD(M8,M)+DFOT(M8)
          ENDDO
        ENDIF
      ENDIF
      GO TO 733
C
C IN ELECTRIC DIPOLE CASE ADD CONTRIBUTION TO FUNCTIONAL G
C
  615 IF(NGROUP.EQ.1.AND.INCLUD.NE.0.AND.MBCOR.EQ.MBLK)THEN
        NGF=NGF+1
        GFL=ABS(GFL)
        GFV=ABS(GFV)
        GFLV=ABS(GFLV)
        SGF=(GFL+GFV-2*GFLV)/(GFL+GFV+2*GFLV)+SGF
      ENDIF
C
C
  733 CONTINUE                               !END LOOP OVER LOWER TERMS
C
      IF(ALLOCATED(DBL))DEALLOCATE (DBL,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'SR.DIAGON: DE-ALLOCATION FAILS FOR DBL'
        NF=0
        GO TO 7450
      ENDIF
c
          if(btime)then
            call cpu_time(timefr)
            timer2=timer2+timefr-timeir
          endif
C
C                                                           !UNRESOLVED
      WLG=ABS(WLG)
      IF(SUMRN(0).GT.WLG)THEN
        IF(BPRNT0)WRITE(MW,501)NFK(J),J,MWJ,IZERO,IZERO,IZERO,
     X                         SUMRN(0),DZERO,DEM
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(J)),int(J),int(MWJ),int(IZERO)
     X                         ,int(IZERO),int(IZERO),SUMRN(0),DZERO,DEM
      ENDIF
      IF(SUMRD(0).GT.WLG)THEN
        IF(BPRNT0)WRITE(MW,501)NFK(J),J,MWJ,IZERO,IZERO,IZERO,
     X                         SUMRD(0),DZERO,DZERO
        IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(J)),int(J),int(MWJ),int(IZERO)
     X                       ,int(IZERO),int(IZERO),SUMRD(0),DZERO,DZERO
      ENDIF
C                                                               !BUNDLED
      DO M=1,NMM
        IF(SUMRN(M).GT.WLG)THEN
          IF(BPRNT0)WRITE(MW,501)NFK(J),J,MWJ,JCP(M),JTP(M),JWRN(M),
     X                           SUMRN(M),DZERO,ERN(M)
          IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(J)),int(J),int(MWJ)
     X       ,int(JCP(M)),int(JTP(M)),int(JWRN(M)),SUMRN(M),DZERO,ERN(M)
        ENDIF
        IF(SUMRD(M).GT.WLG)THEN
          IF(BPRNT0)WRITE(MW,501)NFK(J),J,MWJ,JCP(M),JTP(M),JWRD(M),
     X                           SUMRD(M),DZERO,ERD(M)
          IF(.NOT.BPRNT0)WRITE(MWU)int(NFK(J)),int(J),int(MWJ)
     X       ,int(JCP(M)),int(JTP(M)),int(JWRD(M)),SUMRD(M),DZERO,ERD(M)
        ENDIF
      ENDDO
C
      IF(.NOT.BUNPR.OR.NFK(J).GT.0)GO TO 732
C
      IF(JPOLD.LE.0)THEN
        JP=J
      ELSE
        IF(JJ.LT.JJMX)THEN
          JP=ABS(IORIG(JJ+1))
          JPNEW=ABS(IWRK3(JP))
          IF(IWRK2(J).GT.JIMXLS)JPOLD=JPNEW
        ELSE
          JPNEW=-1
          IF(IWRK2(J).GT.JIMXLS)THEN
            JPOLD=NENERG+1
            NFK(JPOLD)=0     !SLIGHTLY UNSAFE, =MAXTM+1, BUT VCG BUFFERS
            IWRK2(JPOLD)=0
            DENERG(JPOLD)=DZERO
            DEM=DZERO
          ENDIF
        ENDIF
        IF(JPNEW.EQ.JPOLD)GO TO 732            !SUM OVER CONT DEGENERACY
        JP=JPOLD
      ENDIF
C
      DRY=DENERG(JP)+DENERG(JP)+DEM
C                                                            !UNRESOLVED
      IF(SUMPN(1,0).GT.DZERO)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,501)IZERO,IZERO,IZERO,NFK(JP),JP,IWRK2(JP)
     X                 ,DZERO,DEM,DRY
          WRITE(MWW,515)(SUMPN(M8,0),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO),int(NFK(JP))
     X              ,int(JP),int(IWRK2(JP)),DZERO,DEM,DRY
          WRITE(MWWU)(SUMPN(M8,0),M8=1,MENG)
        ENDIF
      ENDIF
      IF(SUMPD(1,0).GT.DZERO)THEN
        IF(BPRNT0)THEN
          WRITE(MWW,501)IZERO,IZERO,IZERO,NFK(JP),JP,IWRK2(JP)
     X                 ,DZERO,DZERO,DRY
          WRITE(MWW,515)(SUMPD(M8,0),M8=1,MENG)
        ELSE
          WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO),int(NFK(JP))
     X              ,int(JP),int(IWRK2(JP)),DZERO,DZERO,DRY
          WRITE(MWWU)(SUMPD(M8,0),M8=1,MENG)
        ENDIF
      ENDIF
C                                                               !BUNDLED
      DO M=1,NMM
        IF(SUMPN(1,M).GT.DZERO)THEN
          IF(BPRNT0)THEN
            WRITE(MWW,501)JCP(M),JTP(M),JWRN(M),NFK(JP),JP,IWRK2(JP)
     X                   ,DZERO,ERN(M),DRY
            WRITE(MWW,515)(SUMPN(M8,M),M8=1,MENG)
          ELSE
            WRITE(MWWU)int(JCP(M)),int(JTP(M)),int(JWRN(M)),int(NFK(JP))
     X                ,int(JP),int(IWRK2(JP)),DZERO,ERN(M),DRY
            WRITE(MWWU)(SUMPN(M8,M),M8=1,MENG)
          ENDIF
        ENDIF
        IF(SUMPD(1,M).GT.DZERO)THEN
          IF(BPRNT0)THEN
            WRITE(MWW,501)JCP(M),JTP(M),JWRD(M),NFK(JP),JP,IWRK2(JP)
     X                   ,DZERO,ERD(M),DRY
            WRITE(MWW,515)(SUMPD(M8,M),M8=1,MENG)
          ELSE
            WRITE(MWWU)int(JCP(M)),int(JTP(M)),int(JWRD(M)),int(NFK(JP))
     X                ,int(JP),int(IWRK2(JP)),DZERO,ERD(M),DRY
            WRITE(MWWU)(SUMPD(M8,M),M8=1,MENG)
          ENDIF
        ENDIF
      ENDDO
C
C
  732 CONTINUE                                !END LOOP OVER UPPER TERMS
C
C
c determine usage of Born integrals
c note: practically all are used for normal targets.
c e.g. of where usage is low is large pseudostate expansions,
c especially ls coupling. Also, perhaps, use of relaxed orbitals;
c but the bindb variable helps greatly.
c
cbu      if(bborn)then                                       !born usage
cbu        nh=ngroup/2
cbu        icount=0
cbu        icountb=0
cbu        write(778,*)'kpole=',ngroup
cbu        write(779,*)'kpole=',ngroup
cbu        do i=1,mb4(0)
cbu          if(bl(1,i,nh).ne.dzero)then
cbu            nc=indl(i)
cbu            nd=indk(i)
cbu            j=mb4(nc)
cbu            k=mb3(nc)
cbu            if(mod(ngroup,2).eq.mod((ql(j)+ql(k))/2,2))then
cbu              icount=icount+1
cbu              if(iflagb(i).gt.0)then   !used
cbu                icountb=icountb+1
cbu                if(bprnt0)
cbu     x             write(778,*)nc,mb3(nc),mb4(nc),nd,mb3(nd),mb4(nd)
cbu              else                     !not used
cbu                if(bprnt0)
cbu     x             write(779,*)nc,mb3(nc),mb4(nc),nd,mb3(nd),mb4(nd)
cbu              endif
cbu              if(bprnt0)write(777,6999)i,indl(i),iflagb(i),icountb
cbu 6999         format(i7,i5,i3,i6)
cbu            endif
cbu          endif
cbu        enddo
cbu        p=icountb
cbu        if(icount.gt.0)p=100*p/icount
cbu        npp=nint(p)
cbu        write(0,777)ngroup,icount,icountb,npp
cbu        write(6,777)ngroup,icount,icountb,npp
cbu  777   format(/'LAM=',I2,3X,'BORN INTEGRALS: CALC=',I7,'  USED='
cbu     X         ,I7,I5,'%'/)
cbu      endif
C
C END MULTIPOLE LOOP OVER RADIATIVE TRANSITIONS
C
      IF(MLAM.LT.MPOLE)GO TO 740
C
      DEALLOCATE (DG)
C
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
cpar        if(iam.ge.0)then                                        !par
cpar          write(iwp,*)'proc',iam,' for diagon:'                 !par
cpar          write(iwp,*)'    radiative time=',nint(times),'sec'   !par
cpar          call flush(iwp)                                       !par
cpar        else                                                    !par
          write(iw,*)'radiative timer1=',nint(timer1),'sec'
          write(iw,*)'radiative timer2=',nint(timer2),'sec'
          write(iw,*)'radiative time=',nint(times),'sec'
cpar        endif                                                   !par
      endif
C
C WRITE AN ADF04 (AND, MAYBE, INFINITE ENERGY OMEGA) FILE
C
      IF(MENGB.GE.-1)THEN                   !BBORN
c
        if(btime)timei=timef
C
C WRITE DATA TO OMGINF FILE
C
        WRITE(6,*)' '
        WRITE(6,*)'IBOMX=',IBOMX
c        write(0,*)ibifmx,ibomx
C
        CALL DIMUSE('MXBIF',IBOMX)
c
        do j=lupe,1,-1                               !nenerg
          if(iorig(j).gt.0)go to 645
        enddo
        j=lupe                                       !shouldn't get here
  645   lupe=j
C
        IF(ABS(MENGB).EQ.1)THEN            !INF ENG BORN, ROW *AND* COL
C
          IF(MENGB.EQ.-1)THEN
            DO I=1,NOMWRT
              OMR(I)=MIN(OMR(I),D1P30)
              OMC(I)=MIN(OMC(I),D1P30)
            ENDDO
          ENDIF
C
          K=0
          DO J=1,lupe                       !NENERG
            I=IORIG(J)
            IF(I.GT.0)THEN
              K=K+1
              N=NFQ(I)
              IWRK3(K)=(1-QPI(N))*(QSI(N)+1)
              IWRK4(K)=QLI(N)/2
              DWRK(K)=DENERG(I)*DTWO/DZ2
            ENDIF
          ENDDO
C
          IF(K.NE.NSPECE)THEN
            WRITE(6,*)'DIAGON: ENERGY MISMATCH',K,NSPECE     !,lupe
            WRITE(0,*)'DIAGON: ENERGY MISMATCH'
            GO TO 3000
          ENDIF
c
          if(nmeta.eq.0)nmeta=nspece                         !case no E1
          if(nmeta.lt.nspece)then
            ixr=irow(nmeta,nspece,ione1,nspece)
            if(ixr.lt.nomwrt)nomwrt=ixr
            ixc=icol(nmeta,nspece,ione1)
          else
            ixc=nomwrt
          endif
          if(nmeta0.eq.0)nmeta=-nmeta
C
          WRITE(23,*)NZION,MION
          WRITE(23,*)NSPECE,ABS(MENGB),NOMWRT
          WRITE(23,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
          WRITE(23,711)(DWRK(I),I=1,NSPECE)
          WRITE(23,713)EINF,(OMR(I),I=1,NOMWRT)
C
          IF(IDW.EQ.0)THEN                           !COLUMNWISE AS WELL
            NOMWRT=(NSPECE*(NSPECE+1-2*ione1))/2
            if(ixc.lt.nomwrt)nomwrt=ixc
C
            WRITE(23,*)NZION,MION
            WRITE(23,*)NSPECE,ABS(MENGB),-NOMWRT
            WRITE(23,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
            WRITE(23,711)(DWRK(I),I=1,NSPECE)
            WRITE(23,713)EINF,(OMC(I),I=1,NOMWRT)
          ENDIF
C
        ENDIF                                 !SUM BORN MULTIPOLES
C
C WRITE DATA TO ADF04 FILE
C
        BEXP=.FALSE.                          !TRUE=1.0E+0, FALSE=1.0+0
        IF(NSPECE.LT.1000)THEN
          i1=0
          IF(BEXP)THEN
            F761='(F5.2,4X,"1", 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
          ENDIF
        ELSE
          i1=1
          IF(BEXP)THEN
            F761='(F5.2,4X,"1",10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
          ELSE
            F761='(F5.2,4X,"1", 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
          ENDIF
        ENDIF
C
       if(ieq(0).ne.0)then
C
        WRITE(25,F542)-1               !OLD TERMINATOR
c
       else
c                                      !now write orbital energy in s.o.
        cardx=' '
        cardx(4:5)='-1'
        orbfmt='(1x,f7.?)'
c
c truncate to spectroscopic orbitals
        if(bort)then
          isob=0
          inx=0
          do i=1,mxorb
            if(dey(i).ne.dzero)then
              if(dadjus(i).lt.dzero)go to 646
              isob=i
              in=abs(qn(i))
              inx=max(inx,in)
            endif
          enddo
        else
          isob=mxorb
          inx=abs(qn(isob))
        endif
c re-map
 646    isox=0
        inx=(inx*(inx+1))/2
c
        allocate (isorb(0:inx))
c
        do i=1,inx
          isorb(i)=0
        enddo
        do i=1,isob
          in=abs(qn(i))
          il=ql(i)/2
          iso=(in*(in-1))/2+il+1
c          if(iso.le.maxgr)
          isorb(iso)=i
          isox=max(isox,iso)
        enddo
c
c        if(isox.gt.maxgr)then
c          write(6,*)'***sr.diagon: maxgr buffer too short, need ',isox
c          isox=-maxgr
c        endif
        is=9+2*i1
        ie=is+abs(isox)*8
        if(ie.gt.mxlenx)then!note, >200(=7d) not passed by dwxls,adasexj
          write(6,*)'***sr.diagon: cardx too short, need mxlenx=',ie
          isox=-(mxlenx-is)/8
        endif
        if(isox.lt.0)then
          write(6,*)'***adf04ls note: truncated orbital energy list'
c          write(0,*)'***adf04ls note: truncated orbital energy list'
          isox=-isox
        endif
c print
        do ix=1,isox
          ie=is+7
          i=isorb(ix)
          t=dzero
          if(i.gt.0)then                !break into two for bounds check
            if(dey(i).ne.dzero)then
              t=dey(i)-duy(i,i)
              if(bmvd)t=t+dmass(i,i)+dcd(i,i)
              t=-2*t
            endif
          endif
          write(orbfmt(8:8),'(i1)')
     x          max(2,5-max(0,int(log10(max(t,d1m30)))))
          write(cardx(is:ie),orbfmt)t
          is=ie+1
        enddo
c
        orbfmt=' '
        orbfmt(1:7)='(a    )'
        write(orbfmt(3:6),'(i4)')ie
        write(25,orbfmt)cardx(1:ie)
c
        deallocate (isorb)
c
       endif
C
        IF(BEXP)THEN
          WRITE(25,F761)REAL(NZA),(XB(K),K=1,MXNXB)
        ELSE
          MSCP=MSC+1
          OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
          WRITE(MSCP,764)(XB(K),K=1,MXNXB)
          BACKSPACE(MSCP)
          READ(MSCP,765)(XMANT(K),IEXP(K),K=1,MXNXB)
          WRITE(25,F761)REAL(NZA),(XMANT(K),IEXP(K),K=1,MXNXB)
        ENDIF
C
        DO M=MSC0,MSC                     !RE-POINT BORN MULTIPOLE FILES
          REWIND(M)
        ENDDO
C
        IOLD=JJMN               !1+ione1
        JOLD=IIMN               !1
C
        if(nenerg-ione1.eq.0)go to 373
c
        if(iorig(iold).lt.0.or.iorig(jold).lt.0)then
          write(6,*)'Lowest two terms cannot be correlation!'
          write(0,*)'Lowest two terms cannot be correlation!'
          go to 3000
        endif
        INEW=IOLD
        JNEW=JOLD
        KTRAN=0
C
  371   IF(BSCRO)THEN
C
          BBORN=.FALSE.
          DO K=0,MXNXB1
            OMEGAB(K)=DZERO
          ENDDO
C
          IP=IORIG(IOLD)
          IP=NFQ(IP)
          IP=QPI(IP)
          JP=IORIG(JOLD)
          JP=NFQ(JP)
          JP=QPI(JP)
          IF(IP.NE.JP)THEN
            MMN=MSC0+1                     !ODD MULTIPOLES
            MMX=MSC+MOD(MSC,ITWO)-1
          ELSE
            MMN=MSC0
            MMX=MSC-MOD(MSC,ITWO)
          ENDIF
C
          IFLAGO=999
          DO M=MMN,MMX,2
            READ(M,END=370,ERR=370)I,J,(XS(K),K=0,MXNXB1)
            IF(I.GT.IOLD.OR.J.GT.JOLD)THEN
              BACKSPACE(M)
              GO TO 370
            ELSE
              if(jold.gt.iimx)then
                if(nmeta0.eq.0)then
                  go to 370          !unfortunate interchange of i,j use
                else
                  stop '370'
                endif
              endif
              BBORN=.TRUE.
              KMX=MXNXB1
              IF(IP.NE.JP)THEN
                LAM=MOD(M,I80)
                IF(LAM.EQ.1.AND.ABS(XS(MXNXB1)).GT.TOLO)IFLAGO=1 !E1 LIM
                IF(LAM.GT.IFLAGO)KMX=MXNXB    !DON'T OVEFRWRITE E1 LIMIT
              ENDIF
              DO K=0,KMX
                OMEGAB(K)=OMEGAB(K)+XS(K)
              ENDDO
            ENDIF
  370     ENDDO
C
        ELSE
          KTRAN=KTRAN+1
          DO K=0,MXNXB1
            OMEGAB(K)=REAL(OMEGA(K,KTRAN),WP)
          ENDDO
        ENDIF
C
        IF(BBORN)THEN
          DO K=0,MXNXB
            OMEGAB(K)=ABS(OMEGAB(K))
            IF(OMEGAB(K).LT.D1M99)OMEGAB(K)=DZERO
          ENDDO
          IF(OMEGAB(0).LT.D1M30)OMEGAB(0)=D1M30
          IF(OMEGAB(MXNXB1).GT.D1P30)OMEGAB(MXNXB1)=D1P30
          IF(BEXP)THEN
            WRITE(25,F762)INEW,JNEW,(OMEGAB(K),K=0,MXNXB1) !IOLD,JOLD
          ELSE
            BACKSPACE(MSCP)
            WRITE(MSCP,764)(OMEGAB(K),K=0,MXNXB1)
            BACKSPACE(MSCP)
            READ(MSCP,765)(XMANT(K),IEXP(K),K=0,MXNXB1)
            WRITE(25,F762)INEW,JNEW
     X                  ,(XMANT(K),IEXP(K),K=0,MXNXB1)     !IOLD,JOLD
          ENDIF
        ENDIF
C
  373   JOLD=JOLD+1
        IF(JOLD.Gt.IOLD-ione1.or.JOLD.GT.IIMX.and.nmeta0.ne.0)THEN
  372     IOLD=IOLD+1
          IF(IOLD.GT.lupe)THEN                 !NENERG        !TERMINATE
            WRITE(25,F762)-1
            WRITE(25,F762)-1,-1
           if(.not.badas)then                       !adas skip comments
            WRITE(25,758)
            NREC=1
  121       NREC=NREC+1
            BACKSPACE(5)
            BACKSPACE(5)
            READ(5,766)CARD4
            IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
            REWIND(5)
            DO N=1,NREC
              READ(5,760)CARD
              WRITE(25,759)CARD
            ENDDO
            DATE='        '
            CALL DATE_AND_TIME(DATE)
            WRITE(25,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X                  ,DATE(3:3),DATE(4:4)
           endif
            DO M=MSC0,MSC
              CLOSE(M)
            ENDDO
            IF(.NOT.BEXP)CLOSE(MSCP)
          ELSE
            IF(IORIG(IOLD).LT.0)GO TO 372
            JOLD=IIMN          !1
            JNEW=IIMN          !1
            INEW=INEW+1
            GO TO 371
          ENDIF
        ELSE
          IF(IORIG(JOLD).LT.0)GO TO 373
          JNEW=JNEW+1
          GO TO 371
        ENDIF
c
        if(btime)then
          call cpu_time(timef)
          timew=timef-timei
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'proc',iam,' for diagon:'               !par
cpar            write(iwp,*)'    radiative time=',nint(times),'sec' !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
            write(iw,*)'adf04/omginf time=',nint(timew),'sec'
cpar          endif                                                 !par
        endif
C
      ENDIF                               !END ADF04/OMGINF WRITES
C
C DE-ALLOCATE
C
 7450 CONTINUE
C
      IF(BOMRC)THEN
        DEALLOCATE (OMR,OMC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR OMR,OMC'
          NF=MIN(NF,IZERO)
        ENDIF
        BOMRC=.FALSE.
      ENDIF
C
      IF(ALLOCATED(IDY))THEN
        DEALLOCATE (IDY,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR IDY'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(ALLOCATED(OMEGA))THEN
        DEALLOCATE (OMEGA,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR OMEGA'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(.NOT.BFOTJ.AND.ALLOCATED(DVECF))THEN
        DEALLOCATE (DVECF,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR DVECF'
          NF=MIN(NF,IZERO)
        ENDIF
      ENDIF
C
      IF(BPOS)THEN
        DEALLOCATE (NPOS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DIAGON: DE-ALLOCATION FAILS FOR NPOS'
          NF=MIN(NF,IZERO)
        ENDIF
        BPOS=.FALSE.
      ENDIF
C
      IF(NF.LE.0)GO TO 750                                       !RETURN
C
C UPDATE FUNCTIONAL (RE-ENTRY POINT IF NO RADIATION)
C
      IF(NGF.NE.0)SGF=DTWO*SGF/NGF
  745 DRY=DF
      IF(IOPTIM.EQ.0)DRY=DRY+DECORE
      DRY=DRY*DTWO
      IF(BPRNT0)WRITE(6,999)INCLUD,DRY,SGF,NGF,JPRINT  !.AND.INCLUD.NE.0
      IF(JPRINT.EQ.-2)THEN
        DF=SGF
        if(includ.ne.0)WRITE(6,998)
        DECORE=DZERO
      ENDIF
C
  750 CONTINUE
C
C LOCAL DEALLOCATE
C
      IF(ALLOCATED(IHARRY))THEN
        DEALLOCATE (IHARRY,E1BCF,SUMA)
      ENDIF
      IF(ALLOCATED(DENERG))THEN
        DEALLOCATE (DENERG,IWRK2,ID,IORIG,DVECL,DVECV,DVECA)
      ENDIF
      IF(ALLOCATED(DWRK))THEN
        DEALLOCATE (DWRK,IWRK3,IWRK4)
      ENDIF
      IF(ALLOCATED(JCP))THEN
        DEALLOCATE (JCP,JTP,JWRN,JWRD,ERN,ERD)
      ENDIF
      IF(ALLOCATED(JRP))DEALLOCATE (JRP)
      IF(ALLOCATED(SUMRN))THEN
        DEALLOCATE (SUMRN,SUMRD)
      ENDIF
      IF(ALLOCATED(SUMPN))THEN
        DEALLOCATE (SUMPN,SUMPD)
      ENDIF
      if(allocated(iwrkb))then
        deallocate (iwrkb)
      endif
      if(allocated(iwrkg))then
        deallocate (iwrkg)
      endif
      IF(ALLOCATED(ITMP))DEALLOCATE (ITMP)
C
C WRITE TERMINATORS
C
      IF(MODE.GT.0)THEN
        IF(BPRNT0)WRITE(MW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWU)int(IZERO),int(IZERO),int(IZERO)
     X               ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
      IF(.NOT.BFOTJ)THEN
        IF(BPRNT0)WRITE(MWW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWWU)int(IZERO),int(IZERO),int(IZERO)
     X               ,int(IZERO),int(IZERO),int(IZERO),DZERO,DZERO,DZERO
      ENDIF
C
C CLOSE SOME FILES
C
      IF(NJO.LE.0)THEN
        IF(IUNIT(1).GT.0)THEN
          CLOSE(1)
          IUNIT(1)=-1
        ENDIF
        IF(IUNIT(4).GT.0)THEN
          CLOSE(4)
          IUNIT(4)=-1
        ENDIF
      ENDIF
      IF(IUNIT(21).GT.1)THEN
        CLOSE(21)
        IUNIT(21)=-1
      ENDIF
      IF(IUNIT(23).GT.1)THEN                  !so par scratch not closed
        CLOSE(23)
        IUNIT(23)=-1
      ENDIF
      IF(IUNIT(25).GT.1)THEN
        CLOSE(25)
        IUNIT(25)=-1
      ENDIF
C
C
      RETURN
C
C
 2000 IF(NF.GT.0)NF=-1
      GO TO 7600                                            !DE-ALLOCATE
C
 3000 IF(NF.GT.0)NF=-1
      GO TO 7450                                            !DE-ALLOCATE
C
C DIMENSION EXCEEDED, ABORT
C
  710 WRITE(6,984)MC,MAXUC
      WRITE(0,*)'INSUFFICIENT TF COEFFICIENTS OR REDUCED MATRX ELEMENTS'
      GO TO 2000
  990 WRITE(6,980)MAXDI,NC,MAXUC,MM
C      NF=-2
C      DF=DZERO
      WRITE(0,*)'SR.DIAGON: DIMENSION EXCEEDED - MAXDI OR MAXUC'
      GO TO 2000
C
C***********************************************************************
C
   70 FORMAT(I6,' CALC ',F10.1,'     OBS ',F10.1, '   SQ-DIF.SUM',E16.5)
  100 FORMAT(88X, 'R OF 3 LAST P(R):',3F9.4)
  181 FORMAT(I4,3I3,F14.5,F14.6,I3,2I4,10F8.4)
  182 FORMAT((52X,10F8.4))
  200 FORMAT(//' GAM ( N,  L,NION, Z,SIG/D/P)  EPSILON/RY      <1/R>  '
     X,'<Z/R-V>      <R>   <R**2>   <R**3>   (ADJUST, REND, 3 LAST P), '
     X,'IN',I7,' STEPS')
  201 FORMAT(//' GAM ( N,  L,NION, Z,Q.D/D/P)  EPSILON/RY      <1/R>  '
     X,'<Z/R-V>      <R>   <R**2>   <R**3>   (ADJUST, REND, 3 LAST P), '
     X,'IN',I7,' STEPS')
  250 FORMAT(5I4,F9.5,F13.5,1X, 3F9.5,2F9.4, 2X,F8.4,F6.2,1X,3(1PE9.2))
  301 FORMAT(22X,'2MXLBD=',I3)
  400 FORMAT (//'   T,2S+1L  P   H(ZZ)/2RY   EIGEN-H/2RY   CF  NI  NO  '
     X,'MATRIX <GSL!CASL>  AND  H(Z)/2RY-TRIANGLE.  E(CORE)/2RY ='
     X,F10.5,F11.4)
  500 FORMAT(I5,A4,2I4,1PE15.3,0PF14.7,F16.6,3X,2F10.5,F12.4,4F12.4)
  501 FORMAT(    6I5,1PE15.5   ,2(0PF15.6))
  502 FORMAT(1X,4X,I4,2I4,1PE15.3,   2(0PF15.4))
  503 FORMAT(60X,F15.6)
  504 FORMAT(4X,'NA',2X,'W',3X,'T  TP',8X,'AA*SEC',6X,'ECONT(A.U)'
     X,7X,'E-I(A.U)')
  505 FORMAT(8X,'I-S',12X,'C-S',11X,'AUTO-IONIZATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',4X,'T',4X,'W',3X,'CF',4X,'T',4X,'W',6X
     X,'AA*SEC',9X,'E-C(RYD)',6X,'E-I(RYD)')
  506 FORMAT(5I5,4X,'X',1PE15.5,2(0PF15.6))
  507 FORMAT(I3,'CFLS',2X,'G',3X,'Z=',I2,4X,'N=',I2,2X,'NL',62(I3,I2))
  508 FORMAT(8X,'I-S',12X,'G-S',15X,'RADIATIVE DATA',9X,'Z=',I2,3X,'N='
     X,I2/3X,'CF',4X,'T',4X,'W',3X,'CF',4X,'T',4X,'W',6X,'AR*SEC', 9X,
     X'DEL(RYD)',6X,'E-G(RYD)')
  509 FORMAT('+',67X, '(AA DATA INCLUDES TERM ENERGY CORRECTION)' )
  510 FORMAT(4X,'NTERM=',I5,39X,'E1/RY=',F15.6/4X,'I',4X,'T',6X,'2S+1'
     X,4X,'L',8X,'CF',5X,'(EI-E1)/RY')
  511 FORMAT(2I5,5X,2I5,5X,I5,F15.6,I10)
  512 FORMAT(A4)
  513 FORMAT(8X,'I-S',12X,'C-S',7X,'PHOTO-RECOMBINATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',4X,'T',4X,'W',3X,'CF',4X,'T',3X,'EO',6X
     X,' P/CM2',9X,'E-I(RYD)',6X,'E-C(RYD)')
  514 FORMAT(I3,' E(RYD) ' ,2X,'Z=',I2,4X,'N=',I2,5X,'LS-Coupling'
     X,11X,'EIONMIN=',F15.6)
  515 FORMAT(5(1PE15.5))
  516 FORMAT(8X,'I-S',12X,'C-S',10X,'PHOTO-IONIZATION DATA',7X,'Z=',I2
     X,3X,'N=',I2/3X,'CF',4X,'T',4X,'W',3X,'CF',4X,'T',3X,'EO',6X
     X,' P/CM2',9X,'E-I(RYD)',6X,'E-C(RYD)')
  517 FORMAT(2I5,4X,I1,I2,1X,10(I2,A1))
  518 FORMAT(I4,3I3,1PE14.6)
  519 FORMAT(I4,' TERMS AMONG',I4,' (KCUT=',I2,')')
  520 FORMAT(I5,' LS TERMS',I5,36X,A4//
     X'   TERM   2S+1      L     PI     ENERGY(RYD)   ORIG. TERM #')
  521 FORMAT(4I7,F16.7,I15)
  531 FORMAT(3I6,I3,100(I3,I2))
  532 FORMAT(2I6,F13.3)
  536 FORMAT('*** SR.DIAGON: INCREASE INTERNAL DIMENSION MXSTRG TO',I3)
  537 FORMAT(' &ADASEX NTERM= XXX',' &END')                      !,I3
  540 FORMAT('NAME:'/'DATE:'/'.')
  541 FORMAT(A2,'+',I2,2I10,F15.4,A4)
  600 FORMAT('   E',I1, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    '
     X,12X,'G*F',8X,'F(ABS)   -F(EMI)    WAVEL/AE'
     X,5X,'GF(VEL)  V(GFL*GFV)',5X,'GF(ACC)',2X,'ALPHA(POL)')
  601 FORMAT(24X,'VELOCITY',6X,'VELOCITY',91X,'VELOCITY')
  701 FORMAT(/ ' GAM   I(A,C) = ONE-BODY INTEGRALS')
  702 FORMAT(1X,I3,9F14.7/(4X,9F14.7))
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X,'AUTOSTRUCTURE PLANE-WAVE BORN'/
     X'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  767 FORMAT(I6,40(F6.3))
  768 FORMAT(/"CONFIGURATION OVERLAP MATRIX (SET TO ZERO IF CF'S DIFFER"
     X," BY MORE THAN 2 PAIRS) CASE IRLX=2:"/6X,40(I6))
  800 FORMAT('   E',I1, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    '
     X,4X,'10**',I1,'*','  G*F',7X,'*F(ABS)   -F(EMI)    WAVEL/AE'
     X,4X,'*GF(VEL) *V(GFL*GFV)',4X,'*GF(ACC)',3X,'OMG(BORN)')
  801 FORMAT('  E',I2, '-DATA  I  IP', 6X, 'A(EK)*SEC         S    '
     X,4X,'10**',I1,'*','  G*F',7X,'*F(ABS)   -F(EMI)    WAVEL/AE'
     X,4X,'*GF(VEL) *V(GFL*GFV)',4X,'*GF(ACC)',3X,'OMG(BORN)')
  810 FORMAT(24X,'VELOCITY',6X,'VELOCITY')
  897 FORMAT(I6)
  898 FORMAT(' ',I8, ' USED, MXAAI=',I8)
  899 FORMAT('*****STORAGE EXCEEDED IN SR.DIAGON, INCREASE MXAAI TO',I8)
  900 FORMAT(//9X,'ONE-BODY RELATIVISTIC CORRECTIONS TO INDIVIDUAL '
     X,'ORBITALS IN UNITS OF 2*RY',35X,'LS.JPRINT =',I4
     X/9X,'GAM    N    L    E(NON.REL)',8X,'E(MASS)',6X,'E(DAR)'
     X,7X,'E(TOT)',23X,'<P**2/RY>')
  901 FORMAT(' CORE CONTRIB. ',F12.4,F12.5)
  902 FORMAT(7X,3I5,F14.6,3X,2F12.6,F13.7,20X,F12.6)
  903 FORMAT(/' ONE-BODY RELATIVISTIC INTEGRALS'/
     X' I(R)  I(  A,  C ) = ',6X,'MASS',9X,'DARWIN',24X,'<P**2>')
  904 FORMAT(I5,3X,2I4,3X,2F14.7,16X,F14.7)
  980 FORMAT(/' SR.DIAGON: IF MAXDI =',I5,'.LT.',I5,  '    INCREASE  ',
     X'MAXDI'/' *********  IF MAXUC=',I7,'.LT.',I7, ' INCREASE *MAXUC')
  981 FORMAT(' S L P',3X,'CF',3X,'NI',7X,'ENERGY(RYD)')
  984 FORMAT(/' SR.DIAGON   MAXUC=',I7, '  REQUIRED FOR ARRAY TFU'/20X
     X,I6, '  INSUFFICIENT TO COMPUTE RADIATIVE TRANSITION DATA')
  989 FORMAT(//' *** ATTN: BECAUSE BORN MULTIPOLES ARE BEING COMPUTED'
     X,' FOR NON-E1 TRANSITIONS, RADIATIVE DATA IS NOT COMPUTED FOR',
     X' THOSE E3 TRANSITIONS'/11X,'FOR WHICH E1 DATA ALREADY'
     X,' EXISTS (SO AS NOT TO OVERWRITE THE E1-LIMIT)'/)
  991 FORMAT(/' *** WORKING ARRAYS TOO SMALL IN SR.DIAGON, INCREASE'
     X,' MXAAI TO:',I6/' *** OR REDUCE NUMBER OF SPECTROSCOPIC TERMS')
  992 FORMAT(3I2,I5,I5,F18.6,3X,A4)
  993 FORMAT(90X, 'TERM ENERGY ',A24)
  994 FORMAT(' ',85X,I5,F10.0,F11.6,F14.6)
  995 FORMAT(2I10,F13.0,I5,I2,I5,A4,F8.3,F18.6,I10)
  996 FORMAT(9X,'I',8X,' T',8X,'K*CM',2X, '2S+1 L   CF',5X,'WEIGHTS',8X
     X,'(EI-E1)/RY     E1/RY =',F14.6)
  997 FORMAT(//I6,' (IF .GT. 0: LOWEST STAT-WEIGHTED) TERMS ARE'
     X,' MINIMIZED;    SCALING PARAMETERS ',5F9.5,/((84X,5F9.5)))
  998 FORMAT(68X, '*WARNING*  G WILL BE MINIMIZED, AS JPRINT=-2')
  999 FORMAT(//9X,'INCLUD =',I5,9X, 'FUNCTIONAL F =',1PE14.7,9X
     X,'FUNCTIONAL G =',E10.3,' (',I4, ' TRANSITIONS)',9X
     X, 'LS.JPRINT=',I2//)
 1000 FORMAT(' SR.DIAGON DOES NOT CALCULATE E-ENERGIES (OR RATES) SINCE'
     X,' MPRINT= ',I2/' ***********************************************'
     X,'******************* ')
 1001 FORMAT(' *****ERROR IN SR.DIAGON, IT IS NOT POSSIBLE TO RUN MDEL'
     X,' .LT. 0 AND BDR .TRUE. AS PROGRAMMED ')
 1002 FORMAT(33X,I1,'-POLE PERTURBED TFDA POTENTIAL SCALING PARAMETERS '
     X,5F9.5,/((84X,5F9.5)))
 1137 FORMAT('SR.DIAGON: ALLOCATION INCREASES NO. OF BORN INTERACTIONS '
     X       ,'IXBIF=',I10,' .GT. MXBIF=',I10)
 1603 FORMAT(2X,2I5,I4,10X,9(I2,I1))
 1604 FORMAT(//1X,'LIST OF CFS THAT CONTRIBUTE AN ENERGY GREATER THAN '
     X,F7.0,'  /CM'//)
 1605 FORMAT('*** SR.DIAGON: COULD ACCESS MEMORY FASTER IF MXD30=',I7)
 1749 FORMAT(//'*** FILE "ITANAL" WRITTEN FOR:  ITANAL=',I6,5X,'ECNTRB='
     X,F12.2,' /CM'/)
 1750 FORMAT(1X,2I5,F10.5,F15.2,F12.2,5X,9(I2,I1))
 1751 FORMAT(//1X,'TERM NUMBER',I4,'  SLP = ',2I3,'  ENERGY =',F15.2,
     X' /CM'/1X,'***************'//'     T   CF     COEFF   ENERGY-DIFF'
     X,'   ENERGY-CNTRB      ELECTRON CF'/)
 3005 FORMAT (/25X,' Q.E.D. CONTRIBUTIONS /2RY'/8X,'  GAM    N    L'
     X,3X,'VACUUM POLARIZ.',6X,'SELF ENERGY',9X,'TOTAL')
 3010 FORMAT(8X,3I5,3(2X,F15.7),2F10.5)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION ICOL(ILI,ILF,IONE1)
C
      ICOL=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      END FUNCTION ICOL
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DIAGON
C
C                             *******************
C
      SUBROUTINE DIFF(DA,DB,NH,HN,JH)
C
C-----------------------------------------------------------------------
C
C  SR.DIFF COMPUTES THE FIRST DERIVATIVE OF ARRAY DA INTO ARRAY DB,
C  USING A 7 POINT LAGRANGE FORMULA.
C  REFERENCE: W.G. BICKLEY, MATH.GAZ.25, 19-27 (1941).
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DA(*),DB(*),HN(JH),NH(JH)
C
      N=0
C
      DO J=1,JH
        F=1/(60*HN(J))
        NA=N+1
        K=NA
        DB(NA)=(-147*DA(K)+360*DA(K+1)-450*DA(K+2)+400*DA(K+3)
     X          -225*DA(K+4)+72*DA(K+5)-10*DA(K+6))*F
        DB(NA+1)=(-10*DA(K)-77*DA(K+1)+150*DA(K+2)-100*DA(K+3)
     X            +50*DA(K+4)-15*DA(K+5)+2*DA(K+6))*F
        DB(NA+2)=(2*DA(K)-24*DA(K+1)-35*DA(K+2)+80*DA(K+3)-30*DA(K+4)
     X           +8*DA(K+5)-DA(K+6))*F
        N=NH(J)+N
        NB=N-6
C
        DO K=NA,NB
          DB(K+3)=(((DA(K+4)-DA(K+2))*5+DA(K+1)-DA(K+5))*9+DA(K+6)
     X              -DA(K))*F
        ENDDO
C
        K=NB
        NB=N
        DB(NB-2)=(DA(K)-8*DA(K+1)+30*DA(K+2)-80*DA(K+3)+35*DA(K+4)
     X        +24*DA(K+5)-2*DA(K+6))*F
        DB(NB-1)=(-2*DA(K)+15*DA(K+1)-50*DA(K+2)+100*DA(K+3)-150*DA(K+4)
     X           +77*DA(K+5)+10*DA(K+6))*F
        DB(NB)=(10*DA(K)-72*DA(K+1)+225*DA(K+2)-400*DA(K+3)+450*DA(K+4)
     X        -360*DA(K+5)+147*DA(K+6))*F
      ENDDO
C
      RETURN
C
      END SUBROUTINE DIFF
C
C                             *******************
C
      SUBROUTINE DIMUSE(NAME,NDIMEN)
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C-----------------------------------------------------------------------
C
C  SR.DIMUSE
C     NDIMEN.GT.0 STORES THE MAX VALUE OF THE PRIMARY DIMENSION NAME.
C     NDIMEN.LE.0 RETURNS THE MAX VALUE OF THE PRIMARY DIMENSION NAME.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=5) KNAM,NAME
C
      COMMON /NRBDIM/MXUSED(MXDIM),KNAM(MXDIM)
C
      DO K=1,MXDIM
        IF(NAME.EQ.KNAM(K))THEN
          IF(NDIMEN.GT.0)THEN
            MXUSED(K)=MAX(MXUSED(K),NDIMEN)
          ELSE
            NDIMEN=MXUSED(K)
          ENDIF
          RETURN
        ENDIF
      ENDDO
C                                                 SHOULD NEVER GET HERE!
      WRITE(6,*)'SR.DIMUSE: DIMENSION NAME NOT FOUND ',NAME
      STOP 'SR.DIMUSE: DIMENSION NAME NOT FOUND'
C
      END SUBROUTINE DIMUSE
C
C                             *******************
C
       SUBROUTINE DIPOL(JSW,N1,N2,E2,LMAX,CP,CM,JC)
C
C-----------------------------------------------------------------------
C
C  ALAN BURGESS DAMTP CAMBRIDGE, MODS BY NRB.
C
C  SR.DIPOL CALCULATES SQUARES OF HYDROGENIC DIPOLE LENGTH RADIAL MATRIX
C  ELEMENTS FOR BOUND-BOUND OR BOUND-FREE TRANSITIONS.
C
C  BOUND STATES ARE NORMALISED TO UNITY.
C  FREE STATES ARE NORMALISED TO ASYMPTOTIC AMPLITUDE K**(-0.5).
C
C  N.B. DIPOLE ACCELERATION MATRIX ELEMENT = (E12**2/4Z) * DIPOLE LENGTH
C  WHERE E12 = - N1**(-2) + N2**(-2)  FOR BOUND-BOUND
C            = - N1**(-2) + E2        FOR BOUND-FREE
C          Z = REDUCED CHARGE
C  INPUT:
C   FOR BOUND-BOUND,SET JSW=NEGATIVE
C                     N1,N2=PRINCIPAL QUANTUM NUMBERS OF STATES
C                      LMAX=RANGE OF ANGULAR MOMENTUM QUANTUM NUMBERS
C   FOR BOUND-FREE, SET JSW=POSITIVE
C                       N1=BOUND STATE PRINCIPAL QUANTUM NUMBER
C                       E2=FREE STATE ENERGY IN RYDBERGS (=K**2)
C
C  OUTPUT:
C   VECTOR CP(L),L=1,LMAX,CONTAINS SQUARED MATRIX ELEMENTS FOR ANGULAR
C                         MOMENTUM TRANSITIONS FROM L-1 TO L,
C   VECTOR CM(L),L=1,LMAX,CONTAINS SQUARED MATRIX ELEMENTS FOR ANGULAR
C                         MOMENTUM TRANSITIONS FROM L TO L-1,
C               IN BOTH CASES THE TRANSITION IS FROM LOWER TO HIGHER
C               ENERGY, INDEPENDANT OF THE SIGN OF N1-N2 FOR BOUND-BOUND
C               CASES. IF N1=N2 THEN CP(L)=CM(L).
C   VECTOR JC(L),L=1,LMAX WILL USUALLY BE ZERO AND MAY THEN BE IGNORED,
C               BUT FOR EXTREME INPUT VALUES THERE IS POSSIBILITY OF
C               OVER OR UNDERFLOW OF CP(L) OR CM(L),IN WHICH CASE THE
C               OUTPUT VALUES OF CP(L) AND CM(L) SHOULD BE MULTIPLIED
C               BY (1.0D10)**JC(L) TO OBTAIN TRUE VALUES.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (S1=1.0D10)
      PARAMETER (S2=1.0D-10)
      PARAMETER (TEST1=1.0D-20)
      PARAMETER (TEST2=1.0D20)
      PARAMETER (TEST3=0.044D0)
      PARAMETER (TEST4=0.1D0)
      PARAMETER (TEST5=300.0D0)
      PARAMETER (TEST6=1.0D-30)
      PARAMETER (TEST7=1.0D30)
C
      DIMENSION CP(LMAX),CM(LMAX),JC(LMAX)
C
      PI=ACOS(-DONE)
C
      N=N1
      E=E2
      IF(JSW.LE.0)THEN
        EN2=N2
        N3=N2
        IF(N1.EQ.N2)GO TO 59
        IF(N2.LT.N1)THEN
          N=N2
          EN2=N1
          N3=N1
        ENDIF
        E=-DONE/(EN2*EN2)
      ENDIF
C
      EN=N
      ENN=EN*EN
      E1=-DONE/ENN
      JMAX=LMAX
      C1=DONE
      C2=DZERO
      JS=0
      L=N+1
      IF(N.LE.LMAX)THEN
        CP(N)=DONE
        CM(N)=DZERO
        JC(N)=0
        JMAX=N-1
        DO I=L,LMAX
          CP(I)=DZERO
          CM(I)=DZERO
          JC(I)=0
        ENDDO
      ENDIF
C
    9 L=L-1
      IF(L.GT.1)THEN
        EL=L
        ELL=EL*EL
        T1=DONE+ELL*E1
        T2=DONE+ELL*E
        T3=L+L-1
        T4=DONE/(T3+DONE)
        T5=(T3*T1*C2+T2*C1)*T4
        C1=(T1*C2+T3*T2*C1)*T4
        C2=T5
   11   IF(C1*C1.GT.TEST2)THEN
          C1=S2*C1
          C2=S2*C2
          JS=JS+1
          GO TO 11
        ENDIF
        IF(L.LE.LMAX+1)THEN
          CP(L-1)=C1
          CM(L-1)=C2
          JC(L-1)=JS
        ENDIF
        GO TO 9
      ENDIF
C
      JS=0
      T=4
      T=DONE/(T*EN*ENN)
      IF(JSW.LE.0)THEN                          !JSW.LT.0
        ENN2=EN2*EN2
        T1=4
        T1=T1*ENN*ENN2/(ENN2-ENN)
        T1=T1*T1
        T=T*T1*T1/(EN2*ENN2)
        IF(N3.LE.30)THEN
          T=T*((EN2-EN)/(EN2+EN))**(N3+N3)
          GO TO 34
        ENDIF
        E21=E/E1
        IF(E21.LE.TEST4)THEN
          T2=DZERO
          DO J=1,11
            T3=2*(11-J)+1
            T2=DONE/T3+T2*E21
          ENDDO
          T2=T2+T2
        ELSE
          T3=EN/EN2
          T2=LOG((DONE+T3)/(DONE-T3))/T3
        ENDIF
        T2=T2+T2
        T1=T1*EXP(-T2)
C
      ELSE                                      !JSW.GT.0
C
        T1=4
        T1=T1*ENN/(DONE+ENN*E)
        T1=T1*T1
        T=T*T1*T1
        IF(E.LT.TEST3)THEN
          T3=2
          T=T*(PI/T3)
        ELSE
          T4=SQRT(E)
          IF(T4.LE.TEST5)THEN
            T3=(PI+PI)/T4
            T3=DONE-EXP(-T3)
            T3=DONE/T3
          ELSE
            T4=PI/T4
            T3=3
            T3=(DONE+T4+T4*T4/T3)/(T4+T4)
          ENDIF
          T2=2
          T=T*(PI*T3/T2)
        ENDIF
C
        T4=ENN*E
        IF(T4.LE.TEST4)THEN
          T2=DZERO
          DO J=1,11
            T3=2*(11-J)+1
            T2=DONE/T3-T2*T4
          ENDDO
        ELSE
          T3=SQRT(T4)
          T2=ATAN(T3)/T3
        ENDIF
        T2=T2+T2
        T2=T2+T2
        T1=T1*EXP(-T2)
      ENDIF
C                                               !ALL JSW
   34 DO J=1,N
        TJ=J+J
        T2=TJ*(TJ-DONE)
        T2=T2*T2
        T=T*T1/T2
   35   IF(T.LE.TEST1)THEN
          T=T*S1
          JS=JS-1
          GO TO 35
        ENDIF
   37   IF(T.GE.TEST2)THEN
          T=T*S2
          JS=JS+1
          GO TO 37
        ENDIF
      ENDDO
      J=0
C
   40 J=J+1
      IF(J.LE.JMAX)THEN
        TJ=J
        TJ=TJ*TJ
        T1=DONE+TJ*E1
        T2=DONE+TJ*E
        T3=CP(J)
        T3=T2*T*T3*T3
        T4=CM(J)
        T4=T1*T*T4*T4
        L1=JC(J)+JC(J)+JS
C
   42   IF(L1.LT.0)THEN
          IF(T4.GT.TEST6)THEN
            L1=L1+1
            T3=T3*S2
            T4=T4*S2
            GO TO 42
          ENDIF
        ELSEIF(L1.GT.0)THEN
          IF(T3.LT.TEST7)THEN
            L1=L1-1
            T3=T3*S1
            T4=T4*S1
            GO TO 42
          ENDIF
        ENDIF
C
        CP(J)=T3
        CM(J)=T4
        JC(J)=L1
        T=T*T1*T2
   48   IF(T.GT.TEST2)THEN
          T=T*S2
          JS=JS+1
          GO TO 48
        ENDIF
        GO TO 40
      ENDIF
C
      IF(N.LE.LMAX)THEN
        T2=DONE+ENN*E
        T3=CP(N)
        T3=T2*T*T3*T3
        L1=JC(N)+JC(N)+JS
C
   52   IF(L1.LT.0)THEN
          IF(T3.GT.TEST6)THEN
            L1=L1+1
            T3=T3*S2
            GO TO 52
          ENDIF
        ELSEIF(L1.GT.0)THEN
          IF(T3.LT.TEST7)THEN
            L1=L1-1
            T3=T3*S1
            GO TO 52
          ENDIF
        ENDIF
C
        CP(N)=T3
        JC(N)=L1
      ENDIF
C
      RETURN
C
   59 JMAX=LMAX
      IF(N.LE.LMAX)THEN
        DO L=N,LMAX
          CP(L)=DZERO
          CM(L)=DZERO
          JC(L)=0
        ENDDO
        JMAX=N-1
      ENDIF
      T1=9
      T2=4
      T3=(T1/T2)
      T1=EN2*EN2
      T2=T1*T3
      DO J=1,JMAX
        TJ=J
        JC(J)=0
        T=T2*(T1-TJ*TJ)
        CP(J)=T
        CM(J)=T
      ENDDO
C
      RETURN
C
      END SUBROUTINE DIPOL
C
C                             *******************
C
      SUBROUTINE DISKDC(IU,ISTRT,IFIN,KF,NGSYM,IRW,MSTRT0)
C
C-----------------------------------------------------------------------
C
C SR.DISKDC READS/WRITES TO AN UNFORMATTED UNIT=IU FILE.
C ALL WRITES TAKE PLACE BEFORE ALL READS, SO IS SEQUENTIAL
C AND, UNLESS SINGLE STAGE RESTART (MSTRT0.GT.IRL5=6), 'SCRATCH'.
C
C  IRW.EQ.0 ALLOWS OPEN/CLOSE/REWIND OF FILE ETC - SEE  BELOW
C     .GT.0 READ A SLICE OF THE DC (& IDC) ARRAYS
C     .LT.0 WRITE      "        "         "
C FROM
C  ISTRT TO IFIN (IN THE CASE OF READ, IFIN IS OUTPUT ONLY)
C FOR
C  KF CONFIG
C  NGSYM SLP SYMMETRY GROUP INDEX WITHIN THE CONFIG
C
C  MSTART IS USED TO FLAG FILE STATUS AT
C     OPEN: REPLACE/OLD
C    CLOSE: KEEP/DELETE
C (MOST OBVIOUSLY FOR THE USUAL RESTART, BUT MORE GENERALLY AS WELL.)
C
C RELEVANT COMMON VARIABLES:
C  MDCF8 CONTAINS THE TOTAL NUMBER OF VCC'S (DC ARRAY) FOR KF
C  MDCFT8 CONTAINS THE SUM OF MDCF8 OVER ALL CONFIGS.
C  MDCBUF CONTAINS THE CURRENT DC SLICE LENGTH:
C   DURING WRITE IT LOGS THE MAX LENGTH OF SLICE OF ARRAY DC USED
C   AND DURING READ IT CHECKS IFIN DOES NOT EXCEED IT (=MAXDC FOR F77)
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_DC,     ONLY: DC,IDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD14=100)
C
      INTEGER(EP) MDCF8,MDCFT8
C
      PARAMETER (LREC=2**15)
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
      PARAMETER (IRL5=6)                        !5+1 NOW ALG3/4 SEPARATE
C
      CHARACTER(LEN=2) NAME0
      CHARACTER(LEN=9) FILNAM
      CHARACTER(LEN=9) STATLB
cparc                                                               !par
cpar      character(len=1) :: num(0:9)                              !par
C
      ALLOCATABLE :: NPTS0(:)
      ALLOCATABLE :: IREC(:)                     !FOR DIRECT ACCESS ONLY
C
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
cparc                                                               !par
cpar      data num/'0','1','2','3','4','5','6','7','8','9'/         !par
C
      DATA BDSKLP/.FALSE./,BSEQ/.FALSE./,IRECL/0/
C
      SAVE KF0,NPOS0,npos1,npos2,istrt1,ifin1,istrt2,ifin2,NPTS0
     X    ,IREC,IRECW,IWORD,IOPEN,IUP
C
C
      BFAST=DC(0).LT.DZERO                              !ELSE OPT MEMORY
C
      IF(IRECL.EQ.0.AND..NOT.BSEQ)THEN                    !DIRECT ACCESS
        IRECL=8*LREC                                      !*8 DC
        IF(.NOT.BFAST)THEN                                !*4 IDC
          ITEST4=IBUFF4
          ITEST4=ITEST4+1
          IF(ITEST4.LT.IBUFF4)THEN                        !DEFAULT
            IWORD=4
          ELSE                                            !I*8 IMPOSED
            IWORD=8
          ENDIF
          IRECL=IRECL+IWORD*LREC
        ENDIF
      ENDIF
C
      IF(IRW.EQ.0)THEN                                   !INITIALIZE I/O
C
        MSTRT=ABS(MSTRT0)
        MSTART=MOD(MSTRT,IRL5)
        MS1=1
        IF(MSTRT.NE.0)MS1=MSTART/MSTRT
C
        IF(IUNIT(IU).EQ.0)THEN                                     !OPEN
C
          IF(IU.EQ.32)THEN
C
            IUP=IU+1
C
            KSL0=MAXSL*KMAX
            ALLOCATE (NPTS0(KSL0))          !SINCE MAY NOT YET KNOW NSL0
            IF(.NOT.BSEQ)ALLOCATE (IREC(KSL0))
C
            IF(MSTART.EQ.0.OR.MSTART*MS1.EQ.1)THEN
              STATLB='SCRATCH'                         !AS NO RE-RESTART
              IF(BSEQ)THEN
                OPEN(IU,FORM='UNFORMATTED',STATUS=STATLB)
              ELSE
                OPEN(IU,FORM='UNFORMATTED',STATUS=STATLB
     X            ,ACCESS='DIRECT',RECL=IRECL)
                IRECW=1
              ENDIF
            ELSE
              NAME0=''
cparc                                                               !par
cpar              i1=iam/10                                         !par
cpar              i2=iam-(10*(iam/10))                              !par
cpar              name0=num(i1)//num(i2)                            !par
cparc                                                               !par
              FILNAM='DISKDC'//NAME0
              IF(MSTART.LE.1)THEN                       !.EQ.0 TEST KEEP
                STATLB='REPLACE'
              ELSE
                STATLB='OLD'
              ENDIF
              IF(BSEQ)THEN
                OPEN(IU,FILE=FILNAM,FORM='UNFORMATTED',STATUS=STATLB)
              ELSE
                OPEN(IU,FILE=FILNAM,FORM='UNFORMATTED',STATUS=STATLB
     X              ,ACCESS='DIRECT',RECL=IRECL)
                IRECW=1                            !ONLY FOR MSTART.LE.1
              ENDIF
C
              IUNIT(IUP)=1
              FILNAM='IDISKDC'//NAME0
              OPEN(IUP,FILE=FILNAM,FORM='UNFORMATTED',STATUS=STATLB)
              IF(STATLB.EQ.'OLD')THEN
                READ(IUP)KSL0
                READ(IUP)(NPTS0(K),K=1,KSL0)
                IF(.NOT.BSEQ)READ(IUP)(IREC(K),K=1,KSL0)
              ENDIF
            ENDIF
C
          ELSEIF(IU.EQ.33)THEN
C
CDSK            FILNAM='DSKDMP'
CDSK            STATLB='REPLACE'
CDSK            OPEN(IU,FILE=FILNAM,FORM='UNFORMATTED',STATUS=STATLB)
c
            if(mstart.ne.0)stop 'diskdc: illegal mstart (non-zero)'
C
            STATLB='SCRATCH'                   !AS NO RESTARTX, MSTART=0
            IF(BSEQ)THEN
              OPEN(IU,FORM='UNFORMATTED',STATUS=STATLB)
            ELSE
              OPEN(IU,FORM='UNFORMATTED',STATUS=STATLB
     X            ,ACCESS='DIRECT',RECL=IRECL)
              IRECW=1
            ENDIF
C
          ELSE                           ! should not be here
            write(6,*)'sr.diskdc: illegal unit number',iu
            stop 'sr.diskdc: illegal unit number'
          ENDIF
C
          IUNIT(IU)=1
          IOPEN=IU                                  !FOR REDSS OPERATION
C
          KF0=9999
          NPOS0=0
          npos1=-1
          npos2=-1
C
        ELSEIF(IUNIT(IU).GT.0)THEN
C
          IF(ISTRT.EQ.0)THEN                                      !CLOSE
            IF(MSTART.GT.0.AND.MSTART.LT.4*(1-MS1))THEN       !FOR 2/3/4
              IUNIT(IU)=-1
            ELSE                                            !WE ARE DONE
              IUNIT(IU)=0
            ENDIF
            IF(IUNIT(IU).LT.0)THEN
              CLOSE(IU,STATUS='KEEP')
              IF(IU.EQ.32)THEN
                IF(IUNIT(IUP).GT.0)THEN
                  IF(MSTART.LE.1)THEN                           !REPLACE
                    KSL0=KGCF(KMAX)-KGCF(KUTDSK)
                    WRITE(IUP)KSL0
                    WRITE(IUP)(NPTS0(K),K=1,KSL0)
                    IF(.NOT.BSEQ)WRITE(IUP)(IREC(K),K=1,KSL0)
                  ENDIF
                  CLOSE(IUP,STATUS='KEEP')
                  IUNIT(IUP)=-1
                ENDIF
              ENDIF
            ELSEIF(IUNIT(IU).EQ.0)THEN
              CLOSE(IU,STATUS='DELETE')
              IF(IU.EQ.32)THEN
                IF(IUNIT(IUP).GT.0)THEN
                  CLOSE(IUP,STATUS='DELETE')
                  IUNIT(IUP)=0
                ENDIF
              ENDIF
            ENDIF
C
            IF(IU.EQ.IOPEN)THEN                             !WE ARE DONE
              DEALLOCATE (NPTS0)
              IF(.NOT.BSEQ)DEALLOCATE (IREC)
            ENDIF
C
          ELSE                                               !RE-INITIAL
            IF(NGSYM.GT.0)THEN
              KSL0=KGCF(KF-1)-KGCF(KUTDSK)+NGSYM
              NPTS=NPTS0(KSL0)
              IFIN=ISTRT+NPTS-1
            ENDIF
          ENDIF
C
        else                                        !-1
          write(6,*)'sr.diskdc: should not be here'
          stop 'sr.diskdc: should not be here'
        ENDIF
C
      ELSEIF(IRW.LT.0)THEN                                        !WRITE
C
        NPTS=IFIN-ISTRT+1
        MDCBUF=MAX(MDCBUF,NPTS)    !CAN'T USE IFIN BECAUSE OF VCG BUFFER
        IF(KF.GT.KF0)THEN
          MDCFT8=MDCFT8+MDCF8
          MDCF8=0
        ENDIF
        KF0=KF
        MDCF8=MDCF8+INT(NPTS)
c
c        write(0,*)kf,ngsym,istrt,ifin,npts,mdcbuf
C
        KSL0=KGCF(KF-1)-KGCF(KUTDSK)+NGSYM                      !=KSL0+1
        NPTS0(KSL0)=NPTS
C
        IF(BDSKLP)THEN
C          write(6,*)kf,ngsym,npts
          IF(.NOT.BFAST)WRITE(6,101)(IDC(I),I=ISTRT,IFIN)
          WRITE(6,100)(DC(I),I=ISTRT,IFIN)
        ENDIF
C
        IF(BSEQ)THEN
          WRITE(IU)(DC(I),I=ISTRT,IFIN)
          IF(.NOT.BFAST)WRITE(IU)(IDC(I),I=ISTRT,IFIN)
        ELSE
          IREC(KSL0)=IRECW
          I2=ISTRT-1
   50     CONTINUE
          I1=I2+1
          I2=MIN(I2+LREC,IFIN)
          IF(BFAST)THEN
            WRITE(IU,REC=IRECW)(DC(I),I=I1,I2)
          ELSE
            WRITE(IU,REC=IRECW)(DC(I),I=I1,I2),(IDC(I),I=I1,I2)
          ENDIF
          IRECW=IRECW+1                 !POINTS TO NEXT AVAILABLE RECORD
          IF(I2.LT.IFIN)GO TO 50
        ENDIF
C
      ELSEIF(IRW.GT.0)THEN                                         !READ
C
        NREC0=1                                   !ONLY NEEDED FOR BSEQ,
        IF(.NOT.BFAST)NREC0=NREC0+1               !ELSE A VIRTUAL INDEX
C
        KSL0=KGCF(KF-1)-KGCF(KUTDSK)+NGSYM
        NPOS=NREC0*(KSL0-1)                         !WHERE WE WANT TO BE
c
c test to see which buffer in use
c        npos0=0                            !test
c
        if(kutdsk.lt.kfbuff)then            !whole group
          npos1=-1
          npos2=-1
          ibuff=0                           !for variable length
        else                                !by cf
c
c then see if we already have it for quick return
c
          if(npos.eq.npos1)then
            istrt=istrt1
            ifin=ifin1
c                      write(77,*)npos,-kf,ngsym,istrt,ifin,npts
c                      call flush(77)
            return
          elseif(npos.eq.npos2)then
            if(istrt.eq.mtgd1)then
              ifin=mtgd1-1
              do i=istrt2,ifin2
                ifin=ifin+1
                dc(ifin)=dc(i)
                if(.not.bfast)idc(ifin)=idc(i)
              enddo
              istrt1=mtgd1                                    !trivially
              ifin1=ifin
              istrt=istrt1
              ifin=ifin1
              npos1=npos2
              npos2=-1                                      !not necess.
c                      write(79,*)npos,-kf,-ngsym,istrt,ifin,npts
c                      call flush(79)
              return
            else
              istrt=istrt2
              ifin=ifin2
c                      write(78,*)npos,kf,-ngsym,istrt,ifin,npts
c                      call flush(78)
              return
            endif
          endif
c
c no we don't, so read
c
c          ibuff=0   !for variable length (and see end of this if block)
          ibuff=(mdcbuf-mtgd1+1)/2                     !for fixed length
          if(istrt.gt.mtgd1)istrt=mtgd1+ibuff          !for fixed length
        endif
C
        NPTS=NPTS0(KSL0)
C
        IFIN=ISTRT+NPTS-1
        IF(IFIN.GT.MDCBUF)THEN
          WRITE(6,102)IFIN,MDCBUF
          WRITE(0,*)' *** DISKDC ERROR: RECORD TO LONG FOR DC ARRAY'
          IFIN=-IFIN
          RETURN
        ENDIF
c
c        write(76,*)npos,kf,ngsym,istrt,ifin,npts
c        call flush(76)
C
        IF(BSEQ)THEN
C
          IF(NPOS0.EQ.0)REWIND(IU)                           !FIRST READ
C
          IF(NPOS.GT.NPOS0)THEN              !PROGRESS THRU FINAL GROUPS
            DO N=NPOS0+1,NPOS
              READ(IU)
            ENDDO
          ELSEIF(NPOS.LT.NPOS0)THEN   !+NREC0 !START A NEW INITIAL GROUP
            IF(NPOS0-NPOS.GT.NPOS)THEN
              REWIND(IU)
              DO N=1,NPOS
                READ(IU)
              ENDDO
            ELSE
              DO N=NPOS+1,NPOS0
                BACKSPACE(IU)
              ENDDO
            ENDIF
          ENDIF
C
          READ(IU)(DC(I),I=ISTRT,IFIN)
          IF(.NOT.BFAST)READ(IU)(IDC(I),I=ISTRT,IFIN)
C
          NPOS0=NPOS+NREC0
C
        ELSE
C
          IRECR=IREC(KSL0)
          I2=ISTRT-1
   10     CONTINUE
          I1=I2+1
          I2=MIN(I2+LREC,IFIN)
          IF(BFAST)THEN
            READ(IU,REC=IRECR)(DC(I),I=I1,I2)
          ELSE
            READ(IU,REC=IRECR)(DC(I),I=I1,I2),(IDC(I),I=I1,I2)
          ENDIF
          IRECR=IRECR+1
          IF(I2.LT.IFIN)GO TO 10
c
c          if(.not.bfast)write(6,101)(idc(i),i=istrt,ifin)
c          write(6,100)(dc(i),i=istrt,ifin)
C
        ENDIF
c
c - not currently used if(kutdsk.lt.kfbuff)...
c
        if(istrt.eq.mtgd1)then
          npos1=npos
          istrt1=istrt                                        !trivially
          ifin1=ifin
          if(ibuff.eq.0)npos2=-1              !reset unless fixed length
        else
          npos2=npos
          istrt2=istrt
          ifin2=ifin
        endif
C
      ENDIF
C
      RETURN
C
 100  FORMAT(10F8.4)
 101  FORMAT(10I8)
 102  FORMAT(/' *** DISKDC ERROR: ATTEMPT TO READ DC ARRAY TO',I9
     X       ,' WHICH EXCEEDS DIMENSION:',I9)
C
      END SUBROUTINE DISKDC
C
C                             +++++++++++++++++++
C
      SUBROUTINE DNAMP(A0,A,E,C,Q,U,Z,X,NMAX,JMAX)
C
C-----------------------------------------------------------------------
C
C     N.R.BADNELL  D.A.M.T.P. CAMBRIDGE
C     ALAN BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.DNAMP CALCS THE ASYMP. AMP. & ITS  DERIVS. FOR A COULOMB FUNCTION.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) Q
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(*),Y(100),W(100),V(100)
C
      X1=DONE/X
      X2=X1*X1
C
      F=-DTWO*Z*X1
      G=-C*X2
      D=-Q*X2*X1
      H=-U*X2*X2
      W0=E+F+G+D+H
      S=DONE
C
      IF(W0.LT.D1M50)THEN
        W0=-W0
        F=-F
        G=-G
        S=-S
        D=-D
        H=-H
      ENDIF
C
      NMAX2=NMAX+2
C
      DO N=1,NMAX2
        EN=N
        F=-EN*F*X1
        G=-(EN+DONE)*G*X1
        D=-(EN+DTWO)*D*X1
        H=-(EN+DTHREE)*H*X1
        W(N)=F+G+D+H
      ENDDO
C
      CALL DNAQ(W0,W,A0,A,-DQUART,NMAX2,IFIVE)
C
      DO J=1,JMAX
C
        CALL DNAQ(A0,A,Y0,Y,-DONE,NMAX,ITHREE)
C
        A0=A(2)
        DO N=1,NMAX
          A(N)=A(N+2)
        ENDDO
C
        CALL DNPROD(A0,A,Y0,Y,V0,V,NMAX)
C
        Y0=W0+V0*S
        DO N=1,NMAX
          Y(N)=W(N)+V(N)*S
        ENDDO
C
        CALL DNAQ(Y0,Y,A0,A,-DQUART,NMAX,IFIVE)
C
      ENDDO
C
      RETURN
C
      END SUBROUTINE DNAMP
C
C                             +++++++++++++++++++
C
      SUBROUTINE DNAQ(A0,A,Y0,Y,Q,NMAX,JSWICH)
C
C-----------------------------------------------------------------------
C
C     ALAN BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.DNAQ:
C  GIVEN A0 AND ITS FIRST NMAX DERIVATIVES IN ARRAY A, AND GIVEN Q
C  AND NMAX, CALCULATES Y0 AND ARRAY B, BEING THE VALUE AND FIRST
C  NMAX DERIVATIVES OF (A0)**Q
C
C  FOR PERHAPS GREATER SPEED, YOU MAY SET JSWICH TO 2 IF Q IS -2.0
C   JSWICH TO 3 IF Q IS -DONE
C   JSWICH TO 4 IF Q IS -0.5
C   JSWICH TO 5 IF Q IS -0.25
C   JSWICH TO 6 IF Q IS 0.25
C   JSWICH TO 7 IF Q IS 0.5
C   JSWICH TO 8 IF Q IS 2.0
C  OTHERWISE SET JSWICH TO 1
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) Q
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(*),Y(*),W(100)
c
      if(a0.le.0.and.jswich.lt.8)then             !shouldn't get here...
        if(a0.lt.0.and.jswich.le.1.or.jswich.ge.4)then
          write(6,*)'dnaq failure, a0.lt.0 ...'
          stop 'dnaq failure, a0.lt.0...'
        endif
        if(a0.eq.0.and.jswich.ge.2.and.jswich.le.5)then
          write(6,*)'dnaq failure, a0.eq.0 ...'
          stop 'dnaq failure, a0.eq.0...'
        endif
      endif
C
      IF(JSWICH.LE.1.OR.JSWICH.GT.8)THEN
        Y0=A0**Q
      ELSEIF(JSWICH.EQ.2)THEN
        Y0=DONE/(A0*A0)
      ELSEIF(JSWICH.EQ.3)THEN
        Y0=DONE/A0
      ELSEIF(JSWICH.EQ.4)THEN
        Y0=DONE/SQRT(A0)
      ELSEIF(JSWICH.EQ.5)THEN
        Y0=DONE/SQRT(A0)
        Y0=SQRT(Y0)
      ELSEIF(JSWICH.EQ.6)THEN
        Y0=SQRT(A0)
        Y0=SQRT(Y0)
      ELSEIF(JSWICH.EQ.7)THEN
        Y0=SQRT(A0)
      ELSEIF(JSWICH.EQ.8)THEN
        Y0=A0*A0
      ENDIF
C
      W(1)=Q
      C=DONE/A0
      Y(1)=Q*A(1)*Y0*C
C
      DO N=2,NMAX
        Y(N)=Q*Y0*A(N)
        W(N)=Q
        U=-DONE
        J1=N-1
        DO J=1,J1
          V=W(J)
          W(J)=U+W(J)
          U=V
          J2=N-J
          Y(N)=Y(N)+W(J)*A(J)*Y(J2)
        ENDDO
        Y(N)=C*Y(N)
      ENDDO
C
      RETURN
C
      END SUBROUTINE DNAQ
C
C                             *******************
C
      SUBROUTINE DNPROD(A0,A,Y0,Y,C0,C,NMAX)
C
C-----------------------------------------------------------------------
C
C    ALAN BURGESS D.A.M.T.P. CAMBRIDGE
C
C  SR.DNPROD EVALUATES THE ASYMPTOTIC COULOMB AMPLITUDE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(20),Y(20),C(20),W(20)
C
      C0=A0*Y0
C
      DO N=1,NMAX
        C(N)=A0*Y(N)+Y0*A(N)
      ENDDO
C
      W(1)=DONE
      U=DONE
C
      DO N=2,NMAX
        W(N)=DONE
        JMAX=N-1
        DO J=1,JMAX
          V=W(J)
          W(J)=U+W(J)
          U=V
          J1=N-J
          C(N)=C(N)+W(J)*A(J1)*Y(J)
        ENDDO
      ENDDO
C
      RETURN
C
      END SUBROUTINE DNPROD
C
C                             *******************
C
      SUBROUTINE DWX
C
C-----------------------------------------------------------------------
C
C  SR.DWX CALCULATES EIE COLLISION STENGTHS.
C
C  IT CALLS:
C    SR.CADWX
C    SR.RADCX0
C    SR.DWXLS
C    SR.DWXBP
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,nproc,                     !par
cpar     x                           comm_barrier,comm_finalize     !par
C
      USE COMMON_CCLSH,  ONLY: NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,NRK,IRL,NAD,IRLAST
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: BRADF,DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: BNRBDQE,DQNL
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD06=MXENG*MXENG)
C
      ALLOCATABLE :: FRX(:,:,:),PSHFTX(:,:),DRLX(:,:,:)
      ALLOCATABLE :: DZLX(:,:,:),DXTWOX(:,:,:),DETAX(:,:,:)
      ALLOCATABLE :: DNLX(:,:)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
c
      common /nrbuse/buse(mxeng)   !,busi(mxeng,mxeng),btmp(mxeng,mxeng)
C
      IF(NZION.EQ.0)RETURN                                   !QUICK EXIT
C
      BKUTOO=KUTOOX.NE.0
      BKUTSS=KUTSSX.NE.-1.AND.MAXJFS.GE.0
      BREL2=ABS(IREL).EQ.2
C
C
C-----------------------------------------------------------------------
C
      if(nsl0.lt.0)then
        WRITE(6,1000)
      elseif(abs(modd).gt.1)then
        WRITE(6,2000)
      elseif(abs(modd).le.1)then
        WRITE(6,3000)
      endif
C
C-----------------------------------------------------------------------
c TBD recover orbital info: DPNL, DQNL, DORIG, DEY, DUY & RADIAL MESH
c to implement RESTARTX - currently left from (single pass) target run.
c viz. some/all of MODULE /RADF/, /NRBDQE/; COMMON /CRAD/, /NRBNUK/
c And if BKUTOOX then DPNL, DQNL are extended MXORB->MXORB+LCONDW/J
c For now:

      if(bkutoo)then
c
        mrp=mr+1
        close(mrp)
        OPEN(mrp,STATUS='SCRATCH',FORM='UNFORMATTED')
        write(mrp)((dpnl(i,j),i=1,maxrs),j=1,mxorb),
     x            ((dqnl(i,j),i=1,maxrs),j=1,mxorb)
        rewind(mrp)
        deallocate (dpnl,dqnl)
C-----------------------------------------------------------------------
C
        MDIM3=MXORB
        if(bkutoo)MDIM3=MDIM3+MAX(LCONDW,LCONDWJ)
        CALL DIMUSE('MAXGR',MDIM3)
C
        ALLOCATE (DPNL(MAXRS,MDIM3),DQNL(MAXRS,MDIM3),STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DWX: ALLOCATION FAILS FOR DPNL,DQNL'
          NF=0
          GO TO 999
        ENDIF
C                                                          !TBD: mrp->MR
        READ(mrp)((DPNL(I,J),I=1,MAXRS),J=1,MXORB),
     X           ((DQNL(I,J),I=1,MAXRS),J=1,MXORB)
C
C-----------------------------------------------------------------------
      endif
C
C-----------------------------------------------------------------------
C
C READ SCATTERING ENERGIES AND INDEX INTERACTING ENERGY PAIRS.
C GENERATE THE UNIQUE CONTINUUM DW POTENTIAL AND CHECK THE RADIAL GRID.
C
      CALL RADCX0
C
      IF(NF.LE.0)GO TO 900
      IF(IRL.EQ.0)THEN
        WRITE(6,4001)
        GO TO 900
      ENDIF
c                       initialize flag of use of interpolation energies
      do m2=1,meng
        buse(m2)=.false.
c        do m1=1,meng
c          busi(m1,m2)=.false.
c        enddo
      enddo
      do m0=1,meng0
        m=iyy0(m0)
        buse(m)=.true.
c        busi(m,m)=.true.
      enddo
C
C-----------------------------------------------------------------------
C
C NOW ALLOCATE BASED ON KNOWN NO OF POINTS (MAXRS), ENERGIES (MENG),
C ENERGY PAIRS (MTRAN) AND INTEGRALS (IRL), FOR LSTORE+1 TOTAL L-VALUES.
C LS COUPLING ONLY REQUIRES LSTORE=0.
C
      if(abs(modd).gt.1)then
        LSTORE=0
      else
        LSTORE=QCS0+1
      endif
C
      MDIM0=MTRAN
      MDIM1=MAXRS
      IF(BREL2)MDIM1=2*MDIM1
      MDIM2=MENG
      MDIM3=MAX(LCONDW,LCONDWJ)
      MDIM4=IRL
      MDIM5=LSTORE
C
      ALLOCATE (FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: ALLOCATION FAILS FOR DFRX,PSHFTX'
        NF=0
        GO TO 999
      ENDIF
C
      ALLOCATE (DRLX(MDIM4,MDIM0,0:MDIM5),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: ALLOCATION FAILS FOR DRLX'
        NF=0
        GO TO 999
      ENDIF
C
      IF(BKUTOO)THEN
        MDIM6=MDIM0
        MDIM7=MDIM4
        MDIM8=MDIM5
      ELSE
        MDIM6=1
        MDIM7=1
        MDIM8=0
      ENDIF
C
      ALLOCATE (DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
     X         ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: ALLOCATION FAILS FOR DZLX,DXTWOX,DETAX'
        NF=0
        GO TO 999
      ENDIF
C
      IF(BKUTSS)THEN
        MDIM9=MDIM0
        MDIM10=NL000
      ELSE
        MDIM9=1
        MDIM10=1
      ENDIF
C
      ALLOCATE (DNLX(MDIM10,MDIM9) ,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: ALLOCATION FAILS FOR DNLX'
        NF=0
        GO TO 999
      ENDIF
C
      if(nsl0.lt.0)then
C
C-----------------------------------------------------------------------
C
C SR.CADWX CALCULATES EIE (NR) COLLISION STRENGTHS IN CA-COUPLING
C
      CALL CADWX(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4,MDIM5)
C
      IF(NF.LE.0)GO TO 999
C
C-----------------------------------------------------------------------
C
      elseif(abs(modd).gt.1)then
C
C-----------------------------------------------------------------------
C
C SR.DWXLS CALCULATES EIE NR (+2NFS) COLLISION STRENGTHS IN LS-COUPLING
C
      CALL DWXLS(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4,MDIM5
     X          ,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
C
      IF(NF.LE.0)GO TO 999
C
C-----------------------------------------------------------------------
C
      elseif(abs(modd).le.1)then
C
C-----------------------------------------------------------------------
C
C SR.DWXBP CALCULATES EIE BP (+2FS) COLLISION STRENGTHS IN JK-COUPLING
C
      CALL DWXBP(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4,MDIM5
     X          ,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8,DNLX,MDIM9,MDIM10)
C
      IF(NF.LE.0)GO TO 999
C
C-----------------------------------------------------------------------
C
      endif
c                       write use of interpolation energies
c      nskp=0
      do m2=1,meng
        if(.not.buse(m2))then
          write(0,4002)m2,dyy(m2)
          write(6,4002)m2,dyy(m2)
c        else
c          do m1=1,meng
c            if(buse(m1).and.btmp(m1,m2).and..not.busi(m1,m2).and..not.
c     x         busi(m2,m1))then
c     x        write(6,*)'INTEGRAL PAIR NOT USED',m1,m2
c              nskp=nskp+1
c            endif
c          enddo
        endif
      enddo
c      if(nskp.gt.0)write(6,4003)nskp,mtran
C
C
C-----------------------------------------------------------------------
C
C "LOCAL" DE-ALLOCATES
C
 999  CONTINUE
C
      IF(ALLOCATED(FRX))THEN
C
        DEALLOCATE (FRX,PSHFTX,DRLX,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR FRX,PSHFTX,DRLX'
          NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(DZLX))THEN
C
        DEALLOCATE (DZLX,DXTWOX,DETAX,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR DZLX,DXTWOX,DETAX'
          NF=0
        ENDIF
      ENDIF
C
      IF(ALLOCATED(DNLX))THEN
C
        DEALLOCATE (DNLX,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR DNLX'
          NF=0
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C "NON-LOCAL" DE-ALLOCATES
C
 900  CONTINUE
C
C EX-COMMON/NRBDQE/
      if(.not.bnrbdqe)stop 'error DQNL not allocated'
      DEALLOCATE (DQNL,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR DQNL'
        NF=0
      ENDIF
C
C EX-COMMON/RADF/
      if(.not.bradf)stop 'error DPNL not allocated'
      DEALLOCATE (DPNL,DUY,DX,DORIG,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR DPNL,DUY,DX,DORIG'
        NF=0
      ENDIF
C
C EX-COMMON/MQVC/
      DEALLOCATE (NEL,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR NEL'
        NF=0
      ENDIF
c
C EX-COMMON/CCLSH/
      DEALLOCATE (NNL,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR NNL'
        NF=0
      ENDIF
C
C EX-COMMON/DBD2/
      DEALLOCATE (QCG,QL,QN,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR QCG,QL,QN'
        NF=0
      ENDIF
C
C EX-COMMON/DXRL/
      if(.not.bdxrl)stop 'error DXRL not allocated'
      DEALLOCATE (DRK,QRL,NRK,NAD,IRLAST,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR DRK,QRL,NRK,NAD'
        NF=0
      ENDIF
C
      IF(NSL0.GT.0)THEN
C
C EX-COMMON/NRBNF1/
        if(.not.bnrbnf1)stop 'error NRBNF1 not allocated'
        DEALLOCATE (DEK,BFALL,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'DWX: DE-ALLOCATION FAILS FOR  DEK, BFALL'
          NF=0
        ENDIF
      ENDIF
C
      IF(BKUTSS)THEN
C
C EX-COMMON/DMQSS3/
        if(.not.bdmqss3)stop 'error DMQSS3 not allocated'
        DEALLOCATE (DSS,MSS,QSS,NADR,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)
     X         'DWX: DE-ALLOCATION FAILS FOR  DSS,MSS,QSS,NADR'
          NF=0
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(///1X,136('-')//50X,'*** COLLISION HAMILTONIAN (CA) ***'
     X       //1X,136('-')//)
 2000 FORMAT(///1X,136('-')//50X,'*** COLLISION HAMILTONIAN (LS) ***'
     X       //1X,136('-')//)
 3000 FORMAT(///1X,136('-')//50X,'*** COLLISION HAMILTONIAN (BP) ***'
     X       //1X,136('-')//)
 4001 FORMAT(//'*** NO INTERACTIONS/CHANNELS - BAILING-OUT ***')
 4002 FORMAT('*** INTERPOLATION ENERGY',I3,' NOT USED E=',F9.3)
c 4003 format(/' NOTE:',I3,' OUT OF',I4,
c     X       ' ENERGY INTEGRAL PAIRS WERE NOT USED')
C
      END SUBROUTINE DWX
C
C                             *******************
C
      SUBROUTINE DWXBP(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8
     X                ,DNLX,MDIM9,MDIM10)
C
C-----------------------------------------------------------------------
C
C  SR.DWXBP WRAPPER
C
C  IT CALLS:
C    SR.DWXBP_DAXPY
C    SR.DWXBP_DDOT
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
     X         ,DNLX(MDIM10,MDIM9)
C
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
C
      IF(XMIX.LT.DZERO)THEN
        CALL DWXBP_DDOT(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                 ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8
     X                 ,DNLX,MDIM9,MDIM10)
      ELSE
        CALL DWXBP_DAXPY(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                  ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8
     X                  ,DNLX,MDIM9,MDIM10)
      ENDIF
C
      RETURN
C
      END SUBROUTINE DWXBP
C
C                             *******************
C
      SUBROUTINE DWXBP_DAXPY
     X                (FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8
     X                ,DNLX,MDIM9,MDIM10)
C
C-----------------------------------------------------------------------
C
C  SR.DWXBP CALCULATES EIE BP (+2FS) COLLISION STRENGTHS IN JK-COUPLING
C
C  IT CALLS:
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.FSINTX
C    FN:NCHAJK
C    SR.PQ
C    SR.PQLAP
C    FN.QPTLS
C    FN.QPTLSJ
C    SR.RADCNX
C    FN.SJS
C    SR.SLATRX
C    SR.TOP1
C    SR.TOP2
C    FN.XINT
C
C  IT CONTAINS:
C    FN.ICOL
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,comm_barrier               !par
cpar      use mpi, only : mpi_real4,mpi_real8,mpi_integer           !par
cpar     x               ,mpi_sum,mpi_comm_world                    !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: DSS,MSS,QSS,NADR
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
c      use common_nrbiad, only: iadj
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLEN=200)                               !CARD LENGTH
C
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXD13=500)
      PARAMETER (MXD14=100)
C
      PARAMETER (MXNXB=10)    !NO. OF BPW X-VALUES PRE-EXISTING IN ADF04
C
      PARAMETER (D0PT8=0.8D0)
C
      INTEGER(SP) QPTLS,QPTLSJ                 !DO NOT USE SHORT INTEGER
C
      INTEGER(SP) SA,SAP
cparc                                                               !par
cpar      integer(kind(mpi_integer))itmp4,ier4,izero_mpi,my_mpi_real!par
cpar      parameter (izero_mpi=0)                                   !par
cparc                                                               !par
cpar      real(rp) omsend,omrecv                                    !par
C
      REAL(RP) OMEGA,E1M30
      PARAMETER (E1M30=1.E-30)
      PARAMETER (XBTEST=DFIVE)          !APPLY btop ONLY FOR X.GT.XBTEST
C
      CHARACTER(LEN=3) IEXP,IEXP0,IEXP1
      CHARACTER(LEN=4) CARD4
      CHARACTER(LEN=5) XMANT,XMANT0,XMANT1
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=15) F767
      CHARACTER(LEN=35) F762
      CHARACTER(LEN=44) F761
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: RHO1(:,:),RHO2(:,:),OMEGA(:,:),TFU(:)
     X              ,TEMP(:,:),OMGINF(:),KACT(:,:),KTMP(:)
cpar      allocatable :: omsend(:),omrecv(:)                        !par
c
      allocatable :: rhom(:,:),wrkp(:),wrkq(:),iwrkn(:),iwrkl(:)
     x              ,work(:)
C
      ALLOCATABLE :: IEXP(:),XMANT(:)
      ALLOCATABLE :: NADRUG(:),NTGJ(:),TMP(:,:),OMP(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
     X         ,DNLX(MDIM10,MDIM9)
C
      DIMENSION QPX(0:MDIM5),QPX0(0:MDIM5),QPOSJ(MAXGR),DFS(MXDFS)
      DIMENSION PSHFT0(0:20)
c
      dimension bswap(mxd13),bswapj(mxd13)
      dimension ntest(1,1)                   !check channel set-up
C
      COMMON /BASIC/NF,NCHSJ,MGAP(10)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
c      COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)     !target
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C      COMMON /WORKJ/DWRK(MAXLV),IWRK3(MAXLV),IWRK4(MAXLV)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
c      common /nrbrel/irel,kappa,igagr,irtard,ibreit,brel,bjumpr,bmvd !x
c
      common /hps/badas
C
      DATA JOLD/-2/,LOLD/-1/,IU/24/,IUU/26/,IULS/23/
c                          omginfic adf04ic
C
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DWXBP_DAXPY
c      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
C-----------------------------------------------------------------------
C
c some cross section units options: need to uncomment code above and  !x
c below labeled "!x"                                                  !x
c                                                                     !x
c      xconv=done                   !pi*a_0^2                         !x
c      xconv=xconv*acos(-done)      !a_0^2                            !x
c      xconv=xconv*28.003d0         !Mbarns                           !x
c      xconv=xconv*1.d6             !barns                            !x
c
c flag write of "OMEGA" file - this is by final scattered energy and so
c *not* directly usable by R-matrix utility codes such as xtrct/adasexj.
c this is somewhat historic as adasexj *does* read/process dw adf04 file
c
      bomega=.false.
c
c elastic switch (normally ione1=1, no elastic. ione1=0 inc elastic)
c now set by user in algeb, and passed thru /nrbdwm/ as needed.
c
cold  ione1=1
c
c test: DO NOT CHANGE!
cold  ione0=0                !algxls/fs ione1, elastic needed for mixing
c
c some test set-up switches that user joe should not need to touch.
c
      bht=.false.                  !.true. for bht(1970) test comparison
c
c set (approx) unitarity switch
c
      bunit=.true.
      if(bht)bunit=.false.
c
c set approximation-ii unitarization switch - needs the full rho-matrix
c (.and.. not.bthrsh, i.e. lvmax.lt.0) only coded for F95.
c currently, in principle, only for use at medium to high energies
c since it still works with the final scattered energy, but seems to
c work well down to low-e as well - strongest coupling with nearby
c states, i.e. ones calculated at the same/similar relative energy.
c
      bunit2=nmetaj.ge.nspecj.and.ione1.eq.0.and.lvmax.lt.0
c
c set print of approx r(tau=0)-matrix as opposed to rho(tau)-matrix
c *MUST* use full T=-2iR/(1-iR) if converting via R-matrix.   (not done)
c can only use weak coupling T=-2i*rho for rho-matrix -see bunit2 above.
c
      brmx=.false.
      if(jprint.eq.4)brmx=.true.
c
c set mixing switch, can test interpolation followed by mixing (false).
c
      bmix=xmix.ge.dzero                !default xmix->.true.
      xmix=abs(xmix)
c
c flag effect of missing phase shifts.
c
      if(kutssx.eq.-1)then
        if(ione1.eq.0)write(6,1120)
        if(brmx)write(6,1121)
        if(bunit2)write(6,1122)
      endif
 1120 format(//'Note: Elastic collision strengths maybe somewhat'
     x,' inaccurate as not all phases are present...'/'In-elastic'
     x,' collision strengths are unaffected'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
 1121 format(//'Note: R-matrix elements maybe somewhat inaccurate'
     x,' as not all phases are present...'/'rho-matrix and partial'
     x,' collision strengths are unaffected'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
 1122 format(//'Note: elastic transitions maybe somewhat inaccurate'
     x,' as not all phases are present...'/'Inelastic partial collision'
     x,' strengths maybe affected indirectly'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
c
c checks channel set-up (needs ntest dimensione1d)
c
      bntest=.false.                    !ione1.eq.0.and.jprint.ge.2
c
      bntest=bntest.and.nmetaj.ge.nspecj
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD/J(NCOR/J)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
cparc                                                               !par
cpar      if(rp.eq.4)then                                           !par
cpar        my_mpi_real=mpi_real4                                   !par
cpar      elseif(rp.eq.8)then                                       !par
cpar        my_mpi_real=mpi_real8                                   !par
cpar      else                                                      !par
cpar        if(iam.eq.0)write(iw,*)'error rp precsion =',rp         !par
cpar        go to 999                                               !par
cpar      endif                                                     !par
C
C-----------------------------------------------------------------------
c
      btimep=btimex                                        !for iam.ne.0
      if(btimex)then
c        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for dwxbp'           !par
cpar        else                                                    !par
          write(iw,*)'Starting dwxbp'
cpar        endif                                                   !par
c        endif
        call cpu_time(timei)
        time0=timei
      endif
      btimet=btimex  !.false.                             !debug timings
C
C INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TPI=DTWO*PI
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      NZA2=MAX(NZION-MION,IONE)
      NZA2=NZA2*NZA2
      TOLO=E1M10/NZA2
C
      BPRNT2=JPRINT.GE.2                    !FOR DETAILED OMEGA PRINTOUT
      BPRNT3=JPRINT.GE.3                      !FOR DETAILED RHO PRINTOUT
      BPRNT0=JPRINT.NE.-3
C
      KOLDOO=KUTOOX
      BKUTOO=KUTOOX.NE.0
C
      BKUTSS=KUTSSX.NE.-1
C
CL      LAPAK=1                                                  !LAPACK
C
      IF(NZION.EQ.MION)THEN
        NZA=0
        DZ2=DONE
      ELSE
        NZA=NZION-MION
        DZ2=NZA*NZA
      ENDIF
C
      IF(MAXJT.GE.0)THEN
        IF(LRGLAM.GT.MAXJT)THEN
          WRITE(0,*)'*** SR.DWXBP: LRGLAM.GT.MAXJT, SO NO TOP-UP'
          LRGLAM=-1
        ELSE
          IF(LRGLAM.EQ.-999)LRGLAM=MAXJT
        ENDIF
        IF(LRGLAM.EQ.0)LRGLAM=-1
      ENDIF
C
      IF(LRGLAM.GT.1)THEN        !SET L WHERE DIPOLE TOP-UP NEEDS CHECKS
        LRGLMN=LRGLAM-2*(QCL0+QCS0)
      ELSE
        LRGLMN=1000
      ENDIF
c
      btop=btop.and.lrglam.ge.0
c
      jktest=2*maxlx+QCS0+1                           !max J for K.ne.K'
C
      MPOSC=MXORB+(LCONDWJ-1)/2-(LCONDW-1)/2               !BUFFER SPACE
C
C SMALL LOCAL MEMORY
C
      MXD4=MAX(MENG,10_SP)+3
      ALLOCATE (IEXP(0:MXD4),XMANT(0:MXD4))
      ALLOCATE (TMP(MENG,MENG),OMP(MENG))
      ALLOCATE (NADRUG(NJO),NTGJ(NJO))
C
C SET POINTER TO START OF GROUP IN MIXING COEFFICIENT ARRAY TFU,
C AND FOR MAPPING TERMS OF A J-GROUP TO ABSOLUTE LEVEL INDEX.
C
      MC=0
      NCMX=0
      NSUM=0
      DO N=1,NJO
        NADRUG(N)=MC
        NTGJ(N)=NSUM
        NC=NT(N)
        NCMX=MAX(NCMX,NC)
        MC=MC+NC*NC
        NSUM=NSUM+NC
      ENDDO
C
C RECOVER TARGET MIXING COEFFICIENTS
C
      READ(MR)NCTOT
C
      if(nctot.ne.mc)stop 'dwxbp:nctot index error'    !shouldn't happen
C
      ALLOCATE (TFU(NCTOT),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 998
      ENDIF
C
      READ(MR)(TFU(I),I=1,NCTOT)
C
C LOOK FOR LAST SPECTROSCOPIC ENERGY
C
c      NSPECL=0
c      DO N=1,NENERJ
c        NSPECL=MAX(NSPECL,JNDXJ(N))
c      ENDDO
C
C USE ROWWISE TO SIMPLY REDUCE NDIM2 IF NMETAJ.LT.NSPECJ
C
      NOMTG=NCMX*NCMX                               !NEED ALL FOR MIXING
      nmin=min(NMETAJ,NSPECJ)
      NOMWRT=IROW(nmin,NSPECJ,ione1,NSPECJ)                     !ROWWISE
      NOMWR0=NOMWRT
c
ctest    if(ione1.eq.1)nomwr0=nomwr0+nmin      !incase ione1=0 in diagfs
C
C
      BTHRSH=LVMAX.GE.0
      IF(BTHRSH)THEN
        MOGGY=LVMAX+1-LVMIN
      ELSE
        MOGGY=MENG0
      ENDIF
C
      ALLOCATE (RHO1(MTRAN,NOMTG),RHO2(MTRAN,NOMTG),TEMP(MTRAN,NCMX)
     X        ,OMGINF(NOMWR0),OMEGA(MOGGY,NOMWRT),STAT=IERR)
cparc                                                               !par
cpar      allocate (omsend(nomwrt),omrecv(nomwrt),stat=ierr)        !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 900
      ENDIF
C
      DO N=1,NOMWRT
        OMGINF(N)=DZERO
        DO M=1,MOGGY
          OMEGA(M,N)=0
        ENDDO
      ENDDO
C
C RECOVER INFINITE ENERGY INFO (ROWWISE)
C
      IF(IUNIT(IU).EQ.0)THEN                   !ADF04 WILL BE INCOMPLETE
        WRITE(6,*)'NO INFINITE ENERGY FILE="OMGINFIC"...'
        WRITE(0,*)'NO INFINITE ENERGY FILE ON UNIT=',IU
        IF(LRGLAM.GE.0)THEN
          WRITE(6,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          WRITE(0,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          NF=-1
          GO TO 800
        ELSE
          GO TO 110
        ENDIF
      ELSEIF(IUNIT(IU).LT.0)THEN
        OPEN(IU,FILE='OMGINFIC',STATUS='OLD',ERR=110)
        IUNIT(IU)=1
      ELSE                               !SERIAL SHOULD NOT BE HERE
        REWIND(IU)                       !BUT PAR ALREADY OPEN
cpar        if(iam.eq.0)then                                        !par
        stop 'dwxbp: omginfbp confusion'
cpar        endif                                                   !par
      ENDIF
C
      READ(IU,*)NZDUM,MDUM
      READ(IU,*)NSPEC0,MENGB,NOMWR0
C
      IF(NSPEC0.NE.NSPECJ)THEN                   !SHOULD NOT HAPPEN, NOW
        WRITE(6,*)'DWXBP: INFINITE ENERGY TARGET MISMATCH',NSPEC0,NSPECJ
        WRITE(0,*)'DWXBP: INFINITE ENERGY TARGET MISMATCH'
        NF=-1
        GO TO 800
      ENDIF
C
      ALLOCATE (DWRK(NSPEC0),IWRK3(NSPEC0),IWRK4(NSPEC0))
C
      READ(IU,*)(IDUM0,IWRK3(I),I=1,NSPEC0)
      READ(IU,711)(DWRK(I),I=1,NSPEC0)
C
c optionally recover spec energy subset from omginf,
c and retain full-set in denerg back above.
c
c      do i=1,nspec0
c        dwrk0(i)=dwrk0(i)*dz2
c      enddo
c
      iflag=0
      if(nomwrt.ne.nomwr0)then       !should not happen in non-test mode
        if(ione1.eq.0)then                             !elastic in dwxjk
          if(nomwrt-nmin.ne.nomwr0)then
            write(6,*)'dwxbp: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxbp: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=1 in diagfs
            iflag=1
          endif
        else                                         !inelastic in dwxjk
          if(nomwrt+nmin.ne.nomwr0)then
            write(6,*)'dwxbp: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxbp: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=0 in diagfs
            iflag=2
          endif
        endif
      endif
C
      READ(IU,713)EINF,(OMGINF(I),I=1,NOMWR0)
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        IUNIT(IULS)=-1                                          !par
cpar        CLOSE(IULS)                                             !par
cpar        IUNIT(IU)=-1                                            !par
cpar        CLOSE(IU)                                               !par
cpar      endif                                                     !par
c
      if(iflag.eq.1)then                          !make room for elastic
        n=nomwrt+1
        nshft=nmin
        do i=nmin,1,-1
          do j=nspec0,i+1,-1
            n=n-1
            omginf(n)=omginf(n-nshft)
          enddo
          n=n-1
          omginf(n)=done                             !flag poss. allowed
          nshft=nshft-1
        enddo
        if(n.ne.1)stop 'iflag=1 nshft error'
      elseif(iflag.eq.2)then                               !drop elastic
        n=0
        nshft=1
        do i=1,nmin
          do j=i+1,nspec0
            n=n+1
            omginf(n)=omginf(n+nshft)
          enddo
          nshft=nshft+1
        enddo
        if(n.ne.nomwrt)stop 'iflag=2 nshft error'
      endif
c
C
  110 CONTINUE
C
C WRITE-OUT SPEC. TARGET ENERGIES
C
      im=-1
      if(nmetag(0).ne.0)im=1
c
      WRITE(6,1110)
      WRITE(6,996)NMETAJ*im
C
      DO J=1,NSPECJ
        I=INDXJ(J)
        M1=NRR(I)
        II=NFQ(M1)
        IP=(1-QPI(II))*(QSI(II)+1)
        WRITE(6,995)J,I,M1,IP,QLI(II)/2,JN(I),NFK(M1),DSPECJ(J)
      ENDDO
C
      WRITE(6,1111)
C
C FLAG ACTIVE ORBITAL PAIR IN INTERACTING CONFIGS C.F. SR.ALGX BXIST0
C
      ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 800
      ENDIF
C
      DO KF=1,KMAX
        DO KG=1,KF
          KACT(KF,KG)=0
          KACT(KG,KF)=0
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)GO TO 52
            KACT(KF,KG)=QCG(I,KF)
            KACT(KG,KF)=KTMP(L0)
  51      ENDDO
  52    ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C BEGIN LOOP OVER Jp SCATTERING SYMMETRIES
C
C-----------------------------------------------------------------------
c
      if(bunit2)write(6,997)
      iwait=0
      wait=done
C
      DO KX=1,INASTJ
C
        MTJ=JPI(KX)/10
        MTP=JPI(KX)-MTJ*10
        MTP=MTP+MTP
C
C SEE IF WE NEED TO UPDATE INTEGRALS & CONTINUUM BASIS
C
        JNEW=MTJ
C
        IF(JNEW.NE.JOLD)THEN
C
C-----------------------------------------------------------------------
C
          if(btimex)then
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                 ,'updating continuum for 2j=',mtj        !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)
     x        'Begin update of continuum basis & integrals for 2J=',MTJ
cpar            endif                                               !par
c
            call cpu_time(timei)
            times=timei
          endif
C
C-----------------------------------------------------------------------
C
          jstep=jnew-jold
          if(jstep.gt.2.and.jfact.gt.200.and.jold.gt.0)then
            if(iwait.eq.2)then
              iwait=1
            else
              iwait=2
            endif
            wait=iwait*jstep
            wait=wait/dthree
          endif
C
C UPDATE CONTINUUM BASIS
C
C  NOTE: IF THE USER HAS RESTRICTED LCONDWJ THEN ANY FINE-STRUCTURE HAS
C        A TRUNCATED PARTIAL WAVE EXPANSION.
C
          IF(BKUTSS)THEN
C
            IF(BTHRSH)LCONDWJ=-LCONDWJ                        !FLAG
C
            CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3
     X                 ,JNEW/2,JOLD/2,LCONDWJ,-MXORB)
C
            IF(NF.LE.0)GO TO 700
C
            DO L=1,LCONDWJ
              QPOSJ(L)=QPOS(L)
            ENDDO
C
          ENDIF
C
C UPDATE FINE-STRUCTURE
C
          IF(JNEW.LE.MAXJFS)THEN
C
C UPDATE EXCHANGE MULTIPOLE
C
            JDIFF=JNEW
            IF(JOLD.GE.0)JDIFF=JDIFF-JOLD
            jdiff=2*(jdiff/2)
C
            DO L=1,NL000
              IF(QSS(1,L).GT.MXORB.AND.QSS(3,L).GT.MXORB
     X       .OR.QSS(2,L).GT.MXORB.AND.QSS(4,L).GT.MXORB)THEN
              ELSE
                QSS(5,L)=QSS(5,L)+JDIFF                    !EXCHANGE
              ENDIF
            ENDDO
C
C UPDATE FINE-STRUCTURE INTEGRALS
C
            IF(BPRNT0)WRITE(6,1997)JNEW
C
            DO M=1,MTRAN
              M1=MNDEX(M,1)
              M2=MNDEX(M,2)
              CALL FSINTX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DNLX(1,M)
     X                   ,M1,M2,JNEW,MXORB)
            ENDDO

          ENDIF
C
C PREPARE TO UPDATE NON-FINE-STRUCTURE INTEGRALS:
C   SET POINTERS FOR INTEGRAL STORAGE FOR MULTIPLE LTOT
C
          IF(JOLD.LT.0)THEN                               !FIRST TIME
            DO L=0,QCS0+1
              QPX(L)=L+1
            ENDDO
          ELSE
            DO L=0,QCS0+1
              QPX0(L)=QPX(L)
              QPX(L)=0
            ENDDO
            L00=(JOLD-QCS0-1)/2
            K0=(JNEW-JOLD)/2
            DO L=0,QCS0+1
              L0=L00+L
              IF(2*L0.GE.(JNEW-QCS0-1).AND.
     X           2*L0.LE.(JNEW+QCS0+1))THEN               !RE-USE
                K=L-K0
                QPX(K)=-QPX0(L)                           !FLAG OLD
              ELSE
                QPX0(L)=-QPX0(L)                          !NOT WANTED
              ENDIF
            ENDDO
          ENDIF
C
          DO L=0,QCS0+1
            IF(QPX(L).EQ.0)THEN                           !NEW
              DO K=0,QCS0+1                              !LOOK FOR SPACE
                IF(QPX0(K).LT.0)THEN
                  QPX(L)=-QPX0(K)
                  QPX0(K)=0
                  GO TO 150
                ENDIF
              ENDDO
              WRITE(6,*)' SR.DWXBP: QPX INDEX ERROR...'
              WRITE(0,*)' SR.DWXBP: QPX INDEX ERROR...'
              NF=-1
              GO TO 700
            ENDIF
  150       CONTINUE
c        write(0,*)l,qpx(l),qpx0(l)             !debug print
          ENDDO
C
          LPOS=(JNEW-QCS0-1)/2
C
          DO LQ=0,QCS0+1                        !do lq=QCS0+1,0,-1
C
            LNEW=LPOS+LQ
C
C
            IF(LNEW.GE.0.AND.QPX(LQ).GT.0)THEN
C
C UPDATE/RE-LABEL CONTINUUM BASIS FOR THIS LTOT
C
              IF(BKUTSS)THEN
C
C NOTE: CURRENTLY, NO NEW CONTINUUM ORBITALS ARE GENERATED HERE.
C       SO, IF THE USER HAS RESTRICTED LCONDWJ (*NOT A GOOD IDEA*)
C       THEN FLAG & DISCARD PWS.
C
                J=MPOSC-MXORB
                J=J+LNEW-JNEW/2
                MYL2=2*(LNEW-(LCONDW+1)/2)
C
                DO L=1,LCONDW
                  J=J+1
                  MYL2=MYL2+2
                  if(j.le.0.or.j.gt.lcondwj)then !user restricts lcondwj
                    QPOS(L)=0                    !flag not to calculate
                    QL(MPOSC+L)=-99              !flag non-existence
                  else
                    QPOS(L)=ABS(QPOSJ(J))
                    QL(MPOSC+L)=MYL2
                  endif
                ENDDO
C
              ELSE
C
C UPDATE CONTINUUM BASIS
C
                IF(BTHRSH)LCONDW=-LCONDW                        !FLAG
C
                CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3
     X                     ,LNEW,LOLD,LCONDW,MPOSC)
C
                IF(NF.LE.0)GO TO 700
C
              ENDIF
C
C UPDATE EXCHANGE MULTIPOLE
C
              LDIFF=LNEW
              IF(LOLD.GE.0)LDIFF=LDIFF-LOLD
              LDIFF=LDIFF+LDIFF
C
              DO I=1,IRL
                IF(QRL(2,I).GT.MXORB)QRL(5,I)=QRL(5,I)+LDIFF  !EXCHANGE
              ENDDO
C
C UPDATE SLATER INTEGRALS (INC. 2NFS IF BKUTOO=.TRUE.)
C
              IF(BKUTOO.AND.LNEW.GT.MAXLOO)THEN
                KUTOOX=0
                BKUTOO=.FALSE.
              ENDIF
C
              IF(BPRNT0)WRITE(6,1996)LNEW
              LSTORE=QPX(LQ)-1
C
              DO M=1,MTRAN
                M1=MNDEX(M,1)
                M2=MNDEX(M,2)
                IF(BKUTOO)THEN
                  CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                       ,DRLX(1,M,LSTORE)
     X                       ,DZLX(1,M,LSTORE)
     X                       ,DXTWOX(1,M,LSTORE)
     X                       ,DETAX(1,M,LSTORE)
     X                 ,M1,M2,LNEW,MAXLX,MPOSC)
                ELSE
                  CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                       ,DRLX(1,M,LSTORE)
     X                       ,DZLX(1,1,0)
     X                       ,DXTWOX(1,1,0)
     X                       ,DETAX(1,1,0)
     X                 ,M1,M2,LNEW,MAXLX,MPOSC)
                ENDIF
              ENDDO
C
              LOLD=LNEW
              KUTOOX=KOLDOO
              BKUTOO=KUTOOX.NE.0
C
            ENDIF
C
            QPX(LQ)=ABS(QPX(LQ))
C
          ENDDO
C
C RE-SET
C
          JOLD=JNEW
C
C (NOTE: MAKE SURE QL IS SYNCHRONIZED WITH LDIFF USAGE BELOW WHEN
C        TESTING WHETHER "INITIAL" & "FINAL" STATES HAVE BEEN SWAPPED
C        BY FALLING ORDER)
C
          IF(BKUTSS)THEN
            DO J=1,LCONDWJ
              QPOS(J)=QPOSJ(J)
            ENDDO
            JPOS=JNEW
          ELSE
            JPOS=LNEW+LNEW
          ENDIF
C
          MYL2=2*(JPOS/2-(LCONDWJ+1)/2)
          DO L=1,LCONDWJ
            MYL2=MYL2+2
            QL(MXORB+L)=MYL2
          ENDDO
C
C-----------------------------------------------------------------------
c
          if(btimex)then
            call cpu_time(timef)
            times=timef-times
c
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                  ,'updating continuum'                   !par
cpar     x                 ,' time=',nint(times),'sec'              !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'End update of continuum basis & integrals'
     x               ,', time=',nint(times),'sec'
cpar            endif                                               !par
          endif
C
C-----------------------------------------------------------------------
C
        ENDIF
C
C INITIALIZE FOR J-LOOP
C
        IF(BPRNT0)WRITE(6,1114)KX,MTJ,MTP/2
C
        NWTJ=MTJ+1
C                                                     WRITE CHANNEL LIST
        NCHJT=NCHAJK(KX,-IONE,-IONE,-IONE,-IONE,NTGJ,DFS)
        NCHSJT=NCHSJ
C
        IF(.NOT.BPRNT0)WRITE(6,1112)KX,MTJ,MTP/2,NCHSJT,NCHJT
c
        if(bntest)then
          do  i=1,nchjt
            do j=1,nchjt
              ntest(j,i)=0
            enddo
          enddo
        endif
c
c initialize for approximation-ii (memory hog)
c
        if(bunit2)then
c
          nx=(nchjt*(nchjt+1))/2
c
          allocate (rhom(nx,meng0),wrkp(nx),wrkq(nx),iwrkn(nchjt)
     x             ,iwrkl(nchjt),work(nchjt),stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxbp: allocation fails for rhom,wrk'
            nf=0
            go to 700
          endif
c
          do i=1,nchjt
            iwrkn(i)=-1
            iwrkl(i)=-1
          enddo
c
          do m=1,meng0
            n=0
            do i=1,nchjt
              n=n+1
              rhom(n,m)=done
              do j=i+1,nchjt
                n=n+1
                rhom(n,m)=dzero
              enddo
            enddo
          enddo
c
        endif
c
c detailed print
c
        if(jprint.ge.5)then
          write(6,1150)
          if(maxjfs.ge.0)write(6,3050)
        endif
C
        IF(BPRNT2)WRITE(6,1116)
C
C-----------------------------------------------------------------------
c
        if(btimex)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(6,*)'Starting proc',iam                       !par
cpar     x                ,'symmetry',kx,':',mtj,mtp/2              !par
cpar            call flush(6)                                       !par
cpar          else                                                  !par
          write(iw,*)'Starting dwxbp symmetry',kx,' :',mtj,mtp/2
cpar          endif                                                 !par
cparc                                                               !par
          call cpu_time(timei)
          timej=timei
        endif
c
        if(btimet)then
          timeset=dzero
          timemix=dzero
           timemixi=dzero
           timemixf=dzero
           timemixir=dzero
           timemixfr=dzero
          timeunit=dzero
          timeint=dzero
        endif
C
C-----------------------------------------------------------------------
C
        INASTX=NCHGJ(KX)                    !NO. OF LS-SYMMS FOR THIS JP
C
C BEGIN K-LOOPS
C
        KAY2=MTJ+1
        IF(MTJ.GT.0)THEN
          KAY1=MTJ-1
        ELSE
          KAY1=KAY2
        ENDIF
c
        if(mtj.le.jktest)then       !exchange present so K.ne.K' allowed
          kay1p=kay1
          kay2p=kay2
        endif
C
        DO KAYI=KAY1,KAY2,2                  !LOOP OVER INTIAL CHANNEL K
c
          if(mtj.gt.jktest)then                !no-exchange so K=K' only
            kay1p=kayi
            kay2p=kayi
          endif
C
          DO KAYF=KAY1p,KAY2p,2               !LOOP OVER FINAL CHANNEL K
C
C BEGIN TARGET JP LOOPS (CURRENTLY, WE HAVE NOT YET SELECTED SUBSET
C                        THAT CONTRIBUTE TO THE TOTAL JP SYMMETRY,
C                        SO LOOP OVER ALL AND DISCARD ON-THE-FLY.)
C
            DO JIG=1,NJO             !LOOP OVER INITIAL TARGET JP GROUPS
C
              NC=NSLJ(1,JIG)
              JIP=QPI(NC)
              JI=NTGJ(JIG)+1
              JI=JN(JI)
              SJKI=SQRT(REAL((JI+1)*(KAYI+1),WP))
              L1=ABS(KAYI-JI)
              IF(MOD(JIP+L1,IFOUR).NE.MTP)L1=L1+2
              L2=KAYI+JI
              IF(MOD(JIP+L2,IFOUR).NE.MTP)L2=L2-2
C
              NCJ0=NT(JIG)
              NCN0=NGSLJ(JIG)
c
              jf2=jig
              if(kayf.gt.kayi)jf2=jig-1
C
              DO JFG=1,jf2             !LOOP OVER FINAL TARGET JP GROUPS
C
                ND=NSLJ(1,JFG)
                JFP=QPI(ND)
                JF=NTGJ(JFG)+1
                JF=JN(JF)
                SJKF=SQRT(REAL((JF+1)*(KAYF+1),WP))
                L1P=ABS(KAYF-JF)
                IF(MOD(JFP+L1P,IFOUR).NE.MTP)L1P=L1P+2
                L2P=KAYF+JF
                IF(MOD(JFP+L2P,IFOUR).NE.MTP)L2P=L2P-2
C
                NCJP0=NT(JFG)
                NCNP0=NGSLJ(JFG)
C
c get lambda for non-dipole infnite energy top-up
c
                if(jnew.ge.lrglam)then
                  if(ji+jf.ne.0)then
                    litlam=abs(ji-jf)/2
                    if(jip.ne.jfp)then
                      if(litlam.le.1)then          !for case of octupole
                        litlam=3
               elseif(1-2*mod(abs(litlam),itwo).gt.0)then !(-1)**litlam
                        litlam=litlam+1
                      endif
                    else
                      if(litlam.eq.0)then
                        litlam=2
               elseif(1-2*mod(abs(litlam),itwo).lt.0)then !(-1)**litlam
                        litlam=litlam+1
                      endif
                    endif
                    if(litlam.gt.(ji+jf)/2)litlam=0
                  else
                    litlam=0
                  endif
                endif
c
c                beqgrpj=jig.eq.jfg                  !not currently used
C
                DO LI=L1,L2,4               !LOOP OVER INITIAL CHANNEL L
C
c set position of phase shift for this li
c only required by  elastic case for diagonal rho
c or if printing usual reactance matrix
c
                  if(ione1.eq.0.or.brmx)then
                    L=(LCONDWJ+1)/2 -JPOS/2+LI/2
c                    if(l.gt.lcondwj.or.l.lt.1)stop 'phase error'
                    l=min(l,lcondwj)   !case user has restricted lcondwj
                    l=max(l,ione)     !then we don't have all the phases
                    L0=ABS(QPOS(L))
                  endif
C
                  DO LF=L1P,L2P,4             !LOOP OVER FINAL CHANNEL L
C
c set position of phase shift for this lf
c only need if printing usual reactance matrix, not needed by rho matrix
C
                    if(brmx)then
                      L=(LCONDWJ+1)/2 -JPOS/2+LF/2
c                      if(l.gt.lcondwj.or.l.lt.1)stop 'phase error'
                      l=min(l,lcondwj) !case user has restricted lcondwj
                      l=max(l,ione)   !then we don't have all the phases
                      L00=ABS(QPOS(L))
                    endif
C
C NOW FORM JK INTERACTION (BY TARGET SYMMETRY GROUP)
C*************************
C
C THIS IS IN THE RHO-I REPRESENTATION, WHERE
C |T^R(V,V')|=|T^RHO(V,V')| FOR CHANNELS V.NE.V'.
C WE USE T^RHO(V,V')=-2I*RHO(V,V'), WITH A 2X2 UNITARITY CONDITION.
C FOR V.EQ.V' T^R(V,V)~-2*TAN(TAU(V)), FOR RHO(V,V) SMALL.
C (IN GENERAL, WE ARE NOT INTERESTED IN ELASTIC TRANSITIONS.)
C
c
                if(btimet)call cpu_time(timei)
C
                    NOMTG=NCJ0*NCJP0
                    DO N=1,NOMTG
                      DO M=1,MTRAN
                        RHO1(M,N)=DZERO
                      ENDDO
                    ENDDO
C
                    NCI0=0
                    DO NC00=1,NCN0    !BEGIN LOOP OVER INITIAL SL GROUPS
                      NC=NSLJ(NC00,JIG)
                      MC=NSL(NC)
                      SA=QSI(NC)
                      LA=QLI(NC)
                      MCI=NGRPI(NC)
C
                      NCIP0=0
                      DO ND00=1,NCNP0   !BEGIN LOOP OVER FINAL SL GROUPS
                        ND=NSLJ(ND00,JFG)
                        MCP=NSL(ND)
                        SAP=QSI(ND)
c                        IF(ABS(SA-SAP).GT.2)GO TO 68   !unnecessary...
                        IF(NMETAG(NC)+NMETAG(ND).EQ.2)GO TO 68
                        LAP=QLI(ND)
                        MCIP=NGRPI(ND)
C
                        DO IXX=1,INASTX      !LOOP OVER INITIAL LS SYMMS
C
                          IX=JSYMM(IXX,KX)
                          NCN=NCHG(IX)
C
                          nchi=0
                          DO NC0=1,NCN               !FIND INITIAL GROUP
                            LL1=LLCH(1,NC0,IX)
                            LL2=LLCH(2,NC0,IX)
                            nchi=nchi+((ll2-ll1)/4+1)*mc
                            IF(NC.EQ.ITARG(NC0,IX))THEN         !MATCHED
                              IF(LI.LT.LL1.OR.LI.GT.LL2)GO TO 715
                              nchi=nchi-((ll2-li)/4+1)*mc
                              GO TO 720
                            ENDIF
                          ENDDO
C
 715                      CONTINUE
c                      write(6,*)'NO CONTRIB. FROM LS SYM',IXX,' IX=',IX
                          GO TO 750             !SLP DOES NOT CONTRIBUTE
C
 720                      IS=LSPI(IX)/10000
                          IP=LSPI(IX)-IS*10000
                          IL=IP/10
                          IP=IP-IL*10
C
                          IF(MTP.NE.IP+IP)STOP 'IXX ERROR'       !REMOVE
                          MTS=IS-1
                          MTL=IL+IL
C
                          IF(KAYI.LT.ABS(MTL-SA)
     X                   .OR.KAYI.GT.MTL+SA)GO TO 750     !LAST TRIANGLE
C
                          IF(BKUTOO.AND.IL.GT.MAXLOO)THEN
                            KUTOOX=0
                            BKUTOO=.FALSE.
                          ENDIF
C
                          bnx=il.gt.maxlx
c
                          if(jprint.ge.5)then
                            if(bnx)then
                              nwt=-2*is+2
                            else
                              nwt=is
                            endif
                            write(6,1113)ix,nwt,il,ip
                          endif
c
c must be synchronized with current values of l placed in ql(i) for
c orbital and integral evaluations.
c
                          ldiff=2*(jpos/2)-mtl      !for adjust of ql(i)
C
C DETERMINE INITIAL STATE RECOUPLING COEFFICIENT
C
                          W=SJS(LA,LI,MTL,KAYI,SA,JI,DFS)
                          ISGN=(LI+MTL+SA+JI)/2
                          isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                          W=W*ISGN
                          W2=SJS(MTS,MTL,MTJ,KAYI,IONE,SA,DFS)
                          ISGN=(MTL+MTJ+1+SA)/2
                          isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                          W2=W*W2*ISGN
                          W2=W2*SQRT(REAL((MTL+1)*(MTS+1),WP))*SJKI
c
                          if(bnx)then
                            mts=mts-2
                            if(mts.ge.abs(mtj-mtl))then
                              x2=sjs(mts,mtl,mtj,kayi,ione,sa,dfs)
c                              isgn=(mtl+mtj+1+sa)/2
c                              isgn=1-2*mod(abs(isgn),2)!(-1)**isgn
                              x2=w*x2*isgn
                              x2=x2*sqrt(real((mtl+1)*(mts+1),wp))*sjki
                            endif
                          else
                            x2=dzero
                          endif
c
                          if(abs(w2)+abs(x2).lt.1.d-70)go to 750
C
                          JX1=1                            !FS
                          IF(MTJ.GT.MAXJFS)JX1=IXX         !NO-FS
C
                          DO JXX=JX1,IXX       !LOOP OVER FINAL LS SYMMS
C
                            JX=JSYMM(JXX,KX)
                            NCNP=NCHG(JX)
C
                            nchip=0
                            DO ND0=1,NCNP              !FIND FINAL GROUP
                              LL1P=LLCH(1,ND0,JX)
                              LL2P=LLCH(2,ND0,JX)
                              nchip=nchip+((ll2p-ll1p)/4+1)*mcp
                              IF(ND.EQ.ITARG(ND0,JX))THEN       !MATCHED
                                IF(LF.LT.LL1P.OR.LF.GT.LL2P)GO TO 725
                                nchip=nchip-((ll2p-lf)/4+1)*mcp
                                GO TO 730
                              ENDIF
                            ENDDO
C
 725                        CONTINUE
c                   write(6,*)'NO CONTRIB. FROM LS SYM',JXX,' JX=',JX
                            GO TO 740              !SLP DOES NOT CONTRIB
C
 730                        ISP=LSPI(JX)/10000
                            IPP=LSPI(JX)-ISP*10000
                            ILP=IPP/10
                            IPP=IPP-ILP*10
C
                            IF(MTP.NE.IPP+IPP)STOP 'JXX ERROR'   !REMOVE
                            MTSP=ISP-1
                            MTLP=ILP+ILP
C
                            IF(KAYF.LT.ABS(MTLP-SAP)
     X                     .OR.KAYF.GT.MTLP+SAP)GO TO 740 !LAST TRIANGLE
C
                            BLS=IX.EQ.JX
                            b2fs=mtj.le.maxjfs
     X                 .and.     (IS+ISP-2)*(IL+ILP).GT.0
     x                 .and.     abs(NMETAG(NC))+abs(NMETAG(ND)).lt.2
C
                            if(jprint.ge.5)then
                              if(bnx)then
                                nwtp=-2*isp+2
                              else
                                nwtp=isp
                              endif
                              write(6,1115)jx,nwtp,ilp,ipp
                            endif
C
C DETERMINE FINAL STATE RECOUPLING COEFFICIENT
C
                            W=SJS(LAP,LF,MTLP,KAYF,SAP,JF,DFS)
                            ISGN=(LF+MTLP+SAP+JF)/2
                            isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                            W=W*ISGN
                          W2P=SJS(MTSP,MTLP,MTJ,KAYF,IONE,SAP,DFS)
                            ISGN=(MTLP+MTJ+1+SAP)/2
                            isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                            W2P=W*W2P*ISGN
                           W2P=W2P*SQRT(REAL((MTLP+1)*(MTSP+1),WP))*SJKF
C
                            W4=W2*W2P
c
                            if(bnx)then
                              mtsp=mtsp-2
                              if(mtsp.ge.abs(mtj-mtlp))then
                                x2p=
     x                        sjs(mtsp,mtlp,mtj,kayf,ione,sap,dfs)
c                                isgn=(mtlp+mtj+1+sap)/2
c                                isgn=1-2*mod(abs(isgn),2)!(-1)**isgn
                                x2p=w*x2p*isgn
                                x2p=x2p*sqrt(real((mtlp+1)*(mtsp+1),wp))
     x                                 *sjkf
                                w4=w4+x2*x2p
                              endif
                            endif
C
                            if(abs(w4).lt.1.d-70)go to 740
c
c set pointers to ls and fs interactions
c
c
                            beqgrp=bls.and.nc0.eq.nd0     !ls equal grps
c                                                          !to fill rho1
                            beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
c
                            if(bls)then
                              ncor=qptls(ix,nc0,nd0,li,lf)
                              if(ncor.ge.0)then
                                nun=0
                              else             !reverse
                                nun=mc-1
c                       write(6,*)ix,nc0,nd0,li,lf,ncor+1
                              endif
                              ncor0=ncor
                              LSTORE=IL-LPOS
                              LSTORE=QPX(LSTORE)-1
                            else
                              ncor0=0
                            endif
c
                            if(b2fs)then
                              ncorj=qptlsj(kx,ixx,jxx,nc0,nd0,li,lf)
                              if(ncorj.ge.0)then
                                nunj=0
                              else             !reverse
                                nunj=mc-1
c                      write(6,*)kx,ixx,jxx,nc0,nd0,li,lf,ncorj+1
                              endif
                              ncorj0=ncorj
                            else
                              ncorj0=0
                            endif
c
                            icl0=0
                            if(bcorr.and.(ncor0.lt.0.or.ncorj0.lt.0))
     x                                                              then
                              do md1=1,mc
                                j1=md1+mci
                                j=jndex(j1)
                                if(j.lt.0)icl0=icl0+1
                              enddo
                            endif
C
C POPULATE UNMIXED RHO1 INTERACTION MATRIX
C
                            icl=0
                            DO MD1=1,MC        !LOOP OVER INITIAL LEVELS
                              J1=MD1+MCI
c
                              j=jndex(j1)
                              if(kcutx.lt.0)j=abs(j)  !keep corr.-corr.
                              if(bcorr.and.j.lt.0)icl=icl+1
                              KF=NFK(J1)
                              NCJ=NCI0+MD1
C
                              if(ncor0.lt.0)ncor=-ncor0-1+md1-1
                              if(ncorj0.lt.0)ncorj=-ncorj0-1+md1-1
c
                              iclp=0
                              DO MDP1=1,MCP      !LOOP OVER FINAL LEVELS
                                J1P=MDP1+MCIP
c
                                jp=jndex(j1p)
                                if(bcorr.and.jp.lt.0)iclp=iclp+1
                                if(j.lt.0.and.jp.lt.0)then      !cor-cor
                                  if(becor)then
                                    if(bls)ncor=ncor+1
                                    if(b2fs)ncorj=ncorj+1
                                    go to 710
                                  endif
                                  go to 712
                                endif
C
                                KG=NFK(J1P)
                                NCJP=NCIP0+MDP1
C
                                NOMTG=(NCJP-1)*NCJ0+NCJ     !rho1 (orig)
C
C LS ALGEBRA
C
                                IF(BLS)THEN
c                                           since ls only stores half...
                                  if(beqgrpl.and.j1p.gt.j1-ione0)then
                                    ncor=ncor0+icol(md1,mdp1,ione0)-1
                                    if(bcorr)ncor=ncor
     x                                        -icol(iclp-1,iclp-1,ione0)
                                  endif
C
                                  N1=NAD(NCOR)+1
                                  NCOR=NCOR+1
                                  N2=NAD(NCOR)
c debug write
                                  if(jprint.ge.5.and.n1.le.n2)then
                                    nch=nchi+md1
                                    nchp=nchip+mdp1
                                    if(n2-n1.eq.5)then
                                      write(6,9119)ncor,ix,nch,nchp,0,0,
     x                                           (nrk(n),drk(n),n=n1,n2)
                                    else
                                      write(6,9120)ncor,ix,nch,nchp,0,0,
     x                                           (nrk(n),drk(n),n=n1,n2)
                                    endif
                                    if(bkutoo)write(6,9121)
     x                                           (nrk(n),dek(n),n=n1,n2)
                                    write(6,9120)
                                  endif
c
c need to find if Slater integral initial and final states are swapped
c because of falling order. this also picks-up any case that needs
c swapping because initial and final algebraic states are swapped.
c it doesn't pick-up all cases of ncor0.lt.0 but the symmetry of the
c Slater integrals means that such cases are unchanged by a swap.
c
                                  if(n2-n1+1.gt.mxd13)then
                                    write(6,*)'***sr.dwxbp: increase',
     x                              ' internal buffer mxd13 to', n2-n1+1
                                    nf=-1
                                    go to 700
                                  endif
c
                                  ks=0
                                  do n=n1,n2
                                    ks=ks+1
                                    bswap(ks)=.false.
                                    n0=int(nrk(n))
                                    m0=qrl(1,n0)
                                    if(li.eq.ql(m0)-ldiff)then
                                      if(li.eq.lf.and.kf.ne.kg)then
                                        m0=qrl(3,n0)
                                        if(qn(m0).gt.0)then    !exchange
                                          if(m0.ne.kact(kg,kf))then   !f
                                            bswap(ks)=.true.       !swap
                                          endif
c                                       else    !direct - doesn't matter
                                        endif
c                                     else      !distinct/kf=kg so can't
                                      endif
                                    else           !trivially, they were
                                      bswap(ks)=.true.
                                    endif
                                  enddo
c
                                ELSE
                                  N1=1
                                  N2=0
                                ENDIF
C
C FS ALGEBRA
C
                                if(b2fs)then
c                                           since ls only stores half...
                                  if(beqgrpl.and.j1p.gt.j1-ione0)then
                                   ncorj=ncorj0+icol(md1,mdp1,ione0)-1
                                   if(bcorr)ncorj=ncorj
     x                                        -icol(iclp-1,iclp-1,ione0)
                                  endif
c
                                  k1=nadr(ncorj)+1
                                  ncorj=ncorj+1
                                  k2=nadr(ncorj)
c debug write
                                  if(jprint.ge.5.and.k1.le.k2)then
                                    nch=nchi+md1
                                    nchp=nchip+mdp1
                                    if(k2-k1.eq.5)then
                                      write(6,1201)ncorj,kx,ix,jx,nch,
     x                                nchp,0,0,(mss(n),dss(n),n=k1,k2)
                                    else
                                      write(6,1202)ncorj,kx,ix,jx,nch,
     x                                nchp,0,0,(mss(n),dss(n),n=k1,k2)
                                    endif
                                    write(6,1201)
                                  endif
c
c need to find if n & v integral initial and final states are swapped
c because of falling order.
c
c this does *not* pick-up all cases that need swapping because initial
c and final algebraic states are swapped (ncorj0.lt.0) hence additional
c test on ncorj0.
c
                                  if(k2-k1+1.gt.mxd13)then
c                write(0,*)ncorj,iadj
                                    write(6,*)'***sr.dwxbp: increase ',
     x                              'internal buffer mxd13 to', k2-k1+1
                                    nf=-1
                                    go to 700
                                  endif
c
c **********************************************************************
c currently, swapping of indexes due to falling order has been
c suppressed in sr.resx1 (see also sr.fsintx) because of the lesser
c symmetry compared to Slater integrals which means that an additional
c flag is needed.
c **********************************************************************
c
c so, we simply have:
                                  ksj=0
                                  do k=k1,k2
                                    ksj=ksj+1
                                    bswapj(ksj)=ncorj0.lt.0
                                  enddo
cc instead of:
c                                  ksj=0
c                                  do k=k1,k2
c                                    ksj=ksj+1
c                                    bswapj(ksj)=.false.
c                                    k0=int(mss(k))
cc
c                                    i1=qss(1,k0)
c                                    i3=qss(3,k0)
c                                    i2=qss(2,k0)
c                                    i4=qss(4,k0)
c                                    if(qn(i1).lt.0)then
c                                      ic=i1
c                                      if(qn(i3).lt.0)then       !direct
c                                        ib=i4
c                                      else                    !exchange
c                                        ib=i3
c                                      endif
c                                    else
c                                      ic=i2
c                                      if(qn(i4).lt.0)then       !direct
c                                        ib=i3
c                                      else                    !exchange
c                                        ib=i4
c                                      endif
c                                    endif
c                                    if(li.eq.ql(ic))then
c                                      if(li.eq.lf)then
c                                        if(kf.ne.kg)then
c                                          if(ib.ne.kact(kg,kf))then  !f
c                                            bswapj(ksj)=.true.
c                                          endif
c                                        else
cc tbd for exchange falling order (see also sr.resx1 and sr.fsintx):
cc the case of N(C'C;BB)=N(BC;C'B) for Bound and Continuum needs a
cc further flag so as to distinguish it from N(C'C;BB)=N(C'B;BC),
cc since in the former we need C'=M2 while in the latter C'=M1, so
cc                                           if (former) then
cc                                           bswapj(ksj)=.true.
cc           since unlike slater we cannot interchange 1 & 3 with 2 & 4
cc         - this also means that we need
c                                          if(ncorj0.lt.0)
c     x                                    bswapj(ksj)=.not.bswapj(ksj)
c                                        endif
c                                      else           !distinct so can't
c                                      endif
c                                    else          !trivially, they were
c                                      bswapj(ksj)=.true.
c                                    endif
cc
cc                           nj=ntgj(jig)
cc                           njp=ntgj(jfg)
cc                           n1=ncj+nj
cc                           n=jndxj(n1)
cc                           n1p=ncjp+njp
cc                           np=jndxj(n1p)
cc           write(6,*)ixx,jxx,nc0,nd0,n,np,li,lf,ncorj0,k0,bswapj(ksj)
cc           bswapt=ncorj0.lt.0
cc           if(bswapt.neqv.bswapj(ksj))
cc     x     write(0,*)ixx,jxx,nc0,nd0,n,np,li,lf,ncorj0,k0,bswapj(ksj)
cc
cc                                  enddo
c
                                else
                                  k1=1
                                  k2=0
                                endif
C
C LOOP OVER ENERGIES
C
                                DO M=1,MTRAN
                                  M1=MNDEX(M,1)
                                  M2=MNDEX(M,2)
C
C LS CONTRIBUTION:
C
                                  DD=DZERO
                                  ks=0
                                  DO N=N1,N2
                                    ks=ks+1
c
                                    if(bswap(ks))then              !swap
                                      mm=mrndx(m)
                                    else
                                      mm=m
                                    endif
c
                                    N0=INT(NRK(N))
C
                                    DD=DD+DRLX(N0,mm,LSTORE)*DRK(N)
C
                                    IF(BKUTOO)THEN
                                      DS=DZLX(N0,mm,LSTORE)
                                      IF(BFALL(N))DS=-DS
                                      DS=DS+DXTWOX(N0,mm,LSTORE)*DRK(N)
     X                                  +DETAX(N0,mm,LSTORE)*DEK(N)
                                      DD=DD+DS
                                    ENDIF
                                  ENDDO
C
C FS CONTRIBUTION:
C
c                                  dd=dzero !test fs, switch-off coulomb
c
                                  DDJ=DZERO
                                  ksj=0
                                  DO K=K1,K2
                                    ksj=ksj+1
c
                                    if(bswapj(ksj))then            !swap
                                      mm=mrndx(m)
                                    else
                                      mm=m
                                    endif
c
                                    K0=INT(MSS(K))
C
                                    DDJ=DDJ+DNLX(K0,mm)*DSS(K)
                                  ENDDO
C
                                  DEE=DD+DDJ
C                                                               !UNMIXED
                                  RHO1(M,NOMTG)=RHO1(M,NOMTG)+DEE*W4
                                ENDDO
c
c start test print
c                           nj=ntgj(jig)
c                           njp=ntgj(jfg)
c                           n1=ncj+nj
c                           n=jndxj(n1)
c                           n1p=ncjp+njp
c                           np=jndxj(n1p)
c                           write(6,777)n,np,(rho1(m,nomtg),m=1,mtran)
c  777                      format(2i5,1p,10d12.3/(10x,10d12.3))
c                           call flush(6)
c end test print
C
  710                           if(ncor0.lt.0)then
                                  ncor=ncor+nun
                                  if(jp.lt.0)ncor=ncor-icl0
                                endif
                                if(ncorj0.lt.0)then
                                  ncorj=ncorj+nunj
                                  if(jp.lt.0)ncorj=ncorj-icl0
                                endif
c
                              ENDDO          !END LOOP OVER FINAL LEVELS
c
  712                         if(beqgrpl)then
                                if(bls)then
                                  ncor=ncor0+icol(md1,md1,ione0)
                                  if(bcorr)ncor=ncor-icol(icl,icl,ione0)
                                endif
                                if(b2fs)then
                                  ncorj=ncorj0+icol(md1,md1,ione0)
                                  if(bcorr)ncorj=ncorj
     x                                              -icol(icl,icl,ione0)
                                endif
                              endif
C
                            ENDDO          !END LOOP OVER INITIAL LEVELS
C
  740                     ENDDO            !END LOOP OVER FINAL LS SYMMS
C
                          KUTOOX=KOLDOO
                          BKUTOO=KUTOOX.NE.0
C
  750                   ENDDO            !END LOOP OVER INITIAL LS SYMMS
C
  68                    CONTINUE
C
                        NCIP0=NCIP0+MCP
                      ENDDO               !END LOOP OVER FINAL SL GROUPS
                      if(ncip0.ne.ncjp0)
     x                stop 'ncip0.ne.nt(jfg)'                 !temp test
C
                      NCI0=NCI0+MC
                    ENDDO               !END LOOP OVER INITIAL SL GROUPS
                    if(nci0.ne.ncj0)stop 'nci0.ne.nt(jig)'   !temp test
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeset=timeset+timef-timei
                      timei=timef
                    endif
C
C-----------------------------------------------------------------------
C
                    MX=MTRAN
C
C INTERP THEN MIX (APPROX)
C
                   if(.not.bmix)then
C
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
C
                    DO NCJP=1,NCJP0        !BEGIN LOOP OVER FINAL LEVELS
C
                      J1P=NCJP+NJP
                      JP=JNDXJ(J1P)
C
                      NOMTG0=(NCJP-1)*NCJ0
C
                      DO NCJ=1,NCJ0      !BEGIN LOOP OVER INITIAL LEVELS
C
                        J1=NCJ+NJ
                        J=JNDXJ(J1)
C
                        NOMTG=NOMTG0+NCJ              !rho1 nomtg (orig)
C
                        IF(J.LE.JP)THEN !INITIAL ALGEBRAIC IS LOWER ENRG
C
                          JL=J
                          JH=JP
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M1,M2)=RHO1(M,NOMTG)
                          ENDDO
C
                        ELSE            !FINAL ALGEBRAIC IS LOWER ENERGY
C
                          JL=JP
                          JH=J
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M2,M1)=RHO1(M,NOMTG)
                          ENDDO
C
                        ENDIF
C
                        DE=DSPECJ(JH)-DSPECJ(JL)
C
                        NOMT=IROW(JL,JH,ione1,NSPECJ)           !ROWWISE
c
                        bdip=.false.
                        if(jl.le.nmetaj.and.jl.lt.jh)then   !need exists
                          bdip=omginf(nomt).lt.dzero        !flag dipole
                        endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                        DO M0=1,MENG0
C
                          M=IYY0(M0)
c
                          ml=mlim(m,1)
                          mu=mlim(m,2)
c
                          if(bdip)mu=-mu                    !flag dipole
C
                          RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu)!A.U.
C
                          RHO1(M0,NOMTG)=RHO
C
                        ENDDO                    !END LOOP OVER ENERGIES
C
                      ENDDO                !END LOOP OVER INITIAL LEVELS
C
                    ENDDO                    !END LOOP OVER FINAL LEVELS
C
                    if(btimet)then
                      call cpu_time(timef)
                      timeint=timeint+timef-timei
                      timei=timef
                    endif
c
                    mx=meng0                                     !re-set
c
                   endif
C
C-----------------------------------------------------------------------
C
C NOW MIX (INITIAL)
C
                    N0=NADRUG(JIG)
                    N0P=NADRUG(JFG)
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
C                    NCJ0=NT(JIG)
C                    NCJP0=NT(JFG)
C
                    DO NCJ=1,NCJ0        !BEGIN LOOP OVER INITIAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 11                      !omit corr
                      if(j.gt.nmetaj)go to 11       !omit non-metastable
c
                      if(bcorr.or.kayi.eq.kayf)then
                        DO NCJP=1,NCJP0    !SEE IF WE HAVE A FINAL LEVEL
                          J1P=NCJP+NJP
                          IF(J1P.GT.J1.and.kayi.eq.kayf)GO TO 11
                          jp=jndxj(j1p)
                          if(jp.gt.0)go to 5                      !we do
                        ENDDO
                        GO TO 11                               !WE DON'T
                      endif
C
   5                  N1=N0+(NCJ-1)*NCJ0                    !tfu pointer
C
                      DO NCJP=1,NCJP0              !FOR EACH FINAL LEVEL
C
                        DO M=1,MX
                          TEMP(M,NCJP)=DZERO
                        ENDDO
C
                        NG0=(NCJP-1)*NCJ0
                        DO LD1=1,NCJ0              !BEGIN INITIAL MIXING
C
                          NG=NG0+LD1                         !rho1 nomtg
                          N2=N1+LD1
                          TF=TFU(N2)
C
                          IF(ABS(TF).GT.XMIX)THEN
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL           CALL DAXPY(MX,TF,RHO1(1,NG),IONE,TEMP(1,NCJP),IONE) !LAPACK
CL                          ELSE                                 !LAPACK
                            DO M=1,MX
                              TEMP(M,NCJP)=TEMP(M,NCJP)+RHO1(M,NG)*TF
                            ENDDO
CL                          ENDIF                                !LAPACK
                          ENDIF
C
                        ENDDO                        !END INITIAL MIXING
C
c                        j1p=ncjp+njp
c                        write(6,777)j1,j1p,(temp(m,ncjp),m=1,mx)
C
                      ENDDO                        !FOR EACH FINAL LEVEL
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixi=timemixi+timef-timei
                        timei=timef
                      endif
C
C NOW MIX (FINAL)
C
                      NOMTG0=(NCJ-1)*NCJP0
                      DO NCJP=1,NCJP0      !BEGIN LOOP OVER FINAL LEVELS
C
                        J1P=NCJP+NJP
                        if(j1.eq.j1p.and.ione1.ne.0)go to 10
                        if(kayi.eq.kayf)then
                          IF(J1P.GT.J1)GO TO 11
                          if(j1.eq.j1p.and.lf.gt.li)go to 10
                        endif
c
                        jp=jndxj(j1p)
                        if(jp.lt.0)go to 10                   !omit corr
c                        if(min(j,jp).gt.nmetaj)go to 10 !non-metastable
C
                        N1P=N0P+(NCJP-1)*NCJP0
C
                        NOMTG=NOMTG0+NCJP                    !rho2 (new)
                        DO M=1,MX
                          RHO2(M,NOMTG)=DZERO
                        ENDDO
C
                        DO LDP1=1,NCJP0              !BEGIN FINAL MIXING
C
                          N2P=N1P+LDP1
                          TF=TFU(N2P)
C
                          IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL        CALL DAXPY(MX,TF,TEMP(1,LDP1),IONE,RHO2(1,NOMTG),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                            DO M=1,MX
                              RHO2(M,NOMTG)=RHO2(M,NOMTG)
     X                                                  +TEMP(M,LDP1)*TF
                            ENDDO
CL                      ENDIF                                    !LAPACK
                          ENDIF
C
                        ENDDO                          !END FINAL MIXING
C
c                        write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  10                  ENDDO                  !END LOOP OVER FINAL LEVELS
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixf=timemixf+timef-timei
                        timei=timef
                      endif
C
  11                ENDDO                  !END LOOP OVER INITIAL LEVELS
C
C FIRST SEE IF WE NEED REVERSE CASE:
C----------------------------------
C
C  INITIAL & FINAL ARE ALGEBRAIC AND SO NMETA CAN BE IN EITHER/BOTH/NONE
C  BUT WE WANT THE FIRST MIXING MATRIX MULT TO BE FOR NMETAJ SO WE DON'T
C  NEED TO MULTIPLY BY THE ZERO BLOCK. THUS, WE MAKE A DOUBLE PASS. OF
C  COURSE, IF NMETAJ=NSPECJ THEN THE SECOND PASS IS "SKIPPED".
C
                    DO NCJP=1,NT(JIG)              !CHECK INITIAL LEVELS
                      J1P=NCJP+NTGJ(JIG)
                      jp=jndxj(j1p)
                      if(jp.gt.nmetaj)go to 8                    !needed
                    ENDDO
                    GO TO 130                                  !ALL DONE
C
C NOW MIX (FINAL) - REVERSE CASE
C
   8                N0=NADRUG(JFG)
                    N0P=NADRUG(JIG)
                    NJ=NTGJ(JFG)
                    NJP=NTGJ(JIG)
                    NCJ0=NT(JFG)
                    NCJP0=NT(JIG)
C
                    DO NCJ=1,NCJ0          !BEGIN LOOP OVER FINAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 13                      !omit corr
                      if(j.gt.nmetaj)go to 13       !omit non-metastable
C
                      DO NCJP=1,NCJP0      !SEE IF WE HAVE INITIAL LEVEL
                        J1P=NCJP+NJP
                        IF(J1P.LT.J1.and.kayi.eq.kayf)GO TO 6
                        jp=jndxj(j1p)
                        if(jp.gt.nmetaj)go to 7                   !we do
   6                  ENDDO
                      GO TO 13                                 !WE DON'T
C
   7                  N1=N0+(NCJ-1)*NCJ0                    !tfu pointer
C
                      DO NCJP=1,NCJP0            !FOR EACH INITIAL LEVEL
C
                        DO M=1,MX
                          TEMP(M,NCJP)=DZERO
                        ENDDO
C
                        DO LD1=1,NCJ0                !BEGIN FINAL MIXING
C
                          NG=NCJP+(LD1-1)*NCJP0              !rho1 nomtg
                          N2=N1+LD1
                          TF=TFU(N2)
C
                          IF(ABS(TF).GT.XMIX)THEN
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL           CALL DAXPY(MX,TF,RHO1(1,NG),IONE,TEMP(1,NCJP),IONE) !LAPACK
CL                          ELSE                                 !LAPACK
                            DO M=1,MX
                              TEMP(M,NCJP)=TEMP(M,NCJP)+RHO1(M,NG)*TF
                            ENDDO
CL                          ENDIF                                !LAPACK
                          ENDIF
C
                        ENDDO                          !END FINAL MIXING
C
c                        j1p=ncjp+njp
c                        write(6,777)j1,j1p,(temp(m,ncjp),m=1,mx)
C
                      ENDDO                      !FOR EACH INITIAL LEVEL
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixfr=timemixfr+timef-timei
                        timei=timef
                      endif
C
C NOW MIX (INITIAL) - REVERSE CASE
C
                      DO NCJP=1,NCJP0    !BEGIN LOOP OVER INITIAL LEVELS
C
                        J1P=NCJP+NJP
                        if(j1.eq.j1p.and.ione1.ne.0)go to 12
                        if(kayi.eq.kayf)then
                          IF(J1P.LT.J1)GO TO 12
                          if(j1.eq.j1p.and.lf.gt.li)go to 12
                        endif
c
                        jp=jndxj(j1p)
c                        if(jp.lt.0)go to 12                  !omit corr
                        if(jp.le.nmetaj)go to 12         !already gotten
C
                        N1P=N0P+(NCJP-1)*NCJP0              !tfu pointer
C
                        NOMTG=NCJ+(NCJP-1)*NCJ0        !rho2 nomtg (new)
                        DO M=1,MX
                          RHO2(M,NOMTG)=DZERO
                        ENDDO
C
                        DO LDP1=1,NCJP0            !BEGIN INITIAL MIXING
C
                          N2P=N1P+LDP1
                          TF=TFU(N2P)
C
                          IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL        CALL DAXPY(MX,TF,TEMP(1,LDP1),IONE,RHO2(1,NOMTG),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                            DO M=1,MX
                              RHO2(M,NOMTG)=RHO2(M,NOMTG)
     X                                                  +TEMP(M,LDP1)*TF
                            ENDDO
CL                      ENDIF                                    !LAPACK
                          ENDIF
C
                        ENDDO                        !END INITIAL MIXING
C
c                        write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  12                  ENDDO                !END LOOP OVER INITIAL LEVELS
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixir=timemixir+timef-timei
                        timei=timef
                      endif
C
  13                ENDDO                    !END LOOP OVER FINAL LEVELS
C
C RE-SET
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
                    NCJ0=NT(JIG)
                    NCJP0=NT(JFG)
C
  130               CONTINUE
C
C-----------------------------------------------------------------------
C
C (IF bmix INTERPOLATE MIXED RHO2.) CONVERT TO TMX AND ADD TO OMEGA
C NOTE, RHO2 IS IN "A.U"
C ALLOW FOR ANY INITIAL ALGEBRAIC LEVELS NOT BEING LOWEST IN ENERGY.
c
                    if(.not.bmix)mx=-mx              !skip interp set-up
C
                    DO NCJ=1,NCJ0        !BEGIN LOOP OVER INITIAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 14                      !omit corr
C
                      IF(BPRNT2.or.bunit2.or.bntest)
     X                NCHJ=NCHAJK(KX,KAYI,JIG,LI,NCJ,NTGJ,DFS)
c hold
                      if(bunit2)then
                        iwrkn(nchj)=j
                        iwrkl(nchj)=l0
                      endif
C
                      NOMTG0=(NCJ-1)*NCJP0
                      DO NCJP=1,NCJP0      !BEGIN LOOP OVER FINAL LEVELS
C
                        J1P=NCJP+NJP
c
                        if(j1.eq.j1p.and.ione1.ne.0)go to 15
                        if(kayi.eq.kayf)then
                          IF(J1P.GT.J1)GO TO 14
                          if(j1.eq.j1p.and.lf.gt.li)go to 15
                        endif
C
                        JP=JNDXJ(J1P)
                        if(jp.lt.0)go to 15                   !omit corr
                        if(min(j,jp).gt.nmetaj)go to 15  !non-metastable
C
                        IF(BPRNT2.or.bunit2.or.bntest)
     X                  NCHJP=NCHAJK(KX,KAYF,JFG,LF,NCJP,NTGJ,DFS)
c
c                        write(6,*)nchj,nchjp,j1,j1p,j,jp
c
                        if(bntest)ntest(nchj,nchjp)=ntest(nchj,nchjp)+1
c
c "undefined" should not be accessed by xint...
c                        do m2=1,meng
c                          do m1=1,meng
c                            tmp(m1,m2)=1.d70 !dzero              !test
c                          enddo
c                        enddo
C
                        NOMTG=NOMTG0+NCJP              !rho2 nomtg (new)
C
                        IF(J.LE.JP)THEN !INITIAL ALGEBRAIC IS LOWER ENRG
C
                          JL=J
                          JH=JP
                          NCHL=NCHJ
                          NCHH=NCHJP
                          LUP=LF
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M1,M2)=RHO2(M,NOMTG)
                          ENDDO
C
                        ELSE            !FINAL ALGEBRAIC IS LOWER ENERGY
C
                          JL=JP
                          JH=J
                          NCHL=NCHJP
                          NCHH=NCHJ
                          LUP=LI
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M2,M1)=RHO2(M,NOMTG)
                          ENDDO
C
                        ENDIF
C
                        DE=DSPECJ(JH)-DSPECJ(JL)
C
                        NOMT=IROW(JL,JH,ione1,NSPECJ)           !ROWWISE
c
                        if(nomt.gt.nomwrt)then    !shouldn't happen, now
                          write(0,*)jl,jh,nmetaj,nspecj,nomt,nomwrt
                          stop 'omega prob.'
                        endif
c
                        bdip=omginf(nomt).lt.dzero          !flag dipole
c
                        if(bunit2)then
                          if(nchjp.le.nchj)then
                            nchl=nchjp
                            nchh=nchj
                          else
                            nchl=nchj
                            nchh=nchjp
                          endif
                        endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                        DO M0=1,MENG0
C
                          M=IYY0(M0)
c
                         if(mx.gt.0)then                         !interp
c
                          ml=mlim(m,1)
                          mu=mlim(m,2)
c
                          if(bdip)mu=-mu                    !flag dipole
C
                          RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu)!A.U.
c
                         else                              !already have
C
                          RHO=RHO2(M0,NOMTG)
c
                         endif
C
                          RHOSQ=RHO*RHO
c store for ii
                          if(bunit2)then
                            if((j1.eq.j1p.and.li.eq.lf.and.
     x                          kayi.eq.kayf).neqv.(nchj.eq.nchjp))
     x                          stop 'dwbp: diagonal index issue?'
                            nx=irow(nchl,nchh,izero,nchjt)
                            rhom(nx,m0)=rho
                            go to 16
                          endif
C
c                          IF(NCHJ.eq.NCHJP)THEN            !DIAGONAL MX
c
                         if(j1.eq.j1p.and.li.eq.lf.and.kayi.eq.kayf)then
C
                            IF(BRMX)THEN                !USUAL REACTANCE
                              T=PI*PSHFTX(M,L0)
                              CT=COS(T)
                              ST=SIN(T)
                              RMX=(ST+RHO*CT)/(CT+RHO*ST)
                            ENDIF
C
                            IF(BPRNT3)WRITE(6,202)NCHL,NCHH,JL,JH
     X                                    ,PSHFTX(M,L0),M0,'PHASE SHIFT'
                            T=TPI*PSHFTX(M,L0)
                            C2T=COS(T)
                            S2T=SIN(T)
C
                            if(bunit)then                   !2x2 UNITARY
                              TSQ=DONE+(C2T*(RHOSQ-DONE)+DTWO*S2T*RHO)
     X                                /(RHOSQ+DONE)
                            else                            !non-unitary
                              tsq=done+(dtwo*s2t*rho-c2t)
                            endif
c
                            TSQ=TSQ+TSQ     ! T^R=1+EXP(2I*TAU)(T^RHO-1)
C
                          ELSE                             !OFF DIAGONAL
C
                            IF(BRMX)THEN                !USUAL REACTANCE
                              T1=TPI*PSHFTX(M,L0)
                              T2=TPI*PSHFTX(M,L00)
                              DET=COS(T1)*COS(T2)-RHOSQ*SIN(T1)*SIN(T2)
                              RMX=RHO/DET
                            ENDIF
C
                            TSQ=4*RHOSQ      ! |T^R(V,V')|=|T^RHO(V,V')|
C
                            if(bunit)TSQ=TSQ/(DONE+RHOSQ)**2 !~UNITARITY
C
C                                    !FOR ELASTIC LI.NE.LF .OR. KI.NE.KF
                             IF(J1.EQ.J1P)TSQ=TSQ+TSQ
C
                          ENDIF
c
                          if(tsq.lt.d1m20)tsq=dzero
C
                          IF(BPRNT3)THEN
                            IF(BRMX)THEN
                              WRITE(6,202)NCHL,NCHH,JL,JH,RMX,M0,
     X                                   'R-MATRIX  '
                            ELSE
                              WRITE(6,202)NCHL,NCHH,JL,JH,RHO,M0,
     X                                   'RHO-MATRIX'
                            ENDIF
                          ENDIF
C
                          OMPW=wait*TSQ*NWTJ/DTWO
C
                          if(bht)ompw=ompw/2   !for BHT(1970) comparison
C
C LOOK AT TOP-UP ISSUES, IF L LARGE ENOUGH TO WARRANT IT (OFF IF BTHRSH)
C
                          IF(JNEW.GE.LRGLMN)THEN
C                                                     !NON-DIPOLE TOP-UP
                            IF(OMGINF(NOMT).GT.DZERO.and.
     X                                            litlam.gt.0)THEN
C
                              IF(JNEW.EQ.LRGLAM)THEN       !APPLY TOP-UP
                                EJ=DYY0(M0)
                                EI=EJ+DE
c
                                ompw0=ompw
                                ompw=ompw/wait
                                IF(BPRNT3)OMPW=-OMPW         !FLAG PRINT
C
                                CALL TOP2(LITLAM,LRGLAM/2,EI,EJ,OMPW)
C
                                ompw=ompw+ompw0*(wait-done)/wait !adjust
c
                              ELSEIF(JNEW.GT.LRGLAM)THEN
                                OMPW=DZERO
                              ENDIF
C                                                  !DIPOLE:LITLAM=LRGLAM
                            ELSEIF(bdip)THEN              !POSS ZERO-OUT
C                                            !ZERO-OUT AS INC. IN TOP-UP
                              IF(MAX(LI,LF).GT.LRGLAM)OMPW=DZERO
C
                            ENDIF
C
                          ENDIF
C
C ARCHIVE PARTIAL/TOTAL COLLISION STRENGTHS
C
                          IF(BTHRSH)THEN
                            M00=LUP/2+1-LVMIN
                            IF(M00.LT.1.OR.M00.GT.MOGGY)GO TO 15
                          ELSE               !CASE NOT XCLUDED BY ALGXLS
                            M00=M0
                          ENDIF
C
                          OMP(M0)=OMPW
C                                                    !UPDATE TOTAL OMEGA
                          OMEGA(M00,NOMT)=OMEGA(M00,NOMT)+REAL(OMPW,RP)
C
  16                    ENDDO                    !END LOOP OVER ENERGIES
C                                                         !PARTIAL OMEGA
                        IF(BPRNT2.and..not.bunit2)
     X                  WRITE(6,201)NCHL,NCHH,JL,JH,(OMP(M0),M0=1,MENG0)
C
  15                  ENDDO                  !END LOOP OVER FINAL LEVELS
C
  14                ENDDO                  !END LOOP OVER INITIAL LEVELS
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeint=timeint+timef-timei
                      timei=timef
                    endif
C
C-----------------------------------------------------------------------
C
                  ENDDO                           !END LOOP OVER FINAL L
C
                ENDDO                           !END LOOP OVER INITIAL L
C
              ENDDO                       !END LOOP OVER FINAL JP GROUPS
C
            ENDDO                       !END LOOP OVER INITIAL JP GROUPS
C
          ENDDO                                   !END LOOP OVER FINAL K
C
        ENDDO                                   !END LOOP OVER INITIAL K
C
        if(bntest)then
          do i=1,nchjt
            if(ntest(i,i).ne.1)then
                  write(0,*)'checksum wrong for nchj,nchj '
     x           ,i,' :',ntest(i,i)
            endif
            do j=i+1,nchjt
              if(ntest(i,j)+ntest(j,i).ne.1)then
                write(0,*)'checksum wrong for nchj,nchjp'
     x                   ,i,j,' :',ntest(i,j),ntest(j,i)
              endif
            enddo
          enddo
        endif
c
c now determine t-matrix from full rho-matrix for approximation-ii:
c
        if(bunit2)then
c
          do m0=1,meng0
            m=iyy0(m0)
c
CL            if(m0.gt.0)then                                    !LAPACK
CL             call pqlap(nchjt,rhom(1,m0),wrkp,wrkq,work,nf)    !LAPACK
CL            else                                               !LAPACK
             call pq(nchjt,rhom(1,m0),wrkp,wrkq,work,nf)
CL            endif                                              !LAPACK
c
            if(nf.le.0)go to 700
c
            do nchj=1,nchjt
c
              j=iwrkn(nchj)
              if(j.le.0)go to 17
              l0=iwrkl(nchj)
c
              do nchjp=nchj,nchjt
c
                jp=iwrkn(nchjp)
                if(jp.le.0)go to 18
c
                n=irow(nchj,nchjp,izero,nchjt)
                tp=-2*wrkp(n)                 !real T^rho
                tq=-2*wrkq(n)                 !imag T^rho
c
                if(nchj.eq.nchjp)then
                  t=tpi*pshftx(m,l0)
                  if(bprnt2)write(6,202)nchj,nchjp,j,jp
     x                             ,pshftx(m,l0),m0,'phase shift'
                  c2t=cos(t)
                  s2t=sin(t)
                  tp1=tp-done
c                  tr=done+c2t*tp1-tq*s2t
c                  ti=s2t*tp1+c2t*tq
c                  tsq=tr*tr+ti*ti
                  tsq=done+(2*c2t+tp1)*tp1-(2*s2t-tq)*tq
                else
                  tsq=tp*tp+tq*tq
                  if(j.eq.jp)tsq=tsq+tsq
                endif
c
                ompw=wait*tsq*nwtj/dtwo
c
                if(bht)ompw=ompw/2      !for bht(1970) comparison
c
                if(j.le.jp)then
                  jl=j
                  jh=jp
                  nchl=nchj
                  nchh=nchjp
                else
                  jl=jp
                  jh=j
                  nchl=nchjp
                  nchh=nchj
                endif
c
                nomt=irow(jl,jh,ione1,nspecj)
c some top-up
                if(jnew.ge.lrglmn)then             !look at top-up
c
                  if(omginf(nomt).gt.dzero)then        !non-dipole
c
                    if(jnew.eq.lrglam)then           !apply top-up
                      de=dspecj(jh)-dspecj(jl)
                      ej=dyy0(m0)
                      ei=ej+de
c
                      ompw0=ompw
                      ompw=ompw/wait
                      if(bprnt3)ompw=-ompw             !flag print
c
                      call top2(itwo,lrglam/2,ei,ej,ompw)
c
                      ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                    elseif(jnew.gt.lrglam)then
                      ompw=dzero
                    endif
c
                  elseif(omginf(nomt).lt.dzero)then        !dipole
                    if(jnew.gt.lrglam)ompw=dzero
                  endif
c
                endif
c
                omp(m0)=ompw
                omega(m0,nomt)=omega(m0,nomt)+real(ompw,rp)
                if(bprnt2)write(6,201)nchl,nchh,jl,jh,tp,tq,omp(m0)
c
  18          enddo
c
  17        enddo
            if(bprnt2)write(6,*)':'
c
          enddo
c
          if(btimet)then
            call cpu_time(timef)
            timeunit=timeunit+timef-timei
          endif
c
          deallocate (rhom,wrkp,wrkq,iwrkn,iwrkl,work,stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxbp: deallocation fails for rhom,wrk'
            nf=0
            go to 999
          endif
c
        endif
C
C-----------------------------------------------------------------------
C
        if(btimet)then
          write(iw,*)'  set-up time=',nint(timeset),'sec'
          write(iw,*)'   mixi  time=',nint(timemixi),'sec'
          write(iw,*)'   mixf  time=',nint(timemixf),'sec'
          write(iw,*)'   mixir time=',nint(timemixir),'sec'
          write(iw,*)'   mixfr time=',nint(timemixfr),'sec'
          timemix=timemixi+timemixf+timemixir+timemixfr
          write(iw,*)'  mixing time=',nint(timemix),'sec'
          write(iw,*)'  interp time=',nint(timeint),'sec'
          if(bunit2)write(iw,*)' unitary time=',nint(timeunit),'sec'
        endif
c
        if(btimex)then
          call cpu_time(timef)
          times=timef-timej
c
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'Ending proc',iam                       !par
cpar     x               ,'dwxbp symmetry',kx,':',' nchan='         !par
cpar     x               ,nchsjt,'(',nchjt,')'                      !par
cpar     x               ,'  time=',nint(times),'sec'               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Ending dwxbp symmetry ',kx,':',' nchan='
     x             ,nchsjt,'(',nchjt,')'
     x             ,'  time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C
C                                          -----------------------------
      ENDDO                                !END LOOP OVER TOTAL JP SYMMS
C                                          -----------------------------
C
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        if(btimex)then                                          !par
cpar          btimep=.false.                                        !par
cpar          call cpu_time(timef)                                  !par
cpar          times=timef-time0                                     !par
cparc                                                               !par
cpar          write(iw,*)'Ending proc',iam,' for dwxbp:'            !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar        endif                                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      ns=0                                                      !par
cpar      nr=0                                                      !par
cpar      itmp4=int(nomwrt)                                         !par
cparc                                                               !par
cpar      do m0=1,moggy                                             !par
cparc                                                               !par
cpar        call pomsend(ns,omega(1,1),nomwrt,omsend)               !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        call mpi_reduce(omsend,omrecv,itmp4,my_mpi_real,        !par
cpar     x                  mpi_sum,izero_mpi,mpi_comm_world,ier4)  !par
cparc                                                               !par
cpar        if(ier4.ne.0)write(0,*)'mpi_reduce: iam, ier=',iam,ier4 !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        if(iam.eq.0)call pomrecv(nomwrt,omrecv,nr,omega(1,1))   !par
cparc                                                               !par
cpar      enddo                                                     !par
cparc                                                               !par
cpar      if(iam.ne.0)go to 700                                     !par
cparc                                                               !par
C
C APPLY (DIPOLE) TOP-UP (OFF IF BTHRSH)
C
      IF(LRGLAM.GT.1)THEN
C
        WRITE(6,1002)LRGLAM
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,                                !par
cpar     x       'Top-up has been applied: lrglam=',lrglam          !par
cpar        else                                                    !par
          write(iw,*)'Top-up has been applied: lrglam=',lrglam
cpar        endif                                                   !par
        endif
        IF(BPRNT2)WRITE(6,716)
C
        LITLAM=LRGLAM/2                           !USE GLOBAL VALUE JA=0
        CO2S=D3QRT/LOG(EINF*DZ2)
C
        NOMT=0
        DO I=1,NMETAJ                                       !,NSPECL
c          IF(INDXJ(I).GT.0)THEN                               !NON-CORR
C
          DO J=I+ione1,NSPECJ                                !,NSPECL
c            IF(INDXJ(J).GT.0)THEN                             !NON-CORR
C
              NOMT=NOMT+1
              SS=OMGINF(NOMT)
C
              IF(SS.LT.DZERO)THEN                                !DIPOLE
                SS=SS*CO2S                     !CONVERT TO LINE STRENGTH
                DE=DSPECJ(J)-DSPECJ(I)
                DE=DE/DZ2
                DO M0=1,MENG0
                  EJ=DYY0(M0)/DZ2
                  EI=EJ+DE
C
                  CALL TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
                  if(bht)omt=omt/2             !for BHT(1970) comparison
c
                  OM=REAL(OMEGA(M0,NOMT),WP)
                  OMEGA(M0,NOMT)=OMEGA(M0,NOMT)+REAL(OMT,RP)
C
                  IF(BPRNT2)WRITE(6,717)I,J,SS,EI,EJ,DE,OM,OMT,OM+OMT
                ENDDO
              ENDIF
C
c              IF(NOMT.EQ.NOMWRT)GO TO 113                  !WE ARE DONE
c            ENDIF
          ENDDO
C
c          ENDIF
        ENDDO
C
      ELSE
C
        WRITE(6,1003)
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,'Top-up has *NOT* been applied!'!par
cpar        else                                                    !par
          write(iw,*)'Top-up has *NOT* been applied!'
cpar        endif                                                   !par
        endif
C
      ENDIF
C
c 113  CONTINUE
c
c fix top-up failure on high-e near-degenerate Born allowed transitions
c
      if(btop)then
        NOMT=0
        DO I=1,NMETAJ
          DO J=I+ione1,NSPECJ
            NOMT=NOMT+1
            OMB=OMGINF(NOMT)
            IF(OMB.GT.DZERO)THEN                                   !born
              DE=DSPECJ(J)-DSPECJ(I)
              DE=MAX(DE,D1M30)
              OM=REAL(OMEGA(2,NOMT),WP)
              DO M0=3,MENG0                        !skip threshold point
                RAT=DYY0(M0)/DE
                OM1=OM
                OM=REAL(OMEGA(M0,NOMT),WP)
                IF(RAT.GT.XBTEST.AND.OM.LT.D0PT8*OM1.AND.OM1.LT.OMB)THEN
                  MM=M0-1              !max(2,m0-1) if no threshold skip
                  GO TO 196
                ENDIF
              ENDDO
              M0=MENG0
              MM=M0+1
              IF(OM1.GE.OMB)THEN
                IF(OM.LT.OMB)MM=MENG0
              ELSE
                IF(OM.LT.OM1)MM=MENG0
              ENDIF
  196         IF(BPRNT2.AND.MM.LE.MENG0)THEN
                WRITE(6,762)I,J,DYY0(M0),DE,RAT,
     X                        (OMEGA(M,NOMT),M=1,MENG0),OMB
              ENDIF
              DO M0=MM,MENG0
                OMEGA(M0,NOMT)=REAL(OMB,RP)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      endif
c                                                                     !x
c test convert to cross section                                       !x
c                                                                     !x
c      nomt=0                                                         !x
c      do i=1,nmetaj                                                  !x
c        j=indxj(i)                                                   !x
c        wi=jn(j)+1                                                   !x
c        do j=i+ione1,nspecj                                          !x
c          nomt=nomt+1                                                !x
c          de=dspecj(j)-dspecj(i)                                     !x
c          do m0=1,moggy                                              !x
c            ej=dyy0(m0)                                              !x
c            ei=ej+de                                                 !x
c            if(brel)ei=ei+dalf4*ei*ei          !wavenumber           !x
c            om=real(omega(m0,nomt),wp)                               !x
c            om=xconv*om/(ei*wi)                                      !x
c            omega(m0,nomt)=real(om,rp)                               !x
c          enddo                                                      !x
c        enddo                                                        !x
c      enddo                                                          !x
C
C-----------------------------------------------------------------------
C
C WRITE TOTALS
C
      IF(BTHRSH)THEN
        WRITE(6,1001)
        IF(BPRNT0)THEN
          WRITE(6,1118)((I,J,J=I+ione1,NSPECJ),I=1,NMETAJ)      !ROWWISE
          DO M0=1,MOGGY
            WRITE(6,200)REAL(M0-1+LVMIN),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ELSE
        WRITE(6,1000)
        IF(BPRNT0)THEN
          WRITE(6,1117)((I,J,J=I+ione1,NSPECJ),I=1,NMETAJ)      !ROWWISE
          DO M0=1,MENG0                                         !=MOGGY
            WRITE(6,200)DYY0(M0),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ENDIF
C
      IF(IUNIT(IU).GT.0)THEN
c        if(iunit(iuls).lt.0)then                     !same status as IU
        OPEN(IULS,FILE='OMGINFLS',STATUS='OLD')
        CLOSE(IULS,STATUS='DELETE')                             !tidy-up
        IUNIT(IULS)=-1
c        endif
        CLOSE(IU,STATUS='DELETE')
        IF(BTHRSH.or..not.bomega)THEN
          IUNIT(IU)=-1
        ELSE
          OPEN(IU,FILE='OMEGAIC',STATUS='REPLACE')  !OPEN UNDER NEW NAME
CTBD        OPEN(IU,FILE='OMEGAUIC',STATUS='REPLACE',FORM='UNFORMATTED')
          WRITE(IU,*)NZION,MION
          WRITE(IU,*)NSPECJ,-(MENG0+1),NOMWRT      !FLAG NO E'S .LT.0
          WRITE(IU,*)('  0',IWRK3(I),I=1,NSPECJ)
          WRITE(IU,711)(DWRK(I),I=1,NSPECJ)
          DO M0=1,MENG0                                          !=MOGGY
            WRITE(IU,713)DYY0(M0)/DZ2,(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
          WRITE(IU,713)EINF,(OMGINF(N),N=1,NOMWRT)
          IUNIT(IU)=-1
          CLOSE(IU)
        ENDIF
      ENDIF
C
C OVERWRITE PWB ADF04 WITH DW, TAKING ACCOUNT OF THE FACT THAT THE PWB
C DOES NOT CONTAIN (SPIN) FORBIDDEN TRANSITIONS
C
      IF(IUNIT(IUU).GE.0)THEN           !NO ADF04, LIKELY SINCE RAD='NO'
        WRITE(6,*)'NO ADF04 FILE="adf04ic"...'
        WRITE(0,*)'NO ADF04 FILE ON UNIT=',IUU
C        NF=-1
        GO TO 700
      ELSEIF(IUNIT(IUU).LT.0)THEN
        IUNIT(IUU)=1
        OPEN(IUU,FILE='adf04ic',STATUS='OLD',ERR=700)
      ENDIF
C
      BEXP=.FALSE.                              !*MUST* SYNC WITH DIAGFS
      IF(NSPECJ.LT.1000)THEN
        i1=0
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
            F767='(18X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
            F767='(16X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2)/(18X,20(1PE10.2)))'
            F762='(2I4,21(1PE10.2)/(18X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3)/(16X, 20(A5, A3)))'
            F762='(2I4, 21(A5, A3)/(16X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ELSE
        i1=1
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
            F767='(20X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
            F767='(18X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2)/(20X,20(1PE10.2)))'
            F762='(2I5,21(1PE10.2)/(20X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3)/(18X, 20(A5, A3)))'
            F762='(2I5, 21(A5, A3)/(18X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ENDIF
C
      MSC0=80
      OPEN(MSC0,STATUS='SCRATCH',FORM='FORMATTED')
      IF(.NOT.BEXP)THEN
        MSCP=81
        OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
      ENDIF
C
      DO N=1,NSPECJ+2
        READ(IUU,760)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
      NNN=max(NOMWRT,nomwr0)
C
      DO N=1,NNN+2
        READ(IUU,760,END=115)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
 115  REWIND(IUU)
      REWIND(MSC0)
C
      DO N=1,NSPECJ+2
        READ(MSC0,760)CARD
        WRITE(IUU,760)CARD
      ENDDO
C
      IF(BTHRSH)THEN
        ITYPE=6
        WRITE(IUU,F767)(PSHFT0(M-1+LVMIN),M=1,MOGGY)
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(REAL(M-1+LVMIN),M=1,MOGGY)
        ELSE
          WRITE(MSCP,764)(REAL(M-1+LVMIN),M=1,MOGGY)
        ENDIF
      ELSE
        ITYPE=5
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(DYY0(M),M=1,MENG0)   !=MOGGY
        ELSE
          WRITE(MSCP,764)(DYY0(M),M=1,MENG0)                     !=MOGGY
        ENDIF
      ENDIF
C
      IF(BEXP)THEN
        READ(MSC0,F761)
      ELSE
        BACKSPACE(MSCP)
        READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
        iexp(0)='   '
        READ(MSC0,F761)XMANT(0)                                !,IEXP(0)
        WRITE(IUU,F761)XMANT(0),IEXP(0),ITYPE
     X               ,(XMANT(M),IEXP(M),M=1,MOGGY)
      ENDIF
C
      MENG1=MOGGY+1
      IB0=1
      JB0=IB0+IONE1
c
      ntr=0
C
      DO N=1,NNN+1
C
        IF(BEXP)THEN
          READ(MSC0,F762)JB,IB,XB0,(DUM,I=1,MXNXB),XB1
        ELSE
          READ(MSC0,F762)JB,IB,XMANT0,IEXP0,
     X             (XMANT(I),IEXP(I),I=1,MXNXB),XMANT1,IEXP1
        ENDIF
C
        JB1=JB
        IF(JB.LT.0)THEN
          JB1=NSPECJ
          IB=MIN(JB1-IONE1,NMETAJ)
          IF(BEXP)THEN
            XB0=D1M30
            XB1=DZERO
          ELSE
            XMANT0=' 1.00'
            IEXP0='-30'
            XMANT1=' 0.00'
            IEXP1='+00'
          ENDIF
        ENDIF
C
        IF(BEXP)THEN
          X0=D1M30
          X1=DZERO
        ELSE
          XMANT(0)=' 1.00'
          IEXP(0)='-30'
          XMANT(MENG1)=' 0.00'
          IEXP(MENG1)='+00'
        ENDIF
C
        DO JT=JB0,JB1
          IF(JT.EQ.JB1)THEN
            IB1=IB
          ELSE
            IB1=MIN(JT-IONE1,NMETAJ)
          ENDIF
          DO IT=IB0,IB1
C
ctest        if(ione1.eq.0.or.it.ne.jt)then   !catch ione1=0 diagfs only
            ntr=ntr+1
c
            NOMT=IROW(IT,JT,IONE1,NSPECJ)
C                                            !TEST MENG0 STILL IF BTHRSH
            IF(OMEGA(MENG0,NOMT).GT.TOLO)THEN          !SKIP SA-SAP.GT.1
c
c              if(omginf(nomt).lt.dzero)then  !test write reduced dipole
c                do m=1,moggy
c                  de=log(dyy0(m)+2.7183)
c                  omega(m,nomt)=omega(m,nomt)/de
c                enddo
c              endif
C
              IF(BEXP)THEN
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  X0=XB0
                  X1=XB1
                ENDIF
                WRITE(IUU,F762)JT,IT,X0,(OMEGA(M,NOMT),M=1,MOGGY),X1
              ELSE
                BACKSPACE(MSCP)
                WRITE(MSCP,764)(OMEGA(M,NOMT),M=1,MOGGY)
                BACKSPACE(MSCP)
                READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  XMANT(0)=XMANT0
                  IEXP(0)=IEXP0
                  XMANT(MENG1)=XMANT1
                  IEXP(MENG1)=IEXP1
                ENDIF
                WRITE(IUU,F762)JT,IT,(XMANT(M),IEXP(M),M=0,MENG1)
              ENDIF
C
            ENDIF
ctest        endif
          ENDDO
          IB0=1
        ENDDO
C
        IF(JB.LT.0)then
          if(ntr.ne.nomwrt)then                                !checksum
            write(6,*)'adf04 no. of transitions mis-match: ntr,nomwrt='
     x                ,ntr,nomwrt
            write(0,*)'adf04 no. of transitions mis-match'
            nf=-1
            go to 700
          endif
          GO TO 120
        endif
C
        JB0=JB
        IB0=IB+1
C
      ENDDO
C
      WRITE(0,*)'SR.DWXBP: HAVE NOT REACHED END OF adf04ic...'
      WRITE(6,*)'SR.DWXBP: HAVE NOT REACHED END OF adf04ic...'
      NF=-1
      GO TO 700
C
  120 WRITE(IUU,F762)-1
      WRITE(IUU,F762)-1,-1
c
        if(.not.badas)then                           !adas skip comments
      WRITE(IUU,758)
C
      NREC=1
  121 NREC=NREC+1
      BACKSPACE(5)
      BACKSPACE(5)
      READ(5,766)CARD4
      IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
      REWIND(5)
C
      DO N=1,NREC
        READ(5,760)CARD
        WRITE(IUU,759)CARD
      ENDDO
      DATE='        '
      CALL DATE_AND_TIME(DATE)
      WRITE(IUU,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X             ,DATE(3:3),DATE(4:4)
        endif
C
      IUNIT(IUU)=-1
      CLOSE(IUU)
C
      CLOSE(MSC0)
      IF(.NOT.BEXP)CLOSE(MSCP)
C
C-----------------------------------------------------------------------
C
  700 CONTINUE
C
      DEALLOCATE (KACT,KTMP,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 999
      ENDIF
C
  800 CONTINUE
C
      DEALLOCATE (RHO1,RHO2,TEMP,OMGINF,OMEGA,STAT=IERR)
cparc                                                               !par
cpar      deallocate (omsend,omrecv,stat=ierr)                      !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 999
      ENDIF
C
  900 DEALLOCATE (TFU,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 999
      ENDIF
C
  998 CONTINUE
C
      DEALLOCATE (NADRUG,NTGJ)
      DEALLOCATE (TMP,OMP)
      DEALLOCATE (IEXP,XMANT)
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
  999 CONTINUE
C
C-----------------------------------------------------------------------
C
      if(btimep)then
        call cpu_time(timef)
        times=timef-time0
c
C        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for dwxbp:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending dwxbp: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
C        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C
  200 FORMAT(F21.3,2X,1P,10(E11.3)/(23X,10(E11.3)))
  201 FORMAT(2I6,3X,2I5,2X,1P,10(E11.3)/(27X,10(E11.3)))
  202 FORMAT(2I6,3X,2I5,2X,1PE11.3,10X,'E(',I2,')   ',A11)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  716 FORMAT(3X,'CH',2X,'CHP',9X,'S',14X,'EI',10X,'EJ',10X,'DE',
     X9X,'OMEGA(PAR)',2X,'OMEGA(TOP)',4X,'OMEGA(TOT)')
  717 FORMAT(2I5,3X,1PE11.3,2X,0P,3F12.4,5X,2F12.4,2X,F12.4)
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  762 FORMAT(2I5,22(1PE10.2))
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE DISTORTED-WAVE'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  995 FORMAT(1X,3I10,13X,I7,3I5,F19.8)
  996 FORMAT(10X,'K',8X,'LV',8X,' T',17X,'2*S+1  L   2J   CF',9X,
     X      '(EK-E1)/RY',15X,'NMETAJ=',I5)
  997 FORMAT(//' *** FULLY UNITARIZED K- TO T-MATRIX CONVERSION ***'//)
 1000 FORMAT(///1X,136('-')//51X,
     X       '*** TOTAL COLLISION STRENGTHS (BP) ***'//1X,136('-')//)
 1001 FORMAT(///1X,136('-')//45X,
     X       '*** THRESHOLD PARTIAL COLLISION STRENGTHS (BP) ***'//
     X      1X,136('-')//)
 1002 FORMAT(//' *** TOP-UP HAS BEEN APPLIED: LRGLAM=',I5//)
 1003 FORMAT(//' *** TOP-UP HAS *NOT* BEEN APPLIED ***'//)
 1110 FORMAT(//1X,136('-')///
     X   49X,'*** TARGET ENERGIES (IC) ***'/)
 1111 FORMAT(//1X,136('-')/)
 1112 FORMAT(' SYJ=',I3,5X,'2J P =',I4,I3,5X,'NCHJT=',I6,2X,'(',I6,')')
 1113 FORMAT(//' SY1=',I3,5X,'(2S+1) L P =',I3,I4,I3)    !/1X,34('-'))
 1114 FORMAT(//' SYJ=',I3,5X,'2J P =',I4,I3/1X,25('-'))
 1115 FORMAT(//' SY2=',I3,5X,'(2S+1) L P =',I3,I4,I3)    !/1X,34('-'))
 1116 FORMAT(/4X,'CH',3X,'CHP',7X,'K',3X,'KP',4X,'OMEGA(IE=1,MENG):')
 1117 FORMAT(74X,'OMEGA(K-KP)'/74X,11('-')/2X,'*FINAL* ENERGY(RYD)'
     X      ,2X,10(I5,'-',I5)/(23X,10(I5,'-',I5)))
 1118 FORMAT(74X,'OMEGA(K-KP)'/74X,11('-')/1X,'*FINAL* RYDBERG A.M.'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1150 FORMAT(/'    NCYC SY   CH  CHP     MNF  MNR',6(3X,'I(R)  F(A,...)'
     X))
 1201 format(i9,i5,2i4,2i5,i9,i6,6(i6,f9.4))
 1202 format(i9,i5,2i4,2i5,i9,i6,6(i6,f9.4)/(47x,6(i6,f9.4)))
 1996 FORMAT(/' *** UPDATING SLATER INTEGRALS FOR LTOT=',
     X       I3/1X,42('-')/)
 1997 FORMAT(/' *** UPDATING MAGNETIC INTEGRALS FOR 2*JTOT=',
     X       I3/1X,46('-')/)
 3050 FORMAT(7X,'NP',2X,'SYJ',2X,'SY',1X,'SYP',3X,'CH',2X,'CHP',7X,
     X'CN',3X,'IND',6(3X,'I(Y)  X(A-D)'))
 9119 format(i8,i3, 2i5, i8,i5, 6(i6,f11.6))
 9120 format(i8,i3, 2i5, i8,i5, 6(i6,f11.6)/(34x,6(i6,f11.6)))
 9121 format((34x,6(i6,f11.6)))
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION ICOL(ILI,ILF,IONE1)
C
      ICOL=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      END FUNCTION ICOL
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DWXBP_DAXPY
C
C                             *******************
C
      SUBROUTINE DWXBP_DDOT
     X                (FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8
     X                ,DNLX,MDIM9,MDIM10)
C
C-----------------------------------------------------------------------
C
C  SR.DWXBP CALCULATES EIE BP (+2FS) COLLISION STRENGTHS IN JK-COUPLING
C
C  IT CALLS:
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.FSINTX
C    FN:NCHAJK
C    SR.PQ
C    SR.PQLAP
C    FN.QPTLS
C    FN.QPTLSJ
C    SR.RADCNX
C    FN.SJS
C    SR.SLATRX
C    SR.TOP1
C    SR.TOP2
C    FN.XINT
C
C  IT CONTAINS:
C    FN.ICOL
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,comm_barrier               !par
cpar      use mpi, only : mpi_real4,mpi_real8,mpi_integer           !par
cpar     x               ,mpi_sum,mpi_comm_world                    !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: DSS,MSS,QSS,NADR
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
c      use common_nrbiad, only: iadj
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
C
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXD13=500)
      PARAMETER (MXD14=100)
C
      PARAMETER (MXNXB=10)    !NO. OF BPW X-VALUES PRE-EXISTING IN ADF04
C
      PARAMETER (D0PT8=0.8D0)
C
      INTEGER(SP) QPTLS,QPTLSJ                 !DO NOT USE SHORT INTEGER
C
      INTEGER(SP) SA,SAP
cparc                                                               !par
cpar      integer(kind(mpi_integer))itmp4,ier4,izero_mpi,my_mpi_real!par
cpar      parameter (izero_mpi=0)                                   !par
cparc                                                               !par
cpar      real(rp) omsend,omrecv                                    !par
C
      REAL(RP) OMEGA,E1M30
      PARAMETER (E1M30=1.E-30)
      PARAMETER (XBTEST=DFIVE)          !APPLY btop ONLY FOR X.GT.XBTEST
C
      CHARACTER(LEN=3) IEXP,IEXP0,IEXP1
      CHARACTER(LEN=4) CARD4
      CHARACTER(LEN=5) XMANT,XMANT0,XMANT1
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=15) F767
      CHARACTER(LEN=35) F762
      CHARACTER(LEN=44) F761
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: RHO1(:,:),RHO2(:,:),OMEGA(:,:),TFU(:)
     X              ,TEMP(:,:),OMGINF(:),KACT(:,:),KTMP(:)
cpar      allocatable :: omsend(:),omrecv(:)                        !par
c
      allocatable :: rhom(:,:),wrkp(:),wrkq(:),iwrkn(:),iwrkl(:)
     x              ,work(:)
C
      ALLOCATABLE :: IEXP(:),XMANT(:)
      ALLOCATABLE :: NADRUG(:),NTGJ(:),TMP(:,:),OMP(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
     X         ,DNLX(MDIM10,MDIM9)
C
      DIMENSION QPX(0:MDIM5),QPX0(0:MDIM5),QPOSJ(MAXGR),DFS(MXDFS)
      DIMENSION PSHFT0(0:20)
c
      dimension bswap(mxd13),bswapj(mxd13)
      dimension ntest(1,1)                   !check channel set-up
C
      COMMON /BASIC/NF,NCHSJ,MGAP(10)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
c      COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)     !target
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C      COMMON /WORKJ/DWRK(MAXLV),IWRK3(MAXLV),IWRK4(MAXLV)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
c      common /nrbrel/irel,kappa,igagr,irtard,ibreit,brel,bjumpr,bmvd !x
c
      common /hps/badas
C
      DATA JOLD/-2/,LOLD/-1/,IU/24/,IUU/26/,IULS/23/
c                          omginfic adf04ic
C
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DWXBP_DDOT
c      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
C-----------------------------------------------------------------------
C
c some cross section units options: need to uncomment code above and  !x
c below labeled "!x"                                                  !x
c                                                                     !x
c      xconv=done                   !pi*a_0^2                         !x
c      xconv=xconv*acos(-done)      !a_0^2                            !x
c      xconv=xconv*28.003d0         !Mbarns                           !x
c      xconv=xconv*1.d6             !barns                            !x
c
c flag write of "OMEGA" file - this is by final scattered energy and so
c *not* directly usable by R-matrix utility codes such as xtrct/adasexj.
c this is somewhat historic as adasexj *does* read/process dw adf04 file
c
      bomega=.false.
c
c elastic switch (normally ione1=1, no elastic. ione1=0 inc elastic)
c now set by user in algeb, and passed thru /nrbdwm/ as needed.
c
cold  ione1=1
c
c test: DO NOT CHANGE!
cold  ione0=0                !algxls/fs ione1, elastic needed for mixing
c
c some test set-up switches that user joe should not need to touch.
c
      bht=.false.                  !.true. for bht(1970) test comparison
c
c set (approx) unitarity switch
c
      bunit=.true.
      if(bht)bunit=.false.
c
c set approximation-ii unitarization switch - needs the full rho-matrix
c (.and.. not.bthrsh, i.e. lvmax.lt.0) only coded for F95.
c currently, in principle, only for use at medium to high energies
c since it still works with the final scattered energy, but seems to
c work well down to low-e as well - strongest coupling with nearby
c states, i.e. ones calculated at the same/similar relative energy.
c
      bunit2=nmetaj.ge.nspecj.and.ione1.eq.0.and.lvmax.lt.0
c
c set print of approx r(tau=0)-matrix as opposed to rho(tau)-matrix
c *MUST* use full T=-2iR/(1-iR) if converting via R-matrix.   (not done)
c can only use weak coupling T=-2i*rho for rho-matrix -see bunit2 above.
c
      brmx=.false.
      if(jprint.eq.4)brmx=.true.
c
c set mixing switch, can test interpolation followed by mixing (false).
c
      bmix=xmix.ge.dzero                !default xmix->.true.
      xmix=abs(xmix)
c
c flag effect of missing phase shifts.
c
      if(kutssx.eq.-1)then
        if(ione1.eq.0)write(6,1120)
        if(brmx)write(6,1121)
        if(bunit2)write(6,1122)
      endif
 1120 format(//'Note: Elastic collision strengths maybe somewhat'
     x,' inaccurate as not all phases are present...'/'In-elastic'
     x,' collision strengths are unaffected'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
 1121 format(//'Note: R-matrix elements maybe somewhat inaccurate'
     x,' as not all phases are present...'/'rho-matrix and partial'
     x,' collision strengths are unaffected'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
 1122 format(//'Note: elastic transitions maybe somewhat inaccurate'
     x,' as not all phases are present...'/'Inelastic partial collision'
     x,' strengths maybe affected indirectly'//'Set kutssx.ne.-1 and'
     x,' maxjfs=-1 to correct this - if memory allows')
c
c checks channel set-up (needs ntest dimensione1d)
c
      bntest=.false.                    !ione1.eq.0.and.jprint.ge.2
c
      bntest=bntest.and.nmetaj.ge.nspecj
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD/J(NCOR/J)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
cparc                                                               !par
cpar      if(rp.eq.4)then                                           !par
cpar        my_mpi_real=mpi_real4                                   !par
cpar      elseif(rp.eq.8)then                                       !par
cpar        my_mpi_real=mpi_real8                                   !par
cpar      else                                                      !par
cpar        if(iam.eq.0)write(iw,*)'error rp precsion =',rp         !par
cpar        go to 999                                               !par
cpar      endif                                                     !par
C
C-----------------------------------------------------------------------
c
      btimep=btimex                                        !for iam.ne.0
      if(btimex)then
c        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for dwxbp'           !par
cpar        else                                                    !par
          write(iw,*)'Starting dwxbp'
cpar        endif                                                   !par
c        endif
        call cpu_time(timei)
        time0=timei
      endif
      btimet=btimex  !.false.                             !debug timings
C
C INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TPI=DTWO*PI
C
      DFS(1)=1
      DFS(2)=1
      DO I=3,MXDFS,2
        DFS(I)=-DFS(I-2)
        DFS(I+1)=(I-1)*DFS(I-1)/32
      ENDDO
C
      NZA2=MAX(NZION-MION,IONE)
      NZA2=NZA2*NZA2
      TOLO=E1M10/NZA2
C
      BPRNT2=JPRINT.GE.2                    !FOR DETAILED OMEGA PRINTOUT
      BPRNT3=JPRINT.GE.3                      !FOR DETAILED RHO PRINTOUT
      BPRNT0=JPRINT.NE.-3
C
      KOLDOO=KUTOOX
      BKUTOO=KUTOOX.NE.0
C
      BKUTSS=KUTSSX.NE.-1
C
CL      LAPAK=1                                                  !LAPACK
C
      IF(NZION.EQ.MION)THEN
        NZA=0
        DZ2=DONE
      ELSE
        NZA=NZION-MION
        DZ2=NZA*NZA
      ENDIF
C
      IF(MAXJT.GE.0)THEN
        IF(LRGLAM.GT.MAXJT)THEN
          WRITE(0,*)'*** SR.DWXBP: LRGLAM.GT.MAXJT, SO NO TOP-UP'
          LRGLAM=-1
        ELSE
          IF(LRGLAM.EQ.-999)LRGLAM=MAXJT
        ENDIF
        IF(LRGLAM.EQ.0)LRGLAM=-1
      ENDIF
C
      IF(LRGLAM.GT.1)THEN        !SET L WHERE DIPOLE TOP-UP NEEDS CHECKS
        LRGLMN=LRGLAM-2*(QCL0+QCS0)
      ELSE
        LRGLMN=1000
      ENDIF
c
      btop=btop.and.lrglam.ge.0
c
      jktest=2*maxlx+QCS0+1                           !max J for K.ne.K'
C
      MPOSC=MXORB+(LCONDWJ-1)/2-(LCONDW-1)/2               !BUFFER SPACE
C
C SMALL LOCAL MEMORY
C
      MXD4=MAX(MENG,10_SP)+3
      ALLOCATE (IEXP(0:MXD4),XMANT(0:MXD4))
      ALLOCATE (TMP(MENG,MENG),OMP(MENG))
      ALLOCATE (NADRUG(NJO),NTGJ(NJO))
C
C SET POINTER TO START OF GROUP IN MIXING COEFFICIENT ARRAY TFU,
C AND FOR MAPPING TERMS OF A J-GROUP TO ABSOLUTE LEVEL INDEX.
C
      MC=0
      NCMX=0
      NSUM=0
      DO N=1,NJO
        NADRUG(N)=MC
        NTGJ(N)=NSUM
        NC=NT(N)
        NCMX=MAX(NCMX,NC)
        MC=MC+NC*NC
        NSUM=NSUM+NC
      ENDDO
C
C RECOVER TARGET MIXING COEFFICIENTS
C
      READ(MR)NCTOT
C
      if(nctot.ne.mc)stop 'dwxbp:nctot index error'    !shouldn't happen
C
      ALLOCATE (TFU(NCTOT),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 998
      ENDIF
C
      READ(MR)(TFU(I),I=1,NCTOT)
C
C LOOK FOR LAST SPECTROSCOPIC ENERGY
C
c      NSPECL=0
c      DO N=1,NENERJ
c        NSPECL=MAX(NSPECL,JNDXJ(N))
c      ENDDO
C
C USE ROWWISE TO SIMPLY REDUCE NDIM2 IF NMETAJ.LT.NSPECJ
C
      NOMTG=NCMX*NCMX                               !NEED ALL FOR MIXING
      nmin=min(NMETAJ,NSPECJ)
      NOMWRT=IROW(nmin,NSPECJ,ione1,NSPECJ)                     !ROWWISE
      NOMWR0=NOMWRT
c
ctest    if(ione1.eq.1)nomwr0=nomwr0+nmin      !incase ione1=0 in diagfs
C
C
      BTHRSH=LVMAX.GE.0
      IF(BTHRSH)THEN
        MOGGY=LVMAX+1-LVMIN
      ELSE
        MOGGY=MENG0
      ENDIF
C
      MX=MTRAN
      if(.not.bmix)mx=meng0
C
      ALLOCATE (RHO1(NOMTG,MX),RHO2(MTRAN,NOMTG),TEMP(NCMX,MX)
     X         ,OMGINF(NOMWR0),OMEGA(MOGGY,NOMWRT),STAT=IERR)
cparc                                                               !par
cpar      allocate (omsend(nomwrt),omrecv(nomwrt),stat=ierr)        !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 900
      ENDIF
C
      DO N=1,NOMWRT
        OMGINF(N)=DZERO
        DO M=1,MOGGY
          OMEGA(M,N)=0
        ENDDO
      ENDDO
C
C RECOVER INFINITE ENERGY INFO (ROWWISE)
C
      IF(IUNIT(IU).EQ.0)THEN                   !ADF04 WILL BE INCOMPLETE
        WRITE(6,*)'NO INFINITE ENERGY FILE="OMGINFIC"...'
        WRITE(0,*)'NO INFINITE ENERGY FILE ON UNIT=',IU
        IF(LRGLAM.GE.0)THEN
          WRITE(6,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          WRITE(0,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          NF=-1
          GO TO 800
        ELSE
          GO TO 110
        ENDIF
      ELSEIF(IUNIT(IU).LT.0)THEN
        OPEN(IU,FILE='OMGINFIC',STATUS='OLD',ERR=110)
        IUNIT(IU)=1
      ELSE                               !SERIAL SHOULD NOT BE HERE
        REWIND(IU)                       !BUT PAR ALREADY OPEN
cpar        if(iam.eq.0)then                                        !par
        stop 'dwxbp: omginfbp confusion'
cpar        endif                                                   !par
      ENDIF
C
      READ(IU,*)NZDUM,MDUM
      READ(IU,*)NSPEC0,MENGB,NOMWR0
C
      IF(NSPEC0.NE.NSPECJ)THEN                   !SHOULD NOT HAPPEN, NOW
        WRITE(6,*)'DWXBP: INFINITE ENERGY TARGET MISMATCH',NSPEC0,NSPECJ
        WRITE(0,*)'DWXBP: INFINITE ENERGY TARGET MISMATCH'
        NF=-1
        GO TO 800
      ENDIF
C
      ALLOCATE (DWRK(NSPEC0),IWRK3(NSPEC0),IWRK4(NSPEC0))
C
      READ(IU,*)(IDUM0,IWRK3(I),I=1,NSPEC0)
      READ(IU,711)(DWRK(I),I=1,NSPEC0)
C
c optionally recover spec energy subset from omginf,
c and retain full-set in denerg back above.
c
c      do i=1,nspec0
c        dwrk0(i)=dwrk0(i)*dz2
c      enddo
c
      iflag=0
      if(nomwrt.ne.nomwr0)then       !should not happen in non-test mode
        if(ione1.eq.0)then                             !elastic in dwxjk
          if(nomwrt-nmin.ne.nomwr0)then
            write(6,*)'dwxbp: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxbp: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=1 in diagfs
            iflag=1
          endif
        else                                         !inelastic in dwxjk
          if(nomwrt+nmin.ne.nomwr0)then
            write(6,*)'dwxbp: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxbp: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=0 in diagfs
            iflag=2
          endif
        endif
      endif
C
      READ(IU,713)EINF,(OMGINF(I),I=1,NOMWR0)
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        IUNIT(IULS)=-1                                          !par
cpar        CLOSE(IULS)                                             !par
cpar        IUNIT(IU)=-1                                            !par
cpar        CLOSE(IU)                                               !par
cpar      endif                                                     !par
c
      if(iflag.eq.1)then                          !make room for elastic
        n=nomwrt+1
        nshft=nmin
        do i=nmin,1,-1
          do j=nspec0,i+1,-1
            n=n-1
            omginf(n)=omginf(n-nshft)
          enddo
          n=n-1
          omginf(n)=done                             !flag poss. allowed
          nshft=nshft-1
        enddo
        if(n.ne.1)stop 'iflag=1 nshft error'
      elseif(iflag.eq.2)then                               !drop elastic
        n=0
        nshft=1
        do i=1,nmin
          do j=i+1,nspec0
            n=n+1
            omginf(n)=omginf(n+nshft)
          enddo
          nshft=nshft+1
        enddo
        if(n.ne.nomwrt)stop 'iflag=2 nshft error'
      endif
c
C
  110 CONTINUE
C
C WRITE-OUT SPEC. TARGET ENERGIES
C
      im=-1
      if(nmetag(0).ne.0)im=1
c
      WRITE(6,1110)
      WRITE(6,996)NMETAJ*im
C
      DO J=1,NSPECJ
        I=INDXJ(J)
        M1=NRR(I)
        II=NFQ(M1)
        IP=(1-QPI(II))*(QSI(II)+1)
        WRITE(6,995)J,I,M1,IP,QLI(II)/2,JN(I),NFK(M1),DSPECJ(J)
      ENDDO
C
      WRITE(6,1111)
C
C FLAG ACTIVE ORBITAL PAIR IN INTERACTING CONFIGS C.F. SR.ALGX BXIST0
C
      ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: ALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 800
      ENDIF
C
      DO KF=1,KMAX
        DO KG=1,KF
          KACT(KF,KG)=0
          KACT(KG,KF)=0
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)GO TO 52
            KACT(KF,KG)=QCG(I,KF)
            KACT(KG,KF)=KTMP(L0)
  51      ENDDO
  52    ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C BEGIN LOOP OVER Jp SCATTERING SYMMETRIES
C
C-----------------------------------------------------------------------
c
      if(bunit2)write(6,997)
      iwait=0
      wait=done
C
      DO KX=1,INASTJ
C
        MTJ=JPI(KX)/10
        MTP=JPI(KX)-MTJ*10
        MTP=MTP+MTP
C
C SEE IF WE NEED TO UPDATE INTEGRALS & CONTINUUM BASIS
C
        JNEW=MTJ
C
        IF(JNEW.NE.JOLD)THEN
C
C-----------------------------------------------------------------------
C
          if(btimex)then
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                 ,'updating continuum for 2j=',mtj        !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)
     x        'Begin update of continuum basis & integrals for 2J=',MTJ
cpar            endif                                               !par
c
            call cpu_time(timei)
            times=timei
          endif
C
C-----------------------------------------------------------------------
C
          jstep=jnew-jold
          if(jstep.gt.2.and.jfact.gt.200.and.jold.gt.0)then
            if(iwait.eq.2)then
              iwait=1
            else
              iwait=2
            endif
            wait=iwait*jstep
            wait=wait/dthree
          endif
C
C UPDATE CONTINUUM BASIS
C
C  NOTE: IF THE USER HAS RESTRICTED LCONDWJ THEN ANY FINE-STRUCTURE HAS
C        A TRUNCATED PARTIAL WAVE EXPANSION.
C
          IF(BKUTSS)THEN
C
            IF(BTHRSH)LCONDWJ=-LCONDWJ                        !FLAG
C
            CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3
     X                 ,JNEW/2,JOLD/2,LCONDWJ,-MXORB)
C
            IF(NF.LE.0)GO TO 700
C
            DO L=1,LCONDWJ
              QPOSJ(L)=QPOS(L)
            ENDDO
C
          ENDIF
C
C UPDATE FINE-STRUCTURE
C
          IF(JNEW.LE.MAXJFS)THEN
C
C UPDATE EXCHANGE MULTIPOLE
C
            JDIFF=JNEW
            IF(JOLD.GE.0)JDIFF=JDIFF-JOLD
            jdiff=2*(jdiff/2)
C
            DO L=1,NL000
              IF(QSS(1,L).GT.MXORB.AND.QSS(3,L).GT.MXORB
     X       .OR.QSS(2,L).GT.MXORB.AND.QSS(4,L).GT.MXORB)THEN
              ELSE
                QSS(5,L)=QSS(5,L)+JDIFF                    !EXCHANGE
              ENDIF
            ENDDO
C
C UPDATE FINE-STRUCTURE INTEGRALS
C
            IF(BPRNT0)WRITE(6,1997)JNEW
C
            DO M=1,MTRAN
              M1=MNDEX(M,1)
              M2=MNDEX(M,2)
              CALL FSINTX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DNLX(1,M)
     X                   ,M1,M2,JNEW,MXORB)
            ENDDO

          ENDIF
C
C PREPARE TO UPDATE NON-FINE-STRUCTURE INTEGRALS:
C   SET POINTERS FOR INTEGRAL STORAGE FOR MULTIPLE LTOT
C
          IF(JOLD.LT.0)THEN                               !FIRST TIME
            DO L=0,QCS0+1
              QPX(L)=L+1
            ENDDO
          ELSE
            DO L=0,QCS0+1
              QPX0(L)=QPX(L)
              QPX(L)=0
            ENDDO
            L00=(JOLD-QCS0-1)/2
            K0=(JNEW-JOLD)/2
            DO L=0,QCS0+1
              L0=L00+L
              IF(2*L0.GE.(JNEW-QCS0-1).AND.
     X           2*L0.LE.(JNEW+QCS0+1))THEN               !RE-USE
                K=L-K0
                QPX(K)=-QPX0(L)                           !FLAG OLD
              ELSE
                QPX0(L)=-QPX0(L)                          !NOT WANTED
              ENDIF
            ENDDO
          ENDIF
C
          DO L=0,QCS0+1
            IF(QPX(L).EQ.0)THEN                           !NEW
              DO K=0,QCS0+1                              !LOOK FOR SPACE
                IF(QPX0(K).LT.0)THEN
                  QPX(L)=-QPX0(K)
                  QPX0(K)=0
                  GO TO 150
                ENDIF
              ENDDO
              WRITE(6,*)' SR.DWXBP: QPX INDEX ERROR...'
              WRITE(0,*)' SR.DWXBP: QPX INDEX ERROR...'
              NF=-1
              GO TO 700
            ENDIF
  150       CONTINUE
c        write(0,*)l,qpx(l),qpx0(l)             !debug print
          ENDDO
C
          LPOS=(JNEW-QCS0-1)/2
C
          DO LQ=0,QCS0+1                        !do lq=QCS0+1,0,-1
C
            LNEW=LPOS+LQ
C
C
            IF(LNEW.GE.0.AND.QPX(LQ).GT.0)THEN
C
C UPDATE/RE-LABEL CONTINUUM BASIS FOR THIS LTOT
C
              IF(BKUTSS)THEN
C
C NOTE: CURRENTLY, NO NEW CONTINUUM ORBITALS ARE GENERATED HERE.
C       SO, IF THE USER HAS RESTRICTED LCONDWJ (*NOT A GOOD IDEA*)
C       THEN FLAG & DISCARD PWS.
C
                J=MPOSC-MXORB
                J=J+LNEW-JNEW/2
                MYL2=2*(LNEW-(LCONDW+1)/2)
C
                DO L=1,LCONDW
                  J=J+1
                  MYL2=MYL2+2
                  if(j.le.0.or.j.gt.lcondwj)then !user restricts lcondwj
                    QPOS(L)=0                    !flag not to calculate
                    QL(MPOSC+L)=-99              !flag non-existence
                  else
                    QPOS(L)=ABS(QPOSJ(J))
                    QL(MPOSC+L)=MYL2
                  endif
                ENDDO
C
              ELSE
C
C UPDATE CONTINUUM BASIS
C
                IF(BTHRSH)LCONDW=-LCONDW                        !FLAG
C
                CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3
     X                     ,LNEW,LOLD,LCONDW,MPOSC)
C
                IF(NF.LE.0)GO TO 700
C
              ENDIF
C
C UPDATE EXCHANGE MULTIPOLE
C
              LDIFF=LNEW
              IF(LOLD.GE.0)LDIFF=LDIFF-LOLD
              LDIFF=LDIFF+LDIFF
C
              DO I=1,IRL
                IF(QRL(2,I).GT.MXORB)QRL(5,I)=QRL(5,I)+LDIFF  !EXCHANGE
              ENDDO
C
C UPDATE SLATER INTEGRALS (INC. 2NFS IF BKUTOO=.TRUE.)
C
              IF(BKUTOO.AND.LNEW.GT.MAXLOO)THEN
                KUTOOX=0
                BKUTOO=.FALSE.
              ENDIF
C
              IF(BPRNT0)WRITE(6,1996)LNEW
              LSTORE=QPX(LQ)-1
C
              DO M=1,MTRAN
                M1=MNDEX(M,1)
                M2=MNDEX(M,2)
                IF(BKUTOO)THEN
                  CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                       ,DRLX(1,M,LSTORE)
     X                       ,DZLX(1,M,LSTORE)
     X                       ,DXTWOX(1,M,LSTORE)
     X                       ,DETAX(1,M,LSTORE)
     X                 ,M1,M2,LNEW,MAXLX,MPOSC)
                ELSE
                  CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                       ,DRLX(1,M,LSTORE)
     X                       ,DZLX(1,1,0)
     X                       ,DXTWOX(1,1,0)
     X                       ,DETAX(1,1,0)
     X                 ,M1,M2,LNEW,MAXLX,MPOSC)
                ENDIF
              ENDDO
C
              LOLD=LNEW
              KUTOOX=KOLDOO
              BKUTOO=KUTOOX.NE.0
C
            ENDIF
C
            QPX(LQ)=ABS(QPX(LQ))
C
          ENDDO
C
C RE-SET
C
          JOLD=JNEW
C
C (NOTE: MAKE SURE QL IS SYNCHRONIZED WITH LDIFF USAGE BELOW WHEN
C        TESTING WHETHER "INITIAL" & "FINAL" STATES HAVE BEEN SWAPPED
C        BY FALLING ORDER)
C
          IF(BKUTSS)THEN
            DO J=1,LCONDWJ
              QPOS(J)=QPOSJ(J)
            ENDDO
            JPOS=JNEW
          ELSE
            JPOS=LNEW+LNEW
          ENDIF
C
          MYL2=2*(JPOS/2-(LCONDWJ+1)/2)
          DO L=1,LCONDWJ
            MYL2=MYL2+2
            QL(MXORB+L)=MYL2
          ENDDO
C
C-----------------------------------------------------------------------
c
          if(btimex)then
            call cpu_time(timef)
            times=timef-times
c
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                  ,'updating continuum'                   !par
cpar     x                 ,' time=',nint(times),'sec'              !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'End update of continuum basis & integrals'
     x               ,', time=',nint(times),'sec'
cpar            endif                                               !par
          endif
C
C-----------------------------------------------------------------------
C
        ENDIF
C
C INITIALIZE FOR J-LOOP
C
        IF(BPRNT0)WRITE(6,1114)KX,MTJ,MTP/2
C
        NWTJ=MTJ+1
C                                                     WRITE CHANNEL LIST
        NCHJT=NCHAJK(KX,-IONE,-IONE,-IONE,-IONE,NTGJ,DFS)
        NCHSJT=NCHSJ
C
        IF(.NOT.BPRNT0)WRITE(6,1112)KX,MTJ,MTP/2,NCHSJT,NCHJT
c
        if(bntest)then
          do  i=1,nchjt
            do j=1,nchjt
              ntest(j,i)=0
            enddo
          enddo
        endif
c
c initialize for approximation-ii (memory hog)
c
        if(bunit2)then
c
          nx=(nchjt*(nchjt+1))/2
c
          allocate (rhom(nx,meng0),wrkp(nx),wrkq(nx),iwrkn(nchjt)
     x             ,iwrkl(nchjt),work(nchjt),stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxbp: allocation fails for rhom,wrk'
            nf=0
            go to 700
          endif
c
          do i=1,nchjt
            iwrkn(i)=-1
            iwrkl(i)=-1
          enddo
c
          do m=1,meng0
            n=0
            do i=1,nchjt
              n=n+1
              rhom(n,m)=done
              do j=i+1,nchjt
                n=n+1
                rhom(n,m)=dzero
              enddo
            enddo
          enddo
c
        endif
c
c detailed print
c
        if(jprint.ge.5)then
          write(6,1150)
          if(maxjfs.ge.0)write(6,3050)
        endif
C
        IF(BPRNT2)WRITE(6,1116)
C
C-----------------------------------------------------------------------
c
        if(btimex)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(6,*)'Starting proc',iam                       !par
cpar     x                ,'symmetry',kx,':',mtj,mtp/2              !par
cpar            call flush(6)                                       !par
cpar          else                                                  !par
          write(iw,*)'Starting dwxbp symmetry',kx,' :',mtj,mtp/2
cpar          endif                                                 !par
cparc                                                               !par
          call cpu_time(timei)
          timej=timei
        endif
c
        if(btimet)then
          timeset=dzero
          timemix=dzero
           timemixi=dzero
           timemixf=dzero
           timemixir=dzero
           timemixfr=dzero
          timeunit=dzero
          timeint=dzero
        endif
C
C-----------------------------------------------------------------------
C
        INASTX=NCHGJ(KX)                    !NO. OF LS-SYMMS FOR THIS JP
C
C BEGIN K-LOOPS
C
        KAY2=MTJ+1
        IF(MTJ.GT.0)THEN
          KAY1=MTJ-1
        ELSE
          KAY1=KAY2
        ENDIF
c
        if(mtj.le.jktest)then       !exchange present so K.ne.K' allowed
          kay1p=kay1
          kay2p=kay2
        endif
C
        DO KAYI=KAY1,KAY2,2                  !LOOP OVER INTIAL CHANNEL K
c
          if(mtj.gt.jktest)then                !no-exchange so K=K' only
            kay1p=kayi
            kay2p=kayi
          endif
C
          DO KAYF=KAY1p,KAY2p,2               !LOOP OVER FINAL CHANNEL K
C
C BEGIN TARGET JP LOOPS (CURRENTLY, WE HAVE NOT YET SELECTED SUBSET
C                        THAT CONTRIBUTE TO THE TOTAL JP SYMMETRY,
C                        SO LOOP OVER ALL AND DISCARD ON-THE-FLY.)
C
            DO JIG=1,NJO             !LOOP OVER INITIAL TARGET JP GROUPS
C
              NC=NSLJ(1,JIG)
              JIP=QPI(NC)
              JI=NTGJ(JIG)+1
              JI=JN(JI)
              SJKI=SQRT(REAL((JI+1)*(KAYI+1),WP))
              L1=ABS(KAYI-JI)
              IF(MOD(JIP+L1,IFOUR).NE.MTP)L1=L1+2
              L2=KAYI+JI
              IF(MOD(JIP+L2,IFOUR).NE.MTP)L2=L2-2
C
              NCJ0=NT(JIG)
              NCN0=NGSLJ(JIG)
c
              jf2=jig
              if(kayf.gt.kayi)jf2=jig-1
C
              DO JFG=1,jf2             !LOOP OVER FINAL TARGET JP GROUPS
C
                ND=NSLJ(1,JFG)
                JFP=QPI(ND)
                JF=NTGJ(JFG)+1
                JF=JN(JF)
                SJKF=SQRT(REAL((JF+1)*(KAYF+1),WP))
                L1P=ABS(KAYF-JF)
                IF(MOD(JFP+L1P,IFOUR).NE.MTP)L1P=L1P+2
                L2P=KAYF+JF
                IF(MOD(JFP+L2P,IFOUR).NE.MTP)L2P=L2P-2
C
                NCJP0=NT(JFG)
                NCNP0=NGSLJ(JFG)
C
c get lambda for non-dipole infnite energy top-up
c
                if(jnew.ge.lrglam)then
                  if(ji+jf.ne.0)then
                    litlam=abs(ji-jf)/2
                    if(jip.ne.jfp)then
                      if(litlam.le.1)then          !for case of octupole
                        litlam=3
               elseif(1-2*mod(abs(litlam),itwo).gt.0)then !(-1)**litlam
                        litlam=litlam+1
                      endif
                    else
                      if(litlam.eq.0)then
                        litlam=2
               elseif(1-2*mod(abs(litlam),itwo).lt.0)then !(-1)**litlam
                        litlam=litlam+1
                      endif
                    endif
                    if(litlam.gt.(ji+jf)/2)litlam=0
                  else
                    litlam=0
                  endif
                endif
c
c                beqgrpj=jig.eq.jfg                  !not currently used
C
                DO LI=L1,L2,4               !LOOP OVER INITIAL CHANNEL L
C
c set position of phase shift for this li
c only required by  elastic case for diagonal rho
c or if printing usual reactance matrix
c
                  if(ione1.eq.0.or.brmx)then
                    L=(LCONDWJ+1)/2 -JPOS/2+LI/2
c                    if(l.gt.lcondwj.or.l.lt.1)stop 'phase error'
                    l=min(l,lcondwj)   !case user has restricted lcondwj
                    l=max(l,ione)     !then we don't have all the phases
                    L0=ABS(QPOS(L))
                  endif
C
                  DO LF=L1P,L2P,4             !LOOP OVER FINAL CHANNEL L
C
c set position of phase shift for this lf
c only need if printing usual reactance matrix, not needed by rho matrix
C
                    if(brmx)then
                      L=(LCONDWJ+1)/2 -JPOS/2+LF/2
c                      if(l.gt.lcondwj.or.l.lt.1)stop 'phase error'
                      l=min(l,lcondwj) !case user has restricted lcondwj
                      l=max(l,ione)   !then we don't have all the phases
                      L00=ABS(QPOS(L))
                    endif
C
C-----------------------------------------------------------------------
C
C NOW FORM JK INTERACTION (BY TARGET SYMMETRY GROUP)
C*************************
C
C THIS IS IN THE RHO-I REPRESENTATION, WHERE
C |T^R(V,V')|=|T^RHO(V,V')| FOR CHANNELS V.NE.V'.
C WE USE T^RHO(V,V')=-2I*RHO(V,V'), WITH A 2X2 UNITARITY CONDITION.
C FOR V.EQ.V' T^R(V,V)~-2*TAN(TAU(V)), FOR RHO(V,V) SMALL.
C (IN GENERAL, WE ARE NOT INTERESTED IN ELASTIC TRANSITIONS.)
C
c
                if(btimet)call cpu_time(timei)
C
                    NOMTG=NCJ0*NCJP0
                    DO N=1,NOMTG
                      DO M=1,MTRAN
                        RHO2(M,N)=DZERO
                      ENDDO
                    ENDDO
C
                    NCI0=0
                    DO NC00=1,NCN0    !BEGIN LOOP OVER INITIAL SL GROUPS
                      NC=NSLJ(NC00,JIG)
                      MC=NSL(NC)
                      SA=QSI(NC)
                      LA=QLI(NC)
                      MCI=NGRPI(NC)
C
                      NCIP0=0
                      DO ND00=1,NCNP0   !BEGIN LOOP OVER FINAL SL GROUPS
                        ND=NSLJ(ND00,JFG)
                        MCP=NSL(ND)
                        SAP=QSI(ND)
c                        IF(ABS(SA-SAP).GT.2)GO TO 68   !unnecessary...
                        IF(NMETAG(NC)+NMETAG(ND).EQ.2)GO TO 68
                        LAP=QLI(ND)
                        MCIP=NGRPI(ND)
C
                        DO IXX=1,INASTX      !LOOP OVER INITIAL LS SYMMS
C
                          IX=JSYMM(IXX,KX)
                          NCN=NCHG(IX)
C
                          nchi=0
                          DO NC0=1,NCN               !FIND INITIAL GROUP
                            LL1=LLCH(1,NC0,IX)
                            LL2=LLCH(2,NC0,IX)
                            nchi=nchi+((ll2-ll1)/4+1)*mc
                            IF(NC.EQ.ITARG(NC0,IX))THEN         !MATCHED
                              IF(LI.LT.LL1.OR.LI.GT.LL2)GO TO 715
                              nchi=nchi-((ll2-li)/4+1)*mc
                              GO TO 720
                            ENDIF
                          ENDDO
C
 715                      CONTINUE
c                      write(6,*)'NO CONTRIB. FROM LS SYM',IXX,' IX=',IX
                          GO TO 750             !SLP DOES NOT CONTRIBUTE
C
 720                      IS=LSPI(IX)/10000
                          IP=LSPI(IX)-IS*10000
                          IL=IP/10
                          IP=IP-IL*10
C
                          IF(MTP.NE.IP+IP)STOP 'IXX ERROR'       !REMOVE
                          MTS=IS-1
                          MTL=IL+IL
C
                          IF(KAYI.LT.ABS(MTL-SA)
     X                   .OR.KAYI.GT.MTL+SA)GO TO 750     !LAST TRIANGLE
C
                          IF(BKUTOO.AND.IL.GT.MAXLOO)THEN
                            KUTOOX=0
                            BKUTOO=.FALSE.
                          ENDIF
C
                          bnx=il.gt.maxlx
c
                          if(jprint.ge.5)then
                            if(bnx)then
                              nwt=-2*is+2
                            else
                              nwt=is
                            endif
                            write(6,1113)ix,nwt,il,ip
                          endif
c
c must be synchronized with current values of l placed in ql(i) for
c orbital and integral evaluations.
c
                          ldiff=2*(jpos/2)-mtl      !for adjust of ql(i)
C
C DETERMINE INITIAL STATE RECOUPLING COEFFICIENT
C
                          W=SJS(LA,LI,MTL,KAYI,SA,JI,DFS)
                          ISGN=(LI+MTL+SA+JI)/2
                          isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                          W=W*ISGN
                          W2=SJS(MTS,MTL,MTJ,KAYI,IONE,SA,DFS)
                          ISGN=(MTL+MTJ+1+SA)/2
                          isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                          W2=W*W2*ISGN
                          W2=W2*SQRT(REAL((MTL+1)*(MTS+1),WP))*SJKI
c
                          if(bnx)then
                            mts=mts-2
                            if(mts.ge.abs(mtj-mtl))then
                              x2=sjs(mts,mtl,mtj,kayi,ione,sa,dfs)
c                              isgn=(mtl+mtj+1+sa)/2
c                              isgn=1-2*mod(abs(isgn),2)!(-1)**isgn
                              x2=w*x2*isgn
                              x2=x2*sqrt(real((mtl+1)*(mts+1),wp))*sjki
                            endif
                          else
                            x2=dzero
                          endif
c
                          if(abs(w2)+abs(x2).lt.1.d-70)go to 750
C
                          JX1=1                            !FS
                          IF(MTJ.GT.MAXJFS)JX1=IXX         !NO-FS
C
                          DO JXX=JX1,IXX       !LOOP OVER FINAL LS SYMMS
C
                            JX=JSYMM(JXX,KX)
                            NCNP=NCHG(JX)
C
                            nchip=0
                            DO ND0=1,NCNP              !FIND FINAL GROUP
                              LL1P=LLCH(1,ND0,JX)
                              LL2P=LLCH(2,ND0,JX)
                              nchip=nchip+((ll2p-ll1p)/4+1)*mcp
                              IF(ND.EQ.ITARG(ND0,JX))THEN       !MATCHED
                                IF(LF.LT.LL1P.OR.LF.GT.LL2P)GO TO 725
                                nchip=nchip-((ll2p-lf)/4+1)*mcp
                                GO TO 730
                              ENDIF
                            ENDDO
C
 725                        CONTINUE
c                   write(6,*)'NO CONTRIB. FROM LS SYM',JXX,' JX=',JX
                            GO TO 740              !SLP DOES NOT CONTRIB
C
 730                        ISP=LSPI(JX)/10000
                            IPP=LSPI(JX)-ISP*10000
                            ILP=IPP/10
                            IPP=IPP-ILP*10
C
                            IF(MTP.NE.IPP+IPP)STOP 'JXX ERROR'   !REMOVE
                            MTSP=ISP-1
                            MTLP=ILP+ILP
C
                            IF(KAYF.LT.ABS(MTLP-SAP)
     X                     .OR.KAYF.GT.MTLP+SAP)GO TO 740 !LAST TRIANGLE
C
                            BLS=IX.EQ.JX
                            b2fs=mtj.le.maxjfs
     X                 .and.     (IS+ISP-2)*(IL+ILP).GT.0
     x                 .and.     abs(NMETAG(NC))+abs(NMETAG(ND)).lt.2
C
                            if(jprint.ge.5)then
                              if(bnx)then
                                nwtp=-2*isp+2
                              else
                                nwtp=isp
                              endif
                              write(6,1115)jx,nwtp,ilp,ipp
                            endif
C
C DETERMINE FINAL STATE RECOUPLING COEFFICIENT
C
                            W=SJS(LAP,LF,MTLP,KAYF,SAP,JF,DFS)
                            ISGN=(LF+MTLP+SAP+JF)/2
                            isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                            W=W*ISGN
                          W2P=SJS(MTSP,MTLP,MTJ,KAYF,IONE,SAP,DFS)
                            ISGN=(MTLP+MTJ+1+SAP)/2
                            isgn=1-2*mod(abs(ISGN),ITWO)!(-1)**isgn
                            W2P=W*W2P*ISGN
                           W2P=W2P*SQRT(REAL((MTLP+1)*(MTSP+1),WP))*SJKF
C
                            W4=W2*W2P
c
                            if(bnx)then
                              mtsp=mtsp-2
                              if(mtsp.ge.abs(mtj-mtlp))then
                                x2p=
     x                        sjs(mtsp,mtlp,mtj,kayf,ione,sap,dfs)
c                                isgn=(mtlp+mtj+1+sap)/2
c                                isgn=1-2*mod(abs(isgn),2)!(-1)**isgn
                                x2p=w*x2p*isgn
                                x2p=x2p*sqrt(real((mtlp+1)*(mtsp+1),wp))
     x                                 *sjkf
                                w4=w4+x2*x2p
                              endif
                            endif
C
                            if(abs(w4).lt.1.d-70)go to 740
c
c set pointers to ls and fs interactions
c
c
                            beqgrp=bls.and.nc0.eq.nd0     !ls equal grps
c                                                          !to fill rho
                            beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
c
                            if(bls)then
                              ncor=qptls(ix,nc0,nd0,li,lf)
                              if(ncor.ge.0)then
                                nun=0
                              else             !reverse
                                nun=mc-1
c                       write(6,*)ix,nc0,nd0,li,lf,ncor+1
                              endif
                              ncor0=ncor
                              LSTORE=IL-LPOS
                              LSTORE=QPX(LSTORE)-1
                            else
                              ncor0=0
                            endif
c
                            if(b2fs)then
                              ncorj=qptlsj(kx,ixx,jxx,nc0,nd0,li,lf)
                              if(ncorj.ge.0)then
                                nunj=0
                              else             !reverse
                                nunj=mc-1
c                      write(6,*)kx,ixx,jxx,nc0,nd0,li,lf,ncorj+1
                              endif
                              ncorj0=ncorj
                            else
                              ncorj0=0
                            endif
c
                            icl0=0
                            if(bcorr.and.(ncor0.lt.0.or.ncorj0.lt.0))
     x                                                              then
                              do md1=1,mc
                                j1=md1+mci
                                j=jndex(j1)
                                if(j.lt.0)icl0=icl0+1
                              enddo
                            endif
C
C POPULATE UNMIXED RHO INTERACTION MATRIX
C
                            icl=0
                            DO MD1=1,MC        !LOOP OVER INITIAL LEVELS
                              J1=MD1+MCI
c
                              j=jndex(j1)
                              if(kcutx.lt.0)j=abs(j)  !keep corr.-corr.
                              if(bcorr.and.j.lt.0)icl=icl+1
                              KF=NFK(J1)
                              NCJ=NCI0+MD1
C
                              if(ncor0.lt.0)ncor=-ncor0-1+md1-1
                              if(ncorj0.lt.0)ncorj=-ncorj0-1+md1-1
c
                              iclp=0
                              DO MDP1=1,MCP      !LOOP OVER FINAL LEVELS
                                J1P=MDP1+MCIP
c
                                jp=jndex(j1p)
                                if(bcorr.and.jp.lt.0)iclp=iclp+1
                                if(j.lt.0.and.jp.lt.0)then      !cor-cor
                                  if(becor)then
                                    if(bls)ncor=ncor+1
                                    if(b2fs)ncorj=ncorj+1
                                    go to 710
                                  endif
                                  go to 712
                                endif
C
                                KG=NFK(J1P)
                                NCJP=NCIP0+MDP1
C
                                NOMTG=(NCJP-1)*NCJ0+NCJ            !orig
C
C LS ALGEBRA
C
                                IF(BLS)THEN
c                                           since ls only stores half...
                                  if(beqgrpl.and.j1p.gt.j1-ione0)then
                                    ncor=ncor0+icol(md1,mdp1,ione0)-1
                                    if(bcorr)ncor=ncor
     x                                        -icol(iclp-1,iclp-1,ione0)
                                  endif
C
                                  N1=NAD(NCOR)+1
                                  NCOR=NCOR+1
                                  N2=NAD(NCOR)
c debug write
                                  if(jprint.ge.5.and.n1.le.n2)then
                                    nch=nchi+md1
                                    nchp=nchip+mdp1
                                    if(n2-n1.eq.5)then
                                      write(6,9119)ncor,ix,nch,nchp,0,0,
     x                                           (nrk(n),drk(n),n=n1,n2)
                                    else
                                      write(6,9120)ncor,ix,nch,nchp,0,0,
     x                                           (nrk(n),drk(n),n=n1,n2)
                                    endif
                                    if(bkutoo)write(6,9121)
     x                                           (nrk(n),dek(n),n=n1,n2)
                                    write(6,9120)
                                  endif
c
c need to find if Slater integral initial and final states are swapped
c because of falling order. this also picks-up any case that needs
c swapping because initial and final algebraic states are swapped.
c it doesn't pick-up all cases of ncor0.lt.0 but the symmetry of the
c Slater integrals means that such cases are unchanged by a swap.
c
                                  if(n2-n1+1.gt.mxd13)then
                                    write(6,*)'***sr.dwxbp: increase',
     x                              ' internal buffer mxd13 to', n2-n1+1
                                    nf=-1
                                    go to 700
                                  endif
c
                                  ks=0
                                  do n=n1,n2
                                    ks=ks+1
                                    bswap(ks)=.false.
                                    n0=int(nrk(n))
                                    m0=qrl(1,n0)
                                    if(li.eq.ql(m0)-ldiff)then
                                      if(li.eq.lf.and.kf.ne.kg)then
                                        m0=qrl(3,n0)
                                        if(qn(m0).gt.0)then    !exchange
                                          if(m0.ne.kact(kg,kf))then   !f
                                            bswap(ks)=.true.       !swap
                                          endif
c                                       else    !direct - doesn't matter
                                        endif
c                                     else      !distinct/kf=kg so can't
                                      endif
                                    else           !trivially, they were
                                      bswap(ks)=.true.
                                    endif
                                  enddo
c
                                ELSE
                                  N1=1
                                  N2=0
                                ENDIF
C
C FS ALGEBRA
C
                                if(b2fs)then
c                                           since ls only stores half...
                                  if(beqgrpl.and.j1p.gt.j1-ione0)then
                                   ncorj=ncorj0+icol(md1,mdp1,ione0)-1
                                   if(bcorr)ncorj=ncorj
     x                                        -icol(iclp-1,iclp-1,ione0)
                                  endif
c
                                  k1=nadr(ncorj)+1
                                  ncorj=ncorj+1
                                  k2=nadr(ncorj)
c debug write
                                  if(jprint.ge.5.and.k1.le.k2)then
                                    nch=nchi+md1
                                    nchp=nchip+mdp1
                                    if(k2-k1.eq.5)then
                                      write(6,1201)ncorj,kx,ix,jx,nch,
     x                                nchp,0,0,(mss(n),dss(n),n=k1,k2)
                                    else
                                      write(6,1202)ncorj,kx,ix,jx,nch,
     x                                nchp,0,0,(mss(n),dss(n),n=k1,k2)
                                    endif
                                    write(6,1201)
                                  endif
c
c need to find if n & v integral initial and final states are swapped
c because of falling order.
c
c this does *not* pick-up all cases that need swapping because initial
c and final algebraic states are swapped (ncorj0.lt.0) hence additional
c test on ncorj0.
c
                                  if(k2-k1+1.gt.mxd13)then
c                write(0,*)ncorj,iadj
                                    write(6,*)'***sr.dwxbp: increase ',
     x                              'internal buffer mxd13 to', k2-k1+1
                                    nf=-1
                                    go to 700
                                  endif
c
c **********************************************************************
c currently, swapping of indexes due to falling order has been
c suppressed in sr.resx1 (see also sr.fsintx) because of the lesser
c symmetry compared to Slater integrals which means that an additional
c flag is needed.
c **********************************************************************
c
c so, we simply have:
                                  ksj=0
                                  do k=k1,k2
                                    ksj=ksj+1
                                    bswapj(ksj)=ncorj0.lt.0
                                  enddo
cc instead of:
c                                  ksj=0
c                                  do k=k1,k2
c                                    ksj=ksj+1
c                                    bswapj(ksj)=.false.
c                                    k0=int(mss(k))
cc
c                                    i1=qss(1,k0)
c                                    i3=qss(3,k0)
c                                    i2=qss(2,k0)
c                                    i4=qss(4,k0)
c                                    if(qn(i1).lt.0)then
c                                      ic=i1
c                                      if(qn(i3).lt.0)then       !direct
c                                        ib=i4
c                                      else                    !exchange
c                                        ib=i3
c                                      endif
c                                    else
c                                      ic=i2
c                                      if(qn(i4).lt.0)then       !direct
c                                        ib=i3
c                                      else                    !exchange
c                                        ib=i4
c                                      endif
c                                    endif
c                                    if(li.eq.ql(ic))then
c                                      if(li.eq.lf)then
c                                        if(kf.ne.kg)then
c                                          if(ib.ne.kact(kg,kf))then  !f
c                                            bswapj(ksj)=.true.
c                                          endif
c                                        else
cc tbd for exchange falling order (see also sr.resx1 and sr.fsintx):
cc the case of N(C'C;BB)=N(BC;C'B) for Bound and Continuum needs a
cc further flag so as to distinguish it from N(C'C;BB)=N(C'B;BC),
cc since in the former we need C'=M2 while in the latter C'=M1, so
cc                                           if (former) then
cc                                           bswapj(ksj)=.true.
cc           since unlike slater we cannot interchange 1 & 3 with 2 & 4
cc         - this also means that we need
c                                          if(ncorj0.lt.0)
c     x                                    bswapj(ksj)=.not.bswapj(ksj)
c                                        endif
c                                      else           !distinct so can't
c                                      endif
c                                    else          !trivially, they were
c                                      bswapj(ksj)=.true.
c                                    endif
cc
cc                           nj=ntgj(jig)
cc                           njp=ntgj(jfg)
cc                           n1=ncj+nj
cc                           n=jndxj(n1)
cc                           n1p=ncjp+njp
cc                           np=jndxj(n1p)
cc           write(6,*)ixx,jxx,nc0,nd0,n,np,li,lf,ncorj0,k0,bswapj(ksj)
cc           bswapt=ncorj0.lt.0
cc           if(bswapt.neqv.bswapj(ksj))
cc     x     write(0,*)ixx,jxx,nc0,nd0,n,np,li,lf,ncorj0,k0,bswapj(ksj)
cc
cc                                  enddo
c
                                else
                                  k1=1
                                  k2=0
                                endif
C
C LOOP OVER ENERGIES
C
                                DO M=1,MTRAN
                                  M1=MNDEX(M,1)
                                  M2=MNDEX(M,2)
C
C LS CONTRIBUTION:
C
                                  DD=DZERO
                                  ks=0
                                  DO N=N1,N2
                                    ks=ks+1
c
                                    if(bswap(ks))then              !swap
                                      mm=mrndx(m)
                                    else
                                      mm=m
                                    endif
c
                                    N0=INT(NRK(N))
C
                                    DD=DD+DRLX(N0,mm,LSTORE)*DRK(N)
C
                                    IF(BKUTOO)THEN
                                      DS=DZLX(N0,mm,LSTORE)
                                      IF(BFALL(N))DS=-DS
                                      DS=DS+DXTWOX(N0,mm,LSTORE)*DRK(N)
     X                                  +DETAX(N0,mm,LSTORE)*DEK(N)
                                      DD=DD+DS
                                    ENDIF
                                  ENDDO
C
C FS CONTRIBUTION:
C
c                                  dd=dzero !test fs, switch-off coulomb
c
                                  DDJ=DZERO
                                  ksj=0
                                  DO K=K1,K2
                                    ksj=ksj+1
c
                                    if(bswapj(ksj))then            !swap
                                      mm=mrndx(m)
                                    else
                                      mm=m
                                    endif
c
                                    K0=INT(MSS(K))
C
                                    DDJ=DDJ+DNLX(K0,mm)*DSS(K)
                                  ENDDO
C
                                  DEE=DD+DDJ
C                                                               !UNMIXED
                                  RHO2(M,NOMTG)=RHO2(M,NOMTG)+DEE*W4
C
                                ENDDO
c
c start test print
c                           nj=ntgj(jig)
c                           njp=ntgj(jfg)
c                           n1=ncj+nj
c                           n=jndxj(n1)
c                           n1p=ncjp+njp
c                           np=jndxj(n1p)
c                           write(6,777)n,np,(rho2(m,nomtg),m=1,mtran)
c  777                      format(2i5,1p,10d12.3/(10x,10d12.3))
c                           call flush(6)
c end test print
C
  710                           if(ncor0.lt.0)then
                                  ncor=ncor+nun
                                  if(jp.lt.0)ncor=ncor-icl0
                                endif
                                if(ncorj0.lt.0)then
                                  ncorj=ncorj+nunj
                                  if(jp.lt.0)ncorj=ncorj-icl0
                                endif
c
                              ENDDO          !END LOOP OVER FINAL LEVELS
c
  712                         if(beqgrpl)then
                                if(bls)then
                                  ncor=ncor0+icol(md1,md1,ione0)
                                  if(bcorr)ncor=ncor-icol(icl,icl,ione0)
                                endif
                                if(b2fs)then
                                  ncorj=ncorj0+icol(md1,md1,ione0)
                                  if(bcorr)ncorj=ncorj
     x                                              -icol(icl,icl,ione0)
                                endif
                              endif
C
                            ENDDO          !END LOOP OVER INITIAL LEVELS
C
  740                     ENDDO            !END LOOP OVER FINAL LS SYMMS
C
                          KUTOOX=KOLDOO
                          BKUTOO=KUTOOX.NE.0
C
  750                   ENDDO            !END LOOP OVER INITIAL LS SYMMS
C
  68                    CONTINUE
C
                        NCIP0=NCIP0+MCP
                      ENDDO               !END LOOP OVER FINAL SL GROUPS
                      if(ncip0.ne.ncjp0)
     x                stop 'ncip0.ne.nt(jfg)'                 !temp test
C
                      NCI0=NCI0+MC
                    ENDDO               !END LOOP OVER INITIAL SL GROUPS
                    if(nci0.ne.ncj0)stop 'nci0.ne.nt(jig)'   !temp test
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeset=timeset+timef-timei
                      timei=timef
                    endif
C
C-----------------------------------------------------------------------
C
                    MX=MTRAN
C
C INTERP THEN MIX (APPROX)
C
                   if(.not.bmix)then
C
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
C
                    DO NCJP=1,NCJP0        !BEGIN LOOP OVER FINAL LEVELS
C
                      J1P=NCJP+NJP
                      JP=JNDXJ(J1P)
C
                      NOMTG0=(NCJP-1)*NCJ0
C
                      DO NCJ=1,NCJ0      !BEGIN LOOP OVER INITIAL LEVELS
C
                        J1=NCJ+NJ
                        J=JNDXJ(J1)
C
                        NOMTG=NOMTG0+NCJ                           !orig
C
                        IF(J.LE.JP)THEN !INITIAL ALGEBRAIC IS LOWER ENRG
C
                          JL=J
                          JH=JP
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M1,M2)=RHO2(M,NOMTG)
                          ENDDO
C
                        ELSE            !FINAL ALGEBRAIC IS LOWER ENERGY
C
                          JL=JP
                          JH=J
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M2,M1)=RHO2(M,NOMTG)
                          ENDDO
C
                        ENDIF
C
                        DE=DSPECJ(JH)-DSPECJ(JL)
C
                        NOMT=IROW(JL,JH,ione1,NSPECJ)           !ROWWISE
c
                        bdip=.false.
                        if(jl.le.nmetaj.and.jl.lt.jh)then   !need exists
                          bdip=omginf(nomt).lt.dzero        !flag dipole
                        endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                        DO M0=1,MENG0
C
                          M=IYY0(M0)
c
                          ml=mlim(m,1)
                          mu=mlim(m,2)
c
                          if(bdip)mu=-mu                    !flag dipole
C
                          RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu)!A.U.
C
                          RHO2(M0,NOMTG)=RHO
C
                        ENDDO                    !END LOOP OVER ENERGIES
C
                      ENDDO                !END LOOP OVER INITIAL LEVELS
C
                    ENDDO                    !END LOOP OVER FINAL LEVELS
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeint=timeint+timef-timei
                      timei=timef
                    endif
c
                    mx=meng0                                     !re-set
c
                   endif
C
                    NOMTG=NCJ0*NCJP0
                    DO M=1,MX
                      DO N=1,NOMTG
                        RHO1(N,M)=RHO2(M,N)
                      ENDDO
                    ENDDO
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeset=timeset+timef-timei
                      timei=timef
                    endif
C
C-----------------------------------------------------------------------
C
C NOW MIX (INITIAL)
C
                    N0=NADRUG(JIG)
                    N0P=NADRUG(JFG)
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
C                    NCJ0=NT(JIG)
C                    NCJP0=NT(JFG)
C
                    DO NCJ=1,NCJ0        !BEGIN LOOP OVER INITIAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 11                      !omit corr
                      if(j.gt.nmetaj)go to 11       !omit non-metastable
c
                      if(bcorr.or.kayi.eq.kayf)then
                        DO NCJP=1,NCJP0    !SEE IF WE HAVE A FINAL LEVEL
                          J1P=NCJP+NJP
                          IF(J1P.GT.J1.and.kayi.eq.kayf)GO TO 11
                          jp=jndxj(j1p)
                          if(jp.gt.0)go to 5                      !we do
                        ENDDO
                        GO TO 11                               !WE DON'T
                      endif
C
   5                  N1=N0+(NCJ-1)*NCJ0                    !tfu pointer
C
                      DO M=1,MX
C
                        DO NCJP=1,NCJP0            !FOR EACH FINAL LEVEL
C
                          NG0=(NCJP-1)*NCJ0              !for rho1 nomtg
C
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL                DD=DDOT(NCJ0,RHO1(NG0+1,M),IONE,TFU(N1+1),IONE)!LAPACK
CL                          ELSE                                 !LAPACK
                            DD=DZERO
                            DO LD1=1,NCJ0          !BEGIN INITIAL MIXING
cx                             IF(ABS(TFU(N1+LD1)).GT.XMIX)THEN
                                  DD=DD+RHO1(NG0+LD1,M)*TFU(N1+LD1)
cx                             ENDIF
                            ENDDO                    !END INITIAL MIXING
CL                          ENDIF                                !LAPACK
C
                          TEMP(NCJP,M)=DD
C
c                        j1p=ncjp+njp
c                        write(6,777)j1,j1p,temp(ncjp,m)
                        ENDDO                      !FOR EACH FINAL LEVEL
C
                      ENDDO
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixi=timemixi+timef-timei
                        timei=timef
                      endif
C
C NOW MIX (FINAL)
C
                      NOMTG0=(NCJ-1)*NCJP0                          !new
C
                      DO NCJP=1,NCJP0      !BEGIN LOOP OVER FINAL LEVELS
C
                        J1P=NCJP+NJP
                        if(j1.eq.j1p.and.ione1.ne.0)go to 10
                        if(kayi.eq.kayf)then
                          IF(J1P.GT.J1)GO TO 11
                          if(j1.eq.j1p.and.lf.gt.li)go to 10
                        endif
c
                        jp=jndxj(j1p)
                        if(jp.lt.0)go to 10                   !omit corr
c                        if(min(j,jp).gt.nmetaj)go to 10 !non-metastable
C
                        N1P=N0P+(NCJP-1)*NCJP0              !tfu pointer
C
                        NOMTG=NOMTG0+NCJP                           !new
C
                        DO M=1,MX
C
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL                  DD=DDOT(NCJP0,TEMP(1,M),IONE,TFU(N1P+1),IONE)!LAPACK
CL                          ELSE                                 !LAPACK
                            DD=DZERO
                            DO LDP1=1,NCJP0          !BEGIN FINAL MIXING
cx                             IF(ABS(TFU(N1P+LDP1)).GT.XMIX)THEN
                              DD=DD+TEMP(LDP1,M)*TFU(N1P+LDP1)
cx                             ENDIF
                            ENDDO                      !END FINAL MIXING
CL                          ENDIF                                !LAPACK
C
                          RHO2(M,NOMTG)=DD
C
                        ENDDO
C
c                        write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  10                  ENDDO                  !END LOOP OVER FINAL LEVELS
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixf=timemixf+timef-timei
                        timei=timef
                      endif
C
  11                ENDDO                  !END LOOP OVER INITIAL LEVELS
C
C FIRST SEE IF WE NEED REVERSE CASE:
C----------------------------------
C
C  INITIAL & FINAL ARE ALGEBRAIC AND SO NMETA CAN BE IN EITHER/BOTH/NONE
C  BUT WE WANT THE FIRST MIXING MATRIX MULT TO BE FOR NMETAJ SO WE DON'T
C  NEED TO MULTIPLY BY THE ZERO BLOCK. THUS, WE MAKE A DOUBLE PASS. OF
C  COURSE, IF NMETAJ=NSPECJ THEN THE SECOND PASS IS "SKIPPED".
C
                    DO NCJP=1,NT(JIG)              !CHECK INITIAL LEVELS
                      J1P=NCJP+NTGJ(JIG)
                      jp=jndxj(j1p)
                      if(jp.gt.nmetaj)go to 8                    !needed
                    ENDDO
                    GO TO 130                                  !ALL DONE
C
C NOW MIX (FINAL) - REVERSE CASE
C
   8                N0=NADRUG(JFG)
                    N0P=NADRUG(JIG)
                    NJ=NTGJ(JFG)
                    NJP=NTGJ(JIG)
                    NCJ0=NT(JFG)
                    NCJP0=NT(JIG)
C
                    DO NCJ=1,NCJ0          !BEGIN LOOP OVER FINAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 13                      !omit corr
                      if(j.gt.nmetaj)go to 13       !omit non-metastable
C
                      DO NCJP=1,NCJP0      !SEE IF WE HAVE INITIAL LEVEL
                        J1P=NCJP+NJP
                        IF(J1P.LT.J1.and.kayi.eq.kayf)GO TO 6
                        jp=jndxj(j1p)
                        if(jp.gt.nmetaj)go to 7                   !we do
   6                  ENDDO
                      GO TO 13                                 !WE DON'T
C
   7                  N1=N0+(NCJ-1)*NCJ0                    !tfu pointer
C
                      DO M=1,MX
C
                        DO NCJP=1,NCJP0          !FOR EACH INITIAL LEVEL
C
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL                DD=DDOT(NCJ0,RHO1(NCJP,M),NCJP0,TFU(N1+1),IONE)!LAPACK
CL                          ELSE                                 !LAPACK
                            NG0=NCJP-NCJP0               !for rho1 nomtg
                            DD=DZERO
                            DO LD1=1,NCJ0            !BEGIN FINAL MIXING
cx                              IF(ABS(TFU(N1+LD1)).GT.XMIX)THEN
                              DD=DD+RHO1(NG0+LD1*NCJP0,M)*TFU(N1+LD1)
cx                              ENDIF
                            ENDDO                      !END FINAL MIXING
CL                          ENDIF                                !LAPACK
C
                          TEMP(NCJP,M)=DD
C
c                        j1p=ncjp+njp
c                        write(6,777)j1,j1p,temp(ncjp,m)
                        ENDDO                    !FOR EACH INITIAL LEVEL
C
                      ENDDO
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixfr=timemixfr+timef-timei
                        timei=timef
                      endif
C
C NOW MIX (INITIAL) - REVERSE CASE
C
                      DO NCJP=1,NCJP0    !BEGIN LOOP OVER INITIAL LEVELS
C
                        J1P=NCJP+NJP
                        if(j1.eq.j1p.and.ione1.ne.0)go to 12
                        if(kayi.eq.kayf)then
                          IF(J1P.LT.J1)GO TO 12
                          if(j1.eq.j1p.and.lf.gt.li)go to 12
                        endif
c
                        jp=jndxj(j1p)
c                        if(jp.lt.0)go to 12                  !omit corr
                        if(jp.le.nmetaj)go to 12         !already gotten
C
                        N1P=N0P+(NCJP-1)*NCJP0
C
                        NOMTG=NCJ+(NCJP-1)*NCJ0                     !new
C
                        DO M=1,MX
C
CL                          IF(LAPAK.GT.0)THEN                   !LAPACK
CL                  DD=DDOT(NCJP0,TEMP(1,M),IONE,TFU(N1P+1),IONE)!LAPACK
CL                          ELSE                                 !LAPACK
                            DD=DZERO
                            DO LDP1=1,NCJP0        !BEGIN INITIAL MIXING
cx                              IF(ABS(TFU(N1P+LDP1)).GT.XMIX)THEN
                              DD=DD+TEMP(LDP1,M)*TFU(N1P+LDP1)
cx                              ENDIF
                            ENDDO                    !END INITIAL MIXING
CL                          ENDIF                                !LAPACK
C
                          RHO2(M,NOMTG)=DD
C
                        ENDDO
C
c                        write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  12                  ENDDO                !END LOOP OVER INITIAL LEVELS
c
                      if(btimet)then
                        call cpu_time(timef)
                        timemixir=timemixir+timef-timei
                        timei=timef
                      endif
C
  13                ENDDO                    !END LOOP OVER FINAL LEVELS
C
C RE-SET
                    NJ=NTGJ(JIG)
                    NJP=NTGJ(JFG)
                    NCJ0=NT(JIG)
                    NCJP0=NT(JFG)
C
  130               CONTINUE
C
C-----------------------------------------------------------------------
C
C (IF bmix INTERPOLATE MIXED RHO2.) CONVERT TO TMX AND ADD TO OMEGA
C NOTE, RHO2 IS IN "A.U"
C ALLOW FOR ANY INITIAL ALGEBRAIC LEVELS NOT BEING LOWEST IN ENERGY.
c
                    if(.not.bmix)mx=-mx              !skip interp set-up
C
                    DO NCJ=1,NCJ0        !BEGIN LOOP OVER INITIAL LEVELS
C
                      J1=NCJ+NJ
                      j=jndxj(j1)
                      if(j.lt.0)go to 14                       !omit cor
C
                      IF(BPRNT2.or.bunit2.or.bntest)
     X                NCHJ=NCHAJK(KX,KAYI,JIG,LI,NCJ,NTGJ,DFS)
c hold
                      if(bunit2)then
                        iwrkn(nchj)=j
                        iwrkl(nchj)=l0
                      endif
C
                      NOMTG0=(NCJ-1)*NCJP0
                      DO NCJP=1,NCJP0      !BEGIN LOOP OVER FINAL LEVELS
C
                        J1P=NCJP+NJP
                        if(j1.eq.j1p.and.ione1.ne.0)go to 15
                        if(kayi.eq.kayf)then
                          IF(J1P.GT.J1)GO TO 14
                          if(j1.eq.j1p.and.lf.gt.li)go to 15
                        endif
C
                        JP=JNDXJ(J1P)
                        if(jp.lt.0)go to 15                   !omit corr
                        if(min(j,jp).gt.nmetaj)go to 15  !non-metastable
C
                        IF(BPRNT2.or.bunit2.or.bntest)
     X                  NCHJP=NCHAJK(KX,KAYF,JFG,LF,NCJP,NTGJ,DFS)
c
c                        write(6,*)nchj,nchjp,j1,j1p,j,jp
c
                        if(bntest)ntest(nchj,nchjp)=ntest(nchj,nchjp)+1
c
c "undefined" should not be accessed by xint...
c                        do m2=1,meng
c                          do m1=1,meng
c                            tmp(m1,m2)=1.d70 !dzero              !test
c                          enddo
c                        enddo
C
                        NOMTG=NOMTG0+NCJP              !rho2 nomtg (new)
C
                        IF(J.LE.JP)THEN !INITIAL ALGEBRAIC IS LOWER ENRG
C
                          JL=J
                          JH=JP
                          NCHL=NCHJ
                          NCHH=NCHJP
                          LUP=LF
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M1,M2)=RHO2(M,NOMTG)
                          ENDDO
C
                        ELSE            !FINAL ALGEBRAIC IS LOWER ENERGY
C
                          JL=JP
                          JH=J
                          NCHL=NCHJP
                          NCHH=NCHJ
                          LUP=LI
C
                          DO M=1,MX
                            M1=MNDEX(M,1)
                            M2=MNDEX(M,2)
                            TMP(M2,M1)=RHO2(M,NOMTG)
                          ENDDO
C
                        ENDIF
C
                        DE=DSPECJ(JH)-DSPECJ(JL)
C
                        NOMT=IROW(JL,JH,ione1,NSPECJ)           !ROWWISE
c
                        if(nomt.gt.nomwrt)then    !shouldn't happen, now
                          write(0,*)jl,jh,nmetaj,nspecj,nomt,nomwrt
                          stop 'omega prob.'
                        endif
c
                        bdip=omginf(nomt).lt.dzero          !flag dipole
c
                        if(bunit2)then
                          if(nchjp.le.nchj)then
                            nchl=nchjp
                            nchh=nchj
                          else
                            nchl=nchj
                            nchh=nchjp
                          endif
                        endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                        DO M0=1,MENG0
C
                          M=IYY0(M0)
c
                         if(mx.gt.0)then                         !interp
c
                          ml=mlim(m,1)
                          mu=mlim(m,2)
c
                          if(bdip)mu=-mu                    !flag dipole
C
                          RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu)!A.U.
c
                         else                              !already have
C
                          RHO=RHO2(M0,NOMTG)
c
                         endif
C
                          RHOSQ=RHO*RHO
c store for ii
                          if(bunit2)then
                            if((j1.eq.j1p.and.li.eq.lf.and.
     x                          kayi.eq.kayf).neqv.(nchj.eq.nchjp))
     x                          stop 'dwbp: diagonal index issue?'
                            nx=irow(nchl,nchh,izero,nchjt)
                            rhom(nx,m0)=rho
                            go to 16
                          endif
C
c                          IF(NCHJ.eq.NCHJP)THEN            !DIAGONAL MX
c
                         if(j1.eq.j1p.and.li.eq.lf.and.kayi.eq.kayf)then
C
                            IF(BRMX)THEN                !USUAL REACTANCE
                              T=PI*PSHFTX(M,L0)
                              CT=COS(T)
                              ST=SIN(T)
                              RMX=(ST+RHO*CT)/(CT+RHO*ST)
                            ENDIF
C
                            IF(BPRNT3)WRITE(6,202)NCHL,NCHH,JL,JH
     X                                    ,PSHFTX(M,L0),M0,'PHASE SHIFT'
                            T=TPI*PSHFTX(M,L0)
                            C2T=COS(T)
                            S2T=SIN(T)
C
                            if(bunit)then                   !2x2 UNITARY
                              TSQ=DONE+(C2T*(RHOSQ-DONE)+DTWO*S2T*RHO)
     X                                /(RHOSQ+DONE)
                            else                            !non-unitary
                              tsq=done+(dtwo*s2t*rho-c2t)
                            endif
c
                            TSQ=TSQ+TSQ     ! T^R=1+EXP(2I*TAU)(T^RHO-1)
C
                          ELSE                             !OFF DIAGONAL
C
                            IF(BRMX)THEN                !USUAL REACTANCE
                              T1=TPI*PSHFTX(M,L0)
                              T2=TPI*PSHFTX(M,L00)
                              DET=COS(T1)*COS(T2)-RHOSQ*SIN(T1)*SIN(T2)
                              RMX=RHO/DET
                            ENDIF
C
                            TSQ=4*RHOSQ      ! |T^R(V,V')|=|T^RHO(V,V')|
C
                            if(bunit)TSQ=TSQ/(DONE+RHOSQ)**2 !~UNITARITY
C
C                                    !FOR ELASTIC LI.NE.LF .OR. KI.NE.KF
                             IF(J1.EQ.J1P)TSQ=TSQ+TSQ
C
                          ENDIF
c
                          if(tsq.lt.d1m20)tsq=dzero
C
                          IF(BPRNT3)THEN
                            IF(BRMX)THEN
                              WRITE(6,202)NCHL,NCHH,JL,JH,RMX,M0,
     X                                   'R-MATRIX  '
                            ELSE
                              WRITE(6,202)NCHL,NCHH,JL,JH,RHO,M0,
     X                                   'RHO-MATRIX'
                            ENDIF
                          ENDIF
C
                          OMPW=wait*TSQ*NWTJ/DTWO
C
                          if(bht)ompw=ompw/2   !for BHT(1970) comparison
C
C LOOK AT TOP-UP ISSUES, IF L LARGE ENOUGH TO WARRANT IT (OFF IF BTHRSH)
C
                          IF(JNEW.GE.LRGLMN)THEN
C                                                     !NON-DIPOLE TOP-UP
                            IF(OMGINF(NOMT).GT.DZERO.and.
     X                                            litlam.gt.0)THEN
C
                              IF(JNEW.EQ.LRGLAM)THEN       !APPLY TOP-UP
                                EJ=DYY0(M0)
                                EI=EJ+DE
c
                                ompw0=ompw
                                ompw=ompw/wait
                                IF(BPRNT3)OMPW=-OMPW         !FLAG PRINT
C
                                CALL TOP2(LITLAM,LRGLAM/2,EI,EJ,OMPW)
C
                                ompw=ompw+ompw0*(wait-done)/wait !adjust
c
                              ELSEIF(JNEW.GT.LRGLAM)THEN
                                OMPW=DZERO
                              ENDIF
C                                                  !DIPOLE:LITLAM=LRGLAM
                            ELSEIF(bdip)THEN              !POSS ZERO-OUT
C                                            !ZERO-OUT AS INC. IN TOP-UP
                              IF(MAX(LI,LF).GT.LRGLAM)OMPW=DZERO
C
                            ENDIF
C
                          ENDIF
C
C ARCHIVE PARTIAL/TOTAL COLLISION STRENGTHS
C
                          IF(BTHRSH)THEN
                            M00=LUP/2+1-LVMIN
                            IF(M00.LT.1.OR.M00.GT.MOGGY)GO TO 15
                          ELSE               !CASE NOT XCLUDED BY ALGXLS
                            M00=M0
                          ENDIF
C
                          OMP(M0)=OMPW
C                                                    !UPDATE TOTAL OMEGA
                          OMEGA(M00,NOMT)=OMEGA(M00,NOMT)+REAL(OMPW,RP)
C
  16                    ENDDO                    !END LOOP OVER ENERGIES
C                                                         !PARTIAL OMEGA
                        IF(BPRNT2.and..not.bunit2)
     X                  WRITE(6,201)NCHL,NCHH,JL,JH,(OMP(M0),M0=1,MENG0)
C
  15                  ENDDO                  !END LOOP OVER FINAL LEVELS
C
  14                ENDDO                  !END LOOP OVER INITIAL LEVELS
c
                    if(btimet)then
                      call cpu_time(timef)
                      timeint=timeint+timef-timei
                      timei=timef
                    endif
C
                  ENDDO                           !END LOOP OVER FINAL L
C
                ENDDO                           !END LOOP OVER INITIAL L
C
              ENDDO                       !END LOOP OVER FINAL JP GROUPS
C
            ENDDO                       !END LOOP OVER INITIAL JP GROUPS
C
          ENDDO                                   !END LOOP OVER FINAL K
C
        ENDDO                                   !END LOOP OVER INITIAL K
C
        if(bntest)then
          do i=1,nchjt
            if(ntest(i,i).ne.1)then
                  write(0,*)'checksum wrong for nchj,nchj '
     x           ,i,' :',ntest(i,i)
            endif
            do j=i+1,nchjt
              if(ntest(i,j)+ntest(j,i).ne.1)then
                write(0,*)'checksum wrong for nchj,nchjp'
     x                   ,i,j,' :',ntest(i,j),ntest(j,i)
              endif
            enddo
          enddo
        endif
c
c now determine t-matrix from full rho-matrix for approximation-ii:
c
        if(bunit2)then
c
          do m0=1,meng0
            m=iyy0(m0)
c
CL            if(m0.gt.0)then                                    !LAPACK
CL             call pqlap(nchjt,rhom(1,m0),wrkp,wrkq,work,nf)    !LAPACK
CL            else                                               !LAPACK
             call pq(nchjt,rhom(1,m0),wrkp,wrkq,work,nf)
CL            endif                                              !LAPACK
c
            if(nf.le.0)go to 700
c
            do nchj=1,nchjt
c
              j=iwrkn(nchj)
              if(j.le.0)go to 17
              l0=iwrkl(nchj)
c
              do nchjp=nchj,nchjt
c
                jp=iwrkn(nchjp)
                if(jp.le.0)go to 18
c
                n=irow(nchj,nchjp,izero,nchjt)
                tp=-2*wrkp(n)                 !real T^rho
                tq=-2*wrkq(n)                 !imag T^rho
c
                if(nchj.eq.nchjp)then
                  t=tpi*pshftx(m,l0)
                  if(bprnt2)write(6,202)nchj,nchjp,j,jp
     x                             ,pshftx(m,l0),m0,'phase shift'
                  c2t=cos(t)
                  s2t=sin(t)
                  tp1=tp-done
c                  tr=done+c2t*tp1-tq*s2t
c                  ti=s2t*tp1+c2t*tq
c                  tsq=tr*tr+ti*ti
                  tsq=done+(2*c2t+tp1)*tp1-(2*s2t-tq)*tq
                else
                  tsq=tp*tp+tq*tq
                  if(j.eq.jp)tsq=tsq+tsq
                endif
c
                ompw=wait*tsq*nwtj/dtwo
c
                if(bht)ompw=ompw/2      !for bht(1970) comparison
c
                if(j.le.jp)then
                  jl=j
                  jh=jp
                  nchl=nchj
                  nchh=nchjp
                else
                  jl=jp
                  jh=j
                  nchl=nchjp
                  nchh=nchj
                endif
c
                nomt=irow(jl,jh,ione1,nspecj)
c some top-up
                if(jnew.ge.lrglmn)then             !look at top-up
c
                  if(omginf(nomt).gt.dzero)then        !non-dipole
c
                    if(jnew.eq.lrglam)then           !apply top-up
                      de=dspecj(jh)-dspecj(jl)
                      ej=dyy0(m0)
                      ei=ej+de
c
                      ompw0=ompw
                      ompw=ompw/wait
                      if(bprnt3)ompw=-ompw             !flag print
c
                      call top2(itwo,lrglam/2,ei,ej,ompw)
c
                      ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                    elseif(jnew.gt.lrglam)then
                      ompw=dzero
                    endif
c
                  elseif(omginf(nomt).lt.dzero)then        !dipole
                    if(jnew.gt.lrglam)ompw=dzero
                  endif
c
                endif
c
                omp(m0)=ompw
                omega(m0,nomt)=omega(m0,nomt)+real(ompw,rp)
                if(bprnt2)write(6,201)nchl,nchh,jl,jh,tp,tq,omp(m0)
c
  18          enddo
c
  17        enddo
            if(bprnt2)write(6,*)':'
c
          enddo
c
          if(btimet)then
            call cpu_time(timef)
            timeunit=timeunit+timef-timei
          endif
c
          deallocate (rhom,wrkp,wrkq,iwrkn,iwrkl,work,stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxbp: deallocation fails for rhom,wrk'
            nf=0
            go to 999
          endif
c
        endif
C
C-----------------------------------------------------------------------
C
        if(btimet)then
          write(iw,*)'  set-up time=',nint(timeset),'sec'
          write(iw,*)'   mixi  time=',nint(timemixi),'sec'
          write(iw,*)'   mixf  time=',nint(timemixf),'sec'
          write(iw,*)'   mixir time=',nint(timemixir),'sec'
          write(iw,*)'   mixfr time=',nint(timemixfr),'sec'
          timemix=timemixi+timemixf+timemixir+timemixfr
          write(iw,*)'  mixing time=',nint(timemix),'sec'
          write(iw,*)'  interp time=',nint(timeint),'sec'
          if(bunit2)write(iw,*)' unitary time=',nint(timeunit),'sec'
        endif
c
        if(btimex)then
          call cpu_time(timef)
          times=timef-timej
c
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'Ending proc',iam                       !par
cpar     x               ,'dwxbp symmetry',kx,':',' nchan='         !par
cpar     x               ,nchsjt,'(',nchjt,')'                      !par
cpar     x               ,'  time=',nint(times),'sec'               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Ending dwxbp symmetry ',kx,':',' nchan='
     x             ,nchsjt,'(',nchjt,')'
     x             ,'  time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C
C                                          -----------------------------
      ENDDO                                !END LOOP OVER TOTAL JP SYMMS
C                                          -----------------------------
C
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        if(btimex)then                                          !par
cpar          btimep=.false.                                        !par
cpar          call cpu_time(timef)                                  !par
cpar          times=timef-time0                                     !par
cparc                                                               !par
cpar          write(iw,*)'Ending proc',iam,' for dwxbp:'            !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar        endif                                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      ns=0                                                      !par
cpar      nr=0                                                      !par
cpar      itmp4=int(nomwrt)                                         !par
cparc                                                               !par
cpar      do m0=1,moggy                                             !par
cparc                                                               !par
cpar        call pomsend(ns,omega(1,1),nomwrt,omsend)               !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        call mpi_reduce(omsend,omrecv,itmp4,my_mpi_real,        !par
cpar     x                  mpi_sum,izero_mpi,mpi_comm_world,ier4)  !par
cparc                                                               !par
cpar        if(ier4.ne.0)write(0,*)'mpi_reduce: iam, ier=',iam,ier4 !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        if(iam.eq.0)call pomrecv(nomwrt,omrecv,nr,omega(1,1))   !par
cparc                                                               !par
cpar      enddo                                                     !par
cparc                                                               !par
cpar      if(iam.ne.0)go to 700                                     !par
cparc                                                               !par
C
C APPLY (DIPOLE) TOP-UP (OFF IF BTHRSH)
C
      IF(LRGLAM.GT.1)THEN
C
        WRITE(6,1002)LRGLAM
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,                                !par
cpar     x       'Top-up has been applied: lrglam=',lrglam          !par
cpar        else                                                    !par
          write(iw,*)'Top-up has been applied: lrglam=',lrglam
cpar        endif                                                   !par
        endif
        IF(BPRNT2)WRITE(6,716)
C
        LITLAM=LRGLAM/2                           !USE GLOBAL VALUE JA=0
        CO2S=D3QRT/LOG(EINF*DZ2)
C
        NOMT=0
        DO I=1,NMETAJ                                       !,NSPECL
c          IF(INDXJ(I).GT.0)THEN                               !NON-CORR
C
          DO J=I+ione1,NSPECJ                                !,NSPECL
c            IF(INDXJ(J).GT.0)THEN                             !NON-CORR
C
              NOMT=NOMT+1
              SS=OMGINF(NOMT)
C
              IF(SS.LT.DZERO)THEN                                !DIPOLE
                SS=SS*CO2S                     !CONVERT TO LINE STRENGTH
                DE=DSPECJ(J)-DSPECJ(I)
                DE=DE/DZ2
                DO M0=1,MENG0
                  EJ=DYY0(M0)/DZ2
                  EI=EJ+DE
C
                  CALL TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
                  if(bht)omt=omt/2             !for BHT(1970) comparison
c
                  OM=REAL(OMEGA(M0,NOMT),WP)
                  OMEGA(M0,NOMT)=OMEGA(M0,NOMT)+REAL(OMT,RP)
C
                  IF(BPRNT2)WRITE(6,717)I,J,SS,EI,EJ,DE,OM,OMT,OM+OMT
                ENDDO
              ENDIF
C
c              IF(NOMT.EQ.NOMWRT)GO TO 113                  !WE ARE DONE
c            ENDIF
          ENDDO
C
c          ENDIF
        ENDDO
C
      ELSE
C
        WRITE(6,1003)
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,'Top-up has *NOT* been applied!'!par
cpar        else                                                    !par
          write(iw,*)'Top-up has *NOT* been applied!'
cpar        endif                                                   !par
        endif
C
      ENDIF
C
c 113  CONTINUE
c
c fix top-up failure on high-e near-degenerate Born allowed transitions
c
      if(btop)then
        NOMT=0
        DO I=1,NMETAJ
          DO J=I+ione1,NSPECJ
            NOMT=NOMT+1
            OMB=OMGINF(NOMT)
            IF(OMB.GT.DZERO)THEN                                   !born
              DE=DSPECJ(J)-DSPECJ(I)
              DE=MAX(DE,D1M30)
              OM=REAL(OMEGA(2,NOMT),WP)
              DO M0=3,MENG0                        !skip threshold point
                RAT=DYY0(M0)/DE
                OM1=OM
                OM=REAL(OMEGA(M0,NOMT),WP)
                IF(RAT.GT.XBTEST.AND.OM.LT.D0PT8*OM1.AND.OM1.LT.OMB)THEN
                  MM=M0-1              !max(2,m0-1) if no threshold skip
                  GO TO 196
                ENDIF
              ENDDO
              M0=MENG0
              MM=M0+1
              IF(OM1.GE.OMB)THEN
                IF(OM.LT.OMB)MM=MENG0
              ELSE
                IF(OM.LT.OM1)MM=MENG0
              ENDIF
  196         IF(BPRNT2.AND.MM.LE.MENG0)THEN
                WRITE(6,762)I,J,DYY0(M0),DE,RAT,
     X                        (OMEGA(M,NOMT),M=1,MENG0),OMB
              ENDIF
              DO M0=MM,MENG0
                OMEGA(M0,NOMT)=REAL(OMB,RP)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      endif
c                                                                     !x
c test convert to cross section                                       !x
c                                                                     !x
c      nomt=0                                                         !x
c      do i=1,nmetaj                                                  !x
c        j=indxj(i)                                                   !x
c        wi=jn(j)+1                                                   !x
c        do j=i+ione1,nspecj                                          !x
c          nomt=nomt+1                                                !x
c          de=dspecj(j)-dspecj(i)                                     !x
c          do m0=1,moggy                                              !x
c            ej=dyy0(m0)                                              !x
c            ei=ej+de                                                 !x
c            if(brel)ei=ei+dalf4*ei*ei          !wavenumber           !x
c            om=real(omega(m0,nomt),wp)                               !x
c            om=xconv*om/(ei*wi)                                      !x
c            omega(m0,nomt)=real(om,rp)                               !x
c          enddo                                                      !x
c        enddo                                                        !x
c      enddo                                                          !x
C
C-----------------------------------------------------------------------
C
C WRITE TOTALS
C
      IF(BTHRSH)THEN
        WRITE(6,1001)
        IF(BPRNT0)THEN
          WRITE(6,1118)((I,J,J=I+ione1,NSPECJ),I=1,NMETAJ)      !ROWWISE
          DO M0=1,MOGGY
            WRITE(6,200)REAL(M0-1+LVMIN),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ELSE
        WRITE(6,1000)
        IF(BPRNT0)THEN
          WRITE(6,1117)((I,J,J=I+ione1,NSPECJ),I=1,NMETAJ)      !ROWWISE
          DO M0=1,MENG0                                         !=MOGGY
            WRITE(6,200)DYY0(M0),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ENDIF
C
      IF(IUNIT(IU).GT.0)THEN
c        if(iunit(iuls).lt.0)then                     !same status as IU
        OPEN(IULS,FILE='OMGINFLS',STATUS='OLD')
        CLOSE(IULS,STATUS='DELETE')                             !tidy-up
        IUNIT(IULS)=-1
c        endif
        CLOSE(IU,STATUS='DELETE')
        IF(BTHRSH.or..not.bomega)THEN
          IUNIT(IU)=-1
        ELSE
          OPEN(IU,FILE='OMEGAIC',STATUS='REPLACE')  !OPEN UNDER NEW NAME
CTBD        OPEN(IU,FILE='OMEGAUIC',STATUS='REPLACE',FORM='UNFORMATTED')
          WRITE(IU,*)NZION,MION
          WRITE(IU,*)NSPECJ,-(MENG0+1),NOMWRT      !FLAG NO E'S .LT.0
          WRITE(IU,*)('  0',IWRK3(I),I=1,NSPECJ)
          WRITE(IU,711)(DWRK(I),I=1,NSPECJ)
          DO M0=1,MENG0                                          !=MOGGY
            WRITE(IU,713)DYY0(M0)/DZ2,(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
          WRITE(IU,713)EINF,(OMGINF(N),N=1,NOMWRT)
          IUNIT(IU)=-1
          CLOSE(IU)
        ENDIF
      ENDIF
C
C OVERWRITE PWB ADF04 WITH DW, TAKING ACCOUNT OF THE FACT THAT THE PWB
C DOES NOT CONTAIN (SPIN) FORBIDDEN TRANSITIONS
C
      IF(IUNIT(IUU).GE.0)THEN           !NO ADF04, LIKELY SINCE RAD='NO'
        WRITE(6,*)'NO ADF04 FILE="adf04ic"...'
        WRITE(0,*)'NO ADF04 FILE ON UNIT=',IUU
C        NF=-1
        GO TO 700
      ELSEIF(IUNIT(IUU).LT.0)THEN
        IUNIT(IUU)=1
        OPEN(IUU,FILE='adf04ic',STATUS='OLD',ERR=700)
      ENDIF
C
      BEXP=.FALSE.                              !*MUST* SYNC WITH DIAGFS
      IF(NSPECJ.LT.1000)THEN
        i1=0
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
            F767='(18X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
            F767='(16X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2)/(18X,20(1PE10.2)))'
            F762='(2I4,21(1PE10.2)/(18X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3)/(16X, 20(A5, A3)))'
            F762='(2I4, 21(A5, A3)/(16X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ELSE
        i1=1
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
            F767='(20X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
            F767='(18X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2)/(20X,20(1PE10.2)))'
            F762='(2I5,21(1PE10.2)/(20X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3)/(18X, 20(A5, A3)))'
            F762='(2I5, 21(A5, A3)/(18X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ENDIF
C
      MSC0=80
      OPEN(MSC0,STATUS='SCRATCH',FORM='FORMATTED')
      IF(.NOT.BEXP)THEN
        MSCP=81
        OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
      ENDIF
C
      DO N=1,NSPECJ+2
        READ(IUU,760)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
      NNN=max(NOMWRT,nomwr0)
C
      DO N=1,NNN+2
        READ(IUU,760,END=115)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
 115  REWIND(IUU)
      REWIND(MSC0)
C
      DO N=1,NSPECJ+2
        READ(MSC0,760)CARD
        WRITE(IUU,760)CARD
      ENDDO
C
      IF(BTHRSH)THEN
        ITYPE=6
        WRITE(IUU,F767)(PSHFT0(M-1+LVMIN),M=1,MOGGY)
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(REAL(M-1+LVMIN),M=1,MOGGY)
        ELSE
          WRITE(MSCP,764)(REAL(M-1+LVMIN),M=1,MOGGY)
        ENDIF
      ELSE
        ITYPE=5
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(DYY0(M),M=1,MENG0)   !=MOGGY
        ELSE
          WRITE(MSCP,764)(DYY0(M),M=1,MENG0)                     !=MOGGY
        ENDIF
      ENDIF
C
      IF(BEXP)THEN
        READ(MSC0,F761)
      ELSE
        BACKSPACE(MSCP)
        READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
        iexp(0)='   '
        READ(MSC0,F761)XMANT(0)                                !,IEXP(0)
        WRITE(IUU,F761)XMANT(0),IEXP(0),ITYPE
     X               ,(XMANT(M),IEXP(M),M=1,MOGGY)
      ENDIF
C
      MENG1=MOGGY+1
      IB0=1
      JB0=IB0+IONE1
c
      ntr=0
C
      DO N=1,NNN+1
C
        IF(BEXP)THEN
          READ(MSC0,F762)JB,IB,XB0,(DUM,I=1,MXNXB),XB1
        ELSE
          READ(MSC0,F762)JB,IB,XMANT0,IEXP0,
     X             (XMANT(I),IEXP(I),I=1,MXNXB),XMANT1,IEXP1
        ENDIF
C
        JB1=JB
        IF(JB.LT.0)THEN
          JB1=NSPECJ
          IB=MIN(JB1-IONE1,NMETAJ)
          IF(BEXP)THEN
            XB0=D1M30
            XB1=DZERO
          ELSE
            XMANT0=' 1.00'
            IEXP0='-30'
            XMANT1=' 0.00'
            IEXP1='+00'
          ENDIF
        ENDIF
C
        IF(BEXP)THEN
          X0=D1M30
          X1=DZERO
        ELSE
          XMANT(0)=' 1.00'
          IEXP(0)='-30'
          XMANT(MENG1)=' 0.00'
          IEXP(MENG1)='+00'
        ENDIF
C
        DO JT=JB0,JB1
          IF(JT.EQ.JB1)THEN
            IB1=IB
          ELSE
            IB1=MIN(JT-IONE1,NMETAJ)
          ENDIF
          DO IT=IB0,IB1
C
ctest        if(ione1.eq.0.or.it.ne.jt)then   !catch ione1=0 diagfs only
            ntr=ntr+1
c
            NOMT=IROW(IT,JT,IONE1,NSPECJ)
C                                            !TEST MENG0 STILL IF BTHRSH
            IF(OMEGA(MENG0,NOMT).GT.TOLO)THEN          !SKIP SA-SAP.GT.1
c
c              if(omginf(nomt).lt.dzero)then  !test write reduced dipole
c                do m=1,moggy
c                  de=log(dyy0(m)+2.7183)
c                  omega(m,nomt)=omega(m,nomt)/de
c                enddo
c              endif
C
              IF(BEXP)THEN
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  X0=XB0
                  X1=XB1
                ENDIF
                WRITE(IUU,F762)JT,IT,X0,(OMEGA(M,NOMT),M=1,MOGGY),X1
              ELSE
                BACKSPACE(MSCP)
                WRITE(MSCP,764)(OMEGA(M,NOMT),M=1,MOGGY)
                BACKSPACE(MSCP)
                READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  XMANT(0)=XMANT0
                  IEXP(0)=IEXP0
                  XMANT(MENG1)=XMANT1
                  IEXP(MENG1)=IEXP1
                ENDIF
                WRITE(IUU,F762)JT,IT,(XMANT(M),IEXP(M),M=0,MENG1)
              ENDIF
C
            ENDIF
ctest        endif
          ENDDO
          IB0=1
        ENDDO
C
        IF(JB.LT.0)then
          if(ntr.ne.nomwrt)then                                !checksum
            write(6,*)'adf04 no. of transitions mis-match: ntr,nomwrt='
     x                ,ntr,nomwrt
            write(0,*)'adf04 no. of transitions mis-match'
            nf=-1
            go to 700
          endif
          GO TO 120
        endif
C
        JB0=JB
        IB0=IB+1
C
      ENDDO
C
      WRITE(0,*)'SR.DWXBP: HAVE NOT REACHED END OF adf04ic...'
      WRITE(6,*)'SR.DWXBP: HAVE NOT REACHED END OF adf04ic...'
      NF=-1
      GO TO 700
C
  120 WRITE(IUU,F762)-1
      WRITE(IUU,F762)-1,-1
c
        if(.not.badas)then                           !adas skip comments
      WRITE(IUU,758)
C
      NREC=1
  121 NREC=NREC+1
      BACKSPACE(5)
      BACKSPACE(5)
      READ(5,766)CARD4
      IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
      REWIND(5)
C
      DO N=1,NREC
        READ(5,760)CARD
        WRITE(IUU,759)CARD
      ENDDO
      DATE='        '
      CALL DATE_AND_TIME(DATE)
      WRITE(IUU,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X             ,DATE(3:3),DATE(4:4)
        endif
C
      IUNIT(IUU)=-1
      CLOSE(IUU)
C
      CLOSE(MSC0)
      IF(.NOT.BEXP)CLOSE(MSCP)
C
C-----------------------------------------------------------------------
C
  700 CONTINUE
C
      DEALLOCATE (KACT,KTMP,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 999
      ENDIF
C
  800 CONTINUE
C
      DEALLOCATE (RHO1,RHO2,TEMP,OMGINF,OMEGA,STAT=IERR)
cparc                                                               !par
cpar      deallocate (omsend,omrecv,stat=ierr)                      !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 999
      ENDIF
C
  900 DEALLOCATE (TFU,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXBP: DEALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 999
      ENDIF
C
  998 CONTINUE
C
      DEALLOCATE (NADRUG,NTGJ)
      DEALLOCATE (TMP,OMP)
      DEALLOCATE (IEXP,XMANT)
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
  999 CONTINUE
C
C-----------------------------------------------------------------------
C
      if(btimep)then
        call cpu_time(timef)
        times=timef-time0
c
C        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for dwxbp:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending dwxbp: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
C        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C
  200 FORMAT(F21.3,2X,1P,10(E11.3)/(23X,10(E11.3)))
  201 FORMAT(2I6,3X,2I5,2X,1P,10(E11.3)/(27X,10(E11.3)))
  202 FORMAT(2I6,3X,2I5,2X,1PE11.3,10X,'E(',I2,')   ',A11)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  716 FORMAT(3X,'CH',2X,'CHP',9X,'S',14X,'EI',10X,'EJ',10X,'DE',
     X9X,'OMEGA(PAR)',2X,'OMEGA(TOP)',4X,'OMEGA(TOT)')
  717 FORMAT(2I5,3X,1PE11.3,2X,0P,3F12.4,5X,2F12.4,2X,F12.4)
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  762 FORMAT(2I5,22(1PE10.2))
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE DISTORTED-WAVE'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  995 FORMAT(1X,3I10,13X,I7,3I5,F19.8)
  996 FORMAT(10X,'K',8X,'LV',8X,' T',17X,'2*S+1  L   2J   CF',9X,
     X      '(EK-E1)/RY',15X,'NMETAJ=',I5)
  997 FORMAT(//' *** FULLY UNITARIZED K- TO T-MATRIX CONVERSION ***'//)
 1000 FORMAT(///1X,136('-')//51X,
     X       '*** TOTAL COLLISION STRENGTHS (BP) ***'//1X,136('-')//)
 1001 FORMAT(///1X,136('-')//45X,
     X       '*** THRESHOLD PARTIAL COLLISION STRENGTHS (BP) ***'//
     X      1X,136('-')//)
 1002 FORMAT(//' *** TOP-UP HAS BEEN APPLIED: LRGLAM=',I5//)
 1003 FORMAT(//' *** TOP-UP HAS *NOT* BEEN APPLIED ***'//)
 1110 FORMAT(//1X,136('-')///
     X   49X,'*** TARGET ENERGIES (IC) ***'/)
 1111 FORMAT(//1X,136('-')/)
 1112 FORMAT(' SYJ=',I3,5X,'2J P =',I4,I3,5X,'NCHJT=',I6,2X,'(',I6,')')
 1113 FORMAT(//' SY1=',I3,5X,'(2S+1) L P =',I3,I4,I3)    !/1X,34('-'))
 1114 FORMAT(//' SYJ=',I3,5X,'2J P =',I4,I3/1X,25('-'))
 1115 FORMAT(//' SY2=',I3,5X,'(2S+1) L P =',I3,I4,I3)    !/1X,34('-'))
 1116 FORMAT(/4X,'CH',3X,'CHP',7X,'K',3X,'KP',4X,'OMEGA(IE=1,MENG):')
 1117 FORMAT(74X,'OMEGA(K-KP)'/74X,11('-')/2X,'*FINAL* ENERGY(RYD)'
     X      ,2X,10(I5,'-',I5)/(23X,10(I5,'-',I5)))
 1118 FORMAT(74X,'OMEGA(K-KP)'/74X,11('-')/1X,'*FINAL* RYDBERG A.M.'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1150 FORMAT(/'    NCYC SY   CH  CHP     MNF  MNR',6(3X,'I(R)  F(A,...)'
     X))
 1201 format(i9,i5,2i4,2i5,i9,i6,6(i6,f9.4))
 1202 format(i9,i5,2i4,2i5,i9,i6,6(i6,f9.4)/(47x,6(i6,f9.4)))
 1996 FORMAT(/' *** UPDATING SLATER INTEGRALS FOR LTOT=',
     X       I3/1X,42('-')/)
 1997 FORMAT(/' *** UPDATING MAGNETIC INTEGRALS FOR 2*JTOT=',
     X       I3/1X,46('-')/)
 3050 FORMAT(7X,'NP',2X,'SYJ',2X,'SY',1X,'SYP',3X,'CH',2X,'CHP',7X,
     X'CN',3X,'IND',6(3X,'I(Y)  X(A-D)'))
 9119 format(i8,i3, 2i5, i8,i5, 6(i6,f11.6))
 9120 format(i8,i3, 2i5, i8,i5, 6(i6,f11.6)/(34x,6(i6,f11.6)))
 9121 format((34x,6(i6,f11.6)))
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION ICOL(ILI,ILF,IONE1)
C
      ICOL=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      END FUNCTION ICOL
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DWXBP_DDOT
C
C                             *******************
C
      SUBROUTINE DWXLS(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
C
C-----------------------------------------------------------------------
C
C  SR.DWXLS WRAPPER
C
C  IT CALLS:
C    SR.DWXLS_DAXPY
C    SR.DWXLS_DDOT
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
C
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
C
      IF(XMIX.LT.DZERO)THEN
        CALL DWXLS_DDOT(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                 ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
      ELSE
        CALL DWXLS_DAXPY(FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                  ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
      ENDIF
C
      RETURN
C
      END SUBROUTINE DWXLS
C
C                             *******************
C
      SUBROUTINE DWXLS_DAXPY
     X                (FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
C
C-----------------------------------------------------------------------
C
C  SR.DWXLS CALCULATES EIE 2-BODY NFS COLLISION STRENGTHS IN LS-COUPLING
C
C  IT CALLS:
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.PQ
C    SR.PQLAP
C    FN.QPTLS
C    SR.RADCNX
C    SR.SLATRX
C    SR.TOP1
C    SR.TOP2
C    FN.XINT
C
C  IT CONTAINS:
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,comm_barrier               !par
cpar      use mpi, only : mpi_real4,mpi_real8,mpi_integer           !par
cpar     x               ,mpi_sum,mpi_comm_world                    !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
C
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXD13=500)
      PARAMETER (MXD14=100)
C
      PARAMETER (MXNXB=10)    !NO. OF BPW X-VALUES PRE-EXISTING IN ADF04
C
      PARAMETER (D0PT8=0.8D0)
C
      INTEGER(SP) QPTLS                        !DO NOT USE SHORT INTEGER
C
      INTEGER(SP) SA,SAP
cparc                                                               !par
cpar      integer(kind(mpi_integer))itmp4,ier4,izero_mpi,my_mpi_real!par
cpar      parameter (izero_mpi=0)                                   !par
cparc                                                               !par
cpar      real(rp) omsend,omrecv                                    !par
C
      REAL(RP) OMEGA,E1M30
      PARAMETER (E1M30=1.E-30)
      PARAMETER (XBTEST=DFIVE)          !APPLY btop ONLY FOR X.GT.XBTEST
C
      CHARACTER(LEN=3) IEXP,IEXP0,IEXP1
      CHARACTER(LEN=4) CARD4
      CHARACTER(LEN=5) XMANT,XMANT0,XMANT1
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=15) F767
      CHARACTER(LEN=35) F762
      CHARACTER(LEN=44) F761
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: RHO1(:,:),RHO2(:,:),OMEGA(:,:),TFU(:)
     X              ,TEMP(:,:),OMGINF(:),KACT(:,:),KTMP(:)
cpar      allocatable :: omsend(:),omrecv(:)                        !par
c
      allocatable :: rhom(:,:),wrkp(:),wrkq(:),iwrkn(:),iwrkl(:)
     x              ,work(:)
C
      ALLOCATABLE :: IEXP(:),XMANT(:)
      ALLOCATABLE :: NADRUG(:),TMP(:,:),OMP(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
C
      DIMENSION PSHFT0(0:20)
c
      dimension bswap(mxd13)
      dimension ntest(1,1)                     !check channel set-up
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
c      COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C      COMMON /WORKLS/DWRK(MAXTM),IWRK3(MAXTM),IWRK4(MAXTM)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
c      common /nrbrel/irel,kappa,igagr,irtard,ibreit,brel,bjumpr,bmvd !x
c
      common /hps/badas
C
      DATA LOLD/-1/,IU/23/,IUU/25/
c                 omginfls adf04ls
C
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DWXSL_DAXPY
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
C-----------------------------------------------------------------------
C
c some cross section units options: need to uncomment code above and  !x
c below labeled "!x"                                                  !x
c                                                                     !x
c      xconv=done                   !pi*a_0^2                         !x
c      xconv=xconv*acos(-done)      !a_0^2                            !x
c      xconv=xconv*28.003d0         !Mbarns                           !x
c      xconv=xconv*1.d6             !barns                            !x
c
c flag write of "OMEGA" file - this is by final scattered energy and so
c *not* directly usable by R-matrix utility codes such as xtrct/adasexj.
c this is somewhat historic as adasexj *does* read/process dw adf04 file
c
      bomega=.false.
c
c elastic switch (normally ione1=1, no elastic. ione1=0 inc elastic)
c now set by user in algeb, and passed thru /nrbdwm/ as needed.
c
cold  ione1=1
c
c test: DO NOT CHANGE!
cold  ione0=0                   !algxls ione1, elastic needed for mixing
c
c some test set-up switches that user joe should not need to touch.
c
      bht=.false.                  !.true. for bht(1970) test comparison
c
c set (approx) unitarity switch
c
      bunit=.true.
      if(bht)bunit=.false.
c
c set approximation-ii unitarization switch - needs the full rho-matrix
c (.and.. not.bthrsh, i.e. lvmax.lt.0) only coded for F95.
c currently, in principle, only for use at medium to high energies
c since it still works with the final scattered energy, but seems to
c work well down to low-e as well - strongest coupling with nearby
c states, i.e. ones calculated at the same/similar relative energy.
c
      bunit2=nmeta.ge.nspece.and.ione1.eq.0.and.lvmax.lt.0
c
c set print of approx r(tau=0)-matrix as opposed to rho(tau)-matrix
c *MUST* use full T=-2iR/(1-iR) if converting via R-matrix.   (not done)
c can only use weak coupling T=-2i*rho for rho-matrix -see bunit2 above.
c
      brmx=.false.
      if(jprint.eq.4)brmx=.true.
c
c set mixing switch, can test interpolation followed by mixing (false).
c
      bmix=xmix.ge.dzero                !default xmix->.true.
      xmix=abs(xmix)
c
c checks channel set-up (needs ntest dimensione1d)
c
      bntest=.false.                    !ione1.eq.0.and.jprint.ge.2
c
      bntest=bntest.and.nmeta.ge.nspece
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD(NCOR)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
cparc                                                               !par
cpar      if(rp.eq.4)then                                           !par
cpar        my_mpi_real=mpi_real4                                   !par
cpar      elseif(rp.eq.8)then                                       !par
cpar        my_mpi_real=mpi_real8                                   !par
cpar      else                                                      !par
cpar        if(iam.eq.0)write(iw,*)'error rp precsion =',rp         !par
cpar        go to 999                                               !par
cpar      endif                                                     !par
C
C-----------------------------------------------------------------------
c
      btimep=btimex                                        !for iam.ne.0
      if(btimex)then
c        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for dwxls'           !par
cpar        else                                                    !par
          write(iw,*)'Starting dwxls'
cpar        endif                                                   !par
c        endif
        call cpu_time(timei)
        time0=timei
      endif
      btimet=btimex  !.false.                             !debug timings
C
C INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TPI=DTWO*PI
C
      BPRNT1=JPRINT.GE.1                       !PRINT CHANNEL INFO AGAIN
      BPRNT2=JPRINT.GE.2                    !FOR DETAILED OMEGA PRINTOUT
      BPRNT3=JPRINT.GE.3                      !FOR DETAILED RHO PRINTOUT
      BPRNT0=JPRINT.NE.-3
C
      KOLDOO=KUTOOX
      BKUTOO=KUTOOX.NE.0
C
CL      LAPAK=1                                                  !LAPACK
C
      IF(NZION.EQ.MION)THEN
        NZA=0
        DZ2=DONE
      ELSE
        NZA=NZION-MION
        DZ2=NZA*NZA
      ENDIF
C
      LSTORE=0                                 !TRIVIAL INTEGRAL STORAGE
C
      IF(MAXLT.GE.0)THEN
        IF(LRGLAM.GT.MAXLT)THEN
          WRITE(0,*)'*** SR.DWXLS: LRGLAM.GT.MAXLT, SO NO TOP-UP'
          LRGLAM=-1
        ELSE
          IF(LRGLAM.EQ.-999)LRGLAM=MAXLT
        ENDIF
        IF(LRGLAM.EQ.0)LRGLAM=-1
      ENDIF
C
      IF(LRGLAM.GE.0)THEN        !SET L WHERE DIPOLE TOP-UP NEEDS CHECKS
        LRGLMN=LRGLAM-QCL0
      ELSE
        LRGLMN=1000
      ENDIF
c
      btop=btop.and.lrglam.ge.0
C
C SMALL LOCAL MEMORY
C
      MXD4=MAX(MENG,10_SP)+3
      ALLOCATE (IEXP(0:MXD4),XMANT(0:MXD4))
      ALLOCATE (TMP(MENG,MENG),OMP(MENG))
      ALLOCATE (NADRUG(NSL0))
C
C SET POINTER TO START OF GROUP IN MIXING COEFFICIENT ARRAY TFU
C
      MC=0
      NCMX=0
      DO N0=1,NSL0
        NADRUG(N0)=MC
        NC=NSL(N0)
        NCMX=MAX(NCMX,NC)                        !MAX NO TERMS IN GROUP
        MC=MC+NC*NC
      ENDDO
C
C RECOVER TARGET MIXING COEFFICIENTS
C
      READ(MR)NCTOT
C
      if(nctot.ne.mc)stop 'dwxls:nctot index error'    !shouldn't happen
C
      ALLOCATE (TFU(NCTOT),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 998
      ENDIF
C
      READ(MR)(TFU(I),I=1,NCTOT)
C
C LOOK FOR LAST SPECTROSCOPIC ENERGY
C
c      NSPECL=0
c      DO N=1,NENERG
c        NSPECL=MAX(NSPECL,JNDEX(N))
c      ENDDO
C
C USE ROWWISE TO SIMPLY REDUCE NDIM2 IF NMETA.LT.NSPECE
C
      NOMTG=NCMX*NCMX                               !NEED ALL FOR MIXING
      nmin=min(NMETA,NSPECE)
      NOMWRT=IROW(nmin,NSPECE,ione1,NSPECE)                     !ROWWISE
      NOMWR0=NOMWRT
ctest    if(ione1.eq.1)nomwr0=nomwr0+nmin      !incase ione1=0 in diagon
C
C
      BTHRSH=LVMAX.GE.0
      IF(BTHRSH)THEN
        MOGGY=LVMAX+1-LVMIN
      ELSE
        MOGGY=MENG0
      ENDIF
C
      ALLOCATE (RHO1(MTRAN,NOMTG),RHO2(MTRAN,NOMTG),TEMP(MTRAN,NCMX)
     X        ,OMGINF(NOMWR0),OMEGA(MOGGY,NOMWRT),STAT=IERR)
cparc                                                               !par
cpar      allocate (omsend(nomwrt),omrecv(nomwrt),stat=ierr)        !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 900
      ENDIF
C
      DO N=1,NOMWRT
        OMGINF(N)=DZERO
        DO M=1,MOGGY
          OMEGA(M,N)=0
        ENDDO
      ENDDO
C
C RECOVER INFINITE ENERGY INFO (ROWWISE)
C
      IF(IUNIT(IU).EQ.0)THEN                   !ADF04 WILL BE INCOMPLETE
        WRITE(6,*)'NO INFINITE ENERGY FILE="OMGINFLS"...'
        WRITE(0,*)'NO INFINITE ENERGY FILE ON UNIT=',IU
        IF(LRGLAM.GE.0)THEN
          WRITE(6,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          WRITE(0,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          NF=-1
          GO TO 800
        ELSE
          GO TO 110
        ENDIF
      ELSEIF(IUNIT(IU).LT.0)THEN
        OPEN(IU,FILE='OMGINFLS',STATUS='OLD',ERR=110)
        IUNIT(IU)=1
      ELSE                               !SERIAL SHOULD NOT BE HERE
        REWIND(IU)                       !BUT PAR ALREADY OPEN
cpar        if(iam.eq.0)then                                        !par
        stop 'dwxls: omginfls confusion'
cpar        endif                                                   !par
      ENDIF
C
      READ(IU,*)NZDUM,MDUM
      READ(IU,*)NSPEC0,MENGB,NOMWR0
C
      IF(NSPEC0.NE.NSPECE)THEN                   !SHOULD NOT HAPPEN, NOW
        WRITE(6,*)'DWXLS: INFINITE ENERGY TARGET MISMATCH',NSPEC0,NSPECE
        WRITE(0,*)'DWXLS: INFINITE ENERGY TARGET MISMATCH'
        NF=-1
        GO TO 800
      ENDIF
C
      ALLOCATE (DWRK(NSPEC0),IWRK3(NSPEC0),IWRK4(NSPEC0))
C
      READ(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPEC0)
      READ(IU,711)(DWRK(I),I=1,NSPEC0)
C
c optionally recover spec energy subset from omginf,
c and retain full-set in denerg back in algx.
c
c      do i=1,nspec0
c        dwrk(i)=dwrk(i)*dz2
c      enddo
c
      iflag=0
      if(nomwrt.ne.nomwr0)then       !should not happen in non-test mode
        if(ione1.eq.0)then                             !elastic in dwxls
          if(nomwrt-nmin.ne.nomwr0)then
            write(6,*)'dwxls: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxls: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=1 in diagon
            iflag=1
          endif
        else                                         !inelastic in dwxls
          if(nomwrt+nmin.ne.nomwr0)then
            write(6,*)'dwxls: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxls: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=0 in diagon
            iflag=2
          endif
        endif
      endif
C
      READ(IU,713)EINF,(OMGINF(I),I=1,NOMWR0)
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        IUNIT(IU)=-1                                            !par
cpar        CLOSE(IU)                                               !par
cpar      endif                                                     !par
c
      if(iflag.eq.1)then                          !make room for elastic
        n=nomwrt+1
        nshft=nmin
        do i=nmin,1,-1
          do j=nspec0,i+1,-1
            n=n-1
            omginf(n)=omginf(n-nshft)
          enddo
          n=n-1
          omginf(n)=done                             !flag poss. allowed
          nshft=nshft-1
        enddo
        if(n.ne.1)stop 'iflag=1 nshft error'
      elseif(iflag.eq.2)then                               !drop elastic
        n=0
        nshft=1
        do i=1,nmin
          do j=i+1,nspec0
            n=n+1
            omginf(n)=omginf(n+nshft)
          enddo
          nshft=nshft+1
        enddo
        if(n.ne.nomwrt)stop 'iflag=2 nshft error'
      endif
C
  110 CONTINUE
C
C WRITE-OUT SPEC. TARGET ENERGIES
C
      WRITE(6,1110)
      WRITE(6,996)NMETA
C
      DO J=1,NSPECE
        I=INDEX(J)
        JJ=NFQ(I)
        II=(1-QPI(JJ))*(QSI(JJ)+1)
        WRITE(6,995)J,I,II,QLI(JJ)/2,NFK(I),DSPECE(J)
      ENDDO
C
      WRITE(6,1111)
C
C FLAG ACTIVE ORBITAL PAIR IN INTERACTING CONFIGS C.F. SR.ALGX BXIST0
C
      ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 800
      ENDIF
C
      DO KF=1,KMAX
        DO KG=1,KF
          KACT(KF,KG)=0
          KACT(KG,KF)=0
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)GO TO 52
            KACT(KF,KG)=QCG(I,KF)
            KACT(KG,KF)=KTMP(L0)
  51      ENDDO
  52    ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C BEGIN LOOP OVER SCATTERING SYMMETRIES
C
C-----------------------------------------------------------------------
C
      NCOR=0
c
      if(bunit2)write(6,997)
      iwait=0
      wait=done
C
      DO IX=1,INAST
C
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
C
        LNEW=IL
C
        IF(BKUTOO.AND.LNEW.GT.MAXLOO)THEN
          KUTOOX=0
          BKUTOO=.FALSE.
        ENDIF
C
C SEE IF WE NEED TO UPDATE INTEGRALS & CONTINUUM BASIS
C
        IF(LNEW.NE.LOLD)THEN
C
C-----------------------------------------------------------------------
C
          if(btimex)then
cc        if(abs(modd).gt.1)then   ADD IC FLAG
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                  ,'updating continuum for l=',il         !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)
     x         'Begin update of continuum basis & integrals for L=',lnew
cpar            endif                                               !par
cc        endif
c
            call cpu_time(timei)
            times=timei
          endif
C
C-----------------------------------------------------------------------
C
          lstep=lnew-lold
          if(lstep.gt.1.and.lfact.gt.100.and.lold.gt.0)then
            if(iwait.eq.4)then
              iwait=2
            else
              iwait=4
            endif
            wait=iwait*lstep
            wait=wait/dthree
          endif
C
C UPDATE CONTINUUM BASIS
C
          IF(BTHRSH)LCONDW=-LCONDW                            !FLAG
C
          CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3,LNEW,LOLD
     X               ,LCONDW,MXORB)
C
          IF(NF.LE.0)GO TO 700
C
C UPDATE EXCHANGE MULTIPOLE
C
          LDIFF=LNEW
          IF(LOLD.GE.0)LDIFF=LDIFF-LOLD
          LDIFF=LDIFF+LDIFF
C
          DO I=1,IRL
            IF(QRL(2,I).GT.MXORB)QRL(5,I)=QRL(5,I)+LDIFF  !EXCHANGE
          ENDDO
C
C UPDATE SLATER INTEGRALS (INC. 2NFS IF BKUTOO=.TRUE.)
C
          IF(BPRNT0)WRITE(6,1996)LNEW
C
          DO M=1,MTRAN
            M1=MNDEX(M,1)
            M2=MNDEX(M,2)
            IF(BKUTOO)THEN
              CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DRLX(1,M,LSTORE)
     X                   ,DZLX(1,M,LSTORE)
     X                   ,DXTWOX(1,M,LSTORE)
     X                   ,DETAX(1,M,LSTORE)
     X             ,M1,M2,LNEW,MAXLX,MXORB)
            ELSE
              CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DRLX(1,M,LSTORE)
     X                   ,DZLX(1,1,0)
     X                   ,DXTWOX(1,1,0)
     X                   ,DETAX(1,1,0)
     X             ,M1,M2,LNEW,MAXLX,MXORB)
            ENDIF
          ENDDO
C
          LOLD=LNEW
C
C-----------------------------------------------------------------------
C
          if(btimex)then
            call cpu_time(timef)
            times=timef-times
c
cc        if(abs(modd).gt.1)then
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                  ,'updating continuum'                   !par
cpar     x                 ,' time=',nint(times),'sec'              !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'End update of continuum basis & integrals'
     x               ,', time=',nint(times),'sec'
cpar            endif                                               !par
cc        endif
          endif
C
C-----------------------------------------------------------------------
C
        ENDIF
C
C
C INITIALIZE FOR LS-LOOP
C
        nwt=is
        if(il.gt.maxlx)nwt=-2*is+2
C
        IF(BPRNT1)WRITE(6,1115)IX,nwt,IL,IP
c
c count channels
c
        if(bprnt1)write(6,1112)
c
        nchlt=0
        nchs=0
c
        do n=1,nchg(ix)
          nc=itarg(n,ix)
          mc=nsl(nc)
          mci=ngrpi(nc)
          l1=llch(1,n,ix)
          l2=llch(2,n,ix)
          do l=l1,l2,4
            do m=1,mc
              j1=m+mci
              nchlt=nchlt+1
              if(jndex(j1).gt.0)then
                if(bprnt1)write(6,1113)nchlt,j1,l/2
                nchs=nchs+1
              endif
            enddo
          enddo
        enddo
c
        if(bntest)then
          do  i=1,nchlt
            do j=1,nchlt
              ntest(j,i)=0
            enddo
          enddo
        endif
c
c initialize for approximation-ii (memory hog)
c
        if(bunit2)then
c
          nx=(nchlt*(nchlt+1))/2
c
          allocate (rhom(nx,meng0),wrkp(nx),wrkq(nx),iwrkn(nchlt)
     x             ,iwrkl(nchlt),work(nchlt),stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxls: allocation fails for rhom,wrk'
            nf=0
            go to 700
          endif
c
          do i=1,nchlt
            iwrkn(i)=-1
            iwrkl(i)=-1
          enddo
c
          do m=1,meng0
            n=0
            do i=1,nchlt
              n=n+1
              rhom(n,m)=done
              do j=i+1,nchlt
                n=n+1
                rhom(n,m)=dzero
              enddo
            enddo
          enddo
c
        endif
C
        IF(.NOT.BPRNT0)then
          WRITE(6,1114)IX,nwt,IL,IP,nchs,nchlt
        ELSEIF(.not.BPRNT1)then
          WRITE(6,1119)IX,nwt,IL,IP,nchs,nchlt
        ENDIF
        IF(BPRNT2)WRITE(6,1116)
C
C-----------------------------------------------------------------------
C
        if(btimex)then
cc        if(abs(modd).gt.1)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'Starting proc',iam                     !par
cpar     x                ,'dwxls symmetry',ix,':',nwt,il,ip        !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Starting dwxls symmetry',ix,':',nwt,il,ip
cpar          endif                                                 !par
cc        endif
c
          call cpu_time(timei)
          times=timei
        endif
c
        if(btimet)then
          timeset=dzero
          timemix=dzero
           timemixi=dzero
           timemixf=dzero
           timemixir=dzero
           timemixfr=dzero
          timeunit=dzero
          timeint=dzero
        endif
C
C-----------------------------------------------------------------------
C
        nwt=abs(nwt)*(2*il+1)
C
        NCN=NCHG(IX)
C
        NCHI=0
        NCHI0=0
C
        DO NC0=1,NCN                     !BEGIN LOOP OVER INITIAL GROUPS
          L1=LLCH(1,NC0,IX)
          L2=LLCH(2,NC0,IX)
          NC=ITARG(NC0,IX)
          MC=NSL(NC)
          SA=QSI(NC)
          LA=QLI(NC)
          MCI=NGRPI(NC)
C
          NCHIP=0
          NCHIP0=0
C
          DO ND0=1,NC0                     !BEGIN LOOP OVER FINAL GROUPS
            L1P=LLCH(1,ND0,IX)
            L2P=LLCH(2,ND0,IX)
            ND=ITARG(ND0,IX)
            MCP=NSL(ND)
            SAP=QSI(ND)
C            IF(ABS(SA-SAP).GT.2)GO TO 68   !unnecessary...
            IF(NMETAG(NC)+NMETAG(ND).EQ.2)THEN
              NCHI=NCHI0+((L2-L1)/4+1)*MC
              NCHIP=NCHIP0+((L2P-L1P)/4+1)*MCP
              GO TO 68
            ENDIF
            LAP=QLI(ND)
            MCIP=NGRPI(ND)
C
            beqgrp=nc.eq.nd          !flag equal groups for filling rho1
c
c get lambda for non-dipole infnite energy top-up
c
            if(lnew.ge.lrglam)then
              if(sa.eq.sap)then
                litlam=0
                if(qpi(nc).ne.qpi(nd))then
                  litlam=3                         !for case of octupole
                else
                  if(la-lap.eq.0)then
                    if(la+lap.ge.4)litlam=2
                  else
                    litlam=abs(la-lap)/2
                  endif
                endif
              else
                litlam=-1
              endif
            endif
C
            NCHI=NCHI0
            DO LI=L1,L2,4                   !LOOP OVER INITIAL CHANNEL L
C
c set position of phase shift for this li
c only required by  elastic case for diagonal rho
c or if printing usual reactance matrix
c
              if(ione1.eq.0.or.brmx)then
                L=LCONDW/2+1-LNEW+LI/2
                L0=ABS(QPOS(L))
              endif
C
              lf2=l2p
              if(beqgrp)lf2=li
c
              NCHIP=NCHIP0
              DO LF=L1P,lf2,4                 !LOOP OVER FINAL CHANNEL L
c
                beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
c
                ncort=qptls(ix,nc0,nd0,li,lf)
c
                if(ncort.ne.ncor)then
                  write(0,*)ix,nc0,nd0,li,lf,ncor,ncort
                  stop 'ncor mis-match'
                endif
C
c set position of phase shift for this lf
c only need if printing usual reactance matrix, not needed by rho matrix
C
                if(brmx)then
                  L=LCONDW/2+1-LNEW+LF/2
                  L00=ABS(QPOS(L))
                endif
C
C-----------------------------------------------------------------------
C
C NOW FORM LS INTERACTION (BY TARGET SYMMETRY GROUP)
C*************************
C
C THIS IS IN THE RHO-I REPRESENTATION, WHERE
C |T^R(V,V')|=|T^RHO(V,V')| FOR CHANNELS V.NE.V'.
C WE USE T^RHO(V,V')=-2I*RHO(V,V'), WITH A 2X2 UNITARITY CONDITION.
C FOR V.EQ.V' T^R(V,V)~-2*TAN(TAU(V)), FOR RHO(V,V) SMALL.
C (IN GENERAL, WE ARE NOT INTERESTED IN ELASTIC TRANSITIONS.)
C
c
                if(btimet)call cpu_time(timei)
C
                NOMTG=MC*MCP
                DO N=1,NOMTG
                  DO M=1,MTRAN
                    RHO1(M,N)=DZERO
                  ENDDO
                ENDDO
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(kcutx.lt.0)j=abs(j)                !keep corr-corr
                  KF=NFK(J1)
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
                    J1P=MDP1+MCIP
                    IF(beqgrpl.and.J1P.GT.J1-ione0)GO TO 2  !sync algxls
c
                    jp=jndex(j1p)
                    if(j.lt.0.and.jp.lt.0)then  !omit cor-cor, as algxls
                      if(becor)then
                        ncor=ncor+1
                        go to 1
                      endif
                      go to 2
                    endif
C
                    N1=NAD(NCOR)+1
                    NCOR=NCOR+1
                    N2=NAD(NCOR)
c                                    write(73,*)ix,md1,mdp1,j,jp,ncor,n2
                    IF(N1.GT.N2)GO TO 1
                    KG=NFK(J1P)
c
c need to find if Slater integral initial and final states are swapped
c because of falling order. (algebraic are not swapped in LS.)
c
                    if(n2-n1+1.gt.mxd13)then
                      write(6,*)'***sr.dwxls: increase internal buffer',
     x                          ' mxd13 to', n2-n1+1
                      nf=-1
                      go to 700
                    endif
c
                    ks=0
                    do n=n1,n2
                      ks=ks+1
                      bswap(ks)=.false.
                      n0=int(nrk(n))
                      m0=qrl(1,n0)
                      if(li.eq.ql(m0))then
                        if(li.eq.lf.and.kf.ne.kg)then
                          m0=qrl(3,n0)
                          if(qn(m0).gt.0)then                  !exchange
                            if(m0.ne.kact(kg,kf))then              !swap
                              bswap(ks)=.true.
                            endif
c                         else             !direct and it doesn't matter
                          endif
c                       else           !distinct or kf=kg, so they can't
                        endif
                      else                         !trivially, they were
                        bswap(ks)=.true.
                      endif
                    enddo
C
                    NOMTG=(MDP1-1)*MC+MD1                   !rho1 (orig)
                    if(beqgrpl)nmteq=(md1-1)*mcp+mdp1
C
                    DO M=1,MTRAN
C
                      DD=DZERO
                      ks=0
                      DO N=N1,N2
                        ks=ks+1
c
                        if(bswap(ks))then !swap because of falling order
                          mm=mrndx(m)
                        else
                          mm=m
                        endif
c
                        N0=INT(NRK(N))
C
                        DD=DD+DRLX(N0,mm,LSTORE)*DRK(N)
                        IF(BKUTOO)THEN
                          DS=DZLX(N0,mm,LSTORE)
                          IF(BFALL(N))DS=-DS
                          DS=DS+DXTWOX(N0,mm,LSTORE)*DRK(N)
     X                      +DETAX(N0,mm,LSTORE)*DEK(N)
                          DD=DD+DS
                        ENDIF
                      ENDDO
C
                      RHO1(M,NOMTG)=RHO1(M,NOMTG)+DD            !UNMIXED
c
                      if(beqgrpl.and.nomtg.ne.nmteq)then  !pop lower tri
                        mm=mrndx(m)                        !need reverse
                        rho1(mm,nmteq)=rho1(mm,nmteq)+dd
                      endif
C
                    ENDDO
c
c                    write(6,777)j1,j1p,(rho1(m,nomtg),m=1,mtran)
c  777               format(2i5,1p,10d12.3/(10x,10d12.3))
C
   1              ENDDO                       !END LOOP OVER FINAL TERMS
C
   2            ENDDO                       !END LOOP OVER INITIAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeset=timeset+timef-timei
                  timei=timef
                endif
C
C-----------------------------------------------------------------------
C
                MX=MTRAN
C
C INTERP THEN MIX (APPROX)
C
               if(.not.bmix)then
C
                DO MDP1=1,MCP               !BEGIN LOOP OVER FINAL TERMS
C
                  J1P=MDP1+MCIP
                  JP=JNDEX(J1P)
C
                  NOMTG0=(MDP1-1)*MC
C
                  DO MD1=1,MC             !BEGIN LOOP OVER INITIAL TERMS
C
                    J1=MD1+MCI
                    J=JNDEX(J1)
C
                    NOMTG=NOMTG0+MD1                  !rho1 nomtg (orig)
C
                    IF(J.LE.JP)THEN   !INITIAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=J
                      JH=JP
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M1,M2)=RHO1(M,NOMTG)
                      ENDDO
C
                    ELSE                !FINAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=JP
                      JH=J
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M2,M1)=RHO1(M,NOMTG)
                      ENDDO
C
                    ENDIF
C
                    DE=DSPECE(JH)-DSPECE(JL)
C
                    NOMT=IROW(JL,JH,ione1,NSPECE)               !ROWWISE
c
                    bdip=.false.
                    if(jl.le.nmeta.and.jl.lt.jh)then        !need exists
                      bdip=omginf(nomt).lt.dzero            !flag dipole
                    endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                    DO M0=1,MENG0
C
                      M=IYY0(M0)
c
                      ml=mlim(m,1)
                      mu=mlim(m,2)
c
                      if(bdip)mu=-mu                        !flag dipole
C
                      RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu) !AS A.U.
C
                      RHO1(M0,NOMTG)=RHO
C
                    ENDDO
C
                  ENDDO                     !END LOOP OVER INITIAL TERMS
C
                ENDDO                         !END LOOP OVER FINAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeint=timeint+timef-timei
                  timei=timef
                endif
c
                mx=meng0                                         !re-set
c
               endif
C
C-----------------------------------------------------------------------
C
C NOW MIX (INITIAL)
C
                N0=NADRUG(NC)
                N0P=NADRUG(ND)
C                MCI=NGRPI(NC)
C                MCIP=NGRPI(ND)
C                MC=NSL(NC)
C                MCP=NSL(ND)
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
C
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(j.lt.0)go to 11                          !omit corr
                  if(j.gt.nmeta)go to 11            !omit non-metastable
c
                  if(bcorr.or.li.eq.lf)then
                    DO MDP1=1,MCP           !SEE IF WE HAVE A FINAL TERM
                      J1P=MDP1+MCIP
                      IF(J1P.GT.J1.and.li.eq.lf)GO TO 11
                      jp=jndex(j1p)
                      if(jp.gt.0)go to 5                          !we do
                    ENDDO
                    GO TO 11                                   !WE DON'T
                  endif
C
   5              N1=N0+(MD1-1)*MC                          !tfu pointer
C
                  DO MDP1=1,MCP                     !FOR EACH FINAL TERM
C
                    DO M=1,MX
                      TEMP(M,MDP1)=DZERO
                    ENDDO
C
                    NG0=(MDP1-1)*MC
                    DO LD1=1,MC                    !BEGIN INITIAL MIXING
C
                      NG=NG0+LD1                             !rho1 nomtg
                      N2=N1+LD1
                      TF=TFU(N2)
C
                      IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL           CALL DAXPY(MX,TF,RHO1(1,NG),IONE,TEMP(1,MDP1),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                        DO M=1,MX
                          TEMP(M,MDP1)=TEMP(M,MDP1)+RHO1(M,NG)*TF
                        ENDDO
CL                      ENDIF                                    !LAPACK
                      ENDIF
C
                    ENDDO                            !END INITIAL MIXING
C
c                    j1p=mdp1+mcip
c                    write(6,777)j1,j1p,(temp(m,mdp1),m=1,mx)
c
                  ENDDO                             !FOR EACH FINAL TERM
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixi=timemixi+timef-timei
                    timei=timef
                  endif
C
C NOW MIX (FINAL)
C
                  NOMTG0=(MD1-1)*MCP
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
C
                    J1P=MDP1+MCIP
                    IF(J1P.GT.J1.and.li.eq.lf)GO TO 11
                    if(j1.eq.j1p.and.ione1.ne.0)go to 10
c
                    jp=jndex(j1p)
                    if(jp.lt.0)go to 10                       !omit corr
c                    if(min(j,jp).gt.nmeta)go to 10      !non-metastable
C
                    N1P=N0P+(MDP1-1)*MCP
C
                    NOMTG=NOMTG0+MDP1                        !rho2 (new)
                    DO M=1,MX
                      RHO2(M,NOMTG)=DZERO
                    ENDDO
C
                    DO LDP1=1,MCP                    !BEGIN FINAL MIXING
C
                      N2P=N1P+LDP1
                      TF=TFU(N2P)
C
                      IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL        CALL DAXPY(MX,TF,TEMP(1,LDP1),IONE,RHO2(1,NOMTG),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                        DO M=1,MX
                          RHO2(M,NOMTG)=RHO2(M,NOMTG)+TEMP(M,LDP1)*TF
                        ENDDO
CL                      ENDIF                                    !LAPACK
                      ENDIF
C
                    ENDDO                              !END FINAL MIXING
C
c                    write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  10              ENDDO                       !END LOOP OVER FINAL TERMS
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixf=timemixf+timef-timei
                    timei=timef
                  endif
C
  11            ENDDO                       !END LOOP OVER INITIAL TERMS
C
C FIRST SEE IF WE NEED REVERSE CASE:
C----------------------------------
C
C  INITIAL & FINAL ARE ALGEBRAIC AND SO NMETA CAN BE IN EITHER/BOTH/NONE
C  BUT WE WANT THE FIRST MIXING MATRIX MULT TO BE FOR NMETA SO WE DON'T
C  NEED TO MULTIPLY BY THE ZERO BLOCK. THUS, WE MAKE A DOUBLE PASS. OF
C  COURSE, IF NMETA=NSPECE THEN THE SECOND PASS IS "SKIPPED".
C
                DO MDP1=1,NSL(NC)                   !CHECK INITIAL TERMS
                  J1P=MDP1+NGRPI(NC)
                  jp=jndex(j1p)
                  if(jp.gt.nmeta)go to 8                         !needed
                ENDDO
                GO TO 130                                      !ALL DONE
C
C NOW MIX (FINAL) - REVERSE CASE
C
   8            N0=NADRUG(ND)
                N0P=NADRUG(NC)
                MCI=NGRPI(ND)
                MCIP=NGRPI(NC)
                MC=NSL(ND)
                MCP=NSL(NC)
C
                DO MD1=1,MC                 !BEGIN LOOP OVER FINAL TERMS
C
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(j.lt.0)go to 13                          !omit corr
                  if(j.gt.nmeta)go to 13            !omit non-metastable
C
                  DO MDP1=1,MCP             !SEE IF WE HAVE INITIAL TERM
                    J1P=MDP1+MCIP
                    IF(J1P.LT.J1.and.li.eq.lf)GO TO 6
                    jp=jndex(j1p)
                    if(jp.gt.nmeta)go to 7                        !we do
   6              ENDDO
                  GO TO 13                                     !WE DON'T
C
   7              N1=N0+(MD1-1)*MC                          !tfu pointer
C
                  DO MDP1=1,MCP                   !FOR EACH INITIAL TERM
C
                    DO M=1,MX
                      TEMP(M,MDP1)=DZERO
                    ENDDO
C
                    DO LD1=1,MC                      !BEGIN FINAL MIXING
C
                      NG=MDP1+(LD1-1)*MCP                    !rho1 nomtg
                      N2=N1+LD1
                      TF=TFU(N2)
C
                      IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL           CALL DAXPY(MX,TF,RHO1(1,NG),IONE,TEMP(1,MDP1),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                        DO M=1,MX
                          TEMP(M,MDP1)=TEMP(M,MDP1)+RHO1(M,NG)*TF
                        ENDDO
CL                      ENDIF                                    !LAPACK
                      ENDIF
C
                    ENDDO                              !END FINAL MIXING
C
c                    j1p=mdp1+mcip
c                    write(6,777)j1,j1p,(temp(m,mdp1),m=1,mx)
c
                  ENDDO                           !FOR EACH INITIAL TERM
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixfr=timemixfr+timef-timei
                    timei=timef
                  endif
C
C NOW MIX (INITIAL) - REVERSE CASE
C
                  DO MDP1=1,MCP           !BEGIN LOOP OVER INITIAL TERMS
C
                    J1P=MDP1+MCIP
                    IF(J1P.LT.J1.and.li.eq.lf)GO TO 12
                    if(j1.eq.j1p.and.ione1.ne.0)go to 12
c
                    jp=jndex(j1p)
c                    if(jp.lt.0)go to 12                      !omit corr
                    if(jp.le.nmeta)go to 12              !already gotten
C
                    N1P=N0P+(MDP1-1)*MCP                    !tfu pointer
C
                    NOMTG=MD1+(MDP1-1)*MC              !rho2 nomtg (new)
                    DO M=1,MX
                      RHO2(M,NOMTG)=DZERO
                    ENDDO
C
                    DO LDP1=1,MCP                  !BEGIN INITIAL MIXING
C
                      N2P=N1P+LDP1
                      TF=TFU(N2P)
C
                      IF(ABS(TF).GT.XMIX)THEN
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL        CALL DAXPY(MX,TF,TEMP(1,LDP1),IONE,RHO2(1,NOMTG),IONE) !LAPACK
CL                      ELSE                                     !LAPACK
                        DO M=1,MX
                          RHO2(M,NOMTG)=RHO2(M,NOMTG)+TEMP(M,LDP1)*TF
                        ENDDO
CL                      ENDIF                                    !LAPACK
                      ENDIF
C
                    ENDDO                            !END INITIAL MIXING
C
c                    write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  12              ENDDO                     !END LOOP OVER INITIAL TERMS
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixir=timemixir+timef-timei
                    timei=timef
                  endif
C
  13            ENDDO                         !END LOOP OVER FINAL TERMS
C
C RE-SET
                MCI=NGRPI(NC)
                MCIP=NGRPI(ND)
                MC=NSL(NC)
                MCP=NSL(ND)
C
  130           CONTINUE
C
C-----------------------------------------------------------------------
C
C (IF bmix INTERPOLATE MIXED RHO2.) CONVERT TO TMX AND ADD TO OMEGA
C NOTE, RHO2 IS IN "A.U"
C ALLOW FOR ANY INITIAL ALGEBRAIC TERMS NOT BEING LOWEST IN ENERGY.
c
                if(.not.bmix)mx=-mx                  !skip interp set-up
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
C
                  J1=MD1+MCI
                  J=JNDEX(J1)
                  if(j.lt.0)go to 14                          !omit corr
C
                  NCH=NCHI+MD1
c hold
                  if(bunit2)then
                    iwrkn(nch)=j
                    iwrkl(nch)=l0
                  endif
C
                  NOMTG0=(MD1-1)*MCP
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
C
                    J1P=MDP1+MCIP
C
                    IF(J1P.GT.J1.and.li.eq.lf)GO TO 14
                    if(j1.eq.j1p.and.ione1.ne.0)go to 15
C
                    JP=JNDEX(J1P)
                    if(jp.lt.0)go to 15                       !omit corr
                    if(min(j,jp).gt.nmeta)go to 15       !non-metastable
C
                    NCHP=NCHIP+MDP1
c
c                    write(6,*)nch,nchp,j1,j1p,j,jp
c
                    if(bntest)ntest(nch,nchp)=ntest(nch,nchp)+1
c
c "undefined" should not be accessed by xint...
c                    do m2=1,meng
c                      do m1=1,meng
c                        tmp(m1,m2)=1.d70 !dzero      !test
c                      enddo
c                    enddo
C
                    NOMTG=NOMTG0+MDP1                  !rho2 nomtg (new)
C
                    IF(J.LE.JP)THEN   !INITIAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=J
                      JH=JP
                      NCHL=NCH
                      NCHH=NCHP
                      LUP=LF
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M1,M2)=RHO2(M,NOMTG)
                      ENDDO
C
                    ELSE                !FINAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=JP
                      JH=J
                      NCHL=NCHP
                      NCHH=NCH
                      LUP=LI
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M2,M1)=RHO2(M,NOMTG)
                      ENDDO
C
                    ENDIF
C
                    DE=DSPECE(JH)-DSPECE(JL)
C
                    NOMT=IROW(JL,JH,ione1,NSPECE)               !ROWWISE
c
                    if(nomt.gt.nomwrt)then        !shouldn't happen, now
                      write(0,*)jl,jh,nmeta,nspece,nomt,nomwrt
                      stop 'omega prob.'
                    endif
c
                    bdip=omginf(nomt).lt.dzero              !flag dipole
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                    DO M0=1,MENG0
C
                      M=IYY0(M0)
c
                     if(bmix)then                                !interp
c
                      ml=mlim(m,1)
                      mu=mlim(m,2)
c
                      if(bdip)mu=-mu                        !flag dipole
C
                      RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu) !AS A.U.
c
                     else                                  !already have
C
                      RHO=RHO2(M0,NOMTG)
c
                     endif
C
                      RHOSQ=RHO*RHO
c store for ii
                      if(bunit2)then
                        if(nchp.gt.nch)stop 'dwxls: channel reversal'
                        nx=irow(nchp,nch,izero,nchlt)
                        rhom(nx,m0)=rho
                        go to 16
                      endif
C
                      IF(NCH.eq.NCHP)THEN                   !DIAGONAL MX
c                        if(j1.ne.j1p.or.li.ne.lf)stop 'not diag'
C
                        IF(BRMX)THEN                    !USUAL REACTANCE
                          T=PI*PSHFTX(M,L0)
                          CT=COS(T)
                          ST=SIN(T)
                          RMX=(ST+RHO*CT)/(CT+RHO*ST)
                        ENDIF
C
                        IF(BPRNT3)WRITE(6,202)NCHL,NCHH,JL,JH
     X                                    ,PSHFTX(M,L0),M0,'PHASE SHIFT'
                        T=TPI*PSHFTX(M,L0)
                        C2T=COS(T)
                        S2T=SIN(T)
C
                        if(bunit)then                       !2x2 UNITARY
                          TSQ=DONE+(C2T*(RHOSQ-DONE)+DTWO*S2T*RHO)
     X                            /(RHOSQ+DONE)
                        else                                !non-unitary
                          tsq=done+(dtwo*s2t*rho-c2t)
                        endif
c
                        TSQ=TSQ+TSQ        !  T^R=1+EXP(2I*TAU)(T^RHO-1)
C
                      ELSE                                 !OFF DIAGONAL
C
                        IF(BRMX)THEN                    !USUAL REACTANCE
                          T1=TPI*PSHFTX(M,L0)
                          T2=TPI*PSHFTX(M,L00)
                          DET=COS(T1)*COS(T2)-RHOSQ*SIN(T1)*SIN(T2)
                          RMX=RHO/DET
                        ENDIF
C
                        TSQ=4*RHOSQ        !   |T^R(V,V')|=|T^RHO(V,V')|
C
                        if(bunit)TSQ=TSQ/(DONE+RHOSQ)**2 !APPROX UNITRTY
C
                        IF(J1.EQ.J1P)TSQ=TSQ+TSQ   !FOR ELASTIC LI.NE.LF
C
                      ENDIF
C
                      IF(BPRNT3)THEN
                        IF(BRMX)THEN
                          WRITE(6,202)NCHL,NCHH,JL,JH,RMX,M0,
     X                               'R-MATRIX  '
                        ELSE
                          WRITE(6,202)NCHL,NCHH,JL,JH,RHO,M0,
     X                               'RHO-MATRIX'
                        ENDIF
                      ENDIF
C
                      OMPW=wait*TSQ*NWT/DTWO
C
                      if(bht)ompw=ompw/2       !for BHT(1970) comparison
C
C LOOK AT TOP-UP ISSUES, IF L LARGE ENOUGH TO WARRANT IT (OFF IF BTHRSH)
C
                      IF(LNEW.GE.LRGLMN)THEN
C                                                     !NON-DIPOLE TOP-UP
                        IF(OMGINF(NOMT).GT.DZERO.and.litlam.gt.0)THEN
C
                          IF(LNEW.EQ.LRGLAM)THEN           !APPLY TOP-UP
                            EJ=DYY0(M0)
                            EI=EJ+DE
c
                            ompw0=ompw
                            ompw=ompw/wait
                            IF(BPRNT3)OMPW=-OMPW             !FLAG PRINT
C
                            CALL TOP2(LITLAM,LRGLAM,EI,EJ,OMPW)
C
                            ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                          ELSEIF(LNEW.GT.LRGLAM)THEN
                            OMPW=DZERO
                          ENDIF
C                                                  !DIPOLE:LITLAM=LRGLAM
                        ELSEIF(bdip)THEN                  !POSS ZERO-OUT
C                                                        !INC. IN TOP-UP
                          IF(MAX(LI,LF)/2.GT.LRGLAM)OMPW=DZERO
C
                        ENDIF
C
                      ENDIF
C
C ARCHIVE PARTIAL/TOTAL COLLISION STRENGTHS
C
                      IF(BTHRSH)THEN
                        M00=LUP/2+1-LVMIN
                        IF(M00.LT.1.OR.M00.GT.MOGGY)GO TO 15
                      ELSE                   !CASE NOT XCLUDED BY ALGXLS
                        M00=M0
                      ENDIF
C
                      OMP(M0)=OMPW
C                                                    !UPDATE TOTAL OMEGA
                      OMEGA(M00,NOMT)=OMEGA(M00,NOMT)+REAL(OMPW,RP)
C
  16                ENDDO                        !END LOOP OVER ENERGIES
C                                                         !PARTIAL OMEGA
                    IF(BPRNT2.and..not.bunit2)
     X              WRITE(6,201)NCHL,NCHH,JL,JH,(OMP(M0),M0=1,MENG0)
C
  15              ENDDO                       !END LOOP OVER FINAL TERMS
C
  14            ENDDO                       !END LOOP OVER INITIAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeint=timeint+timef-timei
                  timei=timef
                endif
C
C-----------------------------------------------------------------------
C
                NCHIP=NCHIP+MCP
              ENDDO                               !END LOOP OVER FINAL L
C
              NCHI=NCHI+MC
            ENDDO                               !END LOOP OVER INITIAL L
C
  68        NCHIP0=NCHIP0+((L2P-L1P)/4+1)*MCP!=NCHIP
            if(nchip0.ne.nchip)stop 'nchip0.ne.nchip'
c            write(0,*)nchip0,nchip
          ENDDO                              !END LOOP OVER FINAL GROUPS
C
          NCHI0=NCHI0+((L2-L1)/4+1)*MC     !=NCHI
          if(nchi0.ne.nchi)stop 'nchi0.ne.nchi'
c            write(0,*)nchi0,nchi
        ENDDO                              !END LOOP OVER INITIAL GROUPS
C
        if(bntest)then
          if(nch.ne.nchp)stop 'channel index error'
          do i=1,nch
            if(ntest(i,i).ne.1)then
                  write(0,*)'checksum wrong for nch,nch '
     x           ,i,' :',ntest(i,i)
            endif
            do j=i+1,nch
              if(ntest(i,j)+ntest(j,i).ne.1)then
                write(0,*)'checksum wrong for nch,nchp'
     x                   ,i,j,' :',ntest(i,j),ntest(j,i)
              endif
            enddo
          enddo
        endif
c
c now determine t-matrix from full rho-matrix for approximation-ii:
c
        if(bunit2)then
c
          do m0=1,meng0
            m=iyy0(m0)
c
CL            if(m0.gt.0)then                                    !LAPACK
CL             call pqlap(nchlt,rhom(1,m0),wrkp,wrkq,work,nf)    !LAPACK
CL            else                                               !LAPACK
             call pq(nchlt,rhom(1,m0),wrkp,wrkq,work,nf)
CL            endif                                              !LAPACK
c
            if(nf.le.0)go to 700
c
            do nch=1,nchlt
c
              j=iwrkn(nch)
              if(j.le.0)go to 17
              l0=iwrkl(nch)
c
              do nchp=nch,nchlt
c
                jp=iwrkn(nchp)
                if(jp.le.0)go to 18
c
                n=irow(nch,nchp,izero,nchlt)
                tp=-2*wrkp(n)                 !real T^rho
                tq=-2*wrkq(n)                 !imag T^rho
c
c get T^K from T^rho
c
                if(nch.eq.nchp)then
                  t=tpi*pshftx(m,l0)
                  if(bprnt2)write(6,202)nch,nchp,j,jp
     x                             ,pshftx(m,l0),m0,'phase shift'
                  c2t=cos(t)
                  s2t=sin(t)
                  tp1=tp-done
c                  tr=done+c2t*tp1-tq*s2t
c                  ti=s2t*tp1+c2t*tq
c                  tsq=tr*tr+ti*ti
                  tsq=done+(2*c2t+tp1)*tp1-(2*s2t-tq)*tq
                else
                  tsq=tp*tp+tq*tq
                  if(j.eq.jp)tsq=tsq+tsq
                endif
c
                ompw=wait*tsq*nwt/dtwo
c
                if(bht)ompw=ompw/2      !for bht(1970) comparison
c
                if(j.le.jp)then
                  jl=j
                  jh=jp
                  nchl=nch
                  nchh=nchp
                else
                  jl=jp
                  jh=j
                  nchl=nchp
                  nchh=nch
                endif
c
                nomt=irow(jl,jh,ione1,nspece)
c some top-up
                if(lnew.ge.lrglmn)then             !look at top-up
c
                  if(omginf(nomt).gt.dzero)then        !non-dipole
c
                    if(lnew.eq.lrglam)then           !apply top-up
                      de=dspece(jh)-dspece(jl)
                      ej=dyy0(m0)
                      ei=ej+de
c
                      ompw0=ompw
                      ompw=ompw/wait
                      if(bprnt3)ompw=-ompw             !flag print
c
                      call top2(itwo,lrglam,ei,ej,ompw)
c
                      ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                    elseif(lnew.gt.lrglam)then
                      ompw=dzero
                    endif
c
                  elseif(omginf(nomt).lt.dzero)then        !dipole
                    if(lnew.gt.lrglam)ompw=dzero
                  endif
c
                endif
c
                omp(m0)=ompw
                omega(m0,nomt)=omega(m0,nomt)+real(ompw,rp)
                if(bprnt2)write(6,201)nchl,nchh,jl,jh,tp,tq,omp(m0)
c
  18          enddo
c
  17        enddo
            if(bprnt2)write(6,*)':'
c
          enddo
c
          if(btimet)then
            call cpu_time(timef)
            timeunit=timeunit+timef-timei
          endif
c
          deallocate (rhom,wrkp,wrkq,iwrkn,iwrkl,work,stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxls: deallocation fails for rhom,wrk'
            nf=0
            go to 999
          endif
c
        endif
C
C-----------------------------------------------------------------------
C
        if(btimet)then
          write(iw,*)'  set-up time=',nint(timeset),'sec'
          write(iw,*)'   mixi  time=',nint(timemixi),'sec'
          write(iw,*)'   mixf  time=',nint(timemixf),'sec'
          write(iw,*)'   mixir time=',nint(timemixir),'sec'
          write(iw,*)'   mixfr time=',nint(timemixfr),'sec'
          timemix=timemixi+timemixf+timemixir+timemixfr
          write(iw,*)'  mixing time=',nint(timemix),'sec'
          write(iw,*)'  interp time=',nint(timeint),'sec'
          if(bunit2)write(iw,*)' unitary time=',nint(timeunit),'sec'
        endif
c
        if(btimex)then
          call cpu_time(timef)
          times=timef-times
c
cpar          if(iam.ge.0)then                                      !par
cpar            write(6,*)'Ending proc',iam                         !par
cpar     x               ,'dwxls symmetry',ix,':',' nchan='         !par
cpar     x               ,nchs,'(',nch,')'                          !par
cpar     x               ,'  time=',nint(times),'sec'               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Ending dwxls symmetry ',ix,':',' nchan='
     x             ,nchs,'(',nch,')'
     x             ,'  time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C
        KUTOOX=KOLDOO
        BKUTOO=KUTOOX.NE.0
C                                             --------------------------
      ENDDO                                   !END LOOP OVER TOTAL SYMMS
C                                             --------------------------
C
      IF(IADD.NE.NCOR)THEN
        WRITE(6,*)'SR.DWXLS: GLOBAL INDEX ERROR:',IADD,NCOR        !test
        GO TO 999
      ENDIF
C
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        if(btimex)then                                          !par
cpar          btimep=.false.                                        !par
cpar          call cpu_time(timef)                                  !par
cpar          times=timef-time0                                     !par
cparc                                                               !par
cpar          write(iw,*)'Ending proc',iam,' for dwxls:'            !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar        endif                                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      ns=0                                                      !par
cpar      nr=0                                                      !par
cpar      itmp4=int(nomwrt)                                         !par
cparc                                                               !par
cpar      do m0=1,moggy                                             !par
cparc                                                               !par
cpar        call pomsend(ns,omega(1,1),nomwrt,omsend)               !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        call mpi_reduce(omsend,omrecv,itmp4,my_mpi_real,        !par
cpar     x                  mpi_sum,izero_mpi,mpi_comm_world,ier4)  !par
cparc                                                               !par
cpar        if(ier4.ne.0)write(0,*)'mpi_reduce: iam, ier=',iam,ier4 !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        if(iam.eq.0)call pomrecv(nomwrt,omrecv,nr,omega(1,1))   !par
cparc                                                               !par
cpar      enddo                                                     !par
cparc                                                               !par
cpar      if(iam.ne.0)go to 700                                     !par
cparc                                                               !par
C
C APPLY (DIPOLE) TOP-UP (OFF IF BTHRSH)
C
      IF(LRGLAM.GT.0)THEN
C
        WRITE(6,1002)LRGLAM
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,                                !par
cpar     x       'Top-up has been applied: lrglam=',lrglam          !par
cpar        else                                                    !par
          write(iw,*)'Top-up has been applied: lrglam=',lrglam
cpar        endif                                                   !par
        endif
        IF(BPRNT2)WRITE(6,716)
C
        LITLAM=LRGLAM                             !USE GLOBAL VALUE LA=0
        CO2S=D3QRT/LOG(EINF*DZ2)
C
        NOMT=0
        DO I=1,NMETA                                        !,NSPECL
c          IF(INDEX(I).GT.0)THEN                               !NON-CORR
C
          DO J=I+ione1,NSPECE                                !,NSPECL
c            IF(INDEX(J).GT.0)THEN                             !NON-CORR
C
              NOMT=NOMT+1
              SS=OMGINF(NOMT)
C
              IF(SS.LT.DZERO)THEN                                !DIPOLE
                SS=SS*CO2S                     !CONVERT TO LINE STRENGTH
                DE=DSPECE(J)-DSPECE(I)
                DE=DE/DZ2
                DO M0=1,MENG0
                  EJ=DYY0(M0)/DZ2
                  EI=EJ+DE
C
                  CALL TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
                  if(bht)omt=omt/2             !for BHT(1970) comparison
c
                  OM=REAL(OMEGA(M0,NOMT),WP)
                  OMEGA(M0,NOMT)=OMEGA(M0,NOMT)+REAL(OMT,RP)
C
                  IF(BPRNT2)WRITE(6,717)I,J,SS,EI,EJ,DE,OM,OMT,OM+OMT
                ENDDO
              ENDIF
C
c              IF(NOMT.EQ.NOMWRT)GO TO 113                  !WE ARE DONE
c            ENDIF
          ENDDO
C
c          ENDIF
        ENDDO
C
      ELSE
C
        WRITE(6,1003)
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,'Top-up has *NOT* been applied!'!par
cpar        else                                                    !par
          write(iw,*)'Top-up has *NOT* been applied!'
cpar        endif                                                   !par
        endif
C
      ENDIF
C
c 113  CONTINUE
c
c fix top-up failure on high-e near-degenerate Born allowed transitions
c
      if(btop)then
        NOMT=0
        DO I=1,NMETA
          DO J=I+ione1,NSPECE
            NOMT=NOMT+1
            OMB=OMGINF(NOMT)
            IF(OMB.GT.DZERO)THEN                                   !born
              DE=DSPECE(J)-DSPECE(I)
              DE=MAX(DE,D1M30)
              OM=REAL(OMEGA(2,NOMT),WP)
              DO M0=3,MENG0                        !skip threshold point
                RAT=DYY0(M0)/DE
                OM1=OM
                OM=REAL(OMEGA(M0,NOMT),WP)
                IF(RAT.GT.XBTEST.AND.OM.LT.D0PT8*OM1.AND.OM1.LT.OMB)THEN
                  MM=M0-1              !max(2,m0-1) if no threshold skip
                  GO TO 196
                ENDIF
              ENDDO
              M0=MENG0
              MM=M0+1
              IF(OM1.GE.OMB)THEN
                IF(OM.LT.OMB)MM=MENG0
              ELSE
                IF(OM.LT.OM1)MM=MENG0
              ENDIF
  196         IF(BPRNT2.AND.MM.LE.MENG0)THEN
                WRITE(6,762)I,J,DYY0(M0),DE,RAT,
     X                        (OMEGA(M,NOMT),M=1,MENG0),OMB
              ENDIF
              DO M0=MM,MENG0
                OMEGA(M0,NOMT)=REAL(OMB,RP)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      endif
c                                                                     !x
c test convert to cross section                                       !x
c                                                                     !x
c      nomt=0                                                         !x
c      do i=1,nmeta                                                   !x
c        j=index(i)                                                   !x
c        jj=nfq(j)                                                    !x
c        wi=(qsi(jj)+1)*(qli(jj)+1)                                   !x
c        do j=i+ione1,nspece                                          !x
c          nomt=nomt+1                                                !x
c          de=dspece(j)-dspece(i)                                     !x
c          do m0=1,moggy                                              !x
c            ej=dyy0(m0)                                              !x
c            ei=ej+de                                                 !x
c            if(brel)ei=ei+dalf4*ei*ei          !wavenumber           !x
c            om=real(omega(m0,nomt),wp)                               !x
c            om=xconv*om/(ei*wi)                                      !x
c            omega(m0,nomt)=real(om,rp)                               !x
c          enddo                                                      !x
c        enddo                                                        !x
c      enddo                                                          !x
C
C-----------------------------------------------------------------------
C
C WRITE TOTALS
C
      IF(BTHRSH)THEN
        WRITE(6,1001)
        IF(BPRNT0)THEN
          WRITE(6,1118)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MOGGY
            WRITE(6,200)REAL(M0-1+LVMIN),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ELSE
        WRITE(6,1000)
        IF(BPRNT0)THEN
          WRITE(6,1117)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MENG0                                         !=MOGGY
            WRITE(6,200)DYY0(M0),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ENDIF
C
      IF(IUNIT(IU).GT.0)THEN
        CLOSE(IU,STATUS='DELETE')
        IF(BTHRSH.or..not.bomega)THEN
          IUNIT(IU)=-1
        ELSE
          OPEN(IU,FILE='OMEGALS',STATUS='REPLACE')  !OPEN UNDER NEW NAME
CTBD        OPEN(IU,FILE='OMEGAULS',STATUS='REPLACE',FORM='UNFORMATTED')
          WRITE(IU,*)NZION,MION
          WRITE(IU,*)NSPECE,-(MENG0+1),NOMWRT       !FLAG NO E'S .LT.0
          WRITE(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
          WRITE(IU,711)(DWRK(I),I=1,NSPECE)
          DO M0=1,MENG0                                          !=MOGGY
            WRITE(IU,713)DYY0(M0)/DZ2,(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
          WRITE(IU,713)EINF,(OMGINF(N),N=1,NOMWRT)
          IUNIT(IU)=-1
          CLOSE(IU)
        ENDIF
      ENDIF
C
C OVERWRITE PWB ADF04 WITH DW, TAKING ACCOUNT OF THE FACT THAT THE PWB
C DOES NOT CONTAIN (SPIN) FORBIDDEN TRANSITIONS
C
      IF(IUNIT(IUU).GE.0)THEN           !NO ADF04, LIKELY SINCE RAD='NO'
        WRITE(6,*)'NO ADF04 FILE="adf04ls"...'
        WRITE(0,*)'NO ADF04 FILE ON UNIT=',IUU
C        NF=-1
        GO TO 700
      ELSEIF(IUNIT(IUU).LT.0)THEN
        IUNIT(IUU)=1
        OPEN(IUU,FILE='adf04ls',STATUS='OLD',ERR=700)
      ENDIF
C
      BEXP=.FALSE.                              !*MUST* SYNC WITH DIAGON
      IF(NSPECE.LT.1000)THEN
        i1=0
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
            F767='(18X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
            F767='(16X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2)/(18X,20(1PE10.2)))'
            F762='(2I4,21(1PE10.2)/(18X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3)/(16X, 20(A5, A3)))'
            F762='(2I4, 21(A5, A3)/(16X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ELSE
        i1=1
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
            F767='(20X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
            F767='(18X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2)/(20X,20(1PE10.2)))'
            F762='(2I5,21(1PE10.2)/(20X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3)/(18X, 20(A5, A3)))'
            F762='(2I5, 21(A5, A3)/(18X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ENDIF
C
      MSC0=80
      OPEN(MSC0,STATUS='SCRATCH',FORM='FORMATTED')
      IF(.NOT.BEXP)THEN
        MSCP=81
        OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
      ENDIF
C
      DO N=1,NSPECE+2
        READ(IUU,760)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
      NNN=max(NOMWRT,nomwr0)
C
      DO N=1,NNN+2
        READ(IUU,760,END=115)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
 115  REWIND(IUU)
      REWIND(MSC0)
C
      DO N=1,NSPECE+2
        READ(MSC0,760)CARD
        WRITE(IUU,760)CARD
      ENDDO
C
      IF(BTHRSH)THEN
        ITYPE=6
        WRITE(IUU,F767)(PSHFT0(M-1+LVMIN),M=1,MOGGY)
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(REAL(M-1+LVMIN),M=1,MOGGY)
        ELSE
          WRITE(MSCP,764)(REAL(M-1+LVMIN),M=1,MOGGY)
        ENDIF
      ELSE
        ITYPE=5
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(DYY0(M),M=1,MENG0)   !=MOGGY
        ELSE
          WRITE(MSCP,764)(DYY0(M),M=1,MENG0)                     !=MOGGY
        ENDIF
      ENDIF
C
      IF(BEXP)THEN
        READ(MSC0,F761)
      ELSE
        BACKSPACE(MSCP)
        READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
        iexp(0)='   '
        READ(MSC0,F761)XMANT(0)                                !,IEXP(0)
        WRITE(IUU,F761)XMANT(0),IEXP(0),ITYPE
     X               ,(XMANT(M),IEXP(M),M=1,MOGGY)
      ENDIF
C
      MENG1=MOGGY+1
      IB0=1
      JB0=IB0+IONE1
c
      nt=0
C
      DO N=1,NNN+1
C
        IF(BEXP)THEN
          READ(MSC0,F762)JB,IB,XB0,(DUM,I=1,MXNXB),XB1
        ELSE
          READ(MSC0,F762)JB,IB,XMANT0,IEXP0,
     X             (XMANT(I),IEXP(I),I=1,MXNXB),XMANT1,IEXP1
        ENDIF
C
        JB1=JB
        IF(JB.LT.0)THEN
          JB1=NSPECE
          IB=MIN(JB1-IONE1,NMETA)
          IF(BEXP)THEN
            XB0=D1M30
            XB1=DZERO
          ELSE
            XMANT0=' 1.00'
            IEXP0='-30'
            XMANT1=' 0.00'
            IEXP1='+00'
          ENDIF
        ENDIF
C
        IF(BEXP)THEN
          X0=D1M30
          X1=DZERO
        ELSE
          XMANT(0)=' 1.00'
          IEXP(0)='-30'
          XMANT(MENG1)=' 0.00'
          IEXP(MENG1)='+00'
        ENDIF
C
        DO JT=JB0,JB1
          IF(JT.EQ.JB1)THEN
            IB1=IB
          ELSE
            IB1=MIN(JT-IONE1,NMETA)
          ENDIF
          DO IT=IB0,IB1
C
ctest        if(ione1.eq.0.or.it.ne.jt)then   !catch ione1=0 diagon only
            nt=nt+1
c
            NOMT=IROW(IT,JT,IONE1,NSPECE)
C                                            !TEST MENG0 STILL IF BTHRSH
            IF(OMEGA(MENG0,NOMT).GT.E1M30)THEN         !SKIP SA-SAP.GT.1
c
c              if(omginf(nomt).lt.dzero)then  !test write reduced dipole
c                do m=1,moggy
c                  de=log(dyy0(m)+2.7183)
c                  omega(m,nomt)=omega(m,nomt)/de
c                enddo
c              endif
C
              IF(BEXP)THEN
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  X0=XB0
                  X1=XB1
                ENDIF
                WRITE(IUU,F762)JT,IT,X0,(OMEGA(M,NOMT),M=1,MOGGY),X1
              ELSE
                BACKSPACE(MSCP)
                WRITE(MSCP,764)(OMEGA(M,NOMT),M=1,MOGGY)
                BACKSPACE(MSCP)
                READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  XMANT(0)=XMANT0
                  IEXP(0)=IEXP0
                  XMANT(MENG1)=XMANT1
                  IEXP(MENG1)=IEXP1
                ENDIF
                WRITE(IUU,F762)JT,IT,(XMANT(M),IEXP(M),M=0,MENG1)
              ENDIF
C
            ENDIF
ctest        endif
          ENDDO
          IB0=1
        ENDDO
C
        IF(JB.LT.0)then
          if(nt.ne.nomwrt)then                                 !checksum
            write(6,*)'adf04 no. of transitions mis-match: nt,nomwrt='
     x                ,nt,nomwrt
            write(0,*)'adf04 no. of transitions mis-match'
            nf=-1
            go to 700
          endif
          GO TO 120
        endif
C
        JB0=JB
        IB0=IB+1
C
      ENDDO
C
      WRITE(0,*)'SR.DWXLS: HAVE NOT REACHED END OF adf04ls...'
      WRITE(6,*)'SR.DWXLS: HAVE NOT REACHED END OF adf04ls...'
      NF=-1
      GO TO 700
C
  120 WRITE(IUU,F762)-1
      WRITE(IUU,F762)-1,-1
c
        if(.not.badas)then                           !adas skip comments
      WRITE(IUU,758)
C
      NREC=1
  121 NREC=NREC+1
      BACKSPACE(5)
      BACKSPACE(5)
      READ(5,766)CARD4
      IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
      REWIND(5)
C
      DO N=1,NREC
        READ(5,760)CARD
        WRITE(IUU,759)CARD
      ENDDO
      DATE='        '
      CALL DATE_AND_TIME(DATE)
      WRITE(IUU,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X             ,DATE(3:3),DATE(4:4)
        endif
C
      IUNIT(IUU)=-1
      CLOSE(IUU)
C
      CLOSE(MSC0)
      IF(.NOT.BEXP)CLOSE(MSCP)
C
C-----------------------------------------------------------------------
C
  700 CONTINUE
C
      DEALLOCATE (KACT,KTMP,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 999
      ENDIF
C
  800 CONTINUE
C
      DEALLOCATE (RHO1,RHO2,TEMP,OMGINF,OMEGA,STAT=IERR)
cparc                                                               !par
cpar      deallocate (omsend,omrecv,stat=ierr)                      !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 999
      ENDIF
C
  900 DEALLOCATE (TFU,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 999
      ENDIF
C
  998 CONTINUE
C
      DEALLOCATE (NADRUG)
      DEALLOCATE (TMP,OMP)
      DEALLOCATE (IEXP,XMANT)
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
  999 CONTINUE
C
C-----------------------------------------------------------------------
C
      if(btimep)then
        call cpu_time(timef)
        times=timef-time0
c
C        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for dwxls:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending dwxls: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
C        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C
  200 FORMAT(F21.3,2X,1P,10(E11.3)/(23X,10(E11.3)))
  201 FORMAT(2I5,3X,2I4,2X,1P,10(E11.3)/(23X,10(E11.3)))
  202 FORMAT(2I5,3X,2I4,2X,1PE11.3,10X,'E(',I2,')   ',A11)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  716 FORMAT(3X,'CH',2X,'CHP',9X,'S',14X,'EI',10X,'EJ',10X,'DE',
     X9X,'OMEGA(PAR)',2X,'OMEGA(TOP)',4X,'OMEGA(TOT)')
  717 FORMAT(2I5,3X,1PE11.3,2X,0P,3F12.4,5X,2F12.4,2X,F12.4)
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  762 FORMAT(2I5,22(1PE10.2))
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE DISTORTED-WAVE'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  995 FORMAT(2I10,13X,I5,I2,I5,12X,F18.6)
  996 FORMAT(9X,'I',8X,' T',14X,'2S+1 L   CF',20X,'(EI-E1)/RY'
     X      ,15X,'NMETA=',I5)
  997 FORMAT(//' *** FULLY UNITARIZED K- TO T-MATRIX CONVERSION ***'//)
 1000 FORMAT(///1X,136('-')//51X,
     X       '*** TOTAL COLLISION STRENGTHS (LS) ***'//1X,136('-')//)
 1001 FORMAT(///1X,136('-')//45X,
     X       '*** THRESHOLD PARTIAL COLLISION STRENGTHS (LS) ***'//
     X      1X,136('-')//)
 1002 FORMAT(//' *** TOP-UP HAS BEEN APPLIED: LRGLAM=',I5//)
 1003 FORMAT(//' *** TOP-UP HAS *NOT* BEEN APPLIED ***'//)
 1110 FORMAT(//1X,136('-')///
     X   49X,'*** TARGET ENERGIES (LS) ***'/)
 1111 FORMAT(//1X,136('-')/)
 1112 FORMAT(13X,'CH',8X,'T',3X,'SMALL L')
 1113 FORMAT(7X,I8,I9,I10)
 1114 FORMAT(' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3,5X,'NCHT=',I6,2X,'('
     X      ,I6,')')
 1115 FORMAT(//' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3/1X,33('-'))
 1116 FORMAT(/3X,'CH',2X,'CHP',6X,'I',2X,'IP',4X,'OMEGA(IE=1,MENG):')
 1117 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/2X,'*FINAL* ENERGY(RYD)'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1118 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/1X,'*FINAL* RYDBERG A.M.'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1119 FORMAT(//' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3,5X,'NCHT=',I6,2X,'('
     X      ,I6,')'/1X,33('-'))
 1996 FORMAT(//' *** UPDATING SLATER INTEGRALS FOR LTOT=',
     X       I3/1X,42('-')/)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DWXLS_DAXPY
C
C                             *******************
C
      SUBROUTINE DWXLS_DDOT
     X                (FRX,PSHFTX,DRLX,MDIM0,MDIM1,MDIM2,MDIM3,MDIM4
     X                ,MDIM5,DZLX,DXTWOX,DETAX,MDIM6,MDIM7,MDIM8)
C
C-----------------------------------------------------------------------
C
C  SR.DWXLS CALCULATES EIE 2-BODY NFS COLLISION STRENGTHS IN LS-COUPLING
C
C  IT CALLS:
C    SR.DATE_AND_TIME (SYSTEM)
C    SR.PQ
C    SR.PQLAP
C    FN.QPTLS
C    SR.RADCNX
C    SR.SLATRX
C    SR.TOP1
C    SR.TOP2
C    FN.XINT
C
C  IT CONTAINS:
C    FN.IROW
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam,comm_barrier               !par
cpar      use mpi, only : mpi_real4,mpi_real8,mpi_integer           !par
cpar     x               ,mpi_sum,mpi_comm_world                    !par
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,NAD
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXLEN=200)                                 !CARD LENGTH
C
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXD13=500)
      PARAMETER (MXD14=100)
C
      PARAMETER (D0PT8=0.8D0)
C
      PARAMETER (MXNXB=10)    !NO. OF BPW X-VALUES PRE-EXISTING IN ADF04
C
      INTEGER(SP) QPTLS                        !DO NOT USE SHORT INTEGER
C
      INTEGER(SP) SA,SAP
cparc                                                               !par
cpar      integer(kind(mpi_integer))itmp4,ier4,izero_mpi,my_mpi_real!par
cpar      parameter (izero_mpi=0)                                   !par
cparc                                                               !par
cpar      real(rp) omsend,omrecv                                    !par
C
      REAL(RP) OMEGA,E1M30
      PARAMETER (E1M30=1.E-30)
      PARAMETER (XBTEST=DFIVE)          !APPLY btop ONLY FOR X.GT.XBTEST
C
      CHARACTER(LEN=3) IEXP,IEXP0,IEXP1
      CHARACTER(LEN=4) CARD4
      CHARACTER(LEN=5) XMANT,XMANT0,XMANT1
      CHARACTER(LEN=8) DATE
      CHARACTER(LEN=15) F767
      CHARACTER(LEN=35) F762
      CHARACTER(LEN=44) F761
      CHARACTER(LEN=MXLEN) CARD
C
      ALLOCATABLE :: RHO1(:,:),RHO2(:,:),OMEGA(:,:),TFU(:)
     X              ,TEMP(:,:),OMGINF(:),KACT(:,:),KTMP(:)
cpar      allocatable :: omsend(:),omrecv(:)                        !par
c
      allocatable :: rhom(:,:),wrkp(:),wrkq(:),iwrkn(:),iwrkl(:)
     x              ,work(:)
C
      ALLOCATABLE :: IEXP(:),XMANT(:)
      ALLOCATABLE :: NADRUG(:),TMP(:,:),OMP(:)
     X              ,DWRK(:),IWRK3(:),IWRK4(:)
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRLX(MDIM4,MDIM0,0:MDIM5)
     X         ,DZLX(MDIM7,MDIM6,0:MDIM8)
     X         ,DXTWOX(MDIM7,MDIM6,0:MDIM8)
     X         ,DETAX(MDIM7,MDIM6,0:MDIM8)
C
      DIMENSION PSHFT0(0:20)
c
      dimension bswap(mxd13)
      dimension ntest(1,1)                     !check channel set-up
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
c      COMMON /REL/DMASS(MAXGR,MAXGR),DCD(MAXGR,MAXGR),D2LL(MAXGR,MAXGR)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C      COMMON /WORKLS/DWRK(MAXTM),IWRK3(MAXTM),IWRK4(MAXTM)
c
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
c      common /nrbrel/irel,kappa,igagr,irtard,ibreit,brel,bjumpr,bmvd !x
c
      common /hps/badas
C
      DATA LOLD/-1/,IU/23/,IUU/25/
c                 omginfls adf04ls
C
C SEE INTERNAL FUNCTION ABOVE END SUBROUTINE DWXSL_DDOT
c      IROW(ILI,ILF,IONE1,NENG)=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
C-----------------------------------------------------------------------
C
c some cross section units options: need to uncomment code above and  !x
c below labeled "!x"                                                  !x
c                                                                     !x
c      xconv=done                   !pi*a_0^2                         !x
c      xconv=xconv*acos(-done)      !a_0^2                            !x
c      xconv=xconv*28.003d0         !Mbarns                           !x
c      xconv=xconv*1.d6             !barns                            !x
c
c flag write of "OMEGA" file - this is by final scattered energy and so
c *not* directly usable by R-matrix utility codes such as xtrct/adasexj.
c this is somewhat historic as adasexj *does* read/process dw adf04 file
c
      bomega=.false.
c
c elastic switch (normally ione1=1, no elastic. ione1=0 inc elastic)
c now set by user in algeb, and passed thru /nrbdwm/ as needed.
c
cold  ione1=1
c
c test: DO NOT CHANGE!
cold  ione0=0                   !algxls ione1, elastic needed for mixing
c
c some test set-up switches that user joe should not need to touch.
c
      bht=.false.                  !.true. for bht(1970) test comparison
c
c set (approx) unitarity switch
c
      bunit=.true.
      if(bht)bunit=.false.
c
c set approximation-ii unitarization switch - needs the full rho-matrix
c (.and.. not.bthrsh, i.e. lvmax.lt.0) only coded for F95.
c currently, in principle, only for use at medium to high energies
c since it still works with the final scattered energy, but seems to
c work well down to low-e as well - strongest coupling with nearby
c states, i.e. ones calculated at the same/similar relative energy.
c
      bunit2=nmeta.ge.nspece.and.ione1.eq.0.and.lvmax.lt.0
c
c set print of approx r(tau=0)-matrix as opposed to rho(tau)-matrix
c *MUST* use full T=-2iR/(1-iR) if converting via R-matrix.   (not done)
c can only use weak coupling T=-2i*rho for rho-matrix -see bunit2 above.
c
      brmx=.false.
      if(jprint.eq.4)brmx=.true.
c
c set mixing switch, can test interpolation followed by mixing (false).
c
      bmix=xmix.ge.dzero                !default xmix->.true.
      xmix=abs(xmix)
c
c checks channel set-up (needs ntest dimensione1d)
c
      bntest=.false.                    !ione1.eq.0.and.jprint.ge.2
c
      bntest=bntest.and.nmeta.ge.nspece
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD(NCOR)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
cparc                                                               !par
cpar      if(rp.eq.4)then                                           !par
cpar        my_mpi_real=mpi_real4                                   !par
cpar      elseif(rp.eq.8)then                                       !par
cpar        my_mpi_real=mpi_real8                                   !par
cpar      else                                                      !par
cpar        if(iam.eq.0)write(iw,*)'error rp precsion =',rp         !par
cpar        go to 999                                               !par
cpar      endif                                                     !par
C
C-----------------------------------------------------------------------
c
      btimep=btimex                                        !for iam.ne.0
      if(btimex)then
c        if(abs(modd).le.1)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for dwxls'           !par
cpar        else                                                    !par
          write(iw,*)'Starting dwxls'
cpar        endif                                                   !par
c        endif
        call cpu_time(timei)
        time0=timei
      endif
      btimet=btimex  !.false.                             !debug timings
C
C INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TPI=DTWO*PI
C
      BPRNT1=JPRINT.GE.1                       !PRINT CHANNEL INFO AGAIN
      BPRNT2=JPRINT.GE.2                    !FOR DETAILED OMEGA PRINTOUT
      BPRNT3=JPRINT.GE.3                      !FOR DETAILED RHO PRINTOUT
      BPRNT0=JPRINT.NE.-3
C
      KOLDOO=KUTOOX
      BKUTOO=KUTOOX.NE.0
C
CL      LAPAK=1                                                  !LAPACK
C
      IF(NZION.EQ.MION)THEN
        NZA=0
        DZ2=DONE
      ELSE
        NZA=NZION-MION
        DZ2=NZA*NZA
      ENDIF
C
      LSTORE=0                                 !TRIVIAL INTEGRAL STORAGE
C
      IF(MAXLT.GE.0)THEN
        IF(LRGLAM.GT.MAXLT)THEN
          WRITE(0,*)'*** SR.DWXLS: LRGLAM.GT.MAXLT, SO NO TOP-UP'
          LRGLAM=-1
        ELSE
          IF(LRGLAM.EQ.-999)LRGLAM=MAXLT
        ENDIF
        IF(LRGLAM.EQ.0)LRGLAM=-1
      ENDIF
C
      IF(LRGLAM.GE.0)THEN        !SET L WHERE DIPOLE TOP-UP NEEDS CHECKS
        LRGLMN=LRGLAM-QCL0
      ELSE
        LRGLMN=1000
      ENDIF
c
      btop=btop.and.lrglam.ge.0
C
C SMALL LOCAL MEMORY
C
      MXD4=MAX(MENG,10_SP)+3
      ALLOCATE (IEXP(0:MXD4),XMANT(0:MXD4))
      ALLOCATE (TMP(MENG,MENG),OMP(MENG))
      ALLOCATE (NADRUG(NSL0))
C
C SET POINTER TO START OF GROUP IN MIXING COEFFICIENT ARRAY TFU
C
      MC=0
      NCMX=0
      DO N0=1,NSL0
        NADRUG(N0)=MC
        NC=NSL(N0)
        NCMX=MAX(NCMX,NC)                        !MAX NO TERMS IN GROUP
        MC=MC+NC*NC
      ENDDO
C
C RECOVER TARGET MIXING COEFFICIENTS
C
      READ(MR)NCTOT
C
      if(nctot.ne.mc)stop 'dwxls:nctot index error'    !shouldn't happen
C
      ALLOCATE (TFU(NCTOT),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 998
      ENDIF
C
      READ(MR)(TFU(I),I=1,NCTOT)
C
C LOOK FOR LAST SPECTROSCOPIC ENERGY
C
c      NSPECL=0
c      DO N=1,NENERG
c        NSPECL=MAX(NSPECL,JNDEX(N))
c      ENDDO
C
C USE ROWWISE TO SIMPLY REDUCE NDIM2 IF NMETA.LT.NSPECE
C
      NOMTG=NCMX*NCMX                               !NEED ALL FOR MIXING
      nmin=min(NMETA,NSPECE)
      NOMWRT=IROW(nmin,NSPECE,ione1,NSPECE)                     !ROWWISE
      NOMWR0=NOMWRT
ctest    if(ione1.eq.1)nomwr0=nomwr0+nmin      !incase ione1=0 in diagon
C
C
      BTHRSH=LVMAX.GE.0
      IF(BTHRSH)THEN
        MOGGY=LVMAX+1-LVMIN
      ELSE
        MOGGY=MENG0
      ENDIF
C
      MX=MTRAN
      if(.not.bmix)mx=meng0
C
      ALLOCATE (RHO1(NOMTG,MX),RHO2(MTRAN,NOMTG),TEMP(NCMX,MX)
     X         ,OMGINF(NOMWR0),OMEGA(MOGGY,NOMWRT),STAT=IERR)
cparc                                                               !par
cpar      allocate (omsend(nomwrt),omrecv(nomwrt),stat=ierr)        !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 900
      ENDIF
C
      DO N=1,NOMWRT
        OMGINF(N)=DZERO
        DO M=1,MOGGY
          OMEGA(M,N)=0
        ENDDO
      ENDDO
C
C RECOVER INFINITE ENERGY INFO (ROWWISE)
C
      IF(IUNIT(IU).EQ.0)THEN                   !ADF04 WILL BE INCOMPLETE
        WRITE(6,*)'NO INFINITE ENERGY FILE="OMGINFLS"...'
        WRITE(0,*)'NO INFINITE ENERGY FILE ON UNIT=',IU
        IF(LRGLAM.GE.0)THEN
          WRITE(6,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          WRITE(0,*)'NO INFINITE ENERGY FILE INFO, CANNOT TOP-UP'
          NF=-1
          GO TO 800
        ELSE
          GO TO 110
        ENDIF
      ELSEIF(IUNIT(IU).LT.0)THEN
        OPEN(IU,FILE='OMGINFLS',STATUS='OLD',ERR=110)
        IUNIT(IU)=1
      ELSE                               !SERIAL SHOULD NOT BE HERE
        REWIND(IU)                       !BUT PAR ALREADY OPEN
cpar        if(iam.eq.0)then                                        !par
        stop 'dwxls: omginfls confusion'
cpar        endif                                                   !par
      ENDIF
C
      READ(IU,*)NZDUM,MDUM
      READ(IU,*)NSPEC0,MENGB,NOMWR0
C
      IF(NSPEC0.NE.NSPECE)THEN                   !SHOULD NOT HAPPEN, NOW
        WRITE(6,*)'DWXLS: INFINITE ENERGY TARGET MISMATCH',NSPEC0,NSPECE
        WRITE(0,*)'DWXLS: INFINITE ENERGY TARGET MISMATCH'
        NF=-1
        GO TO 800
      ENDIF
C
      ALLOCATE (DWRK(NSPEC0),IWRK3(NSPEC0),IWRK4(NSPEC0))
C
      READ(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPEC0)
      READ(IU,711)(DWRK(I),I=1,NSPEC0)
C
c optionally recover spec energy subset from omginf,
c and retain full-set in denerg back in algx.
c
c      do i=1,nspec0
c        dwrk(i)=dwrk(i)*dz2
c      enddo
c
      iflag=0
      if(nomwrt.ne.nomwr0)then       !should not happen in non-test mode
        if(ione1.eq.0)then                             !elastic in dwxls
          if(nomwrt-nmin.ne.nomwr0)then
            write(6,*)'dwxls: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxls: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=1 in diagon
            iflag=1
          endif
        else                                         !inelastic in dwxls
          if(nomwrt+nmin.ne.nomwr0)then
            write(6,*)'dwxls: infinite energy omega mismatch'
     x                ,nomwrt,nomwr0
            write(0,*)'dwxls: infinite energy omega mismatch'
            nf=-1
            go to 800
          else                                   !case ione1=0 in diagon
            iflag=2
          endif
        endif
      endif
C
      READ(IU,713)EINF,(OMGINF(I),I=1,NOMWR0)
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        IUNIT(IU)=-1                                            !par
cpar        CLOSE(IU)                                               !par
cpar      endif                                                     !par
c
      if(iflag.eq.1)then                          !make room for elastic
        n=nomwrt+1
        nshft=nmin
        do i=nmin,1,-1
          do j=nspec0,i+1,-1
            n=n-1
            omginf(n)=omginf(n-nshft)
          enddo
          n=n-1
          omginf(n)=done                             !flag poss. allowed
          nshft=nshft-1
        enddo
        if(n.ne.1)stop 'iflag=1 nshft error'
      elseif(iflag.eq.2)then                               !drop elastic
        n=0
        nshft=1
        do i=1,nmin
          do j=i+1,nspec0
            n=n+1
            omginf(n)=omginf(n+nshft)
          enddo
          nshft=nshft+1
        enddo
        if(n.ne.nomwrt)stop 'iflag=2 nshft error'
      endif
C
  110 CONTINUE
C
C WRITE-OUT SPEC. TARGET ENERGIES
C
      WRITE(6,1110)
      WRITE(6,996)NMETA
C
      DO J=1,NSPECE
        I=INDEX(J)
        JJ=NFQ(I)
        II=(1-QPI(JJ))*(QSI(JJ)+1)
        WRITE(6,995)J,I,II,QLI(JJ)/2,NFK(I),DSPECE(J)
      ENDDO
C
      WRITE(6,1111)
C
C FLAG ACTIVE ORBITAL PAIR IN INTERACTING CONFIGS C.F. SR.ALGX BXIST0
C
      ALLOCATE (KACT(KMAX,KMAX),KTMP(NF),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: ALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 800
      ENDIF
C
      DO KF=1,KMAX
        DO KG=1,KF
          KACT(KF,KG)=0
          KACT(KG,KF)=0
          DO I=1,NF
            KTMP(I)=QCG(I,KG)
          ENDDO
          K=0
          DO I=1,NF
            DO L=1,NF
              IF(IEQ(KTMP(L)).EQ.IEQ(QCG(I,KF)))THEN
                KTMP(L)=0
                GO TO 51
              ELSE
                IF(KTMP(L).NE.0)L0=L
              ENDIF
            ENDDO
            K=K+1
            IF(K.GT.1)GO TO 52
            KACT(KF,KG)=QCG(I,KF)
            KACT(KG,KF)=KTMP(L0)
  51      ENDDO
  52    ENDDO
      ENDDO
C
C-----------------------------------------------------------------------
C
C BEGIN LOOP OVER SCATTERING SYMMETRIES
C
C-----------------------------------------------------------------------
C
      NCOR=0
c
      if(bunit2)write(6,997)
      iwait=0
      wait=done
C
      DO IX=1,INAST
C
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
C
        LNEW=IL
C
        IF(BKUTOO.AND.LNEW.GT.MAXLOO)THEN
          KUTOOX=0
          BKUTOO=.FALSE.
        ENDIF
C
C SEE IF WE NEED TO UPDATE INTEGRALS & CONTINUUM BASIS
C
        IF(LNEW.NE.LOLD)THEN
C
C-----------------------------------------------------------------------
C
          if(btimex)then
cc        if(abs(modd).gt.1)then   ADD IC FLAG
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Starting proc',iam                   !par
cpar     x                  ,'updating continuum for l=',il         !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)
     x         'Begin update of continuum basis & integrals for L=',lnew
cpar            endif                                               !par
cc        endif
c
            call cpu_time(timei)
            times=timei
          endif
C
C-----------------------------------------------------------------------
C
          lstep=lnew-lold
          if(lstep.gt.1.and.lfact.gt.100.and.lold.gt.0)then
            if(iwait.eq.4)then
              iwait=2
            else
              iwait=4
            endif
            wait=iwait*lstep
            wait=wait/dthree
          endif
C
C UPDATE CONTINUUM BASIS
C
          IF(BTHRSH)LCONDW=-LCONDW                            !FLAG
C
          CALL RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3,LNEW,LOLD
     X               ,LCONDW,MXORB)
C
          IF(NF.LE.0)GO TO 700
C
C UPDATE EXCHANGE MULTIPOLE
C
          LDIFF=LNEW
          IF(LOLD.GE.0)LDIFF=LDIFF-LOLD
          LDIFF=LDIFF+LDIFF
C
          DO I=1,IRL
            IF(QRL(2,I).GT.MXORB)QRL(5,I)=QRL(5,I)+LDIFF  !EXCHANGE
          ENDDO
C
C UPDATE SLATER INTEGRALS (INC. 2NFS IF BKUTOO=.TRUE.)
C
          IF(BPRNT0)WRITE(6,1996)LNEW
C
          DO M=1,MTRAN
            M1=MNDEX(M,1)
            M2=MNDEX(M,2)
            IF(BKUTOO)THEN
              CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DRLX(1,M,LSTORE)
     X                   ,DZLX(1,M,LSTORE)
     X                   ,DXTWOX(1,M,LSTORE)
     X                   ,DETAX(1,M,LSTORE)
     X             ,M1,M2,LNEW,MAXLX,MXORB)
            ELSE
              CALL SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                   ,DRLX(1,M,LSTORE)
     X                   ,DZLX(1,1,0)
     X                   ,DXTWOX(1,1,0)
     X                   ,DETAX(1,1,0)
     X             ,M1,M2,LNEW,MAXLX,MXORB)
            ENDIF
          ENDDO
C
          LOLD=LNEW
C
C-----------------------------------------------------------------------
C
          if(btimex)then
            call cpu_time(timef)
            times=timef-times
c
cc        if(abs(modd).gt.1)then
cpar            if(iam.ge.0)then                                    !par
cpar              write(iwp,*)'Ending proc',iam                     !par
cpar     x                  ,'updating continuum'                   !par
cpar     x                 ,' time=',nint(times),'sec'              !par
cpar              call flush(iwp)                                   !par
cpar            else                                                !par
            write(iw,*)'End update of continuum basis & integrals'
     x               ,', time=',nint(times),'sec'
cpar            endif                                               !par
cc        endif
          endif
C
C-----------------------------------------------------------------------
C
        ENDIF
C
C
C INITIALIZE FOR LS-LOOP
C
        nwt=is
        if(il.gt.maxlx)nwt=-2*is+2
C
        IF(BPRNT1)WRITE(6,1115)IX,nwt,IL,IP
c
c count channels
c
        if(bprnt1)write(6,1112)
c
        nchlt=0
        nchs=0
c
        do n=1,nchg(ix)
          nc=itarg(n,ix)
          mc=nsl(nc)
          mci=ngrpi(nc)
          l1=llch(1,n,ix)
          l2=llch(2,n,ix)
          do l=l1,l2,4
            do m=1,mc
              j1=m+mci
              nchlt=nchlt+1
              if(jndex(j1).gt.0)then
                if(bprnt1)write(6,1113)nchlt,j1,l/2
                nchs=nchs+1
              endif
            enddo
          enddo
        enddo
c
        if(bntest)then
          do  i=1,nchlt
            do j=1,nchlt
              ntest(j,i)=0
            enddo
          enddo
        endif
c
c initialize for approximation-ii (memory hog)
c
        if(bunit2)then
c
          nx=(nchlt*(nchlt+1))/2
c
          allocate (rhom(nx,meng0),wrkp(nx),wrkq(nx),iwrkn(nchlt)
     x             ,iwrkl(nchlt),work(nchlt),stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxls: allocation fails for rhom,wrk'
            nf=0
            go to 700
          endif
c
          do i=1,nchlt
            iwrkn(i)=-1
            iwrkl(i)=-1
          enddo
c
          do m=1,meng0
            n=0
            do i=1,nchlt
              n=n+1
              rhom(n,m)=done
              do j=i+1,nchlt
                n=n+1
                rhom(n,m)=dzero
              enddo
            enddo
          enddo
c
        endif
C
        IF(.NOT.BPRNT0)then
          WRITE(6,1114)IX,nwt,IL,IP,nchs,nchlt
        ELSEIF(.not.BPRNT1)then
          WRITE(6,1119)IX,nwt,IL,IP,nchs,nchlt
        ENDIF
        IF(BPRNT2)WRITE(6,1116)
C
C-----------------------------------------------------------------------
C
        if(btimex)then
cc        if(abs(modd).gt.1)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'Starting proc',iam                     !par
cpar     x                ,'dwxls symmetry',ix,':',nwt,il,ip        !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Starting dwxls symmetry',ix,':',nwt,il,ip
cpar          endif                                                 !par
cc        endif
c
          call cpu_time(timei)
          times=timei
        endif
c
        if(btimet)then
          timeset=dzero
          timemix=dzero
           timemixi=dzero
           timemixf=dzero
           timemixir=dzero
           timemixfr=dzero
          timeunit=dzero
          timeint=dzero
        endif
C
C-----------------------------------------------------------------------
C
        nwt=abs(nwt)*(2*il+1)
C
        NCN=NCHG(IX)
C
        NCHI=0
        NCHI0=0
C
        DO NC0=1,NCN                     !BEGIN LOOP OVER INITIAL GROUPS
          L1=LLCH(1,NC0,IX)
          L2=LLCH(2,NC0,IX)
          NC=ITARG(NC0,IX)
          MC=NSL(NC)
          SA=QSI(NC)
          LA=QLI(NC)
          MCI=NGRPI(NC)
C
          NCHIP=0
          NCHIP0=0
C
          DO ND0=1,NC0                     !BEGIN LOOP OVER FINAL GROUPS
            L1P=LLCH(1,ND0,IX)
            L2P=LLCH(2,ND0,IX)
            ND=ITARG(ND0,IX)
            MCP=NSL(ND)
            SAP=QSI(ND)
C            IF(ABS(SA-SAP).GT.2)GO TO 68   !unnecessary...
            IF(NMETAG(NC)+NMETAG(ND).EQ.2)THEN
              NCHI=NCHI0+((L2-L1)/4+1)*MC
              NCHIP=NCHIP0+((L2P-L1P)/4+1)*MCP
              GO TO 68
            ENDIF
            LAP=QLI(ND)
            MCIP=NGRPI(ND)
C
            beqgrp=nc.eq.nd          !flag equal groups for filling rho1
c
c get lambda for non-dipole infnite energy top-up
c
            if(lnew.ge.lrglam)then
              if(sa.eq.sap)then
                litlam=0
                if(qpi(nc).ne.qpi(nd))then
                  litlam=3                         !for case of octupole
                else
                  if(la-lap.eq.0)then
                    if(la+lap.ge.4)litlam=2
                  else
                    litlam=abs(la-lap)/2
                  endif
                endif
              else
                litlam=-1
              endif
            endif
C
            NCHI=NCHI0
            DO LI=L1,L2,4                   !LOOP OVER INITIAL CHANNEL L
C
c set position of phase shift for this li
c only required by  elastic case for diagonal rho
c or if printing usual reactance matrix
c
              if(ione1.eq.0.or.brmx)then
                L=LCONDW/2+1-LNEW+LI/2
                L0=ABS(QPOS(L))
              endif
C
              lf2=l2p
              if(beqgrp)lf2=li
c
              NCHIP=NCHIP0
              DO LF=L1P,lf2,4                 !LOOP OVER FINAL CHANNEL L
c
                beqgrpl=beqgrpl0.and.beqgrp.and.li.eq.lf
c
                ncort=qptls(ix,nc0,nd0,li,lf)
c
                if(ncort.ne.ncor)then
                  write(0,*)ix,nc0,nd0,li,lf,ncor,ncort
                  stop 'ncor mis-match'
                endif
C
c set position of phase shift for this lf
c only need if printing usual reactance matrix, not needed by rho matrix
C
                if(brmx)then
                  L=LCONDW/2+1-LNEW+LF/2
                  L00=ABS(QPOS(L))
                endif
C
C-----------------------------------------------------------------------
C
C NOW FORM LS INTERACTION (BY TARGET SYMMETRY GROUP)
C*************************
C
C THIS IS IN THE RHO-I REPRESENTATION, WHERE
C |T^R(V,V')|=|T^RHO(V,V')| FOR CHANNELS V.NE.V'.
C WE USE T^RHO(V,V')=-2I*RHO(V,V'), WITH A 2X2 UNITARITY CONDITION.
C FOR V.EQ.V' T^R(V,V)~-2*TAN(TAU(V)), FOR RHO(V,V) SMALL.
C (IN GENERAL, WE ARE NOT INTERESTED IN ELASTIC TRANSITIONS.)
C
c
                if(btimet)call cpu_time(timei)
C
                NOMTG=MC*MCP
                DO N=1,NOMTG
                  DO M=1,MTRAN
                    RHO2(M,N)=DZERO
                  ENDDO
                ENDDO
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(kcutx.lt.0)j=abs(j)                !keep corr-corr
                  KF=NFK(J1)
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
                    J1P=MDP1+MCIP
                    IF(beqgrpl.and.J1P.GT.J1-ione0)GO TO 2  !sync algxls
c
                    jp=jndex(j1p)
                    if(j.lt.0.and.jp.lt.0)then  !omit cor-cor, as algxls
                      if(becor)then
                        ncor=ncor+1
                        go to 1
                      endif
                      go to 2
                    endif
C
                    N1=NAD(NCOR)+1
                    NCOR=NCOR+1
                    N2=NAD(NCOR)
c                                    write(73,*)ix,md1,mdp1,j,jp,ncor,n2
                    IF(N1.GT.N2)GO TO 1
                    KG=NFK(J1P)
c
c need to find if Slater integral initial and final states are swapped
c because of falling order. (algebraic are not swapped in LS.)
c
                    if(n2-n1+1.gt.mxd13)then
                      write(6,*)'***sr.dwxls: increase internal buffer',
     x                          ' mxd13 to', n2-n1+1
                      nf=-1
                      go to 700
                    endif
c
                    ks=0
                    do n=n1,n2
                      ks=ks+1
                      bswap(ks)=.false.
                      n0=int(nrk(n))
                      m0=qrl(1,n0)
                      if(li.eq.ql(m0))then
                        if(li.eq.lf.and.kf.ne.kg)then
                          m0=qrl(3,n0)
                          if(qn(m0).gt.0)then                  !exchange
                            if(m0.ne.kact(kg,kf))then              !swap
                              bswap(ks)=.true.
                            endif
c                         else             !direct and it doesn't matter
                          endif
c                       else           !distinct or kf=kg, so they can't
                        endif
                      else                         !trivially, they were
                        bswap(ks)=.true.
                      endif
                    enddo
C
                    NOMTG=(MDP1-1)*MC+MD1                          !orig
                    if(beqgrpl)nmteq=(md1-1)*mcp+mdp1
C
                    DO M=1,MTRAN
C
                      DD=DZERO
                      ks=0
                      DO N=N1,N2
                        ks=ks+1
c
                        if(bswap(ks))then !swap because of falling order
                          mm=mrndx(m)
                        else
                          mm=m
                        endif
c
                        N0=INT(NRK(N))
C
                        DD=DD+DRLX(N0,mm,LSTORE)*DRK(N)
                        IF(BKUTOO)THEN
                          DS=DZLX(N0,mm,LSTORE)
                          IF(BFALL(N))DS=-DS
                          DS=DS+DXTWOX(N0,mm,LSTORE)*DRK(N)
     X                      +DETAX(N0,mm,LSTORE)*DEK(N)
                          DD=DD+DS
                        ENDIF
                      ENDDO
C
                      RHO2(M,NOMTG)=RHO2(M,NOMTG)+DD            !UNMIXED
c
                      if(beqgrpl.and.nomtg.ne.nmteq)then  !pop lower tri
                        mm=mrndx(m)                        !need reverse
                        rho2(mm,nmteq)=rho2(mm,nmteq)+dd
                      endif
C
                    ENDDO
c
c                    write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mtran)
c  777               format(2i5,1p,10d12.3/(10x,10d12.3))
C
   1              ENDDO                       !END LOOP OVER FINAL TERMS
C
   2            ENDDO                       !END LOOP OVER INITIAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeset=timeset+timef-timei
                  timei=timef
                endif
C
C-----------------------------------------------------------------------
C
                MX=MTRAN
C
C INTERP THEN MIX (APPROX)
C
               if(.not.bmix)then
C
                DO MDP1=1,MCP               !BEGIN LOOP OVER FINAL TERMS
C
                  J1P=MDP1+MCIP
                  JP=JNDEX(J1P)
C
                  NOMTG0=(MDP1-1)*MC
C
                  DO MD1=1,MC             !BEGIN LOOP OVER INITIAL TERMS
C
                    J1=MD1+MCI
                    J=JNDEX(J1)
C
                    NOMTG=NOMTG0+MD1                               !orig
C
                    IF(J.LE.JP)THEN   !INITIAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=J
                      JH=JP
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M1,M2)=RHO2(M,NOMTG)
                      ENDDO
C
                    ELSE                !FINAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=JP
                      JH=J
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M2,M1)=RHO2(M,NOMTG)
                      ENDDO
C
                    ENDIF
C
                    DE=DSPECE(JH)-DSPECE(JL)
C
                    NOMT=IROW(JL,JH,ione1,NSPECE)               !ROWWISE
c
                    bdip=.false.
                    if(jl.le.nmeta.and.jl.lt.jh)then        !need exists
                      bdip=omginf(nomt).lt.dzero            !flag dipole
                    endif
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                    DO M0=1,MENG0
C
                      M=IYY0(M0)
c
                      ml=mlim(m,1)
                      mu=mlim(m,2)
c
                      if(bdip)mu=-mu                        !flag dipole
C
                      RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu) !AS A.U.
C
                      RHO2(M0,NOMTG)=RHO
C
                    ENDDO
C
                  ENDDO                     !END LOOP OVER INITIAL TERMS
C
                ENDDO                         !END LOOP OVER FINAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeint=timeint+timef-timei
                  timei=timef
                endif
c
                mx=meng0                                         !re-set
c
               endif
C
                NOMTG=MC*MCP
                DO M=1,MX
                  DO N=1,NOMTG
                    RHO1(N,M)=RHO2(M,N)
                  ENDDO
                ENDDO
c
                if(btimet)then
                  call cpu_time(timef)
                  timeset=timeset+timef-timei
                  timei=timef
                endif
C
C-----------------------------------------------------------------------
C
C NOW MIX (INITIAL)
C
                N0=NADRUG(NC)
                N0P=NADRUG(ND)
C                MCI=NGRPI(NC)
C                MCIP=NGRPI(ND)
C                MC=NSL(NC)
C                MCP=NSL(ND)
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
C
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(j.lt.0)go to 11                          !omit corr
                  if(j.gt.nmeta)go to 11            !omit non-metastable
C
                  if(bcorr.or.li.eq.lf)then
                    DO MDP1=1,MCP           !SEE IF WE HAVE A FINAL TERM
                      J1P=MDP1+MCIP
                      IF(J1P.GT.J1.and.li.eq.lf)GO TO 11
                      jp=jndex(j1p)
                      if(jp.gt.0)go to 5                          !we do
                    ENDDO
                    GO TO 11                                   !WE DON'T
                  endif
C
   5              N1=N0+(MD1-1)*MC                          !tfu pointer
C
                  DO M=1,MX
C
                    DO MDP1=1,MCP                   !FOR EACH FINAL TERM
C
                      NG0=(MDP1-1)*MC                    !for rho1 nomtg
C
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL                  DD=DDOT(MC,RHO1(NG0+1,M),IONE,TFU(N1+1),IONE)!LAPACK
CL                      ELSE                                     !LAPACK
                        DD=DZERO
                        DO LD1=1,MC                !BEGIN INITIAL MIXING
cx                          IF(ABS(TFU(N1+LD1).GT.XMIX)THEN
                          DD=DD+RHO1(NG0+LD1,M)*TFU(N1+LD1)  !ng=ng0+ld1
cx                          ENDIF
                        ENDDO                        !END INITIAL MIXING
CL                      ENDIF                                    !LAPACK
C
                      TEMP(MDP1,M)=DD
C
c                      j1p=mdp1+mcip
c                      write(6,777)j1,j1p,temp(mdp1,m)
                    ENDDO                           !FOR EACH FINAL TERM
C
                  ENDDO
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixi=timemixi+timef-timei
                    timei=timef
                  endif
C
C NOW MIX (FINAL)
C
                  NOMTG0=(MD1-1)*MCP                                !new
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
C
                    J1P=MDP1+MCIP
                    IF(J1P.GT.J1.and.li.eq.lf)GO TO 11
                    if(j1.eq.j1p.and.ione1.ne.0)go to 10
c
                    jp=jndex(j1p)
                    if(jp.lt.0)go to 10                       !omit corr
c                    if(min(j,jp).gt.nmeta)go to 10      !non-metastable
C
                    N1P=N0P+(MDP1-1)*MCP                    !tfu pointer
C
                    NOMTG=NOMTG0+MDP1                               !new
C
                    DO M=1,MX
C
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL                    DD=DDOT(MCP,TEMP(1,M),IONE,TFU(N1P+1),IONE)!LAPACK
CL                      ELSE                                     !LAPACK
                        DD=DZERO
                        DO LDP1=1,MCP                !BEGIN FINAL MIXING
cx                          IF(ABS(TFU(N1P+LDP1)).GT.XMIX)THEN
                          DD=DD+TEMP(LDP1,M)*TFU(N1P+LDP1)
cx                          ENDIF
                        ENDDO                          !END FINAL MIXING
CL                      ENDIF                                    !LAPACK
C
                      RHO2(M,NOMTG)=DD
C
                    ENDDO
C
c                    write(6,777)j1,j1p,rho2(m,nomtg)
  10              ENDDO                       !END LOOP OVER FINAL TERMS
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixf=timemixf+timef-timei
                    timei=timef
                  endif
C
  11            ENDDO                       !END LOOP OVER INITIAL TERMS
C
C FIRST SEE IF WE NEED REVERSE CASE:
C----------------------------------
C
C  INITIAL & FINAL ARE ALGEBRAIC AND SO NMETA CAN BE IN EITHER/BOTH/NONE
C  BUT WE WANT THE FIRST MIXING MATRIX MULT TO BE FOR NMETA SO WE DON'T
C  NEED TO MULTIPLY BY THE ZERO BLOCK. THUS, WE MAKE A DOUBLE PASS. OF
C  COURSE, IF NMETA=NSPECE THEN THE SECOND PASS IS "SKIPPED".
C
                DO MDP1=1,NSL(NC)                   !CHECK INITIAL TERMS
                  J1P=MDP1+NGRPI(NC)
                  jp=jndex(j1p)
                  if(jp.gt.nmeta)go to 8                         !needed
                ENDDO
                GO TO 130                                      !ALL DONE
C
C NOW MIX (FINAL) - REVERSE CASE
C
   8            N0=NADRUG(ND)
                N0P=NADRUG(NC)
                MCI=NGRPI(ND)
                MCIP=NGRPI(NC)
                MC=NSL(ND)
                MCP=NSL(NC)
C
                DO MD1=1,MC                 !BEGIN LOOP OVER FINAL TERMS
C
                  J1=MD1+MCI
                  j=jndex(j1)
                  if(j.lt.0)go to 13                          !omit corr
                  if(j.gt.nmeta)go to 13            !omit non-metastable
C
                  DO MDP1=1,MCP             !SEE IF WE HAVE INITIAL TERM
                    J1P=MDP1+MCIP
                    IF(J1P.LT.J1.and.li.eq.lf)GO TO 6
                    jp=jndex(j1p)
                    if(jp.gt.nmeta)go to 7                        !we do
   6              ENDDO
                  GO TO 13                                     !WE DON'T
C
   7              N1=N0+(MD1-1)*MC                          !tfu pointer
C
                  DO M=1,MX
C
                    DO MDP1=1,MCP                 !FOR EACH INITIAL TERM
C
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL                    DD=DDOT(MC,RHO1(MDP1,M),MCP,TFU(N1+1),IONE)!LAPACK
CL                      ELSE                                     !LAPACK
                        NG0=MDP1-MCP                     !for rho1 nomtg
                        DD=DZERO
                        DO LD1=1,MC                  !BEGIN FINAL MIXING
cx                          IF(ABS(TFU(N1+LD1)).GT.XMIX)THEN
                          DD=DD+RHO1(NG0+LD1*MCP,M)*TFU(N1+LD1)
cx                          ENDIF
                        ENDDO                          !END FINAL MIXING
CL                      ENDIF                                    !LAPACK
C
                      TEMP(MDP1,M)=DD
C
c                    j1p=mdp1+mcip
c                    write(6,777)j1,j1p,temp(mdp1,m)
                    ENDDO                         !FOR EACH INITIAL TERM
C
                  ENDDO
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixfr=timemixfr+timef-timei
                    timei=timef
                  endif
C
C NOW MIX (INITIAL) - REVERSE CASE
C
                  DO MDP1=1,MCP           !BEGIN LOOP OVER INITIAL TERMS
C
                    J1P=MDP1+MCIP
                    IF(J1P.LT.J1.and.li.eq.lf)GO TO 12
                    if(j1.eq.j1p.and.ione1.ne.0)go to 12
c
                    jp=jndex(j1p)
c                    if(jp.lt.0)go to 12                     !omit  corr
                    if(jp.le.nmeta)go to 12              !already gotten
C
                    N1P=N0P+(MDP1-1)*MCP                    !tfu pointer
C
                    NOMTG=MD1+(MDP1-1)*MC                           !new
C
                    DO M=1,MX
C
CL                      IF(LAPAK.GT.0)THEN                       !LAPACK
CL                    DD=DDOT(MCP,TEMP(1,M),IONE,TFU(N1P+1),IONE)!LAPACK
CL                      ELSE                                     !LAPACK
                        DD=DZERO
                        DO LDP1=1,MCP              !BEGIN INITIAL MIXING
cx                          IF(ABS(TFU(N1P+LDP1)).GT.XMIX)THEN
                          DD=DD+TEMP(LDP1,M)*TFU(N1P+LDP1)
cx                          ENDIF
                        ENDDO                        !END INITIAL MIXING
CL                      ENDIF                                    !LAPACK
C
                      RHO2(M,NOMTG)=DD
C
                    ENDDO
C
c                    write(6,777)j1,j1p,(rho2(m,nomtg),m=1,mx)
  12              ENDDO                     !END LOOP OVER INITIAL TERMS
c
                  if(btimet)then
                    call cpu_time(timef)
                    timemixir=timemixir+timef-timei
                    timei=timef
                  endif
C
  13            ENDDO                         !END LOOP OVER FINAL TERMS
C
C RE-SET
                MCI=NGRPI(NC)
                MCIP=NGRPI(ND)
                MC=NSL(NC)
                MCP=NSL(ND)
C
  130           CONTINUE
C
C-----------------------------------------------------------------------
C
C (IF bmix INTERPOLATE MIXED RHO2.) CONVERT TO TMX AND ADD TO OMEGA
C NOTE, RHO2 IS IN "A.U"
C ALLOW FOR ANY INITIAL ALGEBRAIC TERMS NOT BEING LOWEST IN ENERGY.
c
                if(.not.bmix)mx=-mx                  !skip interp set-up
C
                DO MD1=1,MC               !BEGIN LOOP OVER INITIAL TERMS
C
                  J1=MD1+MCI
                  J=JNDEX(J1)
                  if(j.lt.0)go to 14                          !omit corr
C
                  NCH=NCHI+MD1
c hold
                  if(bunit2)then
                    iwrkn(nch)=j
                    iwrkl(nch)=l0
                  endif
C
                  NOMTG0=(MD1-1)*MCP
C
                  DO MDP1=1,MCP             !BEGIN LOOP OVER FINAL TERMS
C
                    J1P=MDP1+MCIP
                    IF(J1P.GT.J1.and.li.eq.lf)GO TO 14
                    if(j1.eq.j1p.and.ione1.ne.0)go to 15
C
                    JP=JNDEX(J1P)
                    if(jp.lt.0)go to 15                       !omit corr
                    if(min(j,jp).gt.nmeta)go to 15       !non-metastable
C
                    NCHP=NCHIP+MDP1
c
c                    write(6,*)nch,nchp,j1,j1p,j,jp
c
                    if(bntest)ntest(nch,nchp)=ntest(nch,nchp)+1
c
c "undefined" should not be accessed by xint...
c                    do m2=1,meng
c                      do m1=1,meng
c                        tmp(m1,m2)=1.d70 !dzero      !test
c                      enddo
c                    enddo
C
                    NOMTG=NOMTG0+MDP1                  !rho2 nomtg (new)
C
                    IF(J.LE.JP)THEN   !INITIAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=J
                      JH=JP
                      NCHL=NCH
                      NCHH=NCHP
                      LUP=LF
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M1,M2)=RHO2(M,NOMTG)
                      ENDDO
C
                    ELSE                !FINAL ALGEBRAIC IS LOWER ENERGY
C
                      JL=JP
                      JH=J
                      NCHL=NCHP
                      NCHH=NCH
                      LUP=LI
C
                      DO M=1,MX
                        M1=MNDEX(M,1)
                        M2=MNDEX(M,2)
                        TMP(M2,M1)=RHO2(M,NOMTG)
                      ENDDO
C
                    ENDIF
C
                    DE=DSPECE(JH)-DSPECE(JL)
C
                    NOMT=IROW(JL,JH,ione1,NSPECE)               !ROWWISE
c
                    if(nomt.gt.nomwrt)then        !shouldn't happen, now
                      write(0,*)jl,jh,nmeta,nspece,nomt,nomwrt
                      stop 'omega prob.'
                    endif
c
                    bdip=omginf(nomt).lt.dzero              !flag dipole
C
C LOOP-OVER MENG0 UPPER STATE SCATTERING ENERGIES
C
                    DO M0=1,MENG0
C
                      M=IYY0(M0)
c
                     if(bmix)then                                !interp
c
                      ml=mlim(m,1)
                      mu=mlim(m,2)
c
                      if(bdip)mu=-mu                        !flag dipole
C
                      RHO=-2*XINT(DE,DYY,NLAG,TMP(1,M),M,ml,mu) !AS A.U.
c
                     else                                  !already have
C
                      RHO=RHO2(M0,NOMTG)
c
                     endif
C
                      RHOSQ=RHO*RHO
c store for ii
                      if(bunit2)then
                        if(nchp.gt.nch)stop 'dwxls: channel reversal'
                        nx=irow(nchp,nch,izero,nchlt)
                        rhom(nx,m0)=rho
                        go to 16
                      endif
C
                      IF(NCH.eq.NCHP)THEN                   !DIAGONAL MX
c                        if(j1.ne.j1p.or.li.ne.lf)stop 'not diag'
C
                        IF(BRMX)THEN                    !USUAL REACTANCE
                          T=PI*PSHFTX(M,L0)
                          CT=COS(T)
                          ST=SIN(T)
                          RMX=(ST+RHO*CT)/(CT+RHO*ST)
                        ENDIF
C
                        IF(BPRNT3)WRITE(6,202)NCHL,NCHH,JL,JH
     X                                    ,PSHFTX(M,L0),M0,'PHASE SHIFT'
                        T=TPI*PSHFTX(M,L0)
                        C2T=COS(T)
                        S2T=SIN(T)
C
                        if(bunit)then                       !2x2 UNITARY
                          TSQ=DONE+(C2T*(RHOSQ-DONE)+DTWO*S2T*RHO)
     X                            /(RHOSQ+DONE)
                        else                                !non-unitary
                          tsq=done+(dtwo*s2t*rho-c2t)
                        endif
c
                        TSQ=TSQ+TSQ        !  T^R=1+EXP(2I*TAU)(T^RHO-1)
C
                      ELSE                                 !OFF DIAGONAL
C
                        IF(BRMX)THEN                    !USUAL REACTANCE
                          T1=TPI*PSHFTX(M,L0)
                          T2=TPI*PSHFTX(M,L00)
                          DET=COS(T1)*COS(T2)-RHOSQ*SIN(T1)*SIN(T2)
                          RMX=RHO/DET
                        ENDIF
C
                        TSQ=4*RHOSQ        !   |T^R(V,V')|=|T^RHO(V,V')|
C
                        if(bunit)TSQ=TSQ/(DONE+RHOSQ)**2 !APPROX UNITRTY
C
                        IF(J1.EQ.J1P)TSQ=TSQ+TSQ   !FOR ELASTIC LI.NE.LF
C
                      ENDIF
C
                      IF(BPRNT3)THEN
                        IF(BRMX)THEN
                          WRITE(6,202)NCHL,NCHH,JL,JH,RMX,M0,
     X                               'R-MATRIX  '
                        ELSE
                          WRITE(6,202)NCHL,NCHH,JL,JH,RHO,M0,
     X                               'RHO-MATRIX'
                        ENDIF
                      ENDIF
C
                      OMPW=wait*TSQ*NWT/DTWO
C
                      if(bht)ompw=ompw/2       !for BHT(1970) comparison
C
C LOOK AT TOP-UP ISSUES, IF L LARGE ENOUGH TO WARRANT IT (OFF IF BTHRSH)
C
                      IF(LNEW.GE.LRGLMN)THEN
C                                                     !NON-DIPOLE TOP-UP
                        IF(OMGINF(NOMT).GT.DZERO.and.litlam.gt.0)THEN
C
                          IF(LNEW.EQ.LRGLAM)THEN           !APPLY TOP-UP
                            EJ=DYY0(M0)
                            EI=EJ+DE
c
                            ompw0=ompw
                            ompw=ompw/wait
                            IF(BPRNT3)OMPW=-OMPW             !FLAG PRINT
C
                            CALL TOP2(LITLAM,LRGLAM,EI,EJ,OMPW)
C
                            ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                          ELSEIF(LNEW.GT.LRGLAM)THEN
                            OMPW=DZERO
                          ENDIF
C                                                  !DIPOLE:LITLAM=LRGLAM
                        ELSEIF(bdip)THEN                  !POSS ZERO-OUT
C                                                        !INC. IN TOP-UP
                          IF(MAX(LI,LF)/2.GT.LRGLAM)OMPW=DZERO
C
                        ENDIF
C
                      ENDIF
C
C ARCHIVE PARTIAL/TOTAL COLLISION STRENGTHS
C
                      IF(BTHRSH)THEN
                        M00=LUP/2+1-LVMIN
                        IF(M00.LT.1.OR.M00.GT.MOGGY)GO TO 15
                      ELSE                   !CASE NOT XCLUDED BY ALGXLS
                        M00=M0
                      ENDIF
C
                      OMP(M0)=OMPW
C                                                    !UPDATE TOTAL OMEGA
                      OMEGA(M00,NOMT)=OMEGA(M00,NOMT)+REAL(OMPW,RP)
C
  16                ENDDO                        !END LOOP OVER ENERGIES
C                                                         !PARTIAL OMEGA
                    IF(BPRNT2.and..not.bunit2)
     X              WRITE(6,201)NCHL,NCHH,JL,JH,(OMP(M0),M0=1,MENG0)
C
  15              ENDDO                       !END LOOP OVER FINAL TERMS
C
  14            ENDDO                       !END LOOP OVER INITIAL TERMS
c
                if(btimet)then
                  call cpu_time(timef)
                  timeint=timeint+timef-timei
                  timei=timef
                endif
C
                NCHIP=NCHIP+MCP
              ENDDO                               !END LOOP OVER FINAL L
C
              NCHI=NCHI+MC
            ENDDO                               !END LOOP OVER INITIAL L
C
  68        NCHIP0=NCHIP0+((L2P-L1P)/4+1)*MCP!=NCHIP
            if(nchip0.ne.nchip)stop 'nchip0.ne.nchip'
c            write(0,*)nchip0,nchip
          ENDDO                              !END LOOP OVER FINAL GROUPS
C
          NCHI0=NCHI0+((L2-L1)/4+1)*MC     !=NCHI
          if(nchi0.ne.nchi)stop 'nchi0.ne.nchi'
c            write(0,*)nchi0,nchi
        ENDDO                              !END LOOP OVER INITIAL GROUPS
C
        if(bntest)then
          if(nch.ne.nchp)stop 'channel index error'
          do i=1,nch
            if(ntest(i,i).ne.1)then
                  write(0,*)'checksum wrong for nch,nch '
     x           ,i,' :',ntest(i,i)
            endif
            do j=i+1,nch
              if(ntest(i,j)+ntest(j,i).ne.1)then
                write(0,*)'checksum wrong for nch,nchp'
     x                   ,i,j,' :',ntest(i,j),ntest(j,i)
              endif
            enddo
          enddo
        endif
c
c now determine t-matrix from full rho-matrix for approximation-ii:
c
        if(bunit2)then
c
          do m0=1,meng0
            m=iyy0(m0)
c
CL            if(m0.gt.0)then                                    !LAPACK
CL             call pqlap(nchlt,rhom(1,m0),wrkp,wrkq,work,nf)    !LAPACK
CL            else                                               !LAPACK
             call pq(nchlt,rhom(1,m0),wrkp,wrkq,work,nf)
CL            endif                                              !LAPACK
c
            if(nf.le.0)go to 700
c
            do nch=1,nchlt
c
              j=iwrkn(nch)
              if(j.le.0)go to 17
              l0=iwrkl(nch)
c
              do nchp=nch,nchlt
c
                jp=iwrkn(nchp)
                if(jp.le.0)go to 18
c
                n=irow(nch,nchp,izero,nchlt)
                tp=-2*wrkp(n)                 !real T^rho
                tq=-2*wrkq(n)                 !imag T^rho
c
c get T^K from T^rho
c
                if(nch.eq.nchp)then
                  t=tpi*pshftx(m,l0)
                  if(bprnt2)write(6,202)nch,nchp,j,jp
     x                             ,pshftx(m,l0),m0,'phase shift'
                  c2t=cos(t)
                  s2t=sin(t)
                  tp1=tp-done
c                  tr=done+c2t*tp1-tq*s2t
c                  ti=s2t*tp1+c2t*tq
c                  tsq=tr*tr+ti*ti
                  tsq=done+(2*c2t+tp1)*tp1-(2*s2t-tq)*tq
                else
                  tsq=tp*tp+tq*tq
                  if(j.eq.jp)tsq=tsq+tsq
                endif
c
                ompw=wait*tsq*nwt/dtwo
c
                if(bht)ompw=ompw/2      !for bht(1970) comparison
c
                if(j.le.jp)then
                  jl=j
                  jh=jp
                  nchl=nch
                  nchh=nchp
                else
                  jl=jp
                  jh=j
                  nchl=nchp
                  nchh=nch
                endif
c
                nomt=irow(jl,jh,ione1,nspece)
c some top-up
                if(lnew.ge.lrglmn)then             !look at top-up
c
                  if(omginf(nomt).gt.dzero)then        !non-dipole
c
                    if(lnew.eq.lrglam)then           !apply top-up
                      de=dspece(jh)-dspece(jl)
                      ej=dyy0(m0)
                      ei=ej+de
c
                      ompw0=ompw
                      ompw=ompw/wait
                      if(bprnt3)ompw=-ompw             !flag print
c
                      call top2(itwo,lrglam,ei,ej,ompw)
c
                      ompw=ompw+ompw0*(wait-done)/wait     !adjust
c
                    elseif(lnew.gt.lrglam)then
                      ompw=dzero
                    endif
c
                  elseif(omginf(nomt).lt.dzero)then        !dipole
                    if(lnew.gt.lrglam)ompw=dzero
                  endif
c
                endif
c
                omp(m0)=ompw
                omega(m0,nomt)=omega(m0,nomt)+real(ompw,rp)
                if(bprnt2)write(6,201)nchl,nchh,jl,jh,tp,tq,omp(m0)
c
  18          enddo
c
  17        enddo
            if(bprnt2)write(6,*)':'
c
          enddo
c
          if(btimet)then
            call cpu_time(timef)
            timeunit=timeunit+timef-timei
          endif
c
          deallocate (rhom,wrkp,wrkq,iwrkn,iwrkl,work,stat=ierr)
c
          if(ierr.ne.0)then
            write(0,*)'dwxls: deallocation fails for rhom,wrk'
            nf=0
            go to 999
          endif
c
        endif
C
C-----------------------------------------------------------------------
C
        if(btimet)then
          write(iw,*)'  set-up time=',nint(timeset),'sec'
          write(iw,*)'   mixi  time=',nint(timemixi),'sec'
          write(iw,*)'   mixf  time=',nint(timemixf),'sec'
          write(iw,*)'   mixir time=',nint(timemixir),'sec'
          write(iw,*)'   mixfr time=',nint(timemixfr),'sec'
          timemix=timemixi+timemixf+timemixir+timemixfr
          write(iw,*)'  mixing time=',nint(timemix),'sec'
          write(iw,*)'  interp time=',nint(timeint),'sec'
          if(bunit2)write(iw,*)' unitary time=',nint(timeunit),'sec'
        endif
c
        if(btimex)then
          call cpu_time(timef)
          times=timef-times
c
cpar          if(iam.ge.0)then                                      !par
cpar            write(6,*)'Ending proc',iam                         !par
cpar     x               ,'dwxls symmetry',ix,':',' nchan='         !par
cpar     x               ,nchs,'(',nch,')'                          !par
cpar     x               ,'  time=',nint(times),'sec'               !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
          write(iw,*)'Ending dwxls symmetry ',ix,':',' nchan='
     x             ,nchs,'(',nch,')'
     x             ,'  time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
C-----------------------------------------------------------------------
C
        KUTOOX=KOLDOO
        BKUTOO=KUTOOX.NE.0
C                                             --------------------------
      ENDDO                                   !END LOOP OVER TOTAL SYMMS
C                                             --------------------------
C
      IF(IADD.NE.NCOR)THEN
        WRITE(6,*)'SR.DWXLS: GLOBAL INDEX ERROR:',IADD,NCOR        !test
        GO TO 999
      ENDIF
C
cparc                                                               !par
cpar      if(iam.ne.0)then                                          !par
cpar        if(btimex)then                                          !par
cpar          btimep=.false.                                        !par
cpar          call cpu_time(timef)                                  !par
cpar          times=timef-time0                                     !par
cparc                                                               !par
cpar          write(iw,*)'Ending proc',iam,' for dwxls:'            !par
cpar     x             ,' time=',nint(times),'sec'                  !par
cpar        endif                                                   !par
cpar      endif                                                     !par
cparc                                                               !par
cpar      ns=0                                                      !par
cpar      nr=0                                                      !par
cpar      itmp4=int(nomwrt)                                         !par
cparc                                                               !par
cpar      do m0=1,moggy                                             !par
cparc                                                               !par
cpar        call pomsend(ns,omega(1,1),nomwrt,omsend)               !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        call mpi_reduce(omsend,omrecv,itmp4,my_mpi_real,        !par
cpar     x                  mpi_sum,izero_mpi,mpi_comm_world,ier4)  !par
cparc                                                               !par
cpar        if(ier4.ne.0)write(0,*)'mpi_reduce: iam, ier=',iam,ier4 !par
cparc                                                               !par
cpar        call comm_barrier()                                     !par
cparc                                                               !par
cpar        if(iam.eq.0)call pomrecv(nomwrt,omrecv,nr,omega(1,1))   !par
cparc                                                               !par
cpar      enddo                                                     !par
cparc                                                               !par
cpar      if(iam.ne.0)go to 700                                     !par
cparc                                                               !par
C
C APPLY (DIPOLE) TOP-UP (OFF IF BTHRSH)
C
      IF(LRGLAM.GT.0)THEN
C
        WRITE(6,1002)LRGLAM
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,                                !par
cpar     x       'Top-up has been applied: lrglam=',lrglam          !par
cpar        else                                                    !par
          write(iw,*)'Top-up has been applied: lrglam=',lrglam
cpar        endif                                                   !par
        endif
        IF(BPRNT2)WRITE(6,716)
C
        LITLAM=LRGLAM                             !USE GLOBAL VALUE LA=0
        CO2S=D3QRT/LOG(EINF*DZ2)
C
        NOMT=0
        DO I=1,NMETA                                        !,NSPECL
c          IF(INDEX(I).GT.0)THEN                               !NON-CORR
C
          DO J=I+ione1,NSPECE                                !,NSPECL
c            IF(INDEX(J).GT.0)THEN                             !NON-CORR
C
              NOMT=NOMT+1
              SS=OMGINF(NOMT)
C
              IF(SS.LT.DZERO)THEN                                !DIPOLE
                SS=SS*CO2S                     !CONVERT TO LINE STRENGTH
                DE=DSPECE(J)-DSPECE(I)
                DE=DE/DZ2
                DO M0=1,MENG0
                  EJ=DYY0(M0)/DZ2
                  EI=EJ+DE
C
                  CALL TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
                  if(bht)omt=omt/2             !for BHT(1970) comparison
c
                  OM=REAL(OMEGA(M0,NOMT),WP)
                  OMEGA(M0,NOMT)=OMEGA(M0,NOMT)+REAL(OMT,RP)
C
                  IF(BPRNT2)WRITE(6,717)I,J,SS,EI,EJ,DE,OM,OMT,OM+OMT
                ENDDO
              ENDIF
C
c              IF(NOMT.EQ.NOMWRT)GO TO 113                  !WE ARE DONE
c            ENDIF
          ENDDO
C
c          ENDIF
        ENDDO
C
      ELSE
C
        WRITE(6,1003)
        if(btimex)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Proc',iam,'Top-up has *NOT* been applied!'!par
cpar        else                                                    !par
          write(iw,*)'Top-up has *NOT* been applied!'
cpar        endif                                                   !par
        endif
C
      ENDIF
C
c 113  CONTINUE
c
c fix top-up failure on high-e near-degenerate Born allowed transitions
c
      if(btop)then
        NOMT=0
        DO I=1,NMETA
          DO J=I+ione1,NSPECE
            NOMT=NOMT+1
            OMB=OMGINF(NOMT)
            IF(OMB.GT.DZERO)THEN                                   !born
              DE=DSPECE(J)-DSPECE(I)
              DE=MAX(DE,D1M30)
              OM=REAL(OMEGA(2,NOMT),WP)
              DO M0=3,MENG0                        !skip threshold point
                RAT=DYY0(M0)/DE
                OM1=OM
                OM=REAL(OMEGA(M0,NOMT),WP)
                IF(RAT.GT.XBTEST.AND.OM.LT.D0PT8*OM1.AND.OM1.LT.OMB)THEN
                  MM=M0-1              !max(2,m0-1) if no threshold skip
                  GO TO 196
                ENDIF
              ENDDO
              M0=MENG0
              MM=M0+1
              IF(OM1.GE.OMB)THEN
                IF(OM.LT.OMB)MM=MENG0
              ELSE
                IF(OM.LT.OM1)MM=MENG0
              ENDIF
  196         IF(BPRNT2.AND.MM.LE.MENG0)THEN
                WRITE(6,762)I,J,DYY0(M0),DE,RAT,
     X                        (OMEGA(M,NOMT),M=1,MENG0),OMB
              ENDIF
              DO M0=MM,MENG0
                OMEGA(M0,NOMT)=REAL(OMB,RP)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      endif
c                                                                     !x
c test convert to cross section                                       !x
c                                                                     !x
c      nomt=0                                                         !x
c      do i=1,nmeta                                                   !x
c        j=index(i)                                                   !x
c        jj=nfq(j)                                                    !x
c        wi=(qsi(jj)+1)*(qli(jj)+1)                                   !x
c        do j=i+ione1,nspece                                          !x
c          nomt=nomt+1                                                !x
c          de=dspece(j)-dspece(i)                                     !x
c          do m0=1,moggy                                              !x
c            ej=dyy0(m0)                                              !x
c            ei=ej+de                                                 !x
c            if(brel)ei=ei+dalf4*ei*ei          !wavenumber           !x
c            om=real(omega(m0,nomt),wp)                               !x
c            om=xconv*om/(ei*wi)                                      !x
c            omega(m0,nomt)=real(om,rp)                               !x
c          enddo                                                      !x
c        enddo                                                        !x
c      enddo                                                          !x
C
C-----------------------------------------------------------------------
C
C WRITE TOTALS
C
      IF(BTHRSH)THEN
        WRITE(6,1001)
        IF(BPRNT0)THEN
          WRITE(6,1118)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MOGGY
            WRITE(6,200)REAL(M0-1+LVMIN),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ELSE
        WRITE(6,1000)
        IF(BPRNT0)THEN
          WRITE(6,1117)((I,J,J=I+ione1,NSPECE),I=1,NMETA)       !ROWWISE
          DO M0=1,MENG0                                         !=MOGGY
            WRITE(6,200)DYY0(M0),(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
        ENDIF
      ENDIF
C
      IF(IUNIT(IU).GT.0)THEN
        CLOSE(IU,STATUS='DELETE')
        IF(BTHRSH.or..not.bomega)THEN
          IUNIT(IU)=-1
        ELSE
          OPEN(IU,FILE='OMEGALS',STATUS='REPLACE')  !OPEN UNDER NEW NAME
CTBD        OPEN(IU,FILE='OMEGAULS',STATUS='REPLACE',FORM='UNFORMATTED')
          WRITE(IU,*)NZION,MION
          WRITE(IU,*)NSPECE,-(MENG0+1),NOMWRT       !FLAG NO E'S .LT.0
          WRITE(IU,*)(IWRK3(I),IWRK4(I),I=1,NSPECE)
          WRITE(IU,711)(DWRK(I),I=1,NSPECE)
          DO M0=1,MENG0                                          !=MOGGY
            WRITE(IU,713)DYY0(M0)/DZ2,(OMEGA(M0,N),N=1,NOMWRT)
          ENDDO
          WRITE(IU,713)EINF,(OMGINF(N),N=1,NOMWRT)
          IUNIT(IU)=-1
          CLOSE(IU)
        ENDIF
      ENDIF
C
C OVERWRITE PWB ADF04 WITH DW, TAKING ACCOUNT OF THE FACT THAT THE PWB
C DOES NOT CONTAIN (SPIN) FORBIDDEN TRANSITIONS
C
      IF(IUNIT(IUU).GE.0)THEN           !NO ADF04, LIKELY SINCE RAD='NO'
        WRITE(6,*)'NO ADF04 FILE="adf04ls"...'
        WRITE(0,*)'NO ADF04 FILE ON UNIT=',IUU
C        NF=-1
        GO TO 700
      ELSEIF(IUNIT(IUU).LT.0)THEN
        IUNIT(IUU)=1
        OPEN(IUU,FILE='adf04ls',STATUS='OLD',ERR=700)
      ENDIF
C
      BEXP=.FALSE.                              !*MUST* SYNC WITH DIAGON
      IF(NSPECE.LT.1000)THEN
        i1=0
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2))'
            F762='(2I4,22(1PE10.2))'
            F767='(18X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3))'
            F762='(2I4, 22(A5, A3))'
            F767='(16X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5, 8X,20(1PE10.2)/(18X,20(1PE10.2)))'
            F762='(2I4,21(1PE10.2)/(18X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 6X, 20(A5, A3)/(16X, 20(A5, A3)))'
            F762='(2I4, 21(A5, A3)/(16X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ELSE
        i1=1
        IF(MOGGY.LE.20)THEN
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2))'
            F762='(2I5,22(1PE10.2))'
            F767='(20X,21(F10.5))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3))'
            F762='(2I5, 22(A5, A3))'
            F767='(18X,21(F8.5))'
          ENDIF
        ELSE
          IF(BEXP)THEN
            F761='(F5.2, I5,10X,20(1PE10.2)/(20X,20(1PE10.2)))'
            F762='(2I5,21(1PE10.2)/(20X,20(1PE10.2)))'
          ELSE
            F761='(A5,A3,I2, 8X, 20(A5, A3)/(18X, 20(A5, A3)))'
            F762='(2I5, 21(A5, A3)/(18X, 20(A5, A3)))'  !WRAP LAST POINT
          ENDIF
        ENDIF
      ENDIF
C
      MSC0=80
      OPEN(MSC0,STATUS='SCRATCH',FORM='FORMATTED')
      IF(.NOT.BEXP)THEN
        MSCP=81
        OPEN(MSCP,STATUS='SCRATCH',FORM='FORMATTED')
      ENDIF
C
      DO N=1,NSPECE+2
        READ(IUU,760)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
      NNN=max(NOMWRT,nomwr0)
C
      DO N=1,NNN+2
        READ(IUU,760,END=115)CARD
        WRITE(MSC0,760)CARD
      ENDDO
C
 115  REWIND(IUU)
      REWIND(MSC0)
C
      DO N=1,NSPECE+2
        READ(MSC0,760)CARD
        WRITE(IUU,760)CARD
      ENDDO
C
      IF(BTHRSH)THEN
        ITYPE=6
        WRITE(IUU,F767)(PSHFT0(M-1+LVMIN),M=1,MOGGY)
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(REAL(M-1+LVMIN),M=1,MOGGY)
        ELSE
          WRITE(MSCP,764)(REAL(M-1+LVMIN),M=1,MOGGY)
        ENDIF
      ELSE
        ITYPE=5
        IF(BEXP)THEN
          WRITE(IUU,F761)REAL(NZA+1),ITYPE,(DYY0(M),M=1,MENG0)   !=MOGGY
        ELSE
          WRITE(MSCP,764)(DYY0(M),M=1,MENG0)                     !=MOGGY
        ENDIF
      ENDIF
C
      IF(BEXP)THEN
        READ(MSC0,F761)
      ELSE
        BACKSPACE(MSCP)
        READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
        iexp(0)='   '
        READ(MSC0,F761)XMANT(0)                                !,IEXP(0)
        WRITE(IUU,F761)XMANT(0),IEXP(0),ITYPE
     X               ,(XMANT(M),IEXP(M),M=1,MOGGY)
      ENDIF
C
      MENG1=MOGGY+1
      IB0=1
      JB0=IB0+IONE1
c
      nt=0
C
      DO N=1,NNN+1
C
        IF(BEXP)THEN
          READ(MSC0,F762)JB,IB,XB0,(DUM,I=1,MXNXB),XB1
        ELSE
          READ(MSC0,F762)JB,IB,XMANT0,IEXP0,
     X             (XMANT(I),IEXP(I),I=1,MXNXB),XMANT1,IEXP1
        ENDIF
C
        JB1=JB
        IF(JB.LT.0)THEN
          JB1=NSPECE
          IB=MIN(JB1-IONE1,NMETA)
          IF(BEXP)THEN
            XB0=D1M30
            XB1=DZERO
          ELSE
            XMANT0=' 1.00'
            IEXP0='-30'
            XMANT1=' 0.00'
            IEXP1='+00'
          ENDIF
        ENDIF
C
        IF(BEXP)THEN
          X0=D1M30
          X1=DZERO
        ELSE
          XMANT(0)=' 1.00'
          IEXP(0)='-30'
          XMANT(MENG1)=' 0.00'
          IEXP(MENG1)='+00'
        ENDIF
C
        DO JT=JB0,JB1
          IF(JT.EQ.JB1)THEN
            IB1=IB
          ELSE
            IB1=MIN(JT-IONE1,NMETA)
          ENDIF
          DO IT=IB0,IB1
C
ctest        if(ione1.eq.0.or.it.ne.jt)then   !catch ione1=0 diagon only
            nt=nt+1
c
            NOMT=IROW(IT,JT,IONE1,NSPECE)
C                                            !TEST MENG0 STILL IF BTHRSH
            IF(OMEGA(MENG0,NOMT).GT.E1M30)THEN         !SKIP SA-SAP.GT.1
c
c              if(omginf(nomt).lt.dzero)then  !test write reduced dipole
c                do m=1,moggy
c                  de=log(dyy0(m)+2.7183)
c                  omega(m,nomt)=omega(m,nomt)/de
c                enddo
c              endif
C
              IF(BEXP)THEN
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  X0=XB0
                  X1=XB1
                ENDIF
                WRITE(IUU,F762)JT,IT,X0,(OMEGA(M,NOMT),M=1,MOGGY),X1
              ELSE
                BACKSPACE(MSCP)
                WRITE(MSCP,764)(OMEGA(M,NOMT),M=1,MOGGY)
                BACKSPACE(MSCP)
                READ(MSCP,765)(XMANT(M),IEXP(M),M=1,MOGGY)
                IF(JT.EQ.JB1.AND.IT.EQ.IB1)THEN             !NOW ALLOWED
                  XMANT(0)=XMANT0
                  IEXP(0)=IEXP0
                  XMANT(MENG1)=XMANT1
                  IEXP(MENG1)=IEXP1
                ENDIF
                WRITE(IUU,F762)JT,IT,(XMANT(M),IEXP(M),M=0,MENG1)
              ENDIF
C
            ENDIF
ctest        endif
          ENDDO
          IB0=1
        ENDDO
C
        IF(JB.LT.0)then
          if(nt.ne.nomwrt)then                                 !checksum
            write(6,*)'adf04 no. of transitions mis-match: nt,nomwrt='
     x                ,nt,nomwrt
            write(0,*)'adf04 no. of transitions mis-match'
            nf=-1
            go to 700
          endif
          GO TO 120
        endif
C
        JB0=JB
        IB0=IB+1
C
      ENDDO
C
      WRITE(0,*)'SR.DWXLS: HAVE NOT REACHED END OF adf04ls...'
      WRITE(6,*)'SR.DWXLS: HAVE NOT REACHED END OF adf04ls...'
      NF=-1
      GO TO 700
C
  120 WRITE(IUU,F762)-1
      WRITE(IUU,F762)-1,-1
c
        if(.not.badas)then                           !adas skip comments
      WRITE(IUU,758)
C
      NREC=1
  121 NREC=NREC+1
      BACKSPACE(5)
      BACKSPACE(5)
      READ(5,766)CARD4
      IF(CARD4.NE.'A.S.'.AND.CARD4.NE.'S.S.')GO TO 121
      REWIND(5)
C
      DO N=1,NREC
        READ(5,760)CARD
        WRITE(IUU,759)CARD
      ENDDO
      DATE='        '
      CALL DATE_AND_TIME(DATE)
      WRITE(IUU,763)DATE(7:7),DATE(8:8),DATE(5:5),DATE(6:6)
     X             ,DATE(3:3),DATE(4:4)
        endif
C
      IUNIT(IUU)=-1
      CLOSE(IUU)
C
      CLOSE(MSC0)
      IF(.NOT.BEXP)CLOSE(MSCP)
C
C-----------------------------------------------------------------------
C
  700 CONTINUE
C
      DEALLOCATE (KACT,KTMP,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR KACT,KTMP'
        NF=0
        GO TO 999
      ENDIF
C
  800 CONTINUE
C
      DEALLOCATE (RHO1,RHO2,TEMP,OMGINF,OMEGA,STAT=IERR)
cparc                                                               !par
cpar      deallocate (omsend,omrecv,stat=ierr)                      !par
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR RHO,OMEGA,TEMP'
        NF=0
        GO TO 999
      ENDIF
C
  900 DEALLOCATE (TFU,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'DWXLS: DEALLOCATION FAILS FOR TFU'
        NF=0
        GO TO 999
      ENDIF
C
  998 CONTINUE
C
      DEALLOCATE (NADRUG)
      DEALLOCATE (TMP,OMP)
      DEALLOCATE (IEXP,XMANT)
      IF(ALLOCATED(DWRK))DEALLOCATE (DWRK,IWRK3,IWRK4)
C
  999 CONTINUE
C
C-----------------------------------------------------------------------
C
      if(btimep)then
        call cpu_time(timef)
        times=timef-time0
c
C        if(abs(modd).le.1)then
c
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for dwxls:'            !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending dwxls: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
C        endif
      endif
C
C-----------------------------------------------------------------------
C
      RETURN
C
C
  200 FORMAT(F21.3,2X,1P,10(E11.3)/(23X,10(E11.3)))
  201 FORMAT(2I5,3X,2I4,2X,1P,10(E11.3)/(23X,10(E11.3)))
  202 FORMAT(2I5,3X,2I4,2X,1PE11.3,10X,'E(',I2,')   ',A11)
  711 FORMAT(1P,5E16.6)
  713 FORMAT(1PE14.8,6E11.3/(14X,6E11.3))
  716 FORMAT(3X,'CH',2X,'CHP',9X,'S',14X,'EI',10X,'EJ',10X,'DE',
     X9X,'OMEGA(PAR)',2X,'OMEGA(TOP)',4X,'OMEGA(TOT)')
  717 FORMAT(2I5,3X,1PE11.3,2X,0P,3F12.4,5X,2F12.4,2X,F12.4)
  758 FORMAT('C',79('-')/'C'/'C')
  759 FORMAT('C ',A200)
  760 FORMAT(A200)
  762 FORMAT(2I5,22(1PE10.2))
  763 FORMAT('C'/'C'/'C',79('-')/'C'/'C',1X
     X ,'AUTOSTRUCTURE DISTORTED-WAVE'/
     X 'C'/'C NAME:'/'C DATE: ',2(A1),'/',2(A1),'/',2(A1)/
     X 'C'/'C',79('-'))
  764 FORMAT(22(1PE9.2))
  765 FORMAT(22(A5,1X,A3))
  766 FORMAT(A4)
  995 FORMAT(2I10,13X,I5,I2,I5,12X,F18.6)
  996 FORMAT(9X,'I',8X,' T',14X,'2S+1 L   CF',20X,'(EI-E1)/RY'
     X      ,15X,'NMETA=',I5)
  997 FORMAT(//' *** FULLY UNITARIZED K- TO T-MATRIX CONVERSION ***'//)
 1000 FORMAT(///1X,136('-')//51X,
     X       '*** TOTAL COLLISION STRENGTHS (LS) ***'//1X,136('-')//)
 1001 FORMAT(///1X,136('-')//45X,
     X       '*** THRESHOLD PARTIAL COLLISION STRENGTHS (LS) ***'//
     X      1X,136('-')//)
 1002 FORMAT(//' *** TOP-UP HAS BEEN APPLIED: LRGLAM=',I5//)
 1003 FORMAT(//' *** TOP-UP HAS *NOT* BEEN APPLIED ***'//)
 1110 FORMAT(//1X,136('-')///
     X   49X,'*** TARGET ENERGIES (LS) ***'/)
 1111 FORMAT(//1X,136('-')/)
 1112 FORMAT(13X,'CH',8X,'T',3X,'SMALL L')
 1113 FORMAT(7X,I8,I9,I10)
 1114 FORMAT(' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3,5X,'NCHT=',I6,2X,'('
     X      ,I6,')')
 1115 FORMAT(//' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3/1X,33('-'))
 1116 FORMAT(/3X,'CH',2X,'CHP',6X,'I',2X,'IP',4X,'OMEGA(IE=1,MENG):')
 1117 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/2X,'*FINAL* ENERGY(RYD)'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1118 FORMAT(74X,'OMEGA(I-IP)'/74X,11('-')/1X,'*FINAL* RYDBERG A.M.'
     X      ,2X,10(2X,I4,'-',I4)/(23X,10(2X,I4,'-',I4)))
 1119 FORMAT(//' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3,5X,'NCHT=',I6,2X,'('
     X      ,I6,')'/1X,33('-'))
 1996 FORMAT(//' *** UPDATING SLATER INTEGRALS FOR LTOT=',
     X       I3/1X,42('-')/)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION IROW(ILI,ILF,IONE1,NENG)
C
      IROW=ILF+NENG*(ILI-1)-(ILI*(ILI-1+2*IONE1))/2
C
      END FUNCTION IROW
C-----------------------------------------------------------------------
C
      END SUBROUTINE DWXLS_DDOT
C
C                             *******************
C
      SUBROUTINE EKALG1(KMAX,NF,MMIN,MMAX,DVC,BAM,BBM,QLML,JYI,JYF,DFS
     X                 ,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.EKALG1 DEALS WITH THE PROBLEMS DESCRIBED IN SECTION 3.2 OF E&N:
C  IT CALCULATES THE PURELY ALGEBRAIC COEFFICIENTS FOR EACH REDUCED
C  ELECTRIC MULTIPOLE MATRIX ELEMENT, IN TERMS OF SLATER STATES. NRB
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL ,  ONLY: IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-8)
C
      CHARACTER(LEN=4) CODE
C
      DIMENSION DVC(0:*),BAM(*),BBM(*),QLML(MAXEL,*),JYI(*),JYF(*)
     X         ,DFS(*)
C
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBFAN/BFANO
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
c      MVC(M1,M2)=((M1+2)*M1/2+M2)/2+1!SEE INTRNL FUNCTN ABVE END EKALG1
C
C INITIALIZATIONS
C
      BSKP=MXLL.EQ.-1
      BKUTOO=KUTOO.NE.0
C
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      MXORB2=MXORBR*MXORBR                                        !FLAGX
c
      i1=mb+1                                                     !FLAGX
      i2=i1
C
      IOSS=0
      LOSS=0
      NCF=0
      NADS(0)=0
      KGG=KMAX
      DD=DONE
C
C LOOP OVER ALL CONFIG PAIRS
C
      DO 99 KF=1,KMAX
C
      JA=JYI(KF)
      JB=JYF(KF)
C
      IF(BBM(1))KGG=KF                   !WITHIN A GROUP
C
      DO 90 KG=1,KGG
C
      NCF=NCF+1
      BSKPCF=NADS(NCF).LT.0         !KF AND/OR KG NOT CONTRIB
      NADS(NCF)=NADS(NCF-1)
      IF(BSKPCF)GO TO 90
C
C MMIN IS SYNC'ED TO GROUP PARITY
C      IF(MOD(QCP(KF)+QCP(KG)+MMIN,4).NE.0)GO TO 90 !WRONG PARITY
C
      IOSS00=IOSS+1
      LOSS00=LOSS
      LOSS1=LOSS00+1
      JAP=JYI(KG)
      JBP=JYF(KG)
      BAM(1)=KF.EQ.KG
C
C LOOP OVER SLATER STATES OF ALL CONFIG PAIRS
C

      DO 15  J=JA,JB
        IF(BAM(J))GO TO 15
C
      IF(BAM(1))JBP=J                    !KF=KG
C
      DO 16  JD=JAP,JBP
        IF(BBM(JD))GO TO 16
C
CTHIS NEXT STATEMENT RESOLVES INTERACTIONS BY SLATER STATE, NOT TERM
COLD      IOSS0=IOSS+1
C
      DO I=LOSS1,LOSS
        IORIG(I)=0
      ENDDO
C
      MK=MMIN
      QCL=0
C
      IF(JD.NE.J)THEN
        QCS=0
        DO I=1,NF
          QCS=QCS+I
          DO K=1,NF
            IF(IEQ(QCG(K,KG)).NE.IEQ(QCG(I,KF)))GO TO 19
            IF(QLML(I,J).NE.QLML(K,JD))GO TO 19
            QCS=QCS-K
            GO TO 18
  19      ENDDO
          IF(QCL.NE.0)GO TO 16
          QCL=I
  18    ENDDO
        QCS0=QCS
        QCL0=QCL
        GO TO 20
      ENDIF
C
  27  QCL=QCL+1
      QCS=QCL
C
  20  NG=QCG(QCL,KF)
      NT=QCG(QCS,KG)
C
C     M1=QN(NG)
C     M2=QN(NT)
C     IF(ABS(M1-M2).LT.MDEL)GO TO 28
C
      M1=QL(NG)
      M2=QL(NT)
      IF(M1+M2.LT.MK)GO TO 28              !MK TOO LARGE A MULTIPOLE
      IF(ABS(M1-M2).GT.MK)GO TO 28         !MK TOO SMALL A MULTIPOLE
      IF(MK.GT.ABS(M1-M2)+4*NMULT)GO TO 28 !MK GIVES TOO MANY MULTIPOLES
C
      IF(.NOT.BSKP)THEN
        ML1=((QLML(QCL,J)+100)/2)*2-100
        ML2=((QLML(QCS,JD)+100)/2)*2-100
        ML2=-ML2
        IF(BVC.OR.(M1.LE.MXLL .AND. M2.LE.MXLL))THEN
          I=MVC(M1,ML1)
          K=MVC(M2,ML2)
          MM=MK/4+1
          DD=VCA(I,K,MM)
        ELSE
          MLK=ML1+ML2
          DD=VCC(M1,M2,MK,IZERO,IZERO,IZERO,DFS)
     X      *VCC(M1,M2,MK,ML1,ML2,MLK,DFS)/(MK+1)
        ENDIF
C
        MMM=(MK-ML2)/2
        ISGN=1-2*mod(abs(MMM+QCL+QCS),ITWO)        !(-1)**(MMM+QCL+QCS)
        DD=ISGN*SQRT(REAL((M1+1)*(M2+1),WP))*DD
C
        IF(ABS(DD/DVC(MK/4)).LT.TYNY)GO TO 28
C
        IF(BFANO)THEN
          IFANO=MK+M2-M1
          IFANO=IFANO/4
          IFANO=1-2*mod(abs(IFANO),ITWO)              !(-1)**IFANO
          DD=DD*IFANO
        ENDIF
      ENDIF
C
C STORE COEFFICIENT
C
      MX=MK
      MX=MX-MPOL0                                                 !FLAGX
      if(irlx.lt.0)then
        i1=icfgp(kf)*mb+1
        i2=icfgp(kg)*mb+1
      endif
      IPLANT=(MX/2)*MXORB2+(NG-I1)*MXORBR+NT-I2
C
      DO L=LOSS1,LOSS
        IF(IPLANT.EQ.JORIG(L))THEN
          IF(J.EQ.JD)THEN
            I=IORIG(L)
            IF(I.GT.0)THEN
              DRKS(I)=DRKS(I)+DD
              GO TO 28
            ENDIF
          ENDIF
          LP=L
          GO TO 30
        ENDIF
      ENDDO
C
C CANNOT FIND OLD ARGUMENT
C
      LP=LOSS+1
      IF(LP.GT.IXRLS)THEN                                     !GO TO 999
C
        IXXX=7*(IXRLS/5+1)
C
        WRITE(6,*)'*** EKALG1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** EKALG1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRLS,IONE,IFIVE,IONE,IXRLS,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'EKALG1: REALLOCATION FAILS FOR QRLS'
          NF=0
          GO TO 999
        ENDIF
C
        IXXX0=MAX(IXRLS,IAXRL)
        IXXX2=MAX(IXXX,IAXRL)
        IF(IXXX2.GT.IXXX0)
     X  CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
        CALL RE_ALLOC(JORIG,IONE,IXRLS,IXXX,IERR)
        CALL RE_ALLOC(JPLANT,IONE,IXRLS,IXXX,IERR)         !KEEP IN SYNC
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'EKALG1: REALLOCATION FAILS FOR IORIG,JORIG,JPLANT'
          NF=0
          GO TO 999
        ENDIF
C
        IXRLS=IXXX
C
      ENDIF
C
      LOSS=LP
      QRLS(1,LP)=NT
      QRLS(2,LP)=NG
      QRLS(3,LP)=MK
      JORIG(LP)=IPLANT
C
  30  IOSS=IOSS+1
      IF(IOSS.GT.IXRKS)THEN                                   !GO TO 999
C
        IXXX=7*(IXRKS/5+1)
C
        WRITE(6,*)'*** EKALG1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** EKALG1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRKS,IONE,IXRKS,IXXX,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEKS,IONE,IXRKS,IXXX,IERR)         !KEEP IN SYNC
          CALL RE_ALLOC(BFALLS,IONE,IXRKS,IXXX,IERR)       !KEEP IN SYNC
        ENDIF
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'EKALG1: REALLOCATION FAILS FOR DRKS,DEKS'
          NF=0
          GO TO 999
        ENDIF
C
        CALL RE_ALLOC(NRKS,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJ,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJD,IONE,IXRKS,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'EKALG1: REALLOCATION FAILS FOR NRKS,NSTJ'
          NF=0
          GO TO 999
        ENDIF
C
        IXRKS=IXXX
C
      ENDIF
C
      IORIG(LP)=IOSS
      NRKS(IOSS)=LP
      DRKS(IOSS)=DD
      NSTJ(IOSS)=J
      NSTJD(IOSS)=JD
C
  28  IF(JD.EQ.J.AND.QCS.LT.NF)GO TO 27
C
      MK=MK+4
      IF(MK.LE.MMAX)THEN    !MULTIPOLE LOOP...
        IF(J.EQ.JD)THEN
          QCL=0
          GO TO 27
        ELSE
          QCL=QCL0
          QCS=QCS0
          GO TO 20
        ENDIF
      ENDIF
C
C
  16  ENDDO                        !END SLATER STATE LOOP
C
  15  ENDDO                      !END SLATER STATE LOOP
C
C
C ELIMINATE ZEROES
C
      IF(IOSS.LT.IOSS00)GO TO 90
C
      K=IOSS00-1
      KP=0
      DO I=LOSS1,LOSS
        IORIG(I)=0
      ENDDO
C
      DO I=IOSS00,IOSS
        JD0=NRKS(I)
        JD=ABS(JD0)
        MK=QRLS(3,JD)
        IF(ABS(DRKS(I)/DVC(MK/4)).LT.TYNY)THEN
          IF(IORIG(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QRLS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
C
        K=K+1
        DRKS(K)=DRKS(I)
        NSTJ(K)=NSTJ(I)
        NSTJD(K)=NSTJD(I)
C
  94    IF(JD.LE.LOSS00)THEN
          IF(LOSS.LE.IXRLS)THEN   !SHOULD NOT GET HERE
            WRITE(6,*)'EKALG1: INFORM NRB OF STOP HERE'
            WRITE(0,*)'EKALG1: INFORM NRB OF STOP HERE'
            NF=-1
            GO TO 999
          ELSE          !GRACEFUL EXIT TO DIMENSION STOP
            LP=JD
            GO TO 92
          ENDIF
        ENDIF
C
        IF(IORIG(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,LOSS00
            DO J=1,3
              IF(QRLS(J,JD).NE.QRLS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG(JD)
          GO TO 92
        ENDIF
C
        IORIG(JD)=LP
        DO J=1,3
          QRLS(J,LP)=QRLS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          NRKS(K)=LP
C          IF(JD0.LT.0)NRKS(K)=-NRKS(K)
        ENDIF
  91  ENDDO
C
      LOSS=LOSS-KP
      IOSS=K
      NADS(NCF)=IOSS
C
C
  90  ENDDO                !END LOOP OVER CFS
C
  99  ENDDO              !END LOOP OVER CFS
C
C
 999  IRLS=LOSS
      IRKS=IOSS
C
      RETURN
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(M1,M2)
C
      MVC=((M1+2)*M1/2+M2)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE EKALG1
C
C                             *******************
C
      SUBROUTINE EKALG2(mam,nam,KK,DVC,JOS,IXY)
C
C-----------------------------------------------------------------------
C
C  SR.EKALG2 DEALS WITH THE PROBLEMS DESCRIBED IN SECTION 3.2 OF E&N:
C  IT CALCULATES THE PURELY ALGEBRAIC COEFFICIENTS FOR EACH REDUCED
C  ELECTRIC MULTIPOLE MATRIX ELEMENT, IN TERMS OF LEVELS. NRB
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,IAXRK,IAXRL,N8
      USE COMMON_DXRLS,  ONLY: DRKS,QRLS,NRKS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBRN2, ONLY: BINDB
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-5)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      CHARACTER(LEN=4) CODE
C
      DIMENSION mam(*),nam(*),DVC(0:*)
C
      COMMON /BASIC/NF,KF,KG,JGAP(2),MB1,MB2,ND1,NDP1,ND2,NDP2,NGAP
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /OUTP1/MPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      BKUTOO=KUTOO.NE.0
C
      if(mpolx.ne.mpole)stop 'mpolx.ne.mpole!'
c
      MX=MPOLX
      MX=MX-MPOL0                                                 !FLAGX
      MXPOL=MAX(IONE,MX/2+1)
      MXORB2=MXORBR*MXORBR                                        !FLAGX
      if(irlx.lt.0)then
        i1=icfgp(kf)*mb+1
        i2=icfgp(kg)*mb+1
      else
        i1=mb+1                                                   !FLAGX
        i2=i1
      endif
C
CB      BBORN=MENGB.GE.0            !BORN CODING USED MORE GENERALLY NOW
C
      IOS0=IOS+1
      LOS=IRL
C
      DO J=1,IRLS
        JORIG(J)=0
      ENDDO
C
      BEQCFS=KG.EQ.KF
C
C     LOOP OVER SLATER STATES
C
      K0=NADS(KK-1)+1
C
      m0=0
      t0=dzero
      DO 57 KS=K0,NADS(KK)
C
        J=NSTJ(KS)
        JD=NSTJD(KS)
C
        IF(BFAST)THEN
          DD=DC(J+ND2)*DC(JD+NDP2)*DRKS(KS)
          IF(BEQCFS.AND.J.NE.JD)DD=DD+DC(J+NDP2)*DC(JD+ND2)*DRKS(KS)
        ELSE
          m=mam(j)
          md=nam(jd)
          if(m.gt.0.and.md.gt.0)then             !m*md can over flow I*4
            if(m.ne.m0)then
              t0=dc(m)
              m0=m
            endif
            DD=t0*DC(md)*DRKS(KS)
          else
            dd=dzero
          endif
          IF(BEQCFS.AND.J.NE.JD)then
            md=mam(jd)
            m=nam(j)
            if(m.gt.0.and.md.gt.0)then           !m*md can over flow I*4
              DD=DD+DC(md)*DC(m)*DRKS(KS)
            endif
          endif
        ENDIF
C
        N=NRKS(KS)
        MM=QRLS(3,N)/2
        IF(ABS(DD/DVC(MM/2)).LE.TTYNY)GO TO 57
C
        L=JORIG(N)
        IF(L.GT.0)THEN
          I=IORIG(L)
          DRK(I)=DRK(I)+DD
        ELSE                                   !CANNOT FIND OLD ARGUMENT
          LOS=LOS+1
          IF(LOS.GT.IAXRL)THEN                                 !GO TO 93
C
            IXXX=7*(IAXRL/5+1)
C
            WRITE(6,*)'*** EKALG2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
            WRITE(0,*)'*** EKALG2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'EKALG2: REALLOCATION FAILS FOR QRL'
              NF=0
              GO TO 93
            ENDIF
C
            IXXX0=MAX(IAXRL,IXRLS)
            IXXX2=MAX(IAXRL,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'EKALG2: REALLOCATION FAILS FOR IORIG'
              NF=0
              GO TO 93
            ENDIF
C
            IAXRL=IXXX
C
          ENDIF
C
          IOS=IOS+1
          IF(IOS.GT.IAXRK)THEN                                 !GO TO 92
C
            IXXX=7*(IAXRK/5+1)
C
            WRITE(6,*)'*** EKALG2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
            WRITE(0,*)'*** EKALG2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
            IF(BKUTOO)THEN
              CALL RE_ALLOC(DEK,IONE,IAXRK,IXXX,IERR)      !KEEP IN SYNC
              CALL RE_ALLOC(BFALL,IONE,IAXRK,IXXX,IERR)    !KEEP IN SYNC
            ENDIF
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'EKALG2: REALLOCATION FAILS FOR DRK,DEK'
              NF=0
              GO TO 92
            ENDIF
C
            CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'EKALG2: REALLOCATION FAILS FOR NRK'
              NF=0
              GO TO 92
            ENDIF
C
            IAXRK=IXXX
C
          ENDIF
C
          DRK(IOS)=DD
          NRK(IOS)=LOS
          IORIG(LOS)=IOS
          JORIG(N)=LOS
          DO I=1,3
            QRL(I,LOS)=QRLS(I,N)
          ENDDO
C
        ENDIF
C
  57  ENDDO
C
C CLEAR ARRAY OF ZEROES
C
      IXY=0
      K=IOS0-1
C
      DO I=IOS0,IOS
C
        DD=DRK(I)
        LL=INT(NRK(I))
        MM=QRL(3,LL)/2
        IF(ABS(DD/DVC(MM/2)).GT.TYNY)THEN
          K=K+1
          NT=QRL(1,LL)
          NG=QRL(2,LL)
CB          IF(BBORN)THEN
          MN=MIN(NT,NG)
          MX=MAX(NT,NG)
          IN=ICOL(MN,MX,IZERO)
          BINDB(IN,MM/2)=.TRUE.
          IF(BREL)BINDB(IN,MM/2+1)=.TRUE.
CB         ENDIF
          N8=MXORB2*MXPOL
          MX=MM-MPOL0/2
          IPLANT=MX*MXORB2+(NG-I1)*MXORBR+NT-I2
          NRK(K)=N8*(NDP1-1)+IPLANT
c          write(6,*)n8,ndp1,mxorb2,mx,mxorbr,ng,i1,nt,i2
          DD0=SQRT(REAL(2*MM+1,WP))
          DRK(K)=DD0*DD/DVC(MM/2)
C
          IF(MPRINT.GT.0)THEN
            IF(MM.LT.10)THEN
              WRITE(6,700)
     X        JOS,ND1,NDP1,NG,NT,K,DRK(K),DD,DVC(MM/2),MB1,MB2,MM
            ELSE
              WRITE(6,701)
     X        JOS,ND1,NDP1,NG,NT,K,DRK(K),DD,DVC(MM/2),MB1,MB2,MM
            ENDIF
          ENDIF
        ENDIF
C
      ENDDO
C
      IOS=K
      IF(IOS.GE.IOS0)JOS=JOS+1
C
      RETURN
C
  92  IXY=1
      RETURN
C
  93  IXY=-1
      RETURN
C
  700 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,2F19.5, 6X,2I4, 5X,'E',I1)
  701 FORMAT( I5, 2X,2(I5,I4),I7, F13.5,2F19.5, 6X,2I4, 5X,'E',I2)
C
      END SUBROUTINE EKALG2
C
C                             *******************
C
      FUNCTION ELAM(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.ELAM EVALUATES THE ETA-LAMDA INTEGRALS OF ORBIT-ORBIT INTERACTION.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
c      IF(LAM.EQ.0)THEN               !test
c        ELAM=DZERO
c        RETURN
c      ENDIF
c
      L1=QL(K1)/2
      L2=QL(K2)/2
      L3=QL(K3)/2
      L4=QL(K4)/2
      LP1=LAM+1
      LP2=LAM+2
      LT=(L1+L3+LP2)*(L3-L1+LP1)*(L1-L3+LP1)*(L1+L3-LAM)*(L2+L4+LP2)
     X  *(L4-L2+LP1)*(L2-L4+LP1)*(L2+L4-LAM)
C
      if(lt.le.0)then                  !not needed for this L (IDW.ne.0)
        elam=dzero                     !1.d99 !test
        return
      endif
C
      T=SQRT(REAL(LT,WP))
      TP=LP1*LP2*(2*LP1-1)*(LP1+LP2)
C JONES  TP=LP1*LP2
      V=VLAM(LAM,K1,K2,K3,K4)
      V=T*V/TP
C
      ELAM=-V                                                 !V->-V
C
C     WRITE(6,100) K1, K2, K3, K4, 2*LAM, ELAM
C100  FORMAT(8X,2(I5,I4),I6,F14.7,' =ELAM')
C
      RETURN
C
      END FUNCTION ELAM
C
C***********************************************************************
C
      FUNCTION F21(A,Y,C,D,EPS,IFAIL)
C
C-----------------------------------------------------------------------
C
C FN.F21 DETERMINES THE 2_F_1 HYPERGEOMETRIC FUNCTION FROM SERIES
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      IPRINT=IFAIL
      IFAIL=0
      T=(A*Y*D)/C
      DD=DONE/(DONE-D)
      SUM=DONE+T
      TN1=DZERO
C
      I=1
    3 AI=I
      T=T*(A+AI)*(Y+AI)*D/((C+AI)*(DONE+AI))
      TN2=T*DD
      F21=SUM+TN2
      SUM=SUM+T
C
      AT=ABS(T+TN2-TN1)
      AS=ABS(F21)*EPS
C
      IF(AS.GE.AT)RETURN
C
      TN1=TN2
      I=I+1
      IF(I.LT.301)GO TO 3
C
      IF(IPRINT.GT.0)WRITE(6,100)
      IFAIL=3
C
      RETURN
C
  100 FORMAT(' FAILED TO CONVERGE IN F21')
C
      END FUNCTION F21
C
C                             *******************
C
      SUBROUTINE FCF4(F,C,E,Z,L,MJH0,MNH,DHNS,DX)
C
C-----------------------------------------------------------------------
C
C  BADNELL AND BURGESS, D.A.M.T.P., CAMBRIDGE.
C
C  SR.FCF4 DETERMINES A CONTINUUM COULOMB FUNCTION BY SERIES EXPANSION.
C
C  IT CONTAINS:
C    FN.WILF
C
C  INPUT. E,Z,L, PLUS GRID INFO FROM SR.RADIAL MJH0,MNH,DHNS,DX.
C
C  OUTPUT. F,C.
C
C  FREE REGULAR COULOMB REAL-FUNCTION IN F(J), AT X=DX(J).
C  F SATISFIES ((D/DX)(D/DX)-L(L+1)/X**2-2Z/X+E)F=0
C  F=C*X**(L+1.0)*(1.0+...) FOR SMALL X
C  F=K**(-0.5)*SIN(KX-0.5*EL*PI-(Z/K)LOG(2KX)+ARGGAMMA(EL+1+I*Z/K))
C  FOR LARGE X
C  WHERE K=SQRT(E)
C  N.B. Z IS POSITIVE FOR REPULSIVE FIELD
C  X0 IS (APPROX.) THE FIRST POINT OF INFLEXION IN F.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION F(*),A(100)
      DIMENSION MNH(*),DHNS(*),DX(*)
C
c      WILF(X)=E+W1/X+W2/(X*X)     !SEE INTERNAL FUNCTION ABOVE END FCF4
C
      PI=ACOS(-DONE)
      EL=L
      W1=-(Z+Z)
      W2=-EL*(EL+DONE)
      W3=(EL+DONE)*(EL+DTWO)
      ZZ=Z*Z
C
      IF(E.GT.D1M40)GO TO 6
      IF(ABS(Z).GT.D1M15)GO TO 3
      WRITE(6,100)
C
   38 K=0
C
      DO M=1,MJH0
        I1=MNH(M)
        DO I=1,I1
          K=K+1
          F(K)=DZERO
        ENDDO
      ENDDO
C
      RETURN
C
    3 IF(Z.LT.DZERO)GO TO 5
    4 WRITE(6,101)
      GO TO 38
C
    5 C=-Z*(PI+PI)
      GO TO 11
C
    6 EK=SQRT(E)
      T1=PI*Z/EK
      T2=ABS(T1)
      IF(T2.GT.D1M2)GO TO 8
C
      C=DTHREE*EK/(DTHREE+T1*(DTHREE+T1*(DTWO+T1)))
      GO TO 11
C
    8 IF(T2.LT.D80)GO TO 10
      IF(Z.LT.DZERO)GO TO 5
      GO TO 4
C
   10 C=DONE-EXP(T1+T1)
      C=-(PI+PI)*Z/C
   11 C2=DONE
C
      IF(L.GT.0)THEN
        DO J=1,L
          CJ=J
          CJ2=J+J
          C2=C2*CJ*(CJ2+DONE)
          C=C*(ZZ+E*CJ*CJ)
   30     IF(C+C2.GE.D1P70)THEN
            C2=D1M5*C2
            C=D1M10*C
            GO TO 30
          ENDIF
        ENDDO
      ENDIF
C
      C=SQRT(C)/C2
      X0=W3/(SQRT(ZZ+W3*E)-Z)
      I1=0
      I=0
C
      DO M=1,MJH0
        MJH=M
        K=MNH(M)
        I1=I1+K
        DO J=1,K
          I=I+1
          IF(X0.LT.DX(I))GO TO 16
        ENDDO
      ENDDO
      J=K
C
   16 IF(I.LT.2)I=2
      IF(J.EQ.K)I=I-1
      I0=I
      X0=DX(I)
      L1=L+1
      A(1)=DONE
      T1=L1
      A(2)=X0*Z/T1
      J=2
      Z2=Z+Z
C
   17 J=J+1
      C2=J-1
      C3=J+L+L
      A(J)=X0*(Z2*A(J-1)-X0*E*A(J-2))/(C2*C3)
      IF(J.LE.6)GO TO 17
      C2=ABS(A(J))+ABS(A(J-1))
      IF(C2.GT.D1M10)GO TO 17
      J0=J
C
      DO I=1,I0
        X=DX(I)
        X=X/X0
        J=J0
        T1=A(J)
   22   J=J-1
        T1=A(J)+X*T1
        IF(J.GT.1)GO TO 22
        F(I)=C*T1*(X*X0)**L1
      ENDDO
C
      IM=1
      I=I0
      X=DX(I)
      H=DHNS(MJH)
C
   24 H0=H*H
      H1=DTWELF*H0
      C0=F(I)*(DONE+(H1-H0)*WILF(X))-F(I-IM)*(DONE+H1*WILF(X-H))
      C1=F(I)*(DONE+H1*WILF(X))
C
   25 I=I+1
      X=DX(I)
      C1=C1+C0
      C2=WILF(X)
      F(I)=C1/(DONE+H1*C2)
      C0=C0-H0*C2*F(I)
      IF(I.LT.I1)GO TO 25
      MJH=MJH+1
C
      IF(MJH.GT.MJH0)RETURN
C
      H=DHNS(MJH)
      IM=2
      I1=I1+MNH(MJH)
      GO TO 24
C
C
  100 FORMAT('***FAILED IN FCF4 BECAUSE E AND Z ARE BOTH ZERO, OUTPUT',
     X       ' SET TO ZERO')
  101 FORMAT('***FCF4 OUTPUT SET TO ZERO BECAUSE E IS LESS THAN 1.0D-40'
     X      ,' AND Z EXCEEDS 1.0D-15')
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION WILF(X)
C
      WILF=E+W1/X+W2/(X*X)
C
      END FUNCTION WILF
C-----------------------------------------------------------------------
C
      END SUBROUTINE FCF4
C
C                             *******************
C
      SUBROUTINE FCF6(FR,C,DEL,L,EI,ZI0,ZIA,QI,U,Z3,ZS,JZNM,ZL,MEND
     X               ,DNUK,MJH0,MNH,DHNS,DX,GR,MAXPS)
C
C-----------------------------------------------------------------------
C
C  N.R.BADNELL D.A.M.T.P. CAMBRIDGE
C
C  SR.FCF6 EVALUATES A DW CONTINUUM RADIAL FUNCTION ON THE INPUT GRID
C  BY SOLVING THE SCHRODINGER EQUATION WITH THE SUMMED COWELL-NUMEROV
C  METHOD, USES SMALLER STEPS IF NECESSARY I.E. IT IS NOT CONSTRAINED
C  BY THE USER INPUT GRID.
C
C  IT CALLS:
C    FN.CNORM
C    SR.DIFF
C    FN.DNAMP
C    FN.PHASEX
C    FN.PMVDAR
C
C  IT CONTAINS:
C    FN.WILT
C
C  INPUT: L,E,Z0,ZA,Q,U,Z3,ZS,JZNM,ZL,MEND,MJH0,MNH,DHNS,DX
C         WHERE
C    F(I)"=L(L+1)/R**2-ZL(I)-E    AND FOR LARGE R
C    F"=2*ZA/R+L(L+1)/R**2+Q/R**3+U/R**4+Z3/R**5-E
C    N.B. Z0,ZA .LT. 0, E .GT. 0
C    ZS(I) I=1,JZNM IS POTENTIAL POWER SERIES EXPANSION ABOUT ORIGIN
C    MEND,MJH0,MNH,DHNS,DX INFORMATION ON GRID DEFINED IN SR.RADIAL
C
C  OUTPUT: FUNCTION FR, C AND NON-COULOMB PHASE SHIFT / PI=DEL
C          WHERE FOR SMALL R F=C*R**(L+1)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) QI,QQ
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D5M2=DFIVE*D1M2)
      PARAMETER (D64=DEIGHT*DEIGHT)
      PARAMETER (DEPS0=D1M10)
C
      DIMENSION FR(*),GR(*),MNH(*),DHNS(*),DX(*),ZL(*),DNUK(*),ZS(0:*)
      DIMENSION A(100),AMP2(20),AMP3(20)
C
      COMMON /COM3/EE,ZP,ELLP                      !,EQ,ZQ,CQ
      COMMON /COM6/DA(MAXB1)
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
C Q,U,Z3=ZERO IN AUTOSTRUCTURE
C WILT(T,E,ZZ,CI)=E-(ZZ+(CI+(Q+(U+Z3*T)*T)*T)*T)*T
C
c      WILT(T,E,ZZ,CI)=E-(ZZ+CI*T)*T  !SEE INTRNAL FUNCTN ABOVE END FCF6
C
C LOOK AT COULOMB NORMALIZATION TO SEE IF FUNCTION IS NUMERICALLY
C DETERMINABLE, BASICALLY A FUNCTION OF L/E. ZERO-OUT IF NOT,
C THIS SHOULD ONLY OCCUR IN EXTREME CASES. (FCF4 DOESN'T EVEN WARN.)
C
      EC=MAX(EI,D1M2)
      C=CNORM(EC,ZIA,L)
c      write(70,700)l,ei,c
C
      IF(C.LE.DZERO)THEN
C
        WRITE(6,1004)L,EI
C
        C=DZERO
        DO I=1,MAXPS
          FR(I)=DZERO
        ENDDO
C
        IF(BREL.AND.ABS(IREL).EQ.2)THEN
          DO I=1,MAXPS
            GR(I)=DZERO
          ENDDO
        ENDIF
C
        RETURN                                !<----------------- RETURN
C
      ENDIF
C
C INITIALIZE
C
      KAPPA=0         !PMVDAR IGNORES KAPPA AND USES ITS OWN, DEFAULT -1
c
c      if(l.gt.0)kappa=-l-1      !l or -l-1
c
      PI=ACOS(-DONE)
      PIH=PI/DTWO
      EL=L
      CI=EL*(EL+DONE)
      ELLP=CI
      ZA=ZIA
      Z0=ZI0
      ZP=-ZI0
      EE=EI
      E=EI
      CI0=CI
      CI1=CI
      Z0Q=ZI0
      qq=qi
C
C ADD-IN FINITE NUCLEUS (RECALL, POINT ALREADY SUBTRACTED FOR FCF6)
C
      DO I=1,INUK
        T=ZL(I)
        ZL(I)=DNUK(I)+t
        DNUK(I)=T
      ENDDO
C
      IF(BREL)THEN
        EQ=DQUART*DALF*EI*EI
        E=EI+EQ
        Z0=ZI0+DHALF*DALF*ZI0*EI
        CI0=CI-DALF*ZI0*ZI0
        IF(MDEN.LE.0.OR.NPITER.LT.0)THEN      !UNSCREENED MVD CORRECTION
          ZQ=DHALF*DALF*ZIA*EI
          Z0Q=ZI0+ZQ
          ZA=ZIA+ZQ
          CQ=-DALF*ZIA*ZIA
          CI1=CI+CQ
          if(kappa.ne.0)qq=qi+2*(kappa+1)*zia*dquart*dalf/
     x                              (done+dquart*dalf*ei)
        ENDIF
        BREL2=ABS(IREL).EQ.2
      ENDIF
C
      Z2=ZA+ZA
      ZA2=ZA*ZA
      Z1=ZI0+ZI0
      VS=ZS(1)
      ZS(1)=VS+EI                                       !TEMP HOLD E
      NNMAX=10
      JMAX=5
      TMAX=DONE/D64
C
C FIND MAX STEP LENGTH ALLOWABLE FOR ACCURATE EVALUATION OF PHASE
C
      W3=DQUART+CI1-D3QRT/Z0
      HMAX=ABS(E)
      IF(L.GT.0)HMAX=HMAX+ZA2/CI1
      IF(HMAX.LT.D1M10)HMAX=D1M10
      HMAX=SQRT(TMAX/HMAX)
C
C ESTIMATE INNER TURNING POINT
C
C      X0=-DONE/Z0
      X0=DX(2)
      W3=W3-CI1+CI0
      IF(L.GT.0)X0=W3/(SQRT(Z0*Z0+W3*E)-Z0)
C
      i10=0
      I=0
      DO M=1,MJH0
        JM=MNH(M)
        DO J=1,JM
          I=I+1
          IF(X0.LE.DX(I))THEN
            I0=I
            GO TO 70
          ENDIF
        ENDDO
      ENDDO
      I0=I
C
  70  CONTINUE
C
C EVALUATE POWER SERIES SOLUTION FOR FIRST TWO POINTS WITH FR .GT. DEPS.
C (NEGLECT ANY PLASMA SCREENING HERE.)
C
cold      A1=DONE
      A1=C
      A(1)=A1
C
      DEPS=DEPS0/SQRT(-Z0)
      DEPS=DEPS*A1/C
C
      IF(BREL)THEN
C        TL=L                                          !=L HERE
        IF(RNUK.LT.DZERO)THEN                !POINT
          J0=2
          TB=DONE+(EI+DFOUR/DALF)*DX(1)/ZP
          TB=DONE/TB
          TB=TB*TB
          T=L*(L+1)-DALF*ZP*ZP+D3QRT*TB
          TLAM=DQUART+T
          TLAM=SQRT(TLAM)-DHALF
          A(2)=(TLAM+DONE)*(TLAM+DTWO)-T
          A(2)=-A(1)*DTWO*ZP*(DONE+EI*DALF/DTWO)/A(2)
          A(3)=A(1)*TLAM/DTWO                     !FOR Q NORM - NOT USED
        ELSE                                 !FINITE
          J0=3
          A(2)=DZERO
          T=(L+2)*(L+3)-L*(L+1)
          TT=DONE+DQUART*DALF*ZS(1)
          TT=-ZS(3)*D3QRT*DALF/TT
          TT=TT-ZS(1)*(DONE+DQUART*DALF)
          A(3)=A(1)*TT/T
        ENDIF
      ELSE
        A(2)=-A(1)*ZS(0)/(EL+DONE)*2
        T=DZERO
        JM=JZNM+1
        jam=10                                         !jm !old
        ks=2
C        TL=EL                                         !=L HERE
        DO J=2,jam
          if(j.gt.jm)ks=j+1-jznm
          DO K=ks,J
            K2=K-1
            K1=J-K2
            T=T-A(K2)*ZS(K1)
          ENDDO
          T=T+Z1*A(J)
          TJ=J
          A(J+1)=T/((EL+EL+TJ+DONE)*TJ)
        ENDDO
        J0=jam+1
      ENDIF
C
      ZS(1)=VS                               !RE-INSTATE PURE POT
c      TLAM=TL                                         !=L HERE
c
      i10=i0
      I00=2
      m00=1
      i1=MNH(m00)
      i11=1
      i2=i0-2
c
c      write(0,*)'Hello World 1'
C
  80  DO I=i11,I00
c      write(0,*)'Hello World 2'
        FR(I)=DZERO
        DO J=1,J0
C          T=real(J,wp)
C          T=T+TL                                      !=J+L HERE
          FR(I)=FR(I)+A(J)*DX(I)**(J+L)
        ENDDO
      ENDDO
C
      IF(ABS(FR(I00)).LT.DEPS.AND.ABS(FR(I00-1)).LT.DEPS)THEN
        if(i00.lt.i2)then
          i11=i11+2
          i00=i00+2
          if(i00.ge.i1)then
            if(i00.eq.i1)i00=i00+1
            m00=m00+1
            if(m00.gt.MJH0)then        !zero across entire mesh
              if(i0.eq.i10)then        !not reached inner turning-point
                m00=m00-1
                i00=i1-1
                fr(i00)=deps
                go to 81
              else                     !maybe need to be renormalized
                write(6,1003)E,L,DX(I0)
                stop 'fcf6: starting f-values must be non-zero'
c                go to 999            !SUN f95 -O4 does not like this...
              endif
            endif
            i1=i1+MNH(m00)
          endif
          go to 80
        elseif(i0.eq.i10)then          !not reached inner turning-point
          i00=i0-1
          fr(i00)=deps
          go to 81
        else                           !beyond inner turning point
          WRITE(6,1003)E,L,DX(I0)
          STOP 'FCF6: STARTING F-VALUES MUST BE NON-ZERO'
C          GO TO 999                  !SUN f95 -O4 does not like this...
        endif
      ENDIF
c      write(0,*)i00,dx(i00),i0,dx(i0)
c
  81  IF(ABS(C-A1).GT.DEPS0)THEN         !SKIP IF A(1)=C (&A(2)=A(1)*...
c         write(0,*)c
         DO I=1,I00
           FR(I)=FR(I)*C
c           write(6,*)i,fr(i)
         ENDDO
      ENDIF
C
C SUMMED COWELL NUMEROV OVER INPUT GRID
C
      M=0                                           !NODES
C
      MJH=m00
      H=DHNS(MJH)
      IM=1
C
      I=I00
      X=DX(I)
      T=DONE/X
C
      V2=ZL(I)+DTWO*VSC(I)+WILT(T,EI,Z1,CI)
      IF(BREL)V2=V2+PMVDAR(I,X)
C
 101  TT=X-H
      T=DONE/TT
      II=I-IM
C
      V1=ZL(II)+DTWO*VSC(II)+WILT(T,EI,Z1,CI)
      IF(BREL)V1=V1+PMVDAR(II,TT)
C
      HH=H*H
      H1=HH/DTWELV
      C0=FR(I)*(DONE+(H1-HH)*V2)-FR(I-IM)*(DONE+H1*V1)
      C1=FR(I)*(DONE+H1*V2)
C
  41  I=I+1
      X=DX(I)
      C1=C1+C0
      T=DONE/X
C
      V2=ZL(I)+DTWO*VSC(I)+WILT(T,EI,Z1,CI)
      IF(BREL)V2=V2+PMVDAR(I,X)
C
      FR(I)=C1/(DONE+H1*V2)
      C0=C0-HH*V2*FR(I)
C
      IF(I.GT.I0.AND.FR(I-1)*FR(I).LT.DZERO)M=M+1                 !NODES
      IF(I.LT.I1)GO TO 41
C
C START NEW INTERVAL
C
      MJH=MJH+1
      H2=H
C
      IF(MJH.LE.MJH0)THEN
        H=DHNS(MJH)
        I1=MNH(MJH)+I1
        IM=2
C
        IF(H.LE.HMAX)GO TO 101       !CHECK IF STEP CAN BE INCREASED
C
        H0=DHNS(MJH-1)
        JH=2
        ITEST=MEND
C
  53    J=0
        IT=I
        IF(MJH.EQ.MJH0)IT=MIN(I,I1-2)
        IF(VSC(1).NE.DZERO)ITEST=I1            !FOR PLASMA/POLARIZTN POT
  54    J=J+1
C
        X=X+H0
        C1=C1+C0
        T=DONE/X
C
        IF(I.LE.ITEST)THEN
          ZT=Z1-X*ZEFXL(X,ZL,DX,IT)            !ZEFXL INCL. VSC & PMVDAR
          V2=WILT(T,EI,ZT,CI)
        ELSE                                   !IF NO PLASMA/POLARIZ POT
          V2=WILT(T,E,Z2,CI1)
          if(kappa.ne.0)then                   !brel
            zp=-zia                            !replace
            v2=v2+pmvdar(-i,x)
            zp=-zi0                            !restore
          endif
        ENDIF
C
        F2=C1/(DONE+H1*V2)
        C0=C0-HH*V2*F2
        IF(J.LT.JH)GO TO 54
C
        I=I+1
        X=DX(I)
        FR(I)=F2
C
        IF(I.GT.I0.AND.FR(I)*FR(I-1).LT.DZERO)M=M+1               !NODES
        IF(I.LT.I1)GO TO 53
C
        MJH=MJH+1
        H2=H0
        IF(MJH.LE.MJH0)THEN
          I1=MNH(MJH)+I1
          JH=JH+JH
          GO TO 53
        ENDIF
C
      ENDIF
C
C END OF REQUESTED TABULATION
C
      F2=FR(I1)
      X1=X
      ZT=Z0Q-(ZL(I1)/DTWO+VSC(I1))*X1                         !ZA-VSC*X1
      Z2=ZT+ZT
C
C TEST IF SHORT RANGE POTENTIALS CAN BE NEGLECTED
C
      T=DONE/X1
      TH=V2-WILT(T,E,Z2,CI1)
      if(kappa.ne.0)th=th+qq*t**3
      V2=V2+D1M10
      IF(ABS(TH)*D1P4.GT.ABS(V2))THEN
        WRITE(6,1000)E,L,X1,ABS(TH/V2)
      ENDIF
C
      CHI=DTHREE*CI1+D60
c      X2=CHI/(SQRT(ZA2+E*CHI)-ZA)
      X2=CHI/(SQRT(ZT*ZT+E*CHI)-ZT)
      XZ=(D1P4*ABS(Z3/V2))**DFIFTH
      X2=MAX(X2,XZ,RZERO)
c      x2=1.5*x2
C
C DETERMINE WHERE TO NORMALISE WHEN PLASMA SCREENING POTENTIAL PRESENT,
C ALWAYS GOES OUT TO AT LEAST TO DX(MTEST).
C
      IF(DENE*ABS(VSC(1)).LE.DZERO)GO TO 299
C
      IF(MOD(MDEN,ITEN).GT.2)THEN
        MTEST=MAXPS
      ELSE
        MTEST=i1 !MEND
      ENDIF
c
c      if(l.eq.0)then
c        write(0,*)'Hello'
c      endif
C
      ITER=0
      DO I=1,I1
        IF(DX(I).GT.X2)GO TO 307
      ENDDO
      I=I1
C
 307  ZX=Z0Q-(ZL(I)/DTWO+VSC(I))*DX(I)                        !ZA-VSC*DX
      XT=CHI/(SQRT(ZX*ZX+E*CHI)-ZX)
c      write(6,*)e,l,iter+1,x2,xt,abs(x2-xt)/max(x2,xt),i,i1
      IF(ABS(X2-XT)/MAX(X2,XT).GT.D1M1)THEN
        ITER=ITER+1
        X2=XT
        IF(ITER.GT.10)GO TO 304
        DO I=1,I1
          IF(DX(I).GT.X2)GO TO 307
        ENDDO
c        write(6,*)x1
        I=I1
        GO TO 307
      ENDIF
C
 304  IF(X2.LT.XC1)THEN
C
        IF(DX(MTEST).LT.XC1)THEN
          IF(X1.LT.XC1)GO TO 299
C
          IF(X2.GT.DX(MTEST))THEN
            DO I=1,I1
              IF(DX(I).GT.X2)GO TO 302
            ENDDO
            I=I1
          ELSE
            I=MTEST
          ENDIF
 302      ZT=Z0Q-(ZL(I)/DTWO+VSC(I))*DX(I)                    !ZA-VSC*DX
C
          GO TO 301
        ELSE
          ZX=Z0Q-(ZL(MTEST)/DTWO+VSC(MTEST))*DX(MTEST)        !ZA-VSC*DX
          XT=CHI/(SQRT(ZX*ZX+E*CHI)-ZX)
          X2=DX(MTEST)
C
          IF(X2.LT.XT)THEN
            X2=XT
            IF(X2.GT.X1)GO TO 304
          ENDIF
C
          IF(X1.GT.XC2)GO TO 102
C
          IF(ABS(X2-XC1).GT.ABS(XC2-X1))THEN
            XT=CHI/(SQRT(ZT*ZT+E*CHI)-ZT)                   !ZT IS AT X1
            IF(XT.LT.X1)GO TO 300
          ENDIF
C
          DO I=1,I1
            IF(DX(I).GT.X2)GO TO 308
          ENDDO
 300      I=I1
 308      ZT=Z0Q-(ZL(I)/DTWO+VSC(I))*DX(I)                    !ZA-VSC*DX
          TT=abs((za-zt)/dx(i)*ZT/DX(I))                      !vsc
          IF(TT.GT.D5M2*(E+DONE))WRITE(6,1002)E,L,X2,tt
          IF(-TT.LT.D1M1*(E+DONE))GO TO 301
          WRITE(6,1001)E,L
          WRITE(0,*)'FCF6: UNABLE TO DETERMINE AMP-PHASE'
          GO TO 999
        ENDIF
C
      ELSE
C
        IF(X1.GT.XC2)then
          ZX=Z0Q-(ZL(I1)/DTWO+VSC(I1))*DX(I1)                 !ZA-VSC*DX
          X2=CHI/(SQRT(ZX*ZX+E*CHI)-ZX)
          GO TO 299
        endif
        IF(X2.LT.X1)THEN
          DO I=1,I1
            IF(DX(I).GT.X2)GO TO 310
          ENDDO
        ENDIF
        I=I1
 310    ZX=Z0Q-(ZL(I)/DTWO+VSC(I))*DX(I)                      !ZA-VSC*DX
        X2=CHI/(SQRT(ZX*ZX+E*CHI)-ZX)
        XT=DX(MTEST)
        IF(XT.LT.X2)XT=X2
C
        IF(X1.LT.X2.OR.ABS(X1-XC2).LT.ABS(XT-XC1))THEN
C USE APPROX ZT (X=X1) IN C-N AND AMP-PHASE
          TT=abs((za-zt)/x1*ZT/X1)                            !vsc
          IF(TT.GT.D5M2*(E+DONE))WRITE(6,1002)E,L,X1,tt
          IF(-TT.LT.D1M1*(E+DONE))GO TO 299
          WRITE(6,1001)E,L
          WRITE(0,*)'FCF6: UNABLE TO DETERMINE AMP-PHASE'
          GO TO 999
        ELSE
          DO I=1,I1
            IF(DX(I).GT.XT)GO TO 312
          ENDDO
          I=I1
C
C CHECK AMP-PHASE ACC
C
 312      ZT=Z0Q-(ZL(I)/DTWO+VSC(I))*DX(I)                    !ZA-VSC*DX
          TT=abs((za-zt)/dx(i)*ZT/DX(I))                      !vsc
          IF(TT.GT.D5M2*(E+DONE))WRITE(6,1002)E,L,DX(I),tt
          IF(-TT.LT.D1M1*(E+DONE))GO TO 301
          WRITE(6,1001)E,L
          WRITE(0,*)'FCF6: UNABLE TO DETERMINE AMP-PHASE'
          GO TO 999
        ENDIF
C
      ENDIF
C
 301  Z2=ZT+ZT
      X=DX(I)
      F2=FR(I)
C
C RE-INITIALISE FOR F3, ALTERNATIVELY COULD SEARCH FOR F3 LATER
C
      H2=DX(I)-DX(I-1)
      NH=1
 303  IF(H2.GT.HMAX)THEN
        H2=DHALF*H2
        NH=NH+1
        GO TO 303
      ENDIF
C
      IF(NH.GT.1)THEN
        TH=NH
        F1=-DHALF*(TH-DONE)*FR(I-2)+(TH+TH-DONE)*FR(I-1)+
     X       DHALF*(TH+TH-DONE)*(TH-DONE)*FR(I)
        F1=F1/(TH*TH)
      ELSE
        F1=FR(I-1)
      ENDIF
C
      HH=H2*H2
      H1=HH/DTWELV
      T=DONE/X
      V2=WILT(T,E,Z2,CI1)
      if(kappa.ne.0)v2=v2-qq*t**3
      TT=X-H2
      T=DONE/TT
      V1=WILT(T,E,Z2,CI1)
      if(kappa.ne.0)v1=v1-qq*t**3
      C0=F2*(DONE+(H1-HH)*V2)-F1*(DONE+H1*V1)
      C1=F2*(DONE+H1*V2)
      IP=I+1
      DO J=IP,I1
        IF(FR(J)*FR(J-1).LT.DZERO)M=M-1                           !NODES
      ENDDO
      GO TO 102
C END PLASMA MOD
C
C CONTINUE INTEGRATION UNTIL CAN USE AMP PHASE
C (COULD INCREASE STEP NOW SINCE NOT RESTRICTED BY TABULATION GRID,
C  BUT STILL NEEDS TO BE FINE ENOUGH FOR NUMEROV.)
C
 299  IF(X2.GT.X1)THEN
C
        T=HMAX/DHNS(MJH0)
        IH=-INT(T)                                         !SUPPRESS
        IF(IH.GT.1.AND.IH.LE.MNH(MJH0))THEN
          IH=MIN(IH,4_SP)                                  !DON'T GO MAD
          H2=DX(I1)-DX(I1-IH)
          HH=H2*H2
          H1=HH/DTWELV
          T=DONE/DX(I1-IH)
          V1=WILT(T,E,Z2,CI1)
          if(kappa.ne.0)v1=v1-qq*t**3
          F1=FR(I1-IH)
          V2=V2-D1M10
          C0=F2*(DONE+(H1-HH)*V2)-F1*(DONE+H1*V1)
        ENDIF
C
 118    F1=F2
        X=X+H2
        C1=C1+C0
        T=DONE/X
        C2=WILT(T,E,Z2,CI1)
        if(kappa.ne.0)c2=c2-qq*t**3
        F2=C1/(DONE+H1*C2)
        C0=C0-HH*C2*F2
        IF(F1*F2.LT.DZERO)M=M+1                                   !NODES
c        write(6,*)x,f2
        IF(X.LT.X2)GO TO 118
C
      ELSE
C
        DO I=MEND,-I1,2                                        !SUPPRESS
          IF(X2.LT.DX(I))THEN
            IP=I+1
            DO J=IP,I1
              IF(FR(J)*FR(J-1).LT.DZERO)M=M-1                     !NODES
            ENDDO
            H2=DX(I)-DX(I-1)
            HH=H2*H2
            H1=HH/DTWELV
            T=DONE/DX(I-1)
            V1=WILT(T,E,Z2,CI1)
            F1=FR(I-1)
            T=DONE/DX(I)
            V2=WILT(T,E,Z2,CI1)
            if(kappa.ne.0)v2=v2-qq*t**3
            F2=FR(I)
            C0=F2*(DONE+(H1-HH)*V2)-F1*(DONE+H1*V1)
            C1=F2*(DONE+H1*V2)
            X=DX(I)
            GO TO 102
          ENDIF
        ENDDO
C
      ENDIF
C
C EVALUATE ASYMPTOTIC AMP AND PHASE AT X2 AND X3=X2+0.5*WAVELENGTH
C
 102  X2=X
C
      CALL DNAMP(A2,AMP2,E,CI1,Qq,U,ZT,X2,NNMAX,JMAX)
C
      LM=L
      IF(BREL)LM=-L-1
C
      PHI2=PHASEX(E,CI1,Qq,U,LM,ZT,X2)
C
      X23=PIH*A2*A2
      X3=X2+X23
C
 103  X=X+H2
      C1=C1+C0
      T=DONE/X
      C2=WILT(T,E,Z2,CI1)
      if(kappa.ne.0)c2=c2-qq*t**3
      F3=C1/(DONE+H1*C2)
      C0=C0-HH*C2*F3
      IF(X.LT.X3)GO TO 103
      X3=X
C
      CALL DNAMP(A3,AMP3,E,CI1,Qq,U,ZT,X3,NNMAX,JMAX)
C
      PHI3=PHASEX(E,CI1,Qq,U,LM,ZT,X3)
C
      F2=F2/A2
      F3=F3/A3
      S2=SIN(PHI2)
      S3=SIN(PHI3)
      C2=COS(PHI2)
      C3=COS(PHI3)
      S23=SIN(PHI3-PHI2)
      C23=COS(PHI3-PHI2)
      CT=SQRT(S23*S23/(F2*F2+F3*F3-DTWO*F2*F3*C23))
      T=CT/S23
      SD=(F2*S3-F3*S2)*T
      CD=(F3*C2-F2*C3)*T
C
C NON-COULOMB PHASE SHIFT
C
      DEL=ATAN2(SD,CD)
      T=(PHI2+DEL)/PI
      M1=INT(T)
      EM1=M-M1
      DEL=EM1+DEL/PI
c      f2norm=sin(phi2+del*pi)*a2
c      f2=f2*a2*ct
C
C NORMALISE FR
C
      IF(FR(I0).LT.DZERO)CT=-CT
      C=C*CT
C
      IF(.NOT.BREL)THEN
C        TLAM=L
        DO I=1,I1
          FR(I)=CT*FR(I)
        ENDDO
c        write(0,*)l,c,fr(1)/dx(1)**(l+1)
      ELSE
C        TLAM=L
        T=DONE
        IF(RNUK.GT.DZERO)T=T+DQUART*DALF*(EI+ZS(1))
        T=DONE/SQRT(T)
        C=C*T
C
C THE FOLLOWING BOTH TRANSFORMS SOLUTION AND CORRECTS NORMALIZATION
C
C (RENORMALIZING FOR OMITTED SMALL CPT IS MINOR IMPROVEMENT AT BEST
C  AT MEDIUM Z, BUT VERY POOR AT HIGH Z.)
C
c        if(brel2)then
          TQ=DQUART
          DE=DONE
c          de=((done+dhalf*dalf*ei)/(done+dquart*dalf*ei))**.25
c        else                  !try and compensate for missing small cpt
c          tq=dquart           !formal renormalization
c          de=sqrt((done+dhalf*dalf*ei)/(done+dquart*dalf*ei))
c          tq=dhalf            !sampson e->e-v
c          de=done
c        endif
C
c        w=done                !standard Darwin
c        if(kappa.ne.0)w=-2.   !see also pmvdar
c
        DO I=1,I1
          T=DONE+TQ*DALF*(EI+ZL(I)+DTWO*VSC(I)-Z1/DX(I))  !INV TRANSFORM
          t=abs(t)
          GR(I)=T
          T=SQRT(T)
c          t=t**(w/dtwo)
          FR(I)=CT*DE*T*FR(I)
        ENDDO
c      call dnamp(a2,amp2,e,ci1,qq,u,zt,x1,nnmax,jmax)
c      phi2=phasex(e,ci1,qq,u,lm,zt,x1)
c      fnorm=sin(phi2+del*pi)*e**.25/ei**.5 !a2
c      write(6,*)l,ei,x1,x2,f2/f2norm,fr(i1)/fnorm
C
C SMALL COMPONENT
C
        IF(BREL2)THEN
          tkap=-1
          if(kappa.ne.0)tkap=kappa
c
          CALL DIFF(FR,DA,MNH,DHNS,MJH0)
C
          DO I=1,I1
c   gr(i)=done+dquart*dalf*(ei+zl(i)+dtwo*vsc(i)-z1/dx(i)) !tq.ne.dquart
            GR(I)=DHALF*DFSC*(DA(I)+tkap*FR(I)/DX(I))/GR(I)
c            if(e.gt.0.)write(6,*)i,t!fr(i)**2+gr(i)**2*4*e/(dalf*ei**2)
          ENDDO
c      gnorm=dhalf*dfsc*cos(phi2+del*pi)*ei**.5/e**.25 !a2*ei/e**.5
c      write(6,*)l,ei,x1,gr(i1)/gnorm
        ENDIF
      ENDIF
C
C REMOVE FINITE NUCLEUS
C
      DO I=1,INUK
        T=ZL(I)
        ZL(I)=DNUK(I)
        DNUK(I)=T-dnuk(i)
      ENDDO
C
c      write(70,700)l,e,c,a1,i0,dx(i0),fr(i0),i1,dx(i1),fr(i1)
c 700  format(i5,1p,3e15.8,i5,2e15.8,i5,2e15.8)
c      write(6,700)l,e,c,a1,i0,dx(i0),fr(i0),i1,dx(i1),fr(i1)
c      do i=1,i1
c        write(6,700)i,dx(i),fr(i)
c      enddo
C
      RETURN                                              !NORMAL RETURN
C
  999 L=-999                                              !FLAG ABORT
C
      RETURN
C
 1000 FORMAT('E=',F10.4,' RYD',5X,'L=',I3,5X,'X1=',F10.6,5X,'RAT=',F8.5,
     X5X,'X1 TOO SMALL, SHORT-RANGE POTENTIALS STILL TOO LARGE IN FCF6')
 1001 FORMAT(//'*** SR.FCF6: E=',F10.4,' RYD',5X,'L=',I3,5X,
     X' UNABLE TO DETERMINE AMP-PHASE, INCREASE MAXB1 OR'
     X,' INCREASE STEP-LENGTH')
 1002 FORMAT(' WARNING, PLASMA SCREENING POTENTIAL MAY CAUSE INACCURACY'
     X,' IN EVALUATION OF AMP-PHASE FOR E=',F10.4,' RYD',5X,'L=',I3
     X,5X,'X2=',2F10.6)
 1003 FORMAT(//'SR.FCF6: BOTH STARTING VALUES OF F ARE ZERO, NUMERICAL '
     X,'INTEGRATION JUST RETURNS A NULL FUNCTION FOR'/'E=',F10.4,' RYD'
     X,5X,'L=',I3,5X,'AT INNER TURNING POINT X0=',F10.4)
 1004 FORMAT('*** SR.FCF6: CONTINUUM FUNCTION NOT DETERMINABLE FOR L,'
     X,' E :',I6,F10.4)
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION WILT(T,E,ZZ,CI)
C
      WILT=E-(ZZ+CI*T)*T
C
      END FUNCTION WILT
C-----------------------------------------------------------------------
C
      END SUBROUTINE FCF6
C
C***********************************************************************
C
      FUNCTION FDIP(EK1,L1,EK2,L2,IFAIL)
C
C-----------------------------------------------------------------------
C
C FN.FDIP:
C    CALCULATES THE FUNCTION I(KAPPA1,L1,KAPPA2,L2,1)
C    DEFINED IN PHIL. TRANS. ROY. SOC. A226, 255, (1970),
C    WHERE EK1=KAPPA1**2 AND EK2=KAPPA2**2.
C    IT IS SUITABLE FOR USE IN EQUATIONS (8),(9),(10) OR (11) OF
C    J. PHYS. B. 7, L364, (1974).
C ALAN BURGESS DEPT. OF APPLIED MATHS. AND THEORETICAL PHYSICS,CAMBRIDGE
C
C NRB: ADDED FDIPA ASYMPTOTIC OPTION FOR EXTREME CASES
C
C  IT CALLS:
C    FN.FDIP0
C    FN.FDIP1
C    FN.FDIP2
C    FN.FDIPA
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D1O6=0.16667D0)     !1/6
      PARAMETER (D1O34=0.02944D0)    !1/34
      PARAMETER (EPS=1.D-4)
C
      IPRINT=IFAIL
C
      IF(EK1+EK2.LT.D1M40)THEN
        FDIP=DZERO
        IFAIL=1
        IF(IPRINT.EQ.-2)WRITE(6,100)IFAIL
        RETURN
      ENDIF
C
      IF(EK1.LE.EK2)THEN
        EMIN=EK1
        EMAX=EK2
      ELSE
        EMIN=EK2
        EMAX=EK1
      ENDIF
C
      T=EMIN/EMAX
C
      IF(T.LT.D1O6)THEN
        FDIP=FDIP1(EK1,L1,EK2,L2)
        IF(FDIP*FDIP.LT.D1M40.AND.T.GT.D1O34)FDIP=FDIP2(EK1,L1,EK2,L2)
      ELSE
        FDIP=FDIP2(EK1,L1,EK2,L2)
      ENDIF
C
      IF(FDIP*FDIP.LT.D1M40)THEN
        IFAIL=2
        IF(IPRINT.EQ.-2)WRITE(6,100)IFAIL
        RETURN
      ENDIF
C
      IF(FDIP.LT.DZERO.OR.FDIP.GT.DONE)THEN
        IFAIL=3
        IF(IPRINT.EQ.-2)WRITE(6,100)IFAIL
        FDIP=DZERO
        RETURN
      ENDIF
C
      IFAIL=0
      FA=FDIPA(EK1,L1,EK2,L2)
C
      IF(FA.EQ.DZERO)THEN
        FA=FDIP0(EK1,L1,EK2,L2,EPS,IFAIL)
        IFAIL=-IFAIL
        IF(FA.EQ.DZERO)RETURN
      ENDIF
C
      RAT=FDIP/FA
      IF(RAT.GT.DTEN)THEN
        IFAIL=4
        IF(IPRINT.EQ.-2)WRITE(6,100)IFAIL
        FDIP=DZERO
      ENDIF
C
      RETURN
C
  100 FORMAT('***FDIP FAILURE: IFAIL=',I2)
C
      END FUNCTION FDIP
C
C***********************************************************************
C
      FUNCTION FDIP0(EK1,L1,EK2,L2,EPS,IFAIL)
C
C-----------------------------------------------------------------------
C
C FN.FDIP0:
C    CALCULATES THE FUNCTION I0(K1,L1,K2,L2,1)
C    DEFINED IN PHIL. TRANS. ROY. SOC. A266,255,1970,
C    WHERE EK1=K1*K1, EK2=K2*K2,
C    AND THE RELATIVE ACCURACY IS APPROXIMATELY EPS.
C    IT IS SUITABLE FOR USE IN EQUATIONS (13) ETC. OF
C    J. PHYS. B. 7,L364, (1974)
C ALAN BURGESS, DEPT OF APPLIED MATHS. AND THEORETICAL PHYSICS,CAMBRIDGE
C
C NRB - IFAIL
C     - REWORKED CONVERGENCE TEST, CASE MODEST EPS.
C
C  IT CALLS:
C    FN.F21
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      IPRINT=IFAIL
      IFAIL=0
      BTWO=.FALSE.
C
      IF(L1.LT.L2)THEN
        L=L1
      ELSEIF(L1.GT.L2)THEN
        L=L2
      ELSE
        IF(IPRINT.EQ.-2)WRITE(6,100)L1
        IFAIL=1
        FDIP0=DZERO
        RETURN
      ENDIF
C
      EL=L
      FDIP0=DHALF/(EL+DONE)
C
      IF(EK1.LT.EK2)THEN
        E=EK1/EK2
        P=L1-L
      ELSEIF(EK1.GT.EK2)THEN
        E=EK2/EK1
        P=L2-L
      ELSE
        RETURN
      ENDIF
C
      FDIP0=FDIP0*E**((EL+P+DHALF)*DHALF)
C
C TO OBTAIN THE FUNCTION EK1 OF M.J. SEATON, PROC. PHYS. SOC. A68,457,
C 1955, REMOVE THE 'C' ON THE NEXT LINE.
C     FDIP0=DONE
C
      IF(E.GE.DHALF)THEN
C
        P1=P-DHALF
        T=P1*(EL+DONE)*(E-DONE)
        I0=L+1
        H0=DZERO
C
        DO I=1,I0
          TI=I
          H0=H0+DONE/TI
        ENDDO
C
        X=DONE-E
        H=DONE-(P+P+H0+LOG(DQUART*X))
        S=DONE+T*H
        A=EL+DONE
        Y=P1
        C=DONE
        D=DZERO
C
10      A=A+DONE
        Y=Y+DONE
        C=C+DONE
        D=D+DONE
        T=T*A*Y*X/(C*D)
        H=H+P1/(D*Y)+EL/(C*A)
        T1=T*H
        S=S+T1
C
        IF(ABS(T1).GE.EPS*ABS(S))THEN
          BTWO=.FALSE.
          IF(C.LT.D300)GO TO 10
          IF(IPRINT.EQ.-2)WRITE(6,101)
          IFAIL=2
C          FDIP0=DZERO
C          RETURN
        ENDIF
C
        IF(BTWO)THEN
          FDIP0=FDIP0*S
        ELSE
          BTWO=.TRUE.
          GO TO 10
        ENDIF
C
      ELSE
C
        A=EL+DONE
        Y=P-DHALF
        C=EL+P+D3HALF
C
        F=F21(A,Y,C,E,EPS,IFAIL)
C
        L=L+1
        EL=L
C
        IF(P.LE.DHALF)THEN
          C1=EL+EL+DONE
        ELSE
          C1=DONE
        ENDIF
C
        DO I=1,L
          AI=I
          AII=AI+AI
          C1=C1*AI*AI*DFOUR/(AII*(AII+DONE))
        ENDDO
C
        FDIP0=FDIP0*F*C1
C
      ENDIF
C
      RETURN
C
100   FORMAT(' FAILED IN FDIP0, L1=L2=',I5)
101   FORMAT(' FAILED TO CONVERGE IN FDIP0')
C
      END FUNCTION FDIP0
C
C    *******************************************************************
C
      FUNCTION FDIP1(EK1,L1,EK2,L2)
C
C-----------------------------------------------------------------------
C
C FN.FDIP1 EVALUATES DIPOLE INTERGALS IN TERMS OF MONOPOLE INTEGRALS -
C          SEE EQU (A3) OF BHT(1970)  - CASE EMAX/EMIN.GT.6.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      IF(L1.LT.L2)THEN
        L=L1
        A1=EK1
        A2=EK2
      ELSEIF(L1.GT.L2)THEN
        L=L2
        A1=EK2
        A2=EK1
      ELSE
        FDIP1=DZERO
        RETURN
      ENDIF
C
      LP=L+1
      ELP=LP
C
      T1=SQRT(DONE+ELP*ELP*A2)*FMON1(EK1,EK2,L)
      T2=SQRT(DONE+ELP*ELP*A1)*FMON1(EK1,EK2,LP)
C
      IF(T1*T2.LT.D1M40)THEN
        FDIP1=DZERO
      ELSE
        FDIP1=(T1-T2)/ELP
      ENDIF
C
      RETURN
C
      END FUNCTION FDIP1
C
C    ******************************************************************
C
      FUNCTION FDIP2(EK1,L1,EK2,L2)
C
C-----------------------------------------------------------------------
C
C EVALUATE DIPOLE INTERGALS IN TERMS OF MONOPOLE INTEGRALS -
C SEE EQU (A3) OF BHT(1970) - CASE EMAX/EMIN.LT.6.
C NRB: BASED ON ALAN'S ORIGINAL.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D1P24=1.0D+24)
C
      PI=ACOS(-DONE)
      WMAX=D200
C
      ETA1=DONE/SQRT(EK1)
      ETA2=DONE/SQRT(EK2)
      W1=ETA2-ETA1
      A=ABS(W1)
      PIA=PI*A
C
      IF(PIA.LE.D1M2)THEN
        C=DTHREE/(DTHREE-PIA*(DTHREE-PIA*(DTWO-PIA)))
        C=SQRT(C)
      ELSEIF(PIA.GE.D4TEEN)THEN
        C=SQRT(PIA+PIA)
      ELSE
        PIA=PIA+PIA
        C1=DONE-EXP(-PIA)
        C=SQRT(PIA/C1)
      ENDIF
C
      C=C/(SQRT(ETA1*ETA2)*DTWO)
      C2=ETA1+ETA2
      C1=DFOUR*ETA1*ETA2/(C2*C2)
C
      IF(L2.LE.L1)THEN
        L=L2
        T1=ETA1
        ETA1=ETA2
        ETA2=T1
        W1=-W1
      ELSE
        L=L1
      ENDIF
C
      C=C*C1**(L+1)
      U0=L+1
      U1=ETA1
      V0=U0
      V1=-ETA2
      W0=DONE
      X0=W1/(C2*C2)
      Y2=-ETA2-ETA2
      Y0=-U0*W1+Y2
      Y1=ETA2*W1
      T1=X0/(DONE+W1*W1)
      Z0=U0*T1
      Z1=U1*T1
      T=Z0-Z1*W1
      Z1=Z0*W1+Z1
      Z0=T
      S0=-DONE+Z0*Y0-Z1*Y1
      S1=Z0*Y1+Z1*Y0
      X=W1*X0
C
    8 U0=U0+DONE
      V0=V0+DONE
      W0=W0+DONE
C
      IF(W0.GT.WMAX)THEN
        FDIP2=DZERO
        RETURN
      ENDIF
C
      Y0=Y0+Y2
      T=Z0*U0-Z1*U1
      Z1=Z0*U1+Z1*U0
      Z0=T
      T=Z0*V0-Z1*V1
      Z1=Z0*V1+Z1*V0
      Z0=T
      T=Z0*W0-Z1*W1
      Z1=Z0*W1+Z1*W0
      Z0=T
      X0=X/(W0*(W0*W0+W1*W1))
      Z0=Z0*X0
      Z1=Z1*X0
      T0=Z0*Y0-Z1*Y1
      T1=Z0*Y1+Z1*Y0
      S0=S0+T0
      S1=S1+T1
      T1=T0*T0+T1*T1
      T0=S0*S0+S1*S1
C
      IF(T0.LT.D1P24*T1)GO TO 8
C
      J1=0
      J2=L+1
      P=ARGAM(REAL(J1,WP),W1)+ARGAM(REAL(L,WP),ETA1)
     X                       -ARGAM(REAL(J2,WP),ETA2)
C      IW0=W0
      IF(A.GT.D1M40)P=P+W1*LOG(C2/A)
C
      P0=COS(P)
      P1=SIN(P)
      T=P0*S0-P1*S1
      S1=P0*S1+P1*S0
      S0=T
      FDIP2=C*S1
C
      RETURN
C
      END FUNCTION FDIP2
C
C***********************************************************************
C
      FUNCTION FDIPA(EK1,L1,EK2,L2)
C
C-----------------------------------------------------------------------
C
C FN.FDIPA EVALUATES ASYMPTOTIC EXPRESSIONS FOR I(KAPPA1,L1,KAPPA2,L2,1)
C          BASED ON A40,1 OF BHT. NRB
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      IF(EK1*EK2.LT.D1M50)THEN
        FDIPA=DZERO
        RETURN
      ENDIF
C
      X1=DONE/SQRT(EK1)
      X2=DONE/SQRT(EK2)
      X12=ABS(X1-X2)
      IF(X12.GT.D100)THEN
        FDIPA=DZERO
        RETURN
      ENDIF
C
      PI=ACOS(-DONE)
      X12P=EXP(PI*X12/DTWO)
C
      IF(EK1.LE.EK2)THEN
C
        E=EK1/EK2
        IF(L1.LE.L2)THEN
          L=L1
          GO TO 7
        ELSE
          L=L2
          GO TO 8
        ENDIF
C
      ELSE
C
        E=EK2/EK1
        IF(L1.LE.L2)THEN
          L=L1
          GO TO 8
        ELSE
          L=L2
          GO TO 7
        ENDIF
C
      ENDIF
C
C A40
C
   7  TL=L
      T0=DONE-E
      IF(TL*T0.LT.E)THEN
        FDIPA=DZERO
        RETURN
      ENDIF
C
      T=PI*TL
      EE=SQRT(E)
      F0=SQRT(T*T0*EE)*EE**L
      TL=L+L+1
      FDIPA=F0*X12P/TL
      RETURN
C
C A41
C
   8  T0=DONE-E
      TL=L
      IF(TL*T0.LT.E)THEN
        FDIPA=DZERO
        RETURN
      ENDIF
C
      T0=DONE/T0
      T=TL*PI
      EE=SQRT(E)
      F0=SQRT(T*T0*EE)*EE**(L+1)
      TL=L+L+1
      TL2=L+L+3
      FDIPA=F0*X12P/(TL*TL2)
C
      RETURN
C
      END FUNCTION FDIPA
C
C                             *******************
C
      SUBROUTINE FILON(L,V,RMAX,IMAX,F,FB,FO)
C
C-----------------------------------------------------------------------
C
C  SR.FILON EVALUATES BORN INETGRALS USING FILON'S RULE.
C  A. BURGESS, DAMTP, CAMBRIDGE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D3M1=DTHREE*D1M1)
      PARAMETER (D8P6=DEIGHT*D1P6)
C
      DIMENSION F(0:*)
C
      H=RMAX/IMAX
      A0=DONE
C
      IF(L.GT.0)THEN
        DO I=1,L
          A0=(I+I+1)*A0
        ENDDO
        A0=DONE/A0
        A1=DONE/(L*4+6)
        A2=A1/(L*8+20)
        TT=L*DQUART
      ELSE
        S2=DZERO
        S3=DZERO
        T1=DONE/5040
        TT=D1M1
      ENDIF
C
      R=DZERO
      S0=DZERO
      S1=DZERO
      V2=V*V
C
      DO I=1,IMAX
C
        R=R+H
        T=V*R
        IF(T.LT.TT)THEN
          T2=T*T
          IF(L.GT.0)THEN
            T1=((A2*T2-A1)*T2+DONE)*A0
            DO K=1,L
              T1=R*T1
            ENDDO
          ELSE
            T0=((42-T2)*T2-840)*T1*R*R
            T2=V2*T0+DONE
          ENDIF
        ELSE
          IF(T.LT.D8P6)THEN
            S=SIN(T)
            C=COS(T)
          ELSE
            S=DZERO
            C=DZERO
          ENDIF
          IF(L.EQ.0)THEN
            T2=S/T
            T0=(T2-DONE)/V2
          ELSE
            U=DONE/T
            T1=(S*U-C)*U
            IF(L.GT.1)THEN
              T0=S*U
              DO K=1,L-1
                T2=(2*K+1)*T1*U-T0
                T0=T1
                T1=T2
              ENDDO
            ENDIF
            U=DONE/V
            DO K=1,L
              T1=T1*U
            ENDDO
          ENDIF
        ENDIF
C
        T=F(I)
        IF(MOD(I,ITWO).EQ.0)THEN
          IF(L.EQ.0)THEN
            S0=T*T0+S0
            S2=T*T2+S2
          ELSE
            S0=T*T1+S0
          ENDIF
        ELSE
          IF(L.EQ.0)THEN
            S1=T*T0+S1
            S3=T*T2+S3
          ELSE
            S1=T*T1+S1
          ENDIF
        ENDIF
C
      ENDDO
C
      T=V*H
      IF(T.LE.D3M1)THEN
        T2=T*T
        A0=(T2*10-108)*T2+378
        C0=(54-T2)*T2-1512
        IF(L.GT.0)THEN
          A=(A0*T2+1890)/2835
          C=(C0*T2+15120)/11340
        ELSE
          A0=A0*H*H/2835
          A=A0*V2+D2THRD
          C0=C0*H*H/11340
          C=C0*V2+D4THRD
        ENDIF
      ELSE
        IF(T.LT.D8P6)THEN
          S=SIN(T)
          C=COS(T)
          T0=C*C
        ELSE
          S=DZERO
          C=DZERO
          T0=DHALF
        ENDIF
        T1=DONE/T
        T2=T1*T1
        A=(DONE+T0-DTWO*S*C*T1)*T2*DTWO
        C=(S*T1-C)*T2*DFOUR
        IF(L.EQ.0)THEN
          C0=(C-D4THRD)/V2
          A0=(A-D2THRD)/V2
        ENDIF
      ENDIF
C
      IF(L.GT.0)THEN
        FB=(A*S0+C*S1)*H
        FO=DZERO
      ELSE
        FO=(A*S2+C*S3)*H
        FB=((S0*DTWO+S1*DFOUR)/DTHREE+A0*S2+C0*S3)*H
      ENDIF
C
      RETURN
C
      END SUBROUTINE FILON
C
C                             *******************
C
      SUBROUTINE FILONW(L,V,dx,mnh,dhns,mjh,maxrs,F,FB,FO)
C
C-----------------------------------------------------------------------
C
C  SR.FILONW IS AN ADAPTATION OF
C  SR.FILON, WHICH EVALUATES BORN INETGRALS USING FILON'S RULE.
C  (A. BURGESS, DAMTP, CAMBRIDGE),
C  TO USE THE STANDARD SS/AS DOUBLING MESH.
C  IT ASSUMES AN EVEN NUMBER OF STEPS MNH(JH) FOR JH=1,MJH
C  WHICH IS THE NORM.
C
C*** SET PARAMETER:
C
C  DJAY0 = 1 TO RETAIN THE DELTA(LAMBDA,0) SUBTRACTION FACTOR (AS FILON)
C  DJAY0 = 0 TO OMIT THE DELTA(LAMBDA,0) FACTOR
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D3M1=DTHREE*D1M1)
      PARAMETER (D8P6=DEIGHT*D1P6)
C
      PARAMETER (DJAY0=DZERO)
C
      DIMENSION F(maxrs),dx(maxrs),dhns(mjh),mnh(mjh)
C
      ih=0
      fo=dzero
      fb=dzero
C
      A0=DONE
C
      IF(L.GT.0)THEN
        DO I=1,L
          A0=(I+I+1)*A0
        ENDDO
        A0=DONE/A0
        A1=DONE/(L*4+6)
        A2=A1/(L*8+20)
        TT=L*DQUART
      ELSE
        S2h=DZERO
c        S3=DZERO
c        T1=DONE/5040
        TT=D1M1
      ENDIF
c
c      H=RMAX/IMAX
c      R=DZERO
      S0h=DZERO
c      S1=DZERO
      V2=V*V
C
      do jh=1,mjh
C
        h=dhns(jh)
        imax=mnh(jh)
        s0=s0h
        S1=DZERO
        IF(L.EQ.0)THEN
          s2=s2h
          S2h=DZERO
          S3=DZERO
          T1=DONE/5040                  !reset as overwritten later...
        ENDIF
C
      DO I=1,IMAX
C
        ih=ih+1
        R=dx(ih)
        T=V*R
        IF(T.LT.TT)THEN
          T2=T*T
          IF(L.GT.0)THEN
            T1=((A2*T2-A1)*T2+DONE)*A0
            DO K=1,L
              T1=R*T1
            ENDDO
          ELSE
            T0=((42-T2)*T2-840)*T1*R*R
            t0=t0+(done-djay0)/v2
            T2=V2*T0+djay0
          ENDIF
        ELSE
          IF(T.LT.D8P6)THEN
            S=SIN(T)
            C=COS(T)
          ELSE
            S=DZERO
            C=DZERO
          ENDIF
          IF(L.EQ.0)THEN
            T2=S/T
            T0=(T2-djay0)/V2
          ELSE
            U=DONE/T
            T1=(S*U-C)*U
            IF(L.GT.1)THEN
              T0=S*U
              DO K=1,L-1
                T2=(2*K+1)*T1*U-T0
                T0=T1
                T1=T2
              ENDDO
            ENDIF
            U=DONE/V
            DO K=1,L
              T1=T1*U
            ENDDO
          ENDIF
        ENDIF
C
        T=F(Ih)
        IF(MOD(I,ITWO).EQ.0)THEN
          IF(L.EQ.0)THEN
            S0=T*T0+S0
            S2=T*T2+S2
          ELSE
            S0=T*T1+S0
          ENDIF
        ELSE
          IF(L.EQ.0)THEN
            S1=T*T0+S1
            S3=T*T2+S3
          ELSE
            S1=T*T1+S1
          ENDIF
        ENDIF
C
      ENDDO
c
      IF(MOD(Ih,ITWO).EQ.0)THEN
        IF(L.EQ.0)THEN
          s0h=t*t0/2
          S0=-s0h+S0
          s2h=t*t2/2
          S2=-s2h+S2
        ELSE
          s0h=t*t1/2
          S0=-s0h+S0
        ENDIF
      ELSE
        if(jh.lt.mjh)stop 'filonw: mesh error - should be even steps'
      ENDIF
C
      T=V*H
      IF(T.LE.D3M1)THEN
        T2=T*T
        A00=(T2*10-108)*T2+378
        C0=(54-T2)*T2-1512
        IF(L.GT.0)THEN
          A=(A00*T2+1890)/2835
          C=(C0*T2+15120)/11340
        ELSE
          A00=A00*H*H/2835
          A=A00*V2+D2THRD
          C0=C0*H*H/11340
          C=C0*V2+D4THRD
        ENDIF
      ELSE
        IF(T.LT.D8P6)THEN
          S=SIN(T)
          C=COS(T)
          T0=C*C
        ELSE
          S=DZERO
          C=DZERO
          T0=DHALF
        ENDIF
        T1=DONE/T
        T2=T1*T1
        A=(DONE+T0-DTWO*S*C*T1)*T2*DTWO
        C=(S*T1-C)*T2*DFOUR
        IF(L.EQ.0)THEN
          C0=(C-D4THRD)/V2
          A00=(A-D2THRD)/V2
        ENDIF
      ENDIF
C
      IF(L.GT.0)THEN
        FB=fb+(A*S0+C*S1)*H
        FO=DZERO
      ELSE
        FO=fo+(A*S2+C*S3)*H
        FB=fb+((S0*DTWO+S1*DFOUR)/DTHREE+A00*S2+C0*S3)*H
      ENDIF
c
      enddo
c
      if(l.gt.0)fb=fb*v**l             !standard filon omits this factor
C
      RETURN
C
      END SUBROUTINE FILONW
C
C                             *******************
C
      SUBROUTINE FIT(A0,M,H,A,C)
C
C-----------------------------------------------------------------------
C
C  N.R.BADNELL D.A.M.T.P. CAMBRIDGE
C
C  SR.FIT FITS A RADIAL FUNCTION NEAR THE ORIGIN BY A POWER SERIES.
C  INPUT TABULATED FUNCTION A(I) WITH I .GE. 5, STEP H AND BEHAVIOUR
C  A0*X**M FOR X SMALL.
C  OUTPUT C(I) (I.GT.5 UNDEFINED) A POWER SERIES EXPANSION OF FORM
C  (A0+C(1)*X+..............C(5)*X**5)*X**M
C  NOTE THAT A0 IS CORRECT LEADING ORDER TERM AND IS NOT REDEFINED.
C  THIS FIT IS DERIVED FROM ALAN BURGESS'S SR.YLAM.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(5),C(5)
C
      X1=H
      C1=A(1)/X1**M-A0
      X2=X1+H
      C2=A(2)/X2**M-A0
      X3=X2+H
      C3=A(3)/X3**M-A0
      X4=X3+H
      C4=A(4)/X4**M-A0
      X5=X4+H
      C5=A(5)/X5**M-A0
C
      H1=DONE/H
      Z=H1/120
      C(1)=(600*(C1-C2)+400*C3-150*C4+24*C5)*Z
      Z=H1*Z
      C(2)=(-770*C1+1070*C2-780*C3+305*C4-50*C5)*Z
      Z=H1*Z
      C(3)=(355*C1-590*C2+490*C3-205*C4+35*C5)*Z
      Z=H1*Z
      C(4)=(-70*C1+130*C2-120*C3+55*C4-10*C5)*Z
      Z=H1*Z
      C(5)=(5*C1+10*(C3-C2)-5*C4+C5)*Z
C
      RETURN
C
      END SUBROUTINE FIT
C
C                             *******************
C
      SUBROUTINE FLGL1(KC,KMAX,NF,JYI,JYF,QLMC,BAM,DFS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.FLGL1: EXPANDS THE ENERGY MATRIX ELEMENT <CASL! H !C'A'SL>
C  IN TERMS OF TWO SORTS OF RADIAL INTEGRALS, EQ.1.6,7,8 IN E&N,
C  AND CALCULATES THE COEFFICIENTS AS DESCRIBED IN SECT.3.2 OF E&N
C
C**THIS VERSION DETERMINES THE SLATER STATE INTERACTIONS ONLY,
C  FOR A GIVEN SLP  -  NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  IT CONTAINS:
C    FN.MVC
C
C  INPUT: KMAX CONFIGURATIONS C.
C  AM(J)=TRUE FOR ALL SLST J WITH TOTAL MS,ML OTHER THAN CONSIDERED.
C  NF VALENCE ELECTRONS, NW CORE ELECTRONS.
C  2*ML , 2*MS OF I'TH ELECTRON IN J'TH SLATER STATE
C            =QLMC(I,J)  +-1, IF QLMC EVEN
C            =QLMC(I,J)-1++1, IF QLMC ODD
C  QCG(I,K)=G OF I'TH ELECTRON IN K'TH CONF; G=1,2,3.. FOR 1S,2S,
C  2P..  IF NOT REDEFINED, GENERALLY NK=QN(K),LK=QL(K)/2.
C  FOR THE CORE  NNL(I)=G, NNL(I+MAXCL)=QLMC AS ABOVE, (I=1,NW)
C  KC IS CONFIG OF FIRST SYMMETRY, USED FOR CORE.
C
C  OUTPUT: COEFFICIENTS DRKS(J) AND ARGUMENT-ADRESSES L=NRKS(J) STORED
C  SEQUENTIALLY FROM IRKS0 ONWARDS; ARGUMENTS QRLS(1...5,L)=A,B,C,D,LD
C  TEMPORARILY LISTED IN NEW SECTION OF REF.-LIST FROM IRLS00 ONWARDS
C  AT THE END ALL QRLS THAT HAD PREVIOUSLY BEEN LISTED ARE CANCELLED.
C  QLMC(K,1) IS USED AS BUFFER (K=1,2,..NF.LE.ME),  AM(1) IS I/O.
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL ,  ONLY: IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD14=100)
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.D-6)
C
      DIMENSION BAM(*),QLMC(MAXEL,*),DFS(*),JYI(*),JYF(*)
     X         ,Q1(2,2),MM(2,2),Q3(2,2),Q4(2,2)
     X         ,NEN(2,2),NEJ(2),MRL(5),NEK(2)
C
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBFAN/BFANO
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
      ALLOCATABLE :: IGRGR(:)
C
c      MVC(M1,M2)=((M1+2)*M1/2+M2)/2+1 !SEE INTRNL FUNCTN ABVE END FLGL1
C
      POINTER :: KF,KG,N1,N2,MJ11,MJ12,ML
      TARGET :: NEK,NEN,MM,MRL
C
      KF=>NEK(1)
      KG=>NEK(2)
      N1=>NEN(1,1)
      N2=>NEN(2,1)
      MJ11=>MM(1,1)
      MJ12=>MM(1,2)
      ML=>MRL(5)
C
c      EQUIVALENCE (KF,NEK(1)),(KG,NEK(2)),(N1,NEN(1,1)),(N2,NEN(2,1))
c     X           ,(MJ11,MM(1,1)),(MJ12,MM(1,2)),(ML,MRL(5))
C
      BPLANT=MXORB.LT.67
      JPLANT(1)=0
      BSKP=MXLL.EQ.-1
      BKUTOO=KUTOO.NE.0
C
      ALLOCATE (IGRGR(MXORB))
C
      DO I=1,MB                                                     !MB0
        IGRGR(I)=I
      ENDDO
C
C INITIALIZE
C
      IRLS=0
      IRKS=0
      NCF=0
      NADS(0)=0
C
      IDIR=0                                               !ALLOW DIRECT
      IXCH=0                                              !ALLOW ECHANGE
ct      idir=1
ct      ixch=1
C
      MXLAM=ABS(MAXLAM)                             !MAX MULTIPOLE VALUE
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      IF(NADS(-1).EQ.-1)THEN
        NE=NF
        NF=0
        BEQCFS=.TRUE.
        KF1=KC
        KG1=KC
      ELSE
        KF1=1
        KG1=1
      ENDIF
C
C LOOP OVER ALL CONFIG PAIRS
C
 100  DO 99 KF=KF1,KMAX
C
      JA=JYI(KF)
      JB=JYF(KF)
C
      DO 90 KG=KG1,KF
C
      IF(NF.NE.0)THEN
        NCF=NCF+1
        BSKPCF=NADS(NCF).LT.0         !KF AND/OR KG NOT CONTRIB
        NADS(NCF)=NADS(NCF-1)
        IF(BSKPCF)GO TO 90
C
        BEQCFS=KG.EQ.KF
      ENDIF
C
C COMPUTE COEFFICIENTS A AND B (SEE E+N SECTION 3.2, DO55 AND DO57
C ARE THE TWO SUMMATIONS OVER SLATER STATES IN EQ.3.17).
C
      IRLS00=IRLS
      IRLS1=IRLS00+1
      IRKS00=IRKS+1
C EVTL IF(BAM(1))  IRLS00=0
      DDA=DONE
      DDB=DZERO
C
      JAP=JYI(KG)
      JBP=JYF(KG)
C
C BEGIN MAIN SLATER-STATE LOOPS OVER 55 AND 57
C
      DO 55 J=JA,JB
C
      IF(BAM(J))GO TO 55
      NEJ(1)=J
      IF(BEQCFS)JBP=J
      IF(NF.EQ.0)JAP=J
C
      DO 57 JD=JAP,JBP
C
      IF(BAM(JD))GO TO 57
      DDH=DONE
C
C THIS NEXT STATEMENT RESOLVES INTERACTIONS BY SLATER STATE, NOT TERM
COLD      IRKS0=IRKS+1
C
      DO I=IRLS1,IRLS
        IORIG(I)=0
        JORIG(I)=0
      ENDDO
C
      BEQTMS=NF.EQ.0           !NEED EQUI AND NON-EQUI CASES
C
      NEJ(2)=JD
      NK=0
      NU=-NW
      IF(JD.EQ.J)GO TO 75                    !SO BEQCFS=.TRUE.
      IF(NF.EQ.0)STOP 'FLGL1: NF=0????'            !GO TO 57
C
C CALCULATE NK-THE NUMBER OF INDIVIDUAL SETS IN WHICH SLATER
C STATE JD DIFFERS FROM J; THE PHASE FACTOR THAT RESULTS FROM
C THE REMAINING NF-NK SETS WILL BE ABSORBED INTO DDH:
C
      MU=0
      DO I=1,NF
        KB=QLMC(I,J)
        KA=QCG(I,KF)
        KAC=IEQ(KA)
        DO L=1,NF
          IF(QLMC(L,JD).NE.KB)GO TO 59
          IF(IEQ(QCG(L,KG)).NE.KAC)GO TO 59
          LP=L
          IGRGR(KA)=QCG(L,KG)
          GO TO 58
  59    ENDDO
        NK=NK+1
        IF(NK.GT.2)GO TO 57
        NEN(1,NK)=I
        MU=I+MU
        LP=0
  58    QLMC(I,1)=LP
      ENDDO
C
      K=0
      DO L=1,NF
        DO I=1,NF
          IF(QLMC(I,1).EQ.L)GO TO 60
        ENDDO
        K=K+1
        NEN(2,K)=L
        MU=L+MU
        IF(K.EQ.NK)GO TO 74
  60  ENDDO
C
  74  DDH=(1-2*MOD(MU,ITWO))*DDH
C
      IF(NK.EQ.2)GO TO 72
C
C NOW NK=1, WHICH IMPLIES NDP1.NE.ND1
      IF(N1.EQ.0.OR.N2.EQ.0)THEN
        WRITE(6,*)
        WRITE(6,*)'***SR.FLGL1: DUPLICATE CONFIGURATIONS',KF,
     X            ' AND',KG,' ????'
        WRITE(0,*)'SR.FLGL1: DUPLICATION CONFIGURATIONS?'
        NF=-1
        GO TO 999
      ENDIF
C
c      if(nk.eq.1)go to 75                !assume cancel with 2-bdy ml=0
      ML=QCG(N1,KF)
      MU=QCG(N2,KG)
      IF(QL(MU).NE.QL(ML))GO TO 75
      IF(QN(ML).GE.90.AND.QN(MU).GE.90)GO TO 75
      IF(.NOT.BSKP)DDA=DDH
C
      DDB=DZERO
      IF(MU.GE.ML)THEN
        LP=ML
        ML=MU
        MU=LP
      ENDIF
      MRL(1)=ML
      MRL(2)=-0
      MRL(3)=MU
      MRL(4)=-0
      ML=-1
      BFALL=.FALSE.
      GO TO 87
C
  75  IF(DDH.EQ.DZERO)GO TO 57
C
      IF(.NOT.BEQTMS.AND.BEQCFS)NU=0
C
  68  NU=NU+1
      IF(NU.GT.NF)GO TO 67
      NEN(1,2)=NU
      IF(NK.NE.0)GO TO 71
      ND=NU
      IF(ND*NF.LT.0)ND=0
  69  ND=ND+1
      IF(ND.GT.NF)GO TO 68
      NEN(1,1)=ND
  71  IF(NEN(1,1).EQ.NEN(1,2))GO TO 65
C
  72  IMT=0
C                                       !test - need to exc kcor as well
c      nval=0                                     !test - exclude "core"
      DO L=1,2  !=1 FOR SLATER STATES J (OF CONFIG KF),=2 FOR JD (OF KG)
        I=L
        DO K=1,2 !=1 FOR FOR FIRST PAIR OF ELECTRON STATES,=2 FOR SECOND
          IF(NK.LT.K)I=1
          KP=NEN(I,K)
          IF(KP.LE.0)THEN
            KP=KP+NW
            LP=NNL(KP,1)
            MU=NNL(KP,2)
          ELSE
            LP=NEJ(I)
            MU=QLMC(KP,LP)
            LP=NEK(I)
            LP=QCG(KP,LP)
            IF(QN(LP).GE.90)IMT=IMT+1
            IF(IMT.GT.1)GO TO 65
          ENDIF
          ML=((QL(LP)+MU)/2)*2-QL(LP)
          Q4(L,K)=(MU-ML)*2-1
          Q3(L,K)=ML
          MM(L,K)=QL(LP)
          Q1(L,K)=LP
c          if(qn(lp).ge.80)nval=nval+1            !test - exclude "core"
        ENDDO
      ENDDO
c      if(nval.ne.2)go to 65                      !test - exclude "core"
      IF(NK.EQ.1)Q1(2,2)=IGRGR(Q1(2,2))
C
C DIRECT
C
      KP=0
C
C EQU  MJ11=Q2(1,1)
C EQU  MJ12=Q2(1,2)
      MM11=-Q3(1,1)
      MM12=-Q3(1,2)
      MV11=MVC(MJ11,MM11)
      MV12=MVC(MJ12,MM12)
C
      IF(IDIR.EQ.1)GO TO 76                                   !NO DIRECT
C
C EXCHANGE RE-ENTRY POINT
C
  77  IF(.NOT.BSKP.AND.Q4(2,1+KP).NE.Q4(1,1))GO TO 76
C
      MJ21=MM(2,KP+1)
      MJ22=MM(2,2-KP)
C
C MU=MAX LAM
      MU=MIN(MJ11+MJ21,MJ12+MJ22,ITWO*MXLAM)
C
C ML=MIN LAM
      ML=MAX(ABS(MJ11-MJ21),ABS(MJ12-MJ22))
C
C LIMIT NUMBER
      MU=MIN(MU,ML+IFOUR*NMULT)
C
C AGAIN (SEE BELOW) ORBIT-ORBIT "LESS RESTRICTIVE" -
C    add .not.BKUTOO !!!!!      HOW I MISSED THIS FOR SO LONG...
      IF(.not.BKUTOO.and.
     X   .NOT.BEQTMS.AND.KP+NK+ML.EQ.0)ML=4
      IF(ML.GT.MU)GO TO 76
c
c      if(ml.eq.0.and.kp.eq.0.and.nk.eq.1)go to 10  !assume cancel ml=-1
C
      IF(.NOT.BSKP)THEN
        MM21=Q3(2,KP+1)
        MMD1=MM21+MM11
        MM22=Q3(2,2-KP)
        MMD2=MM12+MM22
C
C INCREASE MIN LAM BECAUSE OF ML1-ML2
        K=MAX(ABS(MMD1),ABS(MMD2))
C
C ORBIT-ORBIT LAM+1, SO "LESS RESTRICTIVE" -
C                                  THIS WAS IN MY ORIGINAL CODING OF O-O
        IF(BKUTOO)K=K-2
        IF(K.GT.ML)ML=((K+2-ML)/4)*4+ML
        IF(ML.GT.MU)GO TO 76
C
        DSJ=SQRT(REAL((MJ11+1)*(MJ12+1)*(MJ21+1)*(MJ22+1),WP))*
     X           REAL((1-MOD(ABS(MM22-MM11),IFOUR))*(1-2*KP),WP)*DDH
C
        MV21=MVC(MJ21,MM21)
        MV22=MVC(MJ22,MM22)
      ENDIF
C
C REORDER A,B,C,D IN AS MUCH FALLING ORDER AS SYMMETRY ALLOWS FOR
C
      L=0
      K=0
      IF(Q1(2,2-KP).GT.Q1(1,2))K=2                       !FO
      I=0
      IF(Q1(2,1+KP).GT.Q1(1,1))I=2                       !FO
      BFALL=BKUTOO.AND.I+K.EQ.2
C
  62  MRL(1+I+L)=Q1(1,1)
      MRL(3-I+L)=Q1(2,1+KP)
      MRL(2+K-L)=Q1(1,2)
      MRL(4-K-L)=Q1(2,2-KP)
      L=1
      IF(MRL(2).GT.MRL(1))GO TO 62                       !FO
C
C LAMBDA RE-ENTRY POINT
C
  78  IF(.NOT.BSKP)THEN
        LP=ML/4+1
        IF(BVC.OR.(MJ11.LE.MXLL.AND.MJ21.LE.MXLL))THEN
          DDA=VCA(MV11,MV21,LP)
          IF(BKUTOO)DDB=VCB(MV11,MV21,LP)
        ELSE
          DVC=VCC(MJ11,MJ21,ML,IZERO,IZERO,IZERO,DFS)
          DDA=DVC*VCC(MJ11,MJ21,ML,MM11,MM21,MMD1,DFS)/(ML+1)
          IF(BKUTOO)DDB=DVC*VCC(MJ11,MJ21,ML+2,MM11,MM21,MMD1,DFS)
        ENDIF
        IF(BVC.OR.(MJ22.LE.MXLL.AND.MJ12.LE.MXLL))THEN
          DDA=DDA*VCA(MV22,MV12,LP)
          IF(BKUTOO)DDB=DDB*VCB(MV22,MV12,LP)
        ELSE
          DVC=VCC(MJ22,MJ12,ML,IZERO,IZERO,IZERO,DFS)
          DDA=DDA*DVC*VCC(MJ22,MJ12,ML,MM22,MM12,MMD2,DFS)/(ML+1)
          IF(BKUTOO)DDB=DDB*DVC
     X                     *VCC(MJ22,MJ12,ML+2,MM22,MM12,MMD2,DFS)
        ENDIF
C
        IF(ABS(DDA)+ABS(DDB).EQ.DZERO)GO TO 10
C
        IF(BFANO)THEN
          IFANO=QL(Q1(2,1+KP))-QL(Q1(1,1))
          IF(MRL(5).GE.0)IFANO=IFANO+QL(Q1(2,2-KP))-QL(Q1(1,2))
          IFANO=IFANO/4
          IFANO=1-2*mod(abs(IFANO),ITWO)                  !(-1)**IFANO
          DDA=DDA*IFANO
          IF(BKUTOO)DDB=DDB*IFANO
        ENDIF
C
        DDA=DDA*DSJ
        IF(BKUTOO)DDB=DDB*DSJ
      ENDIF
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
  87  IF(BPLANT)IPLANT=MRL(5)/2+
     X((((MRL(4)*MXORB+MRL(3))*MXORB+MRL(2))*MXORB)+MRL(1))*100
C
c      if(qn(mrl(1)).lt.80)go to 84          !test - exclude "core"
c
      DO I=IRLS1,IRLS
        IF(.NOT.BPLANT)THEN
          DO K=5,1,-1
            IF(MRL(K).NE.QRLS(K,I))GO TO 63
          ENDDO
        ELSE
          IF(IPLANT.NE.JPLANT(I))GO TO 63
        ENDIF
        IF(BEQTMS)THEN
          LP=-I
          K=JORIG(I)
        ELSE
          LP=I
          K=IORIG(I)
        ENDIF
        IF(K.GT.0)THEN
          DRKS(K)=DDA+DRKS(K)
          IF(BKUTOO)THEN
            DEKS(K)=DDB+DEKS(K)
            IF(BFALLS(K).NEQV.BFALL)THEN
              WRITE(6,*)'FLGL1: PROBLEM WITH ORBIT-ORBIT ALG.'
              WRITE(0,*)'FLGL1: PROBLEM WITH ORBIT-ORBIT ALG.'
              NF=-1
              GO TO 999
            ENDIF
          ENDIF
          GO TO 84
        ENDIF
C  83  CONTINUE
        GO TO 82
  63  ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
      LP=IRLS+1
      IF(LP.GT.IXRLS)THEN                                     !GO TO 999
C
        IXXX=7*(IXRLS/5+1)
C
        WRITE(6,*)'*** FLGL1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** FLGL1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRLS,IONE,IFIVE,IONE,IXRLS,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGL1: REALLOCATION FAILS FOR QRLS'
          NF=0
          GO TO 999
        ENDIF
C
        IXXX0=MAX(IXRLS,IAXRL)
        IXXX2=MAX(IXXX,IAXRL)
        IF(IXXX2.GT.IXXX0)
     X  CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
        CALL RE_ALLOC(JORIG,IONE,IXRLS,IXXX,IERR)
        CALL RE_ALLOC(JPLANT,IONE,IXRLS,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGL1: REALLOCATION FAILS FOR IORIG,JORIG,JPLANT'
          NF=0
          GO TO 999
        ENDIF
C
        IXRLS=IXXX
C
      ENDIF
C
      IRLS=LP
      DO K=1,5
        QRLS(K,LP)=MRL(K)
      ENDDO
      IF(BPLANT)JPLANT(LP)=IPLANT

      IF(BEQTMS)LP=-LP
C
C      K=-IRKS
  82  IRKS=IRKS+1
      IF(IRKS.GT.IXRKS)THEN                                   !GO TO 999
C
        IXXX=7*(IXRKS/5+1)
C
        WRITE(6,*)'*** FLGL1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** FLGL1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRKS,IONE,IXRKS,IXXX,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEKS,IONE,IXRKS,IXXX,IERR)
          CALL RE_ALLOC(BFALLS,IONE,IXRKS,IXXX,IERR)
        ENDIF
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGL1: REALLOCATION FAILS FOR DRKS,DEKS'
          NF=0
          GO TO 999
        ENDIF
C
        CALL RE_ALLOC(NRKS,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJ,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJD,IONE,IXRKS,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGL1: REALLOCATION FAILS FOR NRKS,NSTJ'
          NF=0
          GO TO 999
        ENDIF
C
        IXRKS=IXXX
C
      ENDIF
C
      DRKS(IRKS)=DDA
      IF(BKUTOO)THEN
        DEKS(IRKS)=DDB
        BFALLS(IRKS)=BFALL
      ENDIF
C
      IF(LP.GT.0)THEN
        IORIG(LP)=IRKS
        JORIG(LP)=0
      ELSE
        JORIG(-LP)=IRKS
      ENDIF
C
      NRKS(IRKS)=LP
      NSTJ(IRKS)=J
      NSTJD(IRKS)=JD
C
  84  CONTINUE
C
c      write(6,998)  j,jd,nk,lp,kp, mrl,dda
c 998  format(5i5,4x,5i3,2f12.5)
C
      IF(ML.LT.0)GO TO 68
  10  ML=ML+4
      IF(ML.LE.MU)GO TO 78                           !NEXT LAMBDA
C
  76  KP=KP+1+IXCH
      IF(KP.EQ.1)GO TO 77                            !EXCHANGE
C
  65  IF(NK-1.LT.0)GO TO 69
      IF(NK-1.EQ.0)GO TO 68
C
  67  IF(J.EQ.JD.AND..NOT.BEQTMS)THEN                !SO BEQCFS=.TRUE.
        BEQTMS=.TRUE.
        NU=-NW
        GO TO 75
      ENDIF
C
C
  57  ENDDO               !END INNER SLATER-STATE LOOP
C
  55  ENDDO              !END OUTER SLATER-STATE LOOP
C
C
C ELIMINATE COEFFICIENTS /DRKS/.LT.TYNY AND ARGUMENTS QRLS THAT HAVE
C BEEN LISTED BEFORE IN THE REFERENCE LIST
C
C  89  IF(KF.GT.0)GO TO 98
      IF(IRKS.LT.IRKS00)GO TO 90
C
      K=IRKS00-1
      KP=0
      DO I=IRLS1,IRLS
        IORIG(I)=0
      ENDDO
C
      DO 91 I=IRKS00,IRKS
C
        JD0=NRKS(I)
        JD=ABS(JD0)
        DD=ABS(DRKS(I))
        IF(BKUTOO)DD=DD+ABS(DEKS(I))
        IF(ABS(DD).LT.TYNY)THEN
          IF(IORIG(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QRLS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
C
        K=K+1
        DRKS(K)=DRKS(I)
        IF(BKUTOO)THEN
          DEKS(K)=DEKS(I)
          BFALLS(K)=BFALLS(I)
        ENDIF
        NSTJ(K)=NSTJ(I)
        NSTJD(K)=NSTJD(I)
C
  94    IF(JD.LE.IRLS00)THEN
          IF(IRLS.LE.MXRLS)THEN   !SHOULD NOT GET HERE
            WRITE(6,*)'FLGL1: INFORM NRB OF STOP HERE'
            WRITE(0,*)'FLGL1: INFORM NRB OF STOP HERE'
            NF=-1
            GO TO 999
          ELSE          !GRACEFUL EXIT TO DIMENSION STOP
            LP=JD
            GO TO 92
          ENDIF
        ENDIF
C
        IF(IORIG(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,IRLS00
            DO J=1,5
              IF(QRLS(J,JD).NE.QRLS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG(JD)
          GO TO 92
        ENDIF
C
        IORIG(JD)=LP
        DO J=1,5
          QRLS(J,LP)=QRLS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          NRKS(K)=LP
          IF(JD0.LT.0)NRKS(K)=-NRKS(K)
        ENDIF
C
  91  ENDDO
C
      IRLS=IRLS-KP
      IRKS=K
C  98  CONTINUE
      NADS(NCF)=IRKS
C
      IF(NF.EQ.0)THEN
        NADS(-1)=0
        NF=NE
        KF1=1
        KG1=1
        GO TO 100
      ENDIF
C
C
  90  ENDDO                   !END OF INNER CF LOOP
C
  99  ENDDO                  !END OF OUTER CF LOOP
C
C
 999  DEALLOCATE (IGRGR)
C
      RETURN
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(M1,M2)
C
      MVC=((M1+2)*M1/2+M2)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE FLGL1
C
C                             *******************
C
      SUBROUTINE FLGL2(mam,nam,KK)
C
C-----------------------------------------------------------------------
C
C  SR.FLGL2 EXPANDS THE ENERGY MATRIX ELEMENT <CASL! H !C'A'SL>
C  IN TERMS OF TWO SORTS OF RADIAL INTEGRALS, EQ.1.6,7,8 IN E&N,
C  AND CALCULATES THE COEFFICIENTS AS DESCRIBED IN SECT.3.2 OF E&N
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  INPUT: KF,KG ARE INDEXES OF CONFIGURATION C,C'
C  DRKS, NRKS CONTAIN AND INDEX SLATER STATE INTERACTIONS BETWEEN
C  SLATER STATES J AND JD ASSOCIATED WITH C AND C' - NRB;
C  DC(J+ND2)=VCC OF J'TH SLATERSTATE TO TERM ND2
C  DC(JD+NDP2)       JD
C
C  OUTPUT: COEFFICIENTS DRL(J) AND ARGUMENT-ADRESSES L=NRK(J) STORED
C  SEQUENTIALLY FROM IRK0 ONWARDS; ARGUMENTS QRL(1...5,L)=A,B,C,D,LD
C  TEMPORARILY LISTED IN NEW SECTION OF REF.-LIST FROM IRL00 ONWARDS
C  AT THE END ALL QRL THAT HAD PREVIOUSLY BEEN LISTED ARE CANCELLED.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-8)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      DIMENSION mam(*),nam(*)
C
      COMMON /BASIC/NF,KF,KG,JGAP(4),ND1,NDP1,ND2,NDP2,NGAP
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
      BKUTOO=KUTOO.NE.0
      DDB=DZERO
C
      IRL00=IRL                                 !EVTL IF(AM(1))  IRL00=0
C
      DO J=1,IRLS
        JORIG(J)=0
      ENDDO
C
      BEQCFS=KG.EQ.KF
      BEQTMS=NDP1.EQ.ND1
C
      IF(KK.EQ.0.AND.IRLX.LT.0)THEN       !UNPACK
        NGRP=-IRLX/100000                 !UNTIL /NRBORB/ IN A MODULE
        MXBORB=-IRLX-100000*NGRP
      ELSE
        MXBORB=0
      ENDIF
C
c      write(6,*)'kf=',kf,'  kg=',kg
C
C BEGIN MAIN LOOP 57 OVER SLATER INTERACTIONS
C
c      m0=0
c      t0=dzero
c      md0=0
c      td0=dzero
      K0=NADS(KK-1)+1
C
      DO 57 KS=K0,NADS(KK)
C
        J=NSTJ(KS)
        JD=NSTJD(KS)
C
        II=NRKS(KS)
        IF(J.EQ.JD)THEN
          IF(BEQTMS.AND.II.GT.0)GO TO 57
          IF(.NOT.BEQTMS.AND.II.LT.0)GO TO 57
          II=ABS(II)
        ENDIF
C
        IF(BFAST)THEN
          DDH=DC(J+ND2)*DC(JD+NDP2)
          IF(BEQCFS.AND.JD.NE.J)DDH=DC(J+NDP2)*DC(JD+ND2)+DDH
        ELSE
c          write(6,*)m,md
          m=mam(j)
          md=nam(jd)
          if(m.gt.0.and.md.gt.0)then             !m*md can over flow I*4
c          if(m.ne.m0)then
c            t0=dc(m)
c            m0=m
c          endif
c          if(md.ne.md0)then
c            td0=dc(md)
c            md0=md
c          endif
c          DDH=t0*td0
          DDH=DC(m)*DC(md)
          else
            ddh=dzero
          endif
          IF(BEQCFS.AND.JD.NE.J)then
            md=mam(jd)
            m=nam(j)
            if(m.gt.0.and.md.gt.0)then           !m*md can over flow I*4
              DDH=DC(md)*DC(m)+DDH
            endif
          endif
        ENDIF
C
        DDA=DDH*DRKS(KS)
        IF(BKUTOO)DDB=DDH*DEKS(KS)
        IF(ABS(DDA)+ABS(DDB).LT.TTYNY)GO TO 57
c        write(6,*)ks,j,jd,ddh,drks(ks),dda
C
        LP=JORIG(II)
        IF(LP.GT.0)THEN
          K=IORIG(LP)
          DRK(K)=DRK(K)+DDA
c          write(6,*)lp,k,drk(k)
          IF(BKUTOO)THEN
            DEK(K)=DDB+DEK(K)
            IF(BFALL(K).NEQV.BFALLS(KS))THEN
              WRITE(6,*)'FLGL2: PROBLEM WITH ORBIT-ORBIT ALG.'
              WRITE(0,*)'FLGL2: PROBLEM WITH ORBIT-ORBIT ALG.'
              NF=-1
              GO TO 90
            ENDIF
          ENDIF
        ELSE
C
C     CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C     MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          LP=IRL+1
          IF(LP.GT.IAXRL)THEN                                  !GO TO 90
C
            IXXX=7*(IAXRL/5+1)
C
            WRITE(6,*)'*** FLGL2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
            WRITE(0,*)'*** FLGL2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGL2: REALLOCATION FAILS FOR QRL'
              NF=0
              GO TO 90
            ENDIF
C
            IXXX0=MAX(IAXRL,IXRLS)
            IXXX2=MAX(IAXRL,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGL2: REALLOCATION FAILS FOR IORIG'
              NF=0
              GO TO 90
            ENDIF
C
            IAXRL=IXXX
C
          ENDIF
C
          IRK=IRK+1
          IF(IRK.GT.IAXRK)THEN                                 !GO TO 90
C
            IXXX=7*(IAXRK/5+1)
C
            WRITE(6,*)'*** FLGL2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
            WRITE(0,*)'*** FLGL2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
            IF(BKUTOO)THEN
              CALL RE_ALLOC(DEK,IONE,IAXRK,IXXX,IERR)
              CALL RE_ALLOC(BFALL,IONE,IAXRK,IXXX,IERR)
            ENDIF
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGL2: REALLOCATION FAILS FOR DRK,DEK'
              NF=0
              GO TO 90
            ENDIF
C
            CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGL2: REALLOCATION FAILS FOR NRK'
              NF=0
              GO TO 90
            ENDIF
C
            IAXRK=IXXX
C
          ENDIF
C
          IRL=LP
          DO K=1,5
            QRL(K,LP)=QRLS(K,II)
          ENDDO
          JORIG(II)=LP
          IORIG(LP)=IRK
          NRK(IRK)=LP
          DRK(IRK)=DDA
          IF(BKUTOO)THEN
            DEK(IRK)=DDB
            BFALL(IRK)=BFALLS(KS)
          ENDIF
c          write(6,*)-lp,irk,drk(irk)
C
          IF(MXBORB.NE.0)THEN     !DUPLICATE CORE FOR EACH GROUP
            DO N=1,NGRP-1
              LP=LP+1             !ASSUME INITIAL ALLOC O.K. FOR CORE...
              DO K=1,4
                QRL(K,LP)=QRL(K,IRL)+N*MXBORB
              ENDDO
              QRL(5,LP)=QRL(5,IRL)
            ENDDO
            IRL=LP
          ENDIF
C
        ENDIF
C
  57  ENDDO
C
C     ELIMINATE COEFFICIENTS /DRK/.LT.TYNY AND ARGUMENTS QRL THAT HAVE
C     BEEN LISTED BEFORE IN THE REFERENCE LIST
C
c      IF(IRK.LT.IRK0)GO TO 90
      K=IRK0-1
      KP=0
C
      DO I=IRK0,IRK
C
       JD=INT(NRK(I))
       DD=ABS(DRK(I))
       IF(BKUTOO)DD=DD+ABS(DEK(I))
C
       IF(ABS(DD).LT.TYNY)THEN
         IF(JD.GT.IRL00)KP=KP+1
         GO TO 91
       ENDIF
C
       K=K+1
       DRK(K)=DRK(I)
       IF(BKUTOO)THEN
         DEK(K)=DEK(I)
         BFALL(K)=BFALL(I)
       ENDIF
C
       LP=JD
       IF(JD.GT.IRL00)THEN
         LP=JD-KP
         DO L=1,IRL00
           DO J=1,5
             IF(QRL(J,JD).NE.QRL(J,L))GO TO 95
           ENDDO
           KP=KP+1
           LP=L
           GO TO 92
  95     ENDDO
         DO J=1,5
           QRL(J,LP)=QRL(J,JD)
         ENDDO
       ENDIF
C
  92   NRK(K)=LP
C
  91  ENDDO
C
      IRL=IRL-KP
      IRK=K
C
  90  RETURN
C
      END SUBROUTINE FLGL2
C
C                             *******************
C
      SUBROUTINE FLGLX0(KK,QLMC,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.FLGLX0 CHECKS WHICH SLATER-STATES OF TWO CFS DIFFER BY ZERO OR ONE
C  PAIR, AND SETS POINTERS TO THEM FOR LATER USE BY FLGLX1.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2,KPTCFM,KINT,MPOINT,IXSTX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION QLMC(MAXEL,*),NEN(2,2)
C
      ALLOCATABLE :: BTEMP(:,:),KTEMP(:),LTEMP(:),MTEMP(:)
     X              ,JTEMP(:),NTEMP(:)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,JGAP(5)
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      NF1=NF+1
      NF2=NF*NF
C
      BEQCFS=KG.EQ.KF
C
C LOCAL (SMALL)
C
      ALLOCATE (BTEMP(NF,NF),KTEMP(NF2+1),LTEMP(NF2),MTEMP(NF))
      ALLOCATE (JTEMP(NF),NTEMP(NF))
C
      DO L=1,NF
        J=QCG(L,KG)
        JTEMP(L)=IEQ(J)
        K=QCG(L,KF)
        NTEMP(L)=IEQ(K)
      ENDDO
C
      K=0
      DO I=NF,1,-1
        DO L=NF,1,-1
          BTEMP(L,I)=JTEMP(L).EQ.NTEMP(I)
          IF(BTEMP(L,I))THEN
            K=K+1
            LTEMP(K)=L
            KTEMP(K)=I
          ENDIF
        ENDDO
      ENDDO
      KTEMP(K+1)=0
      KMX=K
C
      DEALLOCATE (JTEMP,NTEMP)
C
C INITIALIZE GROUP RANGES
C
      IXD02=QCL0/2
C
      MG2=IXD02
      MG1=-IXD02
C
      MG2P=IXD02
      MG1P=-IXD02
C
C LOOP OVER INITIAL ML GROUPS OF CONFIG KF
C
      DO MG=MG2,MG1,-1
C
        M1=MPOINT(MG+1,KF)+1                      !SLATER-STATE RANGE
        M2=MPOINT(MG,KF)
C
C LOOP OVER FINAL MLP GROUPS OF CONFIG KG
C
        IF(BEQCFS)MG1P=MG
C
        DO MGP=MG2P,MG1P,-1
C
          M1P=MPOINT(MGP+1,KG)+1                  !SLATER-STATE RANGE
          M2P=MPOINT(MGP,KG)
C
C LOOP OVER INITIAL SLATER STATES OF ML
C
          DO M=M1,M2
C
            J=M
C
C LOOP OVER FINAL SLATER STATES OF MLP
C
            IF(BEQCFS.AND.MG.EQ.MGP)M2P=M
C
            DO MP=M1P,M2P
C
              JD=MP
C
              NEN2=0
              IF(JD.EQ.J)GO TO 75             !SO BEQCFS=.TRUE.
C
              NK=1                            !FOR CONTINUUM PAIR
              DO K=1,2                        !INITIALIZE NK=1 CONT-CONT
                NEN(K,1)=NF1
              ENDDO
C
C DETERMINE THE SECOND PAIR OF INDIVIDUAL SETS IN WHICH SLATER
C STATE JD DIFFERS FROM J, AND THE PHASE FACTOR THAT RESULTS FROM
C THE REMAINING NF-2 SETS:
C
              NEN(1,2)=0
              MU=0
              DO I=1,NF
                MTEMP(I)=0
              ENDDO
C
C CASES WHERE ORBITAL NL'S MATCH
C
              I0=0
              DO K=1,KMX
                I=KTEMP(K)
                L=LTEMP(K)
                IF(I.NE.I0)THEN                   !NEED TO CHECK L STILL
                  IF(QLMC(L,JD).EQ.QLMC(I,J))THEN
                    MTEMP(I)=L
                    I0=I
                  ELSEIF(KTEMP(K+1).NE.I)THEN     !HAVE MOVED TO A NEW I
                    NK=NK+1
                    IF(NK.GT.2)GO TO 57
                    NEN(1,NK)=I                   !NEN(1,2)
                    MU=I+MU
                  ENDIF
                ENDIF
              ENDDO
C
C CASES WHERE ORBITALS DO NOT MATCH, SEE IF A DIFFERENCE
C HAS ALREADY BEEN FLAGGED, IF NOT, DO SO.
C
              DO I=NF,1,-1
                IF(MTEMP(I).EQ.0.AND.NEN(1,2).NE.I)THEN
                  DO L=NF,1,-1
                    IF(.NOT.BTEMP(L,I))THEN
                      NK=NK+1
                      IF(NK.GT.2)GO TO 57
                      NEN(1,NK)=I                  !NEN(1,2)
                      MU=I+MU
                      GO TO 580
                    ENDIF
                  ENDDO
                ENDIF
 580          ENDDO
C
              K=1                           !0->1 SINCE CONT-CONT IS ONE
              DO L=NF,1,-1
                DO I=NF,1,-1
                  IF(MTEMP(I).EQ.L)GO TO 60
                ENDDO
                K=K+1
                NEN(2,K)=L                         !NEN(2,2)
                MU=L+MU
                IF(K.EQ.NK)GO TO 74
  60          ENDDO
C
  74          IPHASE=(1-2*MOD(MU,ITWO))               !*IPHASE
C
C  NK.EQ.2 HERE
C
              IF(NK.NE.2)THEN
                WRITE(6,*)'FLGLX0: ERROR, SHOULD NOT BE HERE',KF,KG,J,JD
                STOP 'FLGLX0: ERROR, SHOULD NOT BE HERE'
              ENDIF
C
              NEN2=NF1*NEN(1,2)+NEN(2,2)
              NEN2=NEN2*IPHASE
C
C FLAG THIS PAIR AS INTERACTING (TBD DON'T BOTHER TO STORE J=JD CASE?)
C
  75          KINT=KINT+1
              IF(KINT.GT.IXSTX)THEN               !COULD PACK FURTHER...
c
                IXXX=7*(IXSTX/5)
C
                WRITE(6,*)'*** FLGLX0: increasing MXSTX from ',IXSTX
     X                    ,' TO: ',IXXX
                WRITE(0,*)'*** FLGLX0: increasing MXSTX from ',IXSTX
     X                    ,' TO: ',IXXX
C
                CALL RE_ALLOC(KINTI,IONE,IXSTX,IXXX,IERR)
                CALL RE_ALLOC(KINTF,IONE,IXSTX,IXXX,IERR)
                CALL RE_ALLOC(KEN2,IONE,IXSTX,IXXX,IERR)
C
                IF(IERR.NE.0)THEN
                  WRITE(0,*)'FLGLX0: RE-ALLOCATION FAILS FOR KINTI etc'
                  NF=0
                  GO TO 1
                ENDIF
C
                IXSTX=IXXX
C
              ENDIF
C
              KINTI(KINT)=J
              KINTF(KINT)=JD
              KEN2(KINT)=NEN2
C              WRITE(6,*)KF,J,'  **  ',KG,JD
C
  57          CONTINUE
C
            ENDDO           !END FINAL ML SLATER STATE LOOP
C
          ENDDO           !END INITIAL ML SLATER STATE LOOP
C
          KPTCFM(MGP,MG,KK)=KINT
          IF(BEQCFS)KPTCFM(MG,MGP,KK)=KINT
C
        ENDDO           !END FINAL MLP GROUP LOOP FOR KG
C
      ENDDO           !END INITIAL ML GROUP LOOP FOR KF
C
    1 DEALLOCATE (BTEMP,KTEMP,LTEMP,MTEMP)
C
      RETURN
C
      END SUBROUTINE FLGLX0
C
C                             *******************
C
      SUBROUTINE FLGLX1(QLMC,NAM,DFS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.FLGLX1 CALCULATES THE SLATER-STATE ELECTROSTATIC AND, OPTIONALLY,
C  ORBIT-ORBIT INTERACTION BETWEEN PAIRS OF ELECTRONS, ONE PAIR BEING
C  CONTINUUM.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL ,  ONLY: IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.D-6)
C
      INTEGER(SP) Q1(2,2),Q2(2,2),Q3(2,2),Q4(2,2)

      DIMENSION  QLMC(MAXEL,*),NAM(*),DFS(*)
     X          ,NEN(2,2),NEJ(2),MRL(5)                  !,NEK(2)
C                     !,KF,KG         !NEK(2) FOLLOWS FROM NEK(1)
      COMMON /BASIC/NF,NEK(2),JA,JB,JAP,JBP,ND1,NDP1,LLCH(2),MAXLX
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /CMDVC/DVC12O,ICLRR,BLX,BEQUALM
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /XSSADR/IRKS0,IRLS0
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MTS,MTSP,MTL,MTLP,MTP,LCONDWJ,MTJ
     X              ,LVMIN,LVMAX
      COMMON /NRBFAN/BFANO
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
c      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
c      MVC(M,MA)=((M+2)*M/2+MA)/2+1 !SEE INTRNL FUNCTN ABVE END FLGLX1
C
      POINTER :: KF,KG,MJ11,MJ12,ML
      TARGET :: NEK,Q2,MRL
C
      KF=>NEK(1)
      KG=>NEK(2)
      MJ11=>Q2(1,1)
      MJ12=>Q2(1,2)
      ML=>MRL(5)
C
c      EQUIVALENCE (KF,NEK(1)),(KG,NEK(2))
c     X           ,(MJ11,Q2(1,1)),(MJ12,Q2(1,2)),(ML,MRL(5))
C
c      if(kg.ne.nek(2))stop 'flglx1 error'
C
      MPOSC=MXORB+(LCONDWJ-1)/2-(LCONDW-1)/2             !BUFFER SPACE
      MXORBC=MPOSC+LCONDW
      BPLANT=MXORBC.LT.67
      MPOSC=MPOSC+(LCONDW+1)/2
C
      BSKP=MXLL.EQ.-1
      BKUTOO=KUTOOX.NE.0
C
      IRLS1=IRLS0+1
      IF(ICLRR.LT.0)GO TO 400
C
      brev=kf.lt.kg
      BEQCFS=KG.EQ.KF
      IF(.NOT.BEQCFS.AND.MAXLAM.LT.0)GO TO 999    !SINGLE CONFIG
      BEQGRP=ND1.EQ.NDP1                          !WITHIN A GROUP
C
      NF1=NF+1
C
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      IDIR=0
      IF(QSI(ND1).NE.QSI(NDP1))IDIR=1             !NO DIRECT
ct      idir=1
C
      IXCH=0
      IF(MTL.GT.2*MAXLX)IXCH=1                    !NO EXCHANGE
ct      ixch=1
C
      IF(IDIR+IXCH.EQ.2)GO TO 999                 !NULL
C
      DDA=DONE
      DDB=DZERO
      DVC12=DVC12O
C
C BEGIN MAIN SLATER-STATE INTERACTION LOOP (57)
C
      DO 57 J1=JA,JB
C
      kk=nam(j1)
      if(brev.or.kk.lt.0)then
        kk=abs(kk)
        i1=2
        i2=1
      else
        i1=1
        i2=2
      endif
      nej(i1)=kinti(kk)
      nej(i2)=kintf(kk)
      j=nej(1)
      jd=nej(2)
c
c      write(6,*)kf,j,'      ',kg,jd
c
      IF(BEQUALM)THEN
        IF(JD.GT.J)GO TO 57
        IF(JD.LT.J)THEN
          DVC12=2*DVC12O
        ELSE
          DVC12=DVC12O
        ENDIF
      ENDIF
C
      DO I=IRLS1,IRLS
        IORIG(I)=0
        JORIG(I)=0
      ENDDO
C
      DDH=DONE
      BEQTMS=.FALSE.
C
      NK=1                                  !0->1 SINCE CONT-CONT IS ONE
      DO K=1,2                              !INITIALIZE NK=1 CONT-CONT
        NEN(K,1)=NF1
      ENDDO
C
      NU=0
      IF(JD.EQ.J)GO TO 68                   !SO BEQCFS=.TRUE.
C
C  NK.EQ.2 HERE
C
      nk=2
      nen2=ken2(kk)
c                              if(nen2.eq.0)stop 'nen2 error'
      if(nen2.lt.0)then
        ddh=-ddh
        nen2=-nen2
      endif
      nen(i1,2)=nen2/nf1
c                     if(nen(i1,2).eq.0)stop 'nen(1,2) error'
      nen(i2,2)=nen2-nen(i1,2)*nf1
c                     if(nen(i2,2).eq.0)stop 'nen(2,2) error'
c
      go to 72
C
C NOW NK=1 (CASE J.EQ.JD ONLY NOW)
C
  68  NU=NU+1
      IF(NU.GT.NF)GO TO 67
      NEN(1,2)=NU
C
  72  DO L=1,2  !=1 FOR SLATER STATES J (OF CONFIG KF),=2 FOR JD (OF KG)
        I=L
        DO K=1,2 !=1 FOR FOR FIRST PAIR OF ELECTRON STATES,=2 FOR SECOND
          IF(NK.LT.K)I=1
          KP=NEN(I,K)
          IF(KP.LE.0)THEN
            KP=KP+NW
            MU=NNL(KP,2)        !PACKED
            LP=NNL(KP,1)
            Q1(L,K)=LP
            Q2(L,K)=QL(LP)
C            Q3(L,K)=NNL(KP,2)  !UNPACKED
C            Q4(L,K)=NNL(KP,3)  !UNPACKED
          ELSE
            LP=NEJ(I)
            MU=QLMC(KP,LP)
            LP=NEK(I)
            LP=QCG(KP,LP)
            IF(LP.GT.MXORB)THEN            !CONTINUUM
              Q2(L,K)=LLCH(L)
              Q1(L,K)=(LLCH(L)-MTL)/2+MPOSC
            ELSE
              Q2(L,K)=QL(LP)
              Q1(L,K)=LP
            ENDIF
          ENDIF                 !PACKED
            ML=Q2(L,K)
            ML=((ML+MU)/2)*2-ML
            Q3(L,K)=ML
            Q4(L,K)=(MU-ML)*2-1
C          ENDIF                !UNPACKED
        ENDDO
      ENDDO
C
C DIRECT
C
      KP=0
C
C EQU  MJ11=Q2(1,1)
C EQU  MJ12=Q2(1,2)
      MM11=-Q3(1,1)
      MM12=-Q3(1,2)
      MV11=MVC(MJ11,MM11)
      MV12=MVC(MJ12,MM12)
C
      IF(IDIR.EQ.1)GO TO 76                                   !NO DIRECT
C
      MXLAM=ABS(MXLAMX)                         !RESTRICT DIRECT LAMBDA
C
C EXCHANGE RE-ENTRY POINT
C
  77  IF(.NOT.BSKP.AND.Q4(2,1+KP).NE.Q4(1,1))GO TO 76
C
      MJ21=Q2(2,KP+1)
      MJ22=Q2(2,2-KP)
C
C MU=MAX LAM
      MU=MIN(MJ11+MJ21,MJ12+MJ22,ITWO*MXLAM)
C
C ML=MIN LAM
      ML=MAX(ABS(MJ11-MJ21),ABS(MJ12-MJ22))
C
C LIMIT NUMBER
      MU=MIN(MU,ML+IFOUR*NMULT)
C
      IF(ML.GT.MU)GO TO 76
C
      IF(.NOT.BSKP)THEN
        MM21=Q3(2,KP+1)
        MMD1=MM21+MM11
        MM22=Q3(2,2-KP)
        MMD2=MM12+MM22
C
C INCREASE MIN LAM BECAUSE OF ML1-ML2
        K=MAX(ABS(MMD1),ABS(MMD2))
C
C ORBIT-ORBIT LAM+1, SO "LESS RESTRICTIVE"
        IF(BKUTOO)K=K-2
        IF(K.GT.ML)ML=((K+2-ML)/4)*4+ML
        IF(ML.GT.MU)GO TO 76
C
        DSJ=SQRT(REAL((MJ11+1)*(MJ12+1)*(MJ21+1)*(MJ22+1),WP))*
     X        REAL((1-MOD(ABS(MM22-MM11),IFOUR))*(1-2*KP),WP)*DDH*DVC12
C
        MV21=MVC(MJ21,MM21)
        MV22=MVC(MJ22,MM22)
      ENDIF
C
C REORDER A,B,C,D IN AS MUCH FALLING ORDER AS SYMMETRY ALLOWS FOR
C
      L=0
      K=0
      IF(Q1(2,2-KP).GT.Q1(1,2))K=2
      I=0
      IF(Q1(2,1+KP).GT.Q1(1,1))I=2
      BFALL=BKUTOO.AND.I+K.EQ.2
C
  62  MRL(1+I+L)=Q1(1,1)
      MRL(3-I+L)=Q1(2,1+KP)
      MRL(2+K-L)=Q1(1,2)
      MRL(4-K-L)=Q1(2,2-KP)
      L=1
      IF(MRL(2).GT.MRL(1))GO TO 62
      if(mrl(2).eq.mrl(1).and.mrl(4).gt.mrl(3))go to 62!cont in pos nk=1
C
C LAMBDA RE-ENTRY POINT
C
  78  IF(.NOT.BSKP)THEN
        LP=ML/4+1
        IF(BVC.OR.(MJ11.LE.MXLL.AND.MJ21.LE.MXLL))THEN
          DDA=VCA(MV11,MV21,LP)
          IF(BKUTOO)DDB=VCB(MV11,MV21,LP)
        ELSE
          DVC=VCC(MJ11,MJ21,ML,IZERO,IZERO,IZERO,DFS)
          DDA=DVC*VCC(MJ11,MJ21,ML,MM11,MM21,MMD1,DFS)/(ML+1)
          IF(BKUTOO)DDB=DVC*VCC(MJ11,MJ21,ML+2,MM11,MM21,MMD1,DFS)
        ENDIF
        IF(BVC.OR.(MJ22.LE.MXLL.AND.MJ12.LE.MXLL))THEN
          DDA=DDA*VCA(MV22,MV12,LP)
          IF(BKUTOO)DDB=DDB*VCB(MV22,MV12,LP)
        ELSE
          DVC=VCC(MJ22,MJ12,ML,IZERO,IZERO,IZERO,DFS)
          DDA=DDA*DVC*VCC(MJ22,MJ12,ML,MM22,MM12,MMD2,DFS)/(ML+1)
          IF(BKUTOO)DDB=DDB*DVC
     X                     *VCC(MJ22,MJ12,ML+2,MM22,MM12,MMD2,DFS)
        ENDIF
C
        IF(ABS(DDA)+ABS(DDB).EQ.DZERO)GO TO 10
C
        IF(BFANO)THEN
          IFANO=QL(Q1(2,1+KP))-QL(Q1(1,1))
          IF(MRL(5).GE.0)IFANO=IFANO+QL(Q1(2,2-KP))-QL(Q1(1,2))
          IFANO=IFANO/4
          IFANO=1-2*mod(abs(IFANO),ITWO)                !(-1)**IFANO
          DDA=DDA*IFANO
          IF(BKUTOO)DDB=DDB*IFANO
        ENDIF
C
        DDA=DDA*DSJ
        IF(BKUTOO)DDB=DDB*DSJ
      ENDIF
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
      IF(BPLANT)IPLANT=MRL(5)/2+
     X((((MRL(4)*MXORBC+MRL(3))*MXORBC+MRL(2))*MXORBC)+MRL(1))*100
C
      DO I=IRLS1,IRLS
        IF(.NOT.BPLANT)THEN
          DO K=5,1,-1
            IF(MRL(K).NE.QRLS(K,I))GO TO 63
          ENDDO
        ELSE
          IF(IPLANT.NE.JPLANT(I))GO TO 63
        ENDIF
        IF(BEQTMS)THEN
          LP=-I
          K=JORIG(I)
        ELSE
          LP=I
          K=IORIG(I)
        ENDIF
        IF(K.GT.0)THEN
          DRKS(K)=DDA+DRKS(K)
          IF(BKUTOO)THEN
            DEKS(K)=DDB+DEKS(K)
            IF(BFALLS(K).NEQV.BFALL)THEN
              WRITE(6,*)'FLGL1: PROBLEM WITH ORBIT-ORBIT ALG.'
              WRITE(0,*)'FLGL1: PROBLEM WITH ORBIT-ORBIT ALG.'
              NF=-1
              GO TO 999
            ENDIF
          ENDIF
          GO TO 84
        ENDIF
        GO TO 82
  63  ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
      LP=IRLS+1
      IF(LP.GT.IXRLS)THEN                                     !GO TO 999
C
        IXXX=7*(IXRLS/5+1)
C
        WRITE(6,*)'*** FLGLX1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** FLGLX1: increasing MXRLS from ',IXRLS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRLS,IONE,IFIVE,IONE,IXRLS,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX1: REALLOCATION FAILS FOR QRLS'
          NF=0
          GO TO 999
        ENDIF
C
        IXXX0=MAX(IXRLS,IAXRL)
        IXXX2=MAX(IXXX,IAXRL)
        IF(IXXX2.GT.IXXX0)
     X  CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
        CALL RE_ALLOC(JORIG,IONE,IXRLS,IXXX,IERR)
        CALL RE_ALLOC(JPLANT,IONE,IXRLS,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX1: REALLOCATION FAILS FOR IORIG,JORIG,JPLANT'
          NF=0
          GO TO 999
        ENDIF
C
        IXRLS=IXXX
C
      ENDIF
C
      IRLS=LP
      DO K=1,5
        QRLS(K,LP)=MRL(K)
      ENDDO
      IF(BPLANT)JPLANT(LP)=IPLANT
C
      IF(BEQTMS)LP=-LP
C
  82  IRKS=IRKS+1
      IF(IRKS.GT.IXRKS)THEN                                   !GO TO 999
C
        IXXX=7*(IXRKS/5+1)
C
        WRITE(6,*)'*** FLGLX1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
        WRITE(0,*)'*** FLGLX1: increasing MXRKS from ',IXRKS,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRKS,IONE,IXRKS,IXXX,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEKS,IONE,IXRKS,IXXX,IERR)
          CALL RE_ALLOC(BFALLS,IONE,IXRKS,IXXX,IERR)
        ENDIF
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX1: REALLOCATION FAILS FOR DRKS,DEKS'
          NF=0
          GO TO 999
        ENDIF
C
        CALL RE_ALLOC(NRKS,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJ,IONE,IXRKS,IXXX,IERR)
        CALL RE_ALLOC(NSTJD,IONE,IXRKS,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX1: REALLOCATION FAILS FOR NRKS,NSTJ'
          NF=0
          GO TO 999
        ENDIF
C
        IXRKS=IXXX
C
      ENDIF
C
      DRKS(IRKS)=DDA
      IF(BKUTOO)THEN
        DEKS(IRKS)=DDB
        BFALLS(IRKS)=BFALL
      ENDIF
C
      IF(LP.GT.0)THEN
        IORIG(LP)=IRKS
        JORIG(LP)=0
      ELSE
        JORIG(-LP)=IRKS
      ENDIF
C
      NRKS(IRKS)=LP
      NSTJ(IRKS)=J
      NSTJD(IRKS)=JD
C
  84  CONTINUE
C
c      write(6,998)  j,jd,lp,kp, mrl,dda,irks,kf,kg
c 998  format(4i5,4x,5i3,f12.5,i4,2i6)
C
  10  ML=ML+4
      IF(ML.LE.MU)GO TO 78                   !NEXT LAMBDA
C
  76  KP=KP+1+IXCH
      MXLAM=MXLAMX                           !RESTRICT EXCHANGE LAMBDA
      IF(KP.EQ.1)GO TO 77                    !EXCHANGE
C
      IF(NK-1.EQ.0)GO TO 68
C
  67  IF(J.EQ.JD.AND..NOT.BEQTMS)THEN        !SO BEQCFS=.TRUE.
        BEQTMS=.TRUE.
        IF(LLCH(1).EQ.LLCH(2).AND.BEQGRP)THEN
          NU=-NW
        ELSE
          NU=0
        ENDIF
        GO TO 68
      ENDIF
C
C
  57  ENDDO               !END SLATER-STATE INTERACTION LOOP
C
C
C IF THE COEFFICIENTS OF THE MATRIX ELEMENT HAVE NOT BEEN COMPLETELY
C CALCULATED, RETURN - WILL CALL AGAIN, FOR DIFFERENT (MS,ML).
C
      IF(BLX)RETURN
C
C
C ELIMINATE COEFFICIENTS /DRKS/.LT.TYNY AND ARGUMENTS QRLS THAT HAVE
C BEEN LISTED BEFORE IN THE REFERENCE LIST
C
 400  ICLRR=0
      IF(IRKS.LT.IRKS0)GO TO 999
C
      K=IRKS0-1
      KP=0
      DO I=IRLS1,IRLS
        IORIG(I)=0
      ENDDO
C
      DO 91 I=IRKS0,IRKS
C
        JD0=NRKS(I)
        JD=ABS(JD0)
        DD=ABS(DRKS(I))
        IF(BKUTOO)DD=DD+ABS(DEKS(I))
        IF(ABS(DD).LT.TYNY)THEN
          IF(IORIG(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QRLS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
C
        K=K+1
        DRKS(K)=DRKS(I)
        IF(BKUTOO)THEN
          DEKS(K)=DEKS(I)
          BFALLS(K)=BFALLS(I)
        ENDIF
        NSTJ(K)=NSTJ(I)
        NSTJD(K)=NSTJD(I)
C
  94    IF(JD.LE.IRLS0)THEN
          IF(IRLS.LE.IXRLS)THEN   !SHOULD NOT GET HERE
            WRITE(6,*)'FLGLX1: INFORM NRB OF STOP HERE'
            WRITE(0,*)'FLGLX1: INFORM NRB OF STOP HERE'
            NF=-1
            GO TO 999
          ELSE          !GRACEFUL EXIT TO DIMENSION STOP
            LP=JD
            GO TO 92
          ENDIF
        ENDIF
C
        IF(IORIG(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,IRLS0
            DO J=1,5
              IF(QRLS(J,JD).NE.QRLS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG(JD)
          GO TO 92
        ENDIF
C
        IORIG(JD)=LP
        DO J=1,5
          QRLS(J,LP)=QRLS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          NRKS(K)=LP
          IF(JD0.LT.0)NRKS(K)=-NRKS(K)
        ENDIF
C
  91  ENDDO
C
      IRLS=IRLS-KP
      IRKS=K
C
C
 999  RETURN
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(M,MA)
C
      MVC=((M+2)*M/2+MA)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE FLGLX1
C
C                             *******************
C
      SUBROUTINE FLGLX2(iam,ibm,KK)
C
C-----------------------------------------------------------------------
C
C  SR.FLGLX2 CALCULATES THE TERM-RESOLVED ELECTROSTATIC AND, OPTIONALLY,
C  ORBIT-ORBIT INTERACTION BETWEEN PAIRS OF ELECTRONS, ONE PAIR BEING
C  CONTINUUM.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IRL,IAXRK,IAXRL
      USE COMMON_DXRLS,  ONLY: DRKS,DEKS,QRLS,NRKS,BFALLS,IRLS,IRKS
     X                        ,IXRKS,IXRLS
      USE COMMON_NSTS,   ONLY: NADS,NSTJ,NSTJD,IORIG,JORIG,JPLANT
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-8)
      PARAMETER (TTYNY=TYNY/1.D3)
C
      DIMENSION iam(*),ibm(*)
C
      COMMON /BASIC/NF,KF,KG,ND1,ND2,NDP1,NDP2,NGAP(5)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MTS,MTSP,MTL,MTLP,MTP,LCONDWJ,MTJ
     X              ,LVMIN,LVMAX
C
      BKUTOO=KUTOOX.NE.0
      DDB=DZERO
C
      IRK0=IRK+1
      IRL00=IRL
C
      DO J=1,IRLS
        JORIG(J)=0
      ENDDO
C
      BEQTMS=NDP1.EQ.ND1
C
C
C BEGIN MAIN LOOP 57 OVER SLATER INTERACTIONS
C
      K0=NADS(KK-1)+1
C
      DO 57 KS=K0,NADS(KK)
C
        J=NSTJ(KS)
        m=iam(j)
        if(m.eq.0)go to 57
c
        JD=NSTJD(KS)
C
        II=NRKS(KS)
        IF(J.EQ.JD)THEN
          IF(BEQTMS.AND.II.GT.0)GO TO 57
          IF(.NOT.BEQTMS.AND.II.LT.0)GO TO 57
          II=ABS(II)
        ENDIF
C
        IF(BFAST)THEN
          DDH=DC(m)*DC(JD+NDP2)                       !DC(J+ND2)
        ELSE
          md=ibm(jd)
          if(md.eq.0)go to 57
          DDH=DC(m)*DC(md)
        ENDIF
C
        DDA=DDH*DRKS(KS)
c        write(6,*)ks,j,jd,ddh,drks(ks),dda
        IF(BKUTOO)DDB=DDH*DEKS(KS)
        IF(ABS(DDA)+ABS(DDB).LT.TTYNY)GO TO 57
C
        LP=JORIG(II)
        IF(LP.GT.0)THEN
          K=IORIG(LP)
          DRK(K)=DRK(K)+DDA
c          write(6,*)lp,k,drk(k)
          IF(BKUTOO)THEN
            DEK(K)=DDB+DEK(K)
            IF(BFALL(K).NEQV.BFALLS(KS))THEN
              WRITE(6,*)'FLGL2: PROBLEM WITH ORBIT-ORBIT ALG.'
              WRITE(0,*)'FLGL2: PROBLEM WITH ORBIT-ORBIT ALG.'
              NF=-1
              GO TO 90
            ENDIF
          ENDIF
        ELSE
C
C CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          LP=IRL+1
          IF(LP.GT.IAXRL)THEN                                  !GO TO 90
C
            IXXX=7*(IAXRL/5+1)
C
            WRITE(6,*)'*** FLGLX2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
            WRITE(0,*)'*** FLGLX2: increasing MAXRL from ',IAXRL,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRL,IONE,IFIVE,IONE,IAXRL,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGLX2: REALLOCATION FAILS FOR QRL'
              NF=0
              GO TO 90
            ENDIF
C
            IXXX0=MAX(IAXRL,IXRLS)
            IXXX2=MAX(IAXRL,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGLX2: REALLOCATION FAILS FOR IORIG'
              NF=0
              GO TO 90
            ENDIF
C
            IAXRL=IXXX
C
          ENDIF
C
          IRK=IRK+1
          IF(IRK.GT.IAXRK)THEN                                 !GO TO 90
C
            IXXX=7*(IAXRK/5+1)
C
            WRITE(6,*)'*** FLGLX2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
            WRITE(0,*)'*** FLGLX2: increasing MAXRK from ',IAXRK,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
            IF(BKUTOO)THEN
              CALL RE_ALLOC(DEK,IONE,IAXRK,IXXX,IERR)
              CALL RE_ALLOC(BFALL,IONE,IAXRK,IXXX,IERR)
            ENDIF
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGLX2: REALLOCATION FAILS FOR DRK,DEK'
              NF=0
              GO TO 90
            ENDIF
C
            CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'FLGLX2: REALLOCATION FAILS FOR NRK'
              NF=0
              GO TO 90
            ENDIF
C
            IAXRK=IXXX
C
          ENDIF
C
          IRL=LP
          DO K=1,5
            QRL(K,LP)=QRLS(K,II)
          ENDDO
          if(qrl(2,lp).gt.mxorb)qrl(5,lp)=qrl(5,lp)-mtl        !exchange
          JORIG(II)=LP
          IORIG(LP)=IRK
          NRK(IRK)=LP
          DRK(IRK)=DDA
          IF(BKUTOO)THEN
            DEK(IRK)=DDB
            BFALL(IRK)=BFALLS(KS)
          ENDIF
c          write(6,*)-lp,irk,drk(irk)
C
        ENDIF
C
  57  ENDDO
C
C ELIMINATE COEFFICIENTS /DRK/.LT.TYNY AND ARGUMENTS QRL THAT HAVE
C BEEN LISTED BEFORE IN THE REFERENCE LIST
C
      K=IRK0-1
      KP=0
C
      DO I=IRK0,IRK
C
        JD=INT(NRK(I))
        DD=ABS(DRK(I))
        IF(BKUTOO)DD=DD+ABS(DEK(I))
C
        IF(ABS(DD).LT.TYNY)THEN
          IF(JD.GT.IRL00)KP=KP+1
          GO TO 91
        ENDIF
C
        K=K+1
        DRK(K)=DRK(I)
        IF(BKUTOO)THEN
          DEK(K)=DEK(I)
          BFALL(K)=BFALL(I)
        ENDIF
C
        LP=JD
        IF(JD.GT.IRL00)THEN
          LP=JD-KP
          DO L=1,IRL00
            DO J=1,5
              IF(QRL(J,JD).NE.QRL(J,L))GO TO 95
            ENDDO
            KP=KP+1
            LP=L
            GO TO 92
  95      ENDDO
          DO J=1,5
            QRL(J,LP)=QRL(J,JD)
          ENDDO
        ENDIF
C
  92    NRK(K)=LP
C
  91  ENDDO
C
      IRL=IRL-KP
      IRK=K
C
  90  RETURN
C
      END SUBROUTINE FLGLX2
C
C                             *******************
C
      SUBROUTINE FLGLX3(IFLAG1,IFLAG2,LA1,LA2,L1,L2,MTL,MTLO,NCORX,DFS)
C
C-----------------------------------------------------------------------
C
C  SR.FLGLX3 CALCULATES THE TERM-RESOLVED ELECTROSTATIC AND, OPTIONALLY,
C  ORBIT-ORBIT INTERACTION USING SYMMTERY RELATION FOR A PRECEEDING L.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DXRL,   ONLY: DRK,QRL,NRK,IAXRK,NAD
      USE COMMON_NRBNF1, ONLY: DEK,BFALL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.D-6)
C
      DIMENSION DFS(MXDFS)
C
      ALLOCATABLE :: DRKO(:),DEKO(:)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
C
      DATA K1/0/,K2/0/,K1P/0/,K2P/0/,MTLN/0/,IXD16/100/
C
      SAVE K00,DRKO,DEKO
C
      BLAST=NCORX.LT.0
      IF(BLAST)NCORX=-NCORX
C
      BKUTOO=KUTOOX.NE.0
C
      IF(.NOT.ALLOCATED(DRKO))THEN
        IXD16=MAX(MAXRK/10,IAXRK/10,IXD16)
        ALLOCATE (DRKO(IXD16),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX3: ALLOCATION FAILS FOR DRKO'
          NCORX=0
          NF=0
          RETURN
        ENDIF
        IF(BKUTOO)THEN
          ALLOCATE (DEKO(IXD16),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'FLGLX3: ALLOCATION FAILS FOR DEKO'
            NCORX=0                                             !TRACKED
            NF=0                                            !NOT TRACKED
            RETURN
          ENDIF
        ENDIF
      ENDIF
C
      LD=MTL-MTLO
      if(mod(ld,ifour).ne.0)stop 'sr.flglx3: phase error!' !shouldn't be
C
C SET OLD FLGL
C
      IF(IFLAG1.EQ.1.OR.IFLAG2.EQ.1)THEN
        IF(IFLAG1.EQ.1)THEN
          K1=MAX(K1,K2P)
          K0=MAX(K1,K1P)
        ENDIF
        IF(IFLAG2.EQ.1)THEN
          K2=MAX(K2,K1P)
          K0=MAX(K2,K2P)
        ENDIF
C
        L1O=L1-LD
        L2O=L2-LD
        DDO=SQRT(REAL((L1O+1)*(L2O+1),WP))
C
        IXXX=K0+NAD(NCORX)-NAD(NCORX-1)
C
        IF(IXXX.GT.IXD16)THEN                                  !GO TO 99
C
          IXXX=7*(IXXX/5+1)
C
          WRITE(6,*)'*** FLGLX3: increasing MXD16 from ',IXD16,' to: '
     X              ,IXXX
          WRITE(0,*)'*** FLGLX3: increasing MXD16 from ',IXD16,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC(DRKO,IONE,IXD16,IXXX,IERR)
          IF(BKUTOO)THEN
            CALL RE_ALLOC(DEKO,IONE,IXD16,IXXX,IERR)
          ENDIF
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'FLGLX3: REALLOCATION FAILS FOR DRKO,DEKO'
            NF=0
            GO TO 99
          ENDIF
C
          IXD16=IXXX
C
        ENDIF
C
        DO K=NAD(NCORX-1)+1,NAD(NCORX)
C
          K0=K0+1
c          IF(K0.LE.MXD16)THEN
            J=INT(NRK(K))
            MLAM=QRL(5,J)
C
c            write(66,*)'k=',k
c            write(66,*)l1o,l2o,mlam
            D3O=VCC(L1O,L2O,MLAM,IZERO,IZERO,IZERO,DFS)
c            write(66,*)d3o
c            call flush(66)
C
            IF(ABS(DRK(K)).GT.TYNY)THEN             !FOR CASE BKUTOO=.T.
c              write(66,*)j,la1,l1o,mtlo,l2o,la2,mlam
              D6O=SJS(LA1,L1O,MTLO,L2O,LA2,MLAM,DFS)
c              write(66,*)d6o
c              call flush(66)
              if(d3o*d6o.eq.dzero)then
                if(abs(drk(k)).gt.10*tyny)then
                  write(6,*)'sr.flglx3: 3j-/6j-symbol zero'
                  write(6,*)'3j=',d3o
                  write(6,*)j,la1,l1o,mtlo,l2o,la2,mlam
                  write(6,*)'6j=',d6o
                  write(6,*)'k=',k,'drk(k)=',drk(k)
c                  call flush(6)
                  stop 'sr.flglx3: 3j-/6j-symbol zero'
                else
                  drk(k)=dzero
                  d3o=done
                  d6o=done
                endif
              endif
              DRKO(K0)=DRK(K)/(DDO*D3O*D6O)
            ELSE
              DRKO(K0)=DZERO
            ENDIF
C
            IF(BKUTOO)THEN
              IF(ABS(DEK(K)).GT.TYNY)THEN
c              write(66,*)j,la1,l1o,mtlo,l2o,la2,mlam+2
                D6O=SJS(LA1,L1O,MTLO,L2O,LA2,MLAM+2,DFS)    !LAM+1
c                write(66,*)d6o
c                call flush(66)
                if(d3o*d6o.eq.dzero)then
                  if(abs(dek(k)).gt.10*tyny)then
                    write(6,*)'sr.flglx3: 3j-/6j-symbol zero'
                    stop 'sr.flglx3: 3j-/6j-symbol zero'
                  else
                    dek(k)=dzero
                    d3o=done
                    d6o=done
                  endif
                endif
                DEKO(K0)=DEK(K)/(DDO*D3O*D6O)
              ELSE
                DEKO(K0)=DZERO
              ENDIF
            ENDIF
c          ENDIF
C
        ENDDO
C
        IF(IFLAG1.EQ.1)K1P=K0
        IF(IFLAG2.EQ.1)K2P=K0
C
        IF(K0.GT.IXD16)THEN
          WRITE(6,*)'*** SR.FLGLX3: MAY NEED TO ADJUST MXD16 SETTING'
          NCORX=0
          BLAST=.TRUE.
          GO TO 99
        ENDIF
C
      ENDIF
C
C GET NEW FLGL FROM OLD
C
      IF(MTL.GT.MTLN)THEN
        MTLN=MTL
        IF(IFLAG1.GT.0)K00=K1
        IF(IFLAG2.GT.0)K00=K2
      ENDIF
C
      IRK0=IRK+1
      IXXX=IRK+NAD(NCORX)-NAD(NCORX-1)                         !IRK=
C
      IF(IXXX.GT.IAXRK)THEN                                    !GO TO 99
C
        IXXX=7*(IXXX/5+1)
C
        WRITE(6,*)'*** FLGLX3: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
        WRITE(0,*)'*** FLGLX3: increasing MAXRK from ',IAXRK,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRK,IONE,IAXRK,IXXX,IERR)
        IF(BKUTOO)THEN
          CALL RE_ALLOC(DEK,IONE,IAXRK,IXXX,IERR)
          CALL RE_ALLOC(BFALL,IONE,IAXRK,IXXX,IERR)
        ENDIF
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX3: REALLOCATION FAILS FOR DRK,DEK'
          NF=0
          GO TO 99
        ENDIF
C
        CALL RE_ALLOC(NRK,IONE,IAXRK,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX3: REALLOCATION FAILS FOR NRK'
          NF=0
          GO TO 99
        ENDIF
C
        IAXRK=IXXX
C
      ENDIF
C
C      IRK=IRK0-1
C
      DD=SQRT(REAL((L1+1)*(L2+1),WP))
C
      DO K=NAD(NCORX-1)+1,NAD(NCORX)
C
        IRK=IRK+1
C
        NRK(IRK)=NRK(K)
        J=INT(NRK(K))
        MLAM=QRL(5,J)
        IF(MLAM.LT.0)STOP 'SR.FLGLX3: LAMBDA ERROR!'
C
c        write(66,*)'k=',k
c        write(66,*)j,la1,l1,mtl,l2,la2,mlam
        D6=SJS(LA1,L1,MTL,L2,LA2,MLAM,DFS)
c        write(66,*)d6
c        write(66,*)l1,l2,mlam
        D3=VCC(L1,L2,MLAM,IZERO,IZERO,IZERO,DFS)
c        write(66,*)d3
C
        K00=K00+1
C
        IF(ABS(DRKO(K00)).GT.TYNY)THEN
          DDA=DRKO(K00)                            !DRK(K)/(DDO*D3O*D6O)
          DRK(IRK)=DD*DDA*D3*D6
        ELSE
          DRK(IRK)=DZERO
        ENDIF
c
c        write(66,*)k,irk,j,drk(irk)
C
        IF(BKUTOO)THEN
          IF(ABS(DEKO(K00)).GT.TYNY)THEN
            D6=SJS(LA1,L1,MTL,L2,LA2,MLAM+2,DFS)       !RANK LAM+1
C            write(66,*)d6
            DDB=DEKO(K00)                          !DEK(K)/(DDO*D3O*D6O)
            DEK(IRK)=DD*DDB*D3*D6
            BFALL(IRK)=BFALL(K)
          ELSE
            DEK(IRK)=DZERO
          ENDIF
        ENDIF
C
      ENDDO
C
  99  IF(BLAST)THEN
        DEALLOCATE (DRKO,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'FLGLX3: DE-ALLOCATION FAILS FOR DRKO'
          NCORX=0
          NF=0
          RETURN
        ENDIF
        IF(BKUTOO)THEN
          DEALLOCATE (DEKO,STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'FLGLX3: DE-ALLOCATION FAILS FOR DEKO'
            NCORX=0                                             !TRACKED
            NF=0                                            !NOT TRACKED
            RETURN
          ENDIF
        ENDIF
      ENDIF
C
      RETURN
C
      END SUBROUTINE FLGLX3
C
C***********************************************************************
C
      FUNCTION FMON1(EK1,EK2,L)
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,XP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(XP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(XP) QZERO,QONE                      !*8 ->*16 IF CANCELLATION
      REAL(WP) EK1,EK2,FMON1                               !MUST KEEP *8
C
C-----------------------------------------------------------------------
C
C FN.FMON1 EVALUATES MONOPOLE INTEGRALS NEEDED FOR DETERMINATION OF THE
C          DIPOLE ONE - SEE EQUS (A3) & (A4) OF BHT.
C NRB: BASED ON ALAN'S ORIGINAL.
C
C NOTE: THIS ROUTINE MAY SUFFER FROM CANCELLATION ERROR - SEE BELOW.
C
C-----------------------------------------------------------------------
C
      PARAMETER (D64=64.0D0)
      PARAMETER (D1O64=DONE/D64)
      PARAMETER (D1PT5=1.5D0)
      PARAMETER (DPT2=0.2D0)
      PARAMETER (D1P24=1.0D+24)
C
      PARAMETER (QZERO=0.0D0)
      PARAMETER (QONE=1.0D0)
C
      IF(EK1+EK2.LT.D1M40)THEN
        FMON1=D1P50
        RETURN
      ENDIF
C
      VMAX=200                   !MAX NUMBER TERMS TO CONVERGE EXPANSION
C
      X1=SQRT(EK1)
      X2=SQRT(EK2)
      X3=X1+X2
      X4=X3*X3
      X5=X1*X2
      X6=X2-X1
      X7=DFOUR/X4
      PI=ACOS(-DONE)
C
      IF(EK1.LT.EK2)THEN
        ETA=DONE/X2
      ELSE
        ETA=DONE/X1
      ENDIF
C
      G=PI*EXP(-PI*ETA)/DTWO
C
      IF(G.lt.d1m40)THEN                        !NRB OVERFLOW ZEROES OUT
        FMON1=DZERO
        RETURN
      ENDIF
C
      A1=DONE
      A2=DONE
      MG=0
      MA1=0
      MA2=0
C
      M=-1
    4 M=M+1
      EM=M
      T=EM+EM+DONE
      G=G*X7/(T*(T+DONE))
      EMM=EM*EM
      A1=A1*(DONE+EMM*EK1)
      A2=A2*(DONE+EMM*EK2)
C
   30 IF(G.LT.D1O64)THEN
        G=D64*G
        MG=MG-1
        GO TO 30
      ENDIF
C
   32 IF(G.GT.D64)THEN
        G=G/D64
        MG=MG+1
        GO TO 32
      ENDIF
C
   34 IF(A1.GT.D64)THEN
        A1=A1/D64
        MA1=MA1+1
        GO TO 34
      ENDIF
C
   36 IF(A2.GT.D64)THEN
        A2=D1O64*A2
        MA2=MA2+1
        GO TO 36
      ENDIF
C
      IF(M.LT.L)GO TO 4
C
      G=G*(T+DONE)
C
      IF(X1.GE.D300)THEN
        XB=PI/X1
        A1=D1PT5*A1/(XB*(DTHREE-XB*(DTHREE-XB*(DTWO-XB))))
      ELSEIF(X1.GT.DPT2)THEN
        XB=-PI/X1
        A1=A1/(DONE-EXP(XB+XB))
      ENDIF
C
      IF(X2.GE.D300)THEN
        XB=PI/X2
        A2=D1PT5*A2/(XB*(DTHREE-XB*(DTHREE-XB*(DTWO-XB))))
      ELSEIF(X2.GT.DPT2)THEN
        XB=-PI/X2
        A2=A2/(DONE-EXP(XB+XB))
      ENDIF
C
      G=G*SQRT(A1*A2)*DEIGHT**(MG+MG+MA1+MA2)
C
      S0=QONE
      S1=QZERO
      U=L
      V=QZERO
      W=U+U+QONE
      T0=QONE
      T1=QZERO
C
C NRB: THE LOOP 14 CAN SUFFER FROM CANCELLATION ERROR,
C AS DO OTHERS OF ITS ILK - THEIR "SOLUTON" REAL *16...
C
   14 U=U+QONE
      V=V+QONE
      W=W+QONE
C
      IF(V.GT.VMAX)THEN
        FMON1=DZERO
        RETURN
      ENDIF
C
      U0=U*U*X5+QONE
      U1=U*X6
      T=T0*U0-T1*U1
      T1=T0*U1+T1*U0
      T0=T
      T=X7/(V*W)
      T0=T*T0
      T1=T*T1
      S0=S0+T0
      S1=S1+T1
      S=S0*S0+S1*S1
      T=T0*T0+T1*T1
      SM=QONE/S
      TM=QONE/T
C
      IF(SM*TM.EQ.QZERO)THEN                    !NRB OVERFLOW ZEROES OUT
        FMON1=DZERO
        RETURN
      ENDIF
C
      IF(S.LT.D1P24*T)GO TO 14
C
      FMON1=G*SQRT(S)
C      IV=V
C
      RETURN
C
      END FUNCTION FMON1
C
C                             *******************
C
      SUBROUTINE FSINT(BPRNT0)
C
C-----------------------------------------------------------------------
C
C  SR.FSINT CALCULATES THE TWO-BODY FINE-STRUCTURE INTEGRALS (N & V)
C  FOR HAMILTONIAN.
C
C  THE FOUR ELECTRON-ARGUMENTS (1,2,3.. FOR 1S,2S,2P..) HAVE BEEN
C  STORED IN QSS(I,L),I=1,4, AND 2*LAMBDA IN QRSS(5,L).
C
C  IT CALLS:
C    SR.DIFF
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: QSS
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_RELINT, ONLY: DRLP1,DNL
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBFSI, ONLY: BNRBFSI,DNLI,NLI
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
C
      IF(NL.LT.NL000)NL=NL+1
      NN=NL000
C
      IF(BPRNT0)WRITE(6,610)
C
      BREL2=ABS(IREL).EQ.2
C
      IF(BJUMP)THEN                 !JUST RE-COMPUTE OR RE-SCALE RYDBERG
C
        DO J=1,NN
          M=0
          TM=DONE
          DO I=1,4
            N=QSS(I,J)
            M=M+IVAL(N)
            TM=TM*FACT(N)
          ENDDO
          KK=NLI(J)
          IF(M.GT.0)THEN
            IF(BJUMP2)THEN
              DNL(J)=DNL(J)*TM      !RE-SCALE
              IF(KK.GT.0)THEN
                DO I=1,MENG
                  DNLI(I,KK)=DNLI(I,KK)*TM
                ENDDO
              ENDIF
            ELSE
              DNL(J)=DZERO          !ZERO-OUT FOR RE-COMPUTE
            ENDIF
          ENDIF
C
          IF(BJUMP2.AND.BPRNT0)THEN
            IF(KK.GT.0)WRITE(6,140)J,(QSS(I,J),I=1,5)
     X                              ,(DNLI(IC,KK),IC=1,MENG)
            IF(KK.EQ.0)WRITE(6,140)J,(QSS(I,J),I=1,5),DNL(J)
          ENDIF
C
        ENDDO
C
        IF(BJUMP2)GO TO 500                                      !RETURN
C
      ELSE                                 !INITIALIZE AND COMPUTE *ALL*
C
        DO J=1,NN
          DNL(J)=DZERO
        ENDDO
C
      ENDIF
C
C OUTER LOOP TO DETERMINE FINE-STRUCTURE INETGRALS
C
      DO J=1,NN                      !START MAGNETIC TWO-BODY OUTER LOOP
C                                    !OVER INNER ORBITAL PAIR (YLAMK)
        IF(DNL(J).NE.DZERO)GO TO 127
C
        M=QSS(5,J)
        MM=(M+2)/100
        BINT=MM.EQ.2                     !FALSE V; TRUE N
        IF(.NOT.BINT.AND.MM.NE.1)THEN
          WRITE(6,*)'FSINT ERROR: ITYPE=',MM
          WRITE(6,*)'J',J,'  QSS(J):',(QSS(M,J),M=1,5)
          WRITE(0,*)'FSINT ITYPE ERROR'
          NF=-1
          GO TO 500                                              !RETURN
        ENDIF
C
        M1=(M-100*MM)/2
        IF(M1.GT.MAXLAM)GO TO 127
C
        MJ=M-197
        IF(MJ.GT.0)MJ0=3                 !N
        IF(MJ.LT.0)MJ0=-3                !V
        K=0                              !V
        IF(BINT)K=1                      !N
C
        N1=QSS(K+1,J)
        N2=QSS(K+3,J)
        IF(MODE.LT.3)THEN
          IMT=0
          IF(IYY(N1).GT.0)IMT=IMT+1
          IF(IYY(N2).GT.0)IMT=IMT+1
          IF(IMT.GT.1)GO TO 127
        ENDIF
C
        M2=(QL(N1)+QL(N2))/2+2
        IF(BINT)THEN
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N2)*DPNL(I,N1)
          ENDDO
        ELSE
          IF(QL(N2).GT.0)M2=M2-1
C
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N2)/DX(I)
          ENDDO
C
          CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N1)*DP(I)*DX(I)
          ENDDO
        ENDIF
C
        IF(BREL)THEN
          DE1=DEY(N1)-DUY(N1,N1)
          DE2=DEY(N2)-DUY(N2,N2)
          DEL=DE1-DE2                                   ! A.U.
          T=DALF4*DTWO
          DZ=NZION
          IF(BREL2)THEN
            DO I=1,MAXRS
              DD1=DONE+T*(DE1+DZ/DX(I))
              DD2=DONE+T*(DE2+DZ/DX(I))
C              DD1=DONE+T*(DE1+POT(I,1))
C              DD2=DONE+T*(DE2+POT(I,1))
              DSQ=DD1*DD2
              DSQ=SQRT(DSQ)
              DPA(I)=DPA(I)/DSQ
            ENDDO
          ELSE
            dnorm=rnorm(n1)*rnorm(n2)
            DO I=1,MAXRS
              DD1=DONE+DALF4*(DQNL(I,N1)/DPNL(I,N1)+DTWO*DZ/DX(I))
              if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
              DD2=DONE+DALF4*(DQNL(I,N2)/DPNL(I,N2)+DTWO*DZ/DX(I))
              if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
              DSQ=DD1*DD2
              DSQ=SQRT(DSQ)
              DPA(I)=DPA(I)*dnorm/DSQ
            ENDDO
          ENDIF
          CALL YLAMKR(M1,M2,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ELSE
          CALL YLAMK(M1,M2,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ENDIF
C
        IF(.NOT.BINT)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)*DX(I)
          ENDDO
        ENDIF
C
        DO L=J,NN                             !START INNER MAGNETIC LOOP
C                                             !OVER OUTER ORBITAL PAIR
          IF(QSS(5,L).NE.M)GO TO 602
          IF(QSS(K+1,L).NE.N1)GO TO 602
          IF(QSS(K+3,L).NE.N2)GO TO 602
C
          L1=QSS(2-K,L)
          L2=QSS(4-K,L)
          JMT=0
          IF(MODE.LT.3)THEN
            IF(IYY(L1).GT.0)JMT=JMT+1
            IF(IYY(L2).GT.0)JMT=JMT+1
            IF(IMT+JMT.GT.1)GO TO 602
          ENDIF
C
          DO I=1,MAXRS
            DPA(I)=DPNL(I,L1)*DP(I)*DPNL(I,L2)
          ENDDO
C
          IF(BREL)THEN
            DE1=DEY(L1)-DUY(L1,L1)
            DE2=DEY(L2)-DUY(L2,L2)
C            DEL=DE1-DE2                                   ! A.U.
            T=DALF4*DTWO
            DZ=NZION
            IF(BREL2)THEN
              DO I=1,MAXRS
                DD1=DONE+T*(DE1+DZ/DX(I))
                DD2=DONE+T*(DE2+DZ/DX(I))
C                DD1=DONE+T*(DE1+POT(I,1))
C                DD2=DONE+T*(DE2+POT(I,1))
                DSQ=DD1*DD2
                DSQ=SQRT(DSQ)
                DPA(I)=DPA(I)/DSQ
              ENDDO
            ELSE
              dnorm=rnorm(l1)*rnorm(l2)
              DO I=1,MAXRS
                DD1=DONE+DALF4*(DQNL(I,L1)/DPNL(I,L1)+DTWO*DZ/DX(I))
                if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                DD2=DONE+DALF4*(DQNL(I,L2)/DPNL(I,L2)+DTWO*DZ/DX(I))
                if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                DSQ=DD1*DD2
                DSQ=SQRT(DSQ)
                DPA(I)=DPA(I)*dnorm/DSQ
              ENDDO
            ENDIF
          ENDIF
C
          CALL WEDDLE(DZERO,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
          OVL=DONE
          IF(IRLX.EQ.2)THEN        !OVERLAPS
            KF=IGRCF(N1)
            KG=IGRCF(N2)
            IF(KG.EQ.0)KG=IGRCF(L1)
            IF(KF.NE.KG.AND.KG.GT.0)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              OVL=OVLPCF(KK)
              IF(IPAIR(KK).EQ.1)THEN!SURELY THIS CAN BE SIMPLIFIED...
                IF(IEQ(N1).EQ.IEQ(N2))THEN
                  K1=MIN(N1,N2)
                  K2=MAX(N1,N2)
                ELSEIF(IEQ(L1).EQ.IEQ(L2))THEN
                  IF(IGRCF(L1).EQ.0)GO TO 611
                  K1=MIN(L1,L2)
                  K2=MAX(L1,L2)
                ELSEIF(KF.NE.IGRCF(L1))THEN
                  IF(IEQ(N1).EQ.IEQ(L1))THEN
                    K1=MIN(N1,L1)
                    K2=MAX(N1,L1)
                  ELSEIF(IEQ(L2).EQ.IEQ(N2))THEN
                    IF(IGRCF(L2).EQ.0)GO TO 611
                    K1=MIN(L2,N2)
                    K2=MAX(L2,N2)
                  else
                    write(6,*)'fsint: why are we here?',
     x                      kf,kg,n1,l1,n2,l2
                    write(0,*)'fsint: why are we here?'
                    nf=-1
                    go to 500                                    !return
                  ENDIF
                ELSE
                  IF(IEQ(N1).EQ.IEQ(L2))THEN
                    K1=MIN(N1,L2)
                    K2=MAX(N1,L2)
                  ELSEIF(IEQ(L1).EQ.IEQ(N2))THEN
                    K1=MIN(L1,N2)
                    K2=MAX(L1,N2)
                  else
                    write(6,*)'fsint: why are we here?',
     x                      kf,kg,n1,l1,n2,l2
                    write(0,*)'fsint: why are we here?'
                    nf=-1
                    go to 500                                    !return
                  ENDIF
                ENDIF
                KK=((K2-1)*(K2-2))/2+K1
                OVL=OVL/OVLPGR(KK)
              ENDIF
            ENDIF
          ENDIF
C
  611     DNL(L)=DD*DALF4*OVL
          IF(BNRBFSI)THEN
            KK=NLI(L)
            IF(KK.GT.0)THEN
              IF(IRLX.EQ.2)THEN
                DO I=1,MENG
                  DNLI(I,KK)=DNLI(I,KK)*OVL
                ENDDO
              ENDIF
              DNLI(NREL,KK)=DNL(L)
            ENDIF
          ENDIF
C
  602   ENDDO                                            !END INNER LOOP
C
  127   KK=0
        IF(BNRBFSI)KK=NLI(J)
        IF(BPRNT0.AND.KK.EQ.0)WRITE(6,140)J,(QSS(I,J),I=1,5),DNL(J)
        IF(BPRNT0.AND.KK.GT.0)WRITE(6,140)J,(QSS(I,J),I=1,5)
     X                                     ,(DNLI(IC,KK),IC=1,MENG)
C
      ENDDO                                              !END OUTER LOOP
C
  500 RETURN
C
  140 FORMAT(I5,3X,2(I5,I4),I6,7F14.8,1X/(32X,7F14.8))
  610 FORMAT(//5X,"N&V(   A   B    C   D  2LBD') = MAGNETIC INTEGRALS")
C
      END SUBROUTINE FSINT
C
C                             *******************
C
      SUBROUTINE FSINTI(ICOUNT,N,KK)
C
C-----------------------------------------------------------------------
C
C  SR.FSINTI CALCULATES THE TWO-BODY FINE-STRUCTURE INTEGRALS (N&V)
C  INVOLVING CONTINUUM FUNCTIONS (ORBITAL N) AT THE ICOUNT'TH
C  INTERPOLATION ENERGY, INDEXED BY KK.
C
C  IT CALLS:
C    SR.DIFF
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: QSS
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBFSI, ONLY: DNLI,NLI,IXFSS
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM3/DDUM,DZDUM,TM       !TM IS USED STILL BELOW
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBFR/DP(MAXB1)
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      IF(NL.LT.NL000)NL=NL+1
      NN=NL000
C
COLD      DDY=DDUM/DTWO                   !A.U.
      DDY=DYY(ICOUNT)
      DD=DZERO
C
COLD      DZ=DZDUM
      DZ=NZION
C
      BREL2=ABS(IREL).EQ.2
C                                                          !ELSE COMPUTE
      DO J=1,NN                      !START MAGNETIC TWO-BODY OUTER LOOP
C                                    !OVER INNER ORBITAL PAIR (YLAMK)
        KP=NLI(J)
C  ****TEST                                       108
        IF(KP.GT.0)then                   !.AND. for stupid compilers
          if(DNLI(ICOUNT,KP).NE.DZERO)GO TO 127
        endif
C
        M=QSS(5,J)
        MM=(M+2)/100
        BINT=MM.EQ.2                     !FALSE V; TRUE N
        IF(.NOT.BINT.AND.MM.NE.1)THEN
          WRITE(6,*)'FSINTI ERROR: ITYPE=',MM
          WRITE(0,*)'FSINTI ITYPE ERROR'
          KK=-1
          GO TO 999
        ENDIF
C
        M1=(M-100*MM)/2
        IF(M1.GT.MAXLAM)GO TO 127
C
        DO I=1,4              !NO ASSUMPTION ABOUT POSITION OF CONTINUUM
          IF(N.EQ.QSS(I,J))GO TO 121
        ENDDO
        GO TO 127
C
  121   IN=N                        !SUPERFLUOUS WHEN ONLY ONE CONTINUUM
        MJ=M-197
        IF(MJ.GT.0)MJ0=3                 !N
        IF(MJ.LT.0)MJ0=-3                !V
        K=0                              !V
        IF(BINT)K=1                      !N
C
        N1=QSS(K+1,J)
        N2=QSS(K+3,J)
        IF(MODE.LT.3)THEN
          IMT=0
          IF(IYY(N1).GT.0)IMT=IMT+1
          IF(IYY(N2).GT.0)IMT=IMT+1
          IF(IMT.GT.1)GO TO 127
        ENDIF
C
        BCALC=N1.EQ.IN.OR.N2.EQ.IN
C
        IF(.NOT.BLAG)GO TO 125
C
        M2=(QL(N1)+QL(N2))/2+2
        IF(BINT)THEN
          IF(N1.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=DPNL(I,N2)*FR(I)
            ENDDO
          ELSEIF(N2.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=FR(I)*DPNL(I,N1)
            ENDDO
          ELSE
             DO I=1,MAXRS
               DPA(I)=DPNL(I,N2)*DPNL(I,N1)
             ENDDO
          ENDIF
        ELSE
          IF(QL(N2).GT.0)M2=M2-1
C
          IF(N2.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=FR(I)/DX(I)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DPA(I)=DPNL(I,N2)/DX(I)
            ENDDO
          ENDIF
C
          CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
          IF(N1.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=FR(I)*DP(I)*DX(I)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DPA(I)=DPNL(I,N1)*DP(I)*DX(I)
            ENDDO
          ENDIF
        ENDIF
C
        IF(BREL)THEN
          T=DALF4*DTWO
          DE1=DEY(N1)-DUY(N1,N1)
          DE2=DEY(N2)-DUY(N2,N2)
          IF(BREL2)THEN
            IF(N1.EQ.IN)DE1=DDY
            IF(N2.EQ.IN)DE2=DDY
            DO I=1,MAXRS
              DD1=DONE+T*(DE1+DZ/DX(I))
              DD2=DONE+T*(DE2+DZ/DX(I))
C              DD1=DONE+T*(DE1+POT(I,1))
C              DD2=DONE+T*(DE2+POT(I,1))
              DPA(I)=DPA(I)/SQRT(DD1*DD2)
            ENDDO
          ELSE
            dnorm=rnorm(n1)*rnorm(n2)          !use nrel value
            IF(N1.EQ.IN)THEN
              DE1=DDY
              DO I=1,MAXRS
                DD1=DONE+DALF4*(GR(I)/FR(I)+DTWO*DZ/DX(I))
                DD2=DONE+DALF4*(DQNL(I,N2)/DPNL(I,N2)+DTWO*DZ/DX(I))
                if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
              ENDDO
            ELSEIF(N2.EQ.IN)THEN
              DE2=DDY
              DO I=1,MAXRS
                DD1=DONE+DALF4*(DQNL(I,N1)/DPNL(I,N1)+DTWO*DZ/DX(I))
                DD2=DONE+DALF4*(GR(I)/FR(I)+DTWO*DZ/DX(I))
                if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
              ENDDO
            ELSE
             DO I=1,MAXRS
                DD1=DONE+DALF4*(DQNL(I,N1)/DPNL(I,N1)+DTWO*DZ/DX(I))
                DD2=DONE+DALF4*(DQNL(I,N2)/DPNL(I,N2)+DTWO*DZ/DX(I))
                if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
              ENDDO
            ENDIF
          ENDIF
          DEL=DE1-DE2                                   ! A.U.
          CALL YLAMKR(M1,M2,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ELSE
          CALL YLAMK(M1,M2,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ENDIF
C
        IF(.NOT.BINT)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)*DX(I)
          ENDDO
        ENDIF
C
  125   DO L=J,NN                             !START INNER MAGNETIC LOOP
C                                             !OVER OUTER ORBITAL PAIR
          IF(QSS(5,L).NE.M)GO TO 602
          IF(QSS(K+1,L).NE.N1)GO TO 602
          IF(QSS(K+3,L).NE.N2)GO TO 602
C
          L1=QSS(2-K,L)
          L2=QSS(4-K,L)
          JMT=0
          IF(MODE.LT.3)THEN
            IF(IYY(L1).GT.0)JMT=JMT+1
            IF(IYY(L2).GT.0)JMT=JMT+1
            IF(IMT+JMT.ne.1)GO TO 602   !NEED ONE AND ONLY ONE CONTINUUM
          ENDIF
C
          IF(.NOT.BCALC)THEN                      !NOT YET MATCHED ORB N
            IF(L1.NE.IN.AND.L2.NE.IN)GO TO 602    !NOT FOUND
          ENDIF
C
          IF(.NOT.BLAG)GO TO 126
C
          IF(L1.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=FR(I)*DP(I)*DPNL(I,L2)
            ENDDO
          ELSEIF(L2.EQ.IN)THEN
            DO I=1,MAXRS
              DPA(I)=DPNL(I,L1)*DP(I)*FR(I)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DPA(I)=DPNL(I,L1)*DP(I)*DPNL(I,L2)
            ENDDO
          ENDIF
C
          IF(BREL)THEN
            DE1=DEY(L1)-DUY(L1,L1)
            DE2=DEY(L2)-DUY(L2,L2)
            T=DALF4*DTWO
            IF(BREL2)THEN
              IF(L1.EQ.IN)DE1=DDY
              IF(L2.EQ.IN)DE2=DDY
              DO I=1,MAXRS
                DD1=DONE+T*(DE1+DZ/DX(I))
                DD2=DONE+T*(DE2+DZ/DX(I))
C                DD1=DONE+T*(DE1+POT(I,1))
C                DD2=DONE+T*(DE2+POT(I,1))
                DPA(I)=DPA(I)/SQRT(DD1*DD2)
              ENDDO
            ELSE
              dnorm=rnorm(l1)*rnorm(l2)         !use nrel value
              IF(L1.EQ.IN)THEN
c                DE1=DDY
                DO I=1,MAXRS
                  DD1=DONE+DALF4*(GR(I)/FR(I)+DTWO*DZ/DX(I))
                  DD2=DONE+DALF4*(DQNL(I,L2)/DPNL(I,L2)+DTWO*DZ/DX(I))
                  if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                  if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                  DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
                ENDDO
              ELSEIF(L2.EQ.IN)THEN
c                DE2=DDY
                DO I=1,MAXRS
                  DD1=DONE+DALF4*(DQNL(I,L1)/DPNL(I,L1)+DTWO*DZ/DX(I))
                  DD2=DONE+DALF4*(GR(I)/FR(I)+DTWO*DZ/DX(I))
                  if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                  if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                  DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
                ENDDO
              ELSE
                DO I=1,MAXRS
                  DD1=DONE+DALF4*(DQNL(I,L1)/DPNL(I,L1)+DTWO*DZ/DX(I))
                  DD2=DONE+DALF4*(DQNL(I,L2)/DPNL(I,L2)+DTWO*DZ/DX(I))
                  if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
                  if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
                  DPA(I)=DPA(I)*dnorm/SQRT(DD1*DD2)
                ENDDO
              ENDIF
            ENDIF
          ENDIF
C
          CALL WEDDLE(DZERO,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
  126     KP=NLI(L)
          IF(KP.LE.0)THEN
            KK=KK+1
            IF(KK.GT.IXFSS)GO TO 602
            KP=KK
            NLI(L)=KK
          ENDIF
C
          DNLI(ICOUNT,KP)=DD*DALF4
C
  602   ENDDO                                            !END INNER LOOP
C
C **TEST PRINT
C  108 KP=NLI(J)
C      WRITE(6,140)ICOUNT,J,(QSS(I,J),I=1,5),DNLI(ICOUNT,KP)
C  140 FORMAT(2I5,3X,2(I5,I4),I6,F14.8)
C
  127 ENDDO                                              !END OUTER LOOP
C
  999 RETURN
C
      END SUBROUTINE FSINTI
C
C                             *******************
C
      SUBROUTINE FSINTX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                 ,DNL
     X                 ,M1,M2,JNEW,MPOSC)
C
C-----------------------------------------------------------------------
C
C  SR.FSINTX CALCULATES THE DEIE TWO-BODY FINE-STRUCTURE INTEGRALS (N&V)
C
C  THE FOUR ELECTRON-ARGUMENTS (1,2,3.. FOR 1S,2S,2P..) HAVE BEEN
C  STORED IN QSS(I,L),I=1,4, AND 2*LAMBDA IN QSS(5,L).
C
C IT CALLS:
C   SR.VNRKX
C   SR.VNYKX
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: QSS
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DNL(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
C SUPPRESS COMPILER WARNINGS (SIGH...)
C
      DUM=PSHFTX(1,1)
C
      NN=NL000
C
      BPRNT0=JPRINT.GE.4                      !FOR DETAILED PRINTOUT
c      BPRNT0=JPRINT.NE.-3
      BREL2=ABS(IREL).EQ.2
C
      MAXRS1=MAXRS
      IF(BREL2)MAXRS1=MAXRS1+1
C
      IF(BPRNT0)WRITE(6,610)M1,DYY(M1),M2,DYY(M2)
C
C INITIALIZE
C
      DO J=1,NN
        DNL(J)=DZERO
      ENDDO
C
C OUTER LOOP TO DETERMINE FINE-STRUCTURE INETGRALS
C
      DO J=1,NN                      !START MAGNETIC TWO-BODY OUTER LOOP
C                                    !OVER INNER ORBITAL PAIR (YLAMK)
        IF(DNL(J).NE.DZERO)GO TO 127
C
        M5=QSS(5,J)
        IF(M5.LT.100.OR.
     X     M5.LT.198.AND.M5.GT.160+JNEW)GO TO 127 !NO NEED FOR THIS JTOT
C
        MM=(M5+2)/100
        BINT=MM.EQ.2                     !FALSE V; TRUE N
        IF(.NOT.BINT.AND.MM.NE.1)THEN
          WRITE(6,*)'FSINTX ERROR: ITYPE=',MM
          WRITE(6,*)'J',J,'  QSS(J):',(QSS(M,J),M=1,5)
          WRITE(0,*)'FSINTX ITYPE ERROR'
          NF=-1
          GO TO 500                                              !RETURN
        ENDIF
C
        MI=(M5-100*MM)/2
        IF(MI.GT.MAXLAM)GO TO 127
C
        K=0                              !V
        IF(BINT)K=1                      !N
C
        N1=QSS(K+1,J)
        N2=QSS(K+3,J)
        IF(QL(N1).LT.0)GO TO 127
        IF(QL(N2).LT.0)GO TO 127
C
        ML=(QL(N1)+QL(N2))/2+2
        IF(.NOT.BINT.AND.QL(N2).GT.0)ML=ML-1
c
        if(brel)dnorm=rnorm(n1)*rnorm(n2)
C
C DETERMINE "YLAMK"
C
        IF(QN(N1).LT.0)THEN
          Q1=QPOS(N1-MPOSC)
          q1=abs(q1)
          DE1=DYY(M1)/DTWO
        ELSE
          DE1=DEY(N1)-DUY(N1,N1)
        ENDIF
C
        IF(QN(N2).LT.0)THEN
          Q2=QPOS(N2-MPOSC)
          q2=abs(q2)
          DE2=DYY(M2)/DTWO
          IF(QN(N1).LT.0)THEN
C ICASE=1
            CALL VNYKX(FRX(1,M1,Q1),FRX(1,M2,Q2),FRX(MAXRS1,M1,Q1)
     X            ,FRX(MAXRS1,M2,Q2),BINT,MI,ML,DE1,DE2,FR,GR,DX,dnorm)
          ELSE
C ICASE=3
            M=M1
            CALL VNYKX(DPNL(1,N1),FRX(1,M2,Q2),DQNL(1,N1)
     X            ,FRX(MAXRS1,M2,Q2),BINT,MI,ML,DE1,DE2,FR,GR,DX,dnorm)
          ENDIF
        ELSE
          DE2=DEY(N2)-DUY(N2,N2)
          IF(QN(N1).LT.0)THEN
C ICASE=2
c            if(bint)then                             !and falling order
c              m0=m2
c              m=m1
c              de1=dyy(m2)/dtwo
c            else
              M0=M1
              M=M2
c            endif
            CALL VNYKX(FRX(1,M0,Q1),DPNL(1,N2),FRX(MAXRS1,M0,Q1)
     X                ,DQNL(1,N2),BINT,MI,ML,DE1,DE2,FR,GR,DX,dnorm)
          ELSE
C ICASE=4
            M=M1
            CALL VNYKX(DPNL(1,N1),DPNL(1,N2),DQNL(1,N1)
     X                ,DQNL(1,N2),BINT,MI,ML,DE1,DE2,FR,GR,DX,dnorm)
          ENDIF
        ENDIF
C
        DO L=J,NN                             !START INNER MAGNETIC LOOP
C                                             !OVER OUTER ORBITAL PAIR
          IF(QSS(5,L).NE.M5)GO TO 602
          IF(QSS(K+1,L).NE.N1)GO TO 602
          IF(QSS(K+3,L).NE.N2)GO TO 602
          L1=QSS(2-K,L)
          L2=QSS(4-K,L)
          IF(QL(L1).LT.0)GO TO 602
          IF(QL(L2).LT.0)GO TO 602
c
          if(brel)dnorm=rnorm(l1)*rnorm(l2)
C
C DETERMINE "RK" (A.U.)
C
          IF(QN(L1).LT.0)THEN
            Q1=QPOS(L1-MPOSC)
            q1=abs(q1)
            DE1=DYY(M)/DTWO
          ELSE
            DE1=DEY(L1)-DUY(L1,L1)
          ENDIF
C
          IF(QN(L2).LT.0)THEN
            Q2=QPOS(L2-MPOSC)
            q2=abs(q2)
            DE2=DYY(M2)/DTWO
            IF(QN(L1).LT.0)THEN
C JCASE=4
              CALL VNRKX(FRX(1,M1,Q1),FRX(1,M2,Q2),FRX(MAXRS1,M1,Q1)
     X              ,FRX(MAXRS1,M2,Q2),DE1,DE2,FR,GR,DX,dnorm,DD)
            ELSE
C JCASE=2
              CALL VNRKX(DPNL(1,L1),FRX(1,M,Q2),DQNL(1,L1)
     X              ,FRX(MAXRS1,M,Q2),DE1,DE2,FR,GR,DX,dnorm,DD)
            ENDIF
          ELSE
            DE2=DEY(L2)-DUY(L2,L2)
            IF(QN(L1).LT.0)THEN
C JCASE=3
              CALL VNRKX(FRX(1,M,Q1),DPNL(1,L2),FRX(MAXRS1,M,Q1)
     X                 ,DQNL(1,L2),DE1,DE2,FR,GR,DX,dnorm,DD)
            ELSE
C JCASE=1
              CALL VNRKX(DPNL(1,L1),DPNL(1,L2),DQNL(1,L1)
     X                 ,DQNL(1,L2),DE1,DE2,FR,GR,DX,dnorm,DD)
            ENDIF
          ENDIF
C
          DNL(L)=DD
C
  602   ENDDO                                            !END INNER LOOP
C
  127   IF(BPRNT0)WRITE(6,140)J,(QSS(I,J),I=1,5),DNL(J)
C
      ENDDO                                              !END OUTER LOOP
C
  500 RETURN
C
  140 FORMAT(I5,3X,2(I5,I4),I6,F14.8)
  610 FORMAT(/5X,"N&V(   A   B    C   D  2LBD') = MAGNETIC INTEGRALS"
     X,3X,'FOR    E(',I2,')=',F10.3,5X,'E(',I2,')=',F10.3,'  RYD')
C
      END SUBROUTINE FSINTX
C
C                             *******************
C
      SUBROUTINE FZALF(ZEFF,I,SLFE)
C
C-----------------------------------------------------------------------
C
C  This routine obtains an estimate of the self energy contribution
C  to the energy resulting from either 1s, 2s, 2p- or 2p orbital in
C  the field of a point nucleus with effective charge ZEFF.
C  The values are interpolated among the values supplied by P.J. Mohr
C
C  Subroutine called: INTRPG
C
C  Based on PHN's GRASP0 routine and freely adapted by NRB.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION ARG(11),VAL1S(11),VAL2P1(11)
      DIMENSION VAL2P3(11),VAL2S(11)
C
C-----------------------------------------------------------------------
C
C  1s data :
C
      DATA VAL1S/4.654D0,3.246D0,2.5519D0,2.1351D0,1.8644D0,1.6838D0
     X,1.5675D0,1.5032D0,1.4880D0,1.5317D0,1.6614D0/
C
C  2s data :
C
      DATA VAL2S/4.8930D0,3.5063D0,2.8391D0,2.4550D0,2.2244D0,2.0948D0
     X,2.0435D0,2.0650D0,2.1690D0,2.3870D0,2.7980D0/
C
C  2p- data :
C
      DATA VAL2P1/-0.1145D0,-0.0922D0,-0.0641D0,-0.0308D0,0.0082D0
     X,0.0549D0,0.1129D0,0.1884D0,0.2934D0,0.4530D0,0.7250D0/
C
C  2p data
C
      DATA VAL2P3/0.1303D0,0.1436D0,0.1604D0,0.1794D0,0.1999D0,0.2215D0
     X,0.2440D0,0.2671D0,0.2906D0,0.3141D0,0.3367D0/
C
C  Z data values :
C
      DATA ARG/10.0D0,20.0D0,30.0D0,40.0D0,50.0D0,60.0D0,70.0D0,80.0D0
     X,90.0D0,100.0D0,110.0D0/
C
C  Number of data points
C
      DATA NUMVAL/11/
C-----------------------------------------------------------------------
C
      IF(QN(I).EQ.1)THEN
C
C  1s case
C
        CALL INTRPG(ARG,VAL1S,ZEFF,NUMVAL,SLFE)
C
      ELSE
C
C  ns case
C
        IF(QL(I).EQ.0)THEN
C
          CALL INTRPG(ARG,VAL2S,ZEFF,NUMVAL,SLFE)
C
        ELSEIF(QL(I).EQ.2)THEN
C
C  np- case
C
          CALL INTRPG(ARG,VAL2P1,ZEFF,NUMVAL,SLFE1)
C
C  np case
C
          CALL INTRPG(ARG,VAL2P3,ZEFF,NUMVAL,SLFE3)
C
C FORM KAPPA AVERAGE
C
          SLFE=(SLFE1+DTWO*SLFE3)/DTHREE
C
        ELSE
C
          SLFE=DZERO
C
        ENDIF
C
      ENDIF
C
      RETURN
C
      END SUBROUTINE FZALF
C
C                             *******************
C
      FUNCTION GAMA7(XX)
C
C-----------------------------------------------------------------------
C
C  FN.GAMA7 EVALUATES THE GAMMA FUNCTION OF ARGUMENT X,
C  USING THE 7-POINT APPROXIMATE FORM OF ABRAMOWITZ AND STEGUN.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (ERR=1.D-6)
      PARAMETER (ARGFCT=57.0D0)
C
      PARAMETER (C1=0.57710166D0)
      PARAMETER (C2=0.98585399D0)
      PARAMETER (C3=0.87642182D0)
      PARAMETER (C4=0.8328212D0)
      PARAMETER (C5=0.5684729D0)
      PARAMETER (C6=0.25482049D0)
      PARAMETER (C7=0.05149930D0)
C
      IER=2
      X=XX
      IF(X.GT.ARGFCT)GO TO 9
C
      GX=DONE
   2  IF(X.GE.DTWO)THEN
        X=X-DONE
        GX=GX*X
        GO TO 2
      ENDIF
C
      IF(X.LT.ERR)THEN
        IER=1
        Y=REAL(INT(X),WP)-X
        IF(ABS(Y).LT.ERR)GO TO 9
        IF(DONE-Y-ERR.LE.DZERO)GO TO 9
      ENDIF
C
   5  IF(X.EQ.DONE)THEN
        GAMA7=GX
        RETURN
      ENDIF
      IF(X.LT.DONE)THEN
        GX=GX/X
        X=X+DONE
        GO TO 5
      ENDIF
C
      Y=X-DONE
      GX=(((((((-C7*Y+C6)*Y-C5)*Y+C4)*Y-C3)*Y+C2)*Y-C1)*Y+DONE)*GX
C
      GAMA7=GX
      RETURN
C
C SHOULD NOT OCCUR AS ALL USES OF GAMA7 CHECK FOR VALID RANGE BEFOREHAND
C
   9  WRITE(6,100)IER
      WRITE(0,*)'***ERROR IN FUNCTION GAMA7'
      STOP '***ERROR IN FUNCTION GAMA7'
 100  FORMAT('***ERROR',I3,' IN FUNCTION GAMA7')
C
      END FUNCTION GAMA7
C
C                             *******************
C
      SUBROUTINE HDIAG(NMAX,NE,EU,DU,MAXNJ,DEV,WRK,NF,INFO)
C
C-----------------------------------------------------------------------
C
C SR.HDIAG DIAGONALIZES A REAL SYMMETRIC (HAMILTONIAN) MATRIX
C    THERE ARE SEVERAL ROUTINES CODED-FOR.
C
C    ON INPUT:
C
C     DU(:,:)  CONTAINS THE LOWER TRIANGLE MATRIX OF ORDER NMAX
C              AND ROW DIMENSION MAXNJ.
C
C         NE   SPECIFIES THE NUMBER OF E-VALUES AND E-VECTORS REQUIRED.
C              A VALID RANGE IS  1 .LE. NE .LE. NMAX
C              AND REQUIRES DSYEVX TO BE ACTIVATED (SEE DSYEVR NOTE)
C         EU   SPECIFIES THE RANGE OF E-VALUES AND E-VECTORS REQUIRED
C              A VALID RANGE IS -INFTY .LT. EU .LT. ZERO.
C        ***   IF A VALID RANGE IS NOT SPECIFIED THEN *ALL* NMAX
C              ARE CALCULATED, USING DSYEVD (IF ACTIVE) OR SR.DIAG.
C              (THE RANGE [1,NMAX] ALSO USES DSYEVD/SR.DIAG.)
C
C        INFO  SHOULD BE SET ZERO ON THE FIRST CALL TO SR.HDIAG.
C              IF A LAPACK ROUTINE FAILS IT IS RESET NON-ZERO AND
C              A SUBSEQUENT CALL TO SR.HDIAG WILL USE SR.DIAG INSTEAD,
C              UNLESS THE USER CODE RESETS IT ZERO AGAIN...
C              THE USER NEEDS TO RE-LOAD DU FOR USE BY SR.DIAG.
C              INFO IS THEN RE-SET ZERO ON OUTPUT SO THAT THE LAPACK
C              ROUTINE IS USED AGAIN FOR THE NEXT DIAGONALIZATION.
C
C       IDIAG  .GT. 0  OVERRIDES EVERYTHING AND USES THE HISTORIC
C              (VERY) SLOW SR.JACORD.
C
C    ON OUTPUT:
C
C     DU(:,:)  CONTAINS THE E-VECTORS
C     DEV(:)   CONTAINS THE E-VALUES.
C              THEY ARE ORDERED BY DOMINANT E-VECTOR COMPONENT.
C              IF A RANGE WAS SPECIFIED, THOSE ENTRIES NOT DETERMINED
C              ARE ZEROED-OUT.
C          NE  IF EU SPECIFIED A RANGE OF ENERGIES THEN NE NOW CONTAINS
C              THE NUMBER OF E-STATES FOUND.
C
C        INFO  SEE INPUT.
C
C         WRK IS A WORK VECTOR OF LENGTH AT LEAST NMAX.
C
C   NOTE: WHILE IN PRINCIPLE DSYEVR IS A REPLACEMENT FOR DSYEVD AND
C         DSYEVX, BEING AS FAST AS DSYEVD AND ALLOWING A RANGE OF
C         E-STATES AS DSYEVX, IT IS NOT ROBUST. IT REQUIRES NON-IEEE
C         COMPLIANCE AND VENDOR LIBRARIES TEND TO FORCE SUCH MEANING
C         IT MAKES A SLOW DSYEVX-LIKE OPERATION INSTEAD.
C
C IT CALLS:
C   SR.DIAG
C   SR.JACORD
CLC SR.DSYEVD                                                    !LAPACK
CLC SR.DSYEVR                                                    !LAPACK
CLC SR.DSYEVX                                                    !LAPACK
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
CL      PARAMETER (EPS=1.0D-12)                                  !DSYEVR
CL      PARAMETER (EPS=1.0D-12)                                  !DSYEVX
CLC                                                              !LAPACK
CL      CHARACTER(LEN=1) CRNG                                    !LAPACK
C
      ALLOCATABLE :: DSV(:,:),IWRK1(:),IWRK2(:)
CL      ALLOCATABLE :: WORK(:),IWORK(:),ISUPP(:)                 !LAPACK
C
      DIMENSION DU(MAXNJ,*),DEV(*),WRK(*)
C
      COMMON /NRBDIJ/IDIAG,JRAD
C
      DATA IWARN/0/
C
      IF(NMAX.EQ.1)THEN                                    !QUICK RETURN
        IF(EU.GE.DZERO.OR.DU(1,1).LT.EU)THEN
          DEV(1)=DU(1,1)
          DU(1,1)=DONE
        ELSE
          DEV(1)=DZERO
          DU(1,1)=DZERO
        ENDIF
        RETURN
      ENDIF
C
      IL=1                                             !FIXED, CURRENTLY
      IU=NE
C
      VL=-D1P30                                        !FIXED, CURRENTLY
      VU=EU                                   !TAKES PRECEDENCE IF .LT.0
C
      IF(EU.GE.DZERO)THEN
       BALL=IL.EQ.1.AND.IU.EQ.NMAX.OR.IL.LT.1..OR.IU.GT.NMAX.OR.IL.GT.IU
      ELSE
       BALL=.FALSE.
      ENDIF
C
      IF(IDIAG.LE.0)THEN
C
        ALLOCATE (IWRK1(NMAX),IWRK2(NMAX),STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)' HDIAG: ALLOCATION FAILS FOR IWRK1,IWRK2'
          GO TO 7600
        ENDIF
C
CL        IF(INFO.GT.0)GO TO 200      !PREVIOUS LAPACK FAILURE   !LAPACK
C
        INFO=1                                            !FLAG FOR DIAG
C
CLC ALL LAPACK                                                   !LAPACK
CLC                                                              !LAPACK
CL        IF(BALL)THEN                                           !LAPACK
CL          CRNG='A'                                             !LAPACK
CL          NEIGEN=NMAX                                          !LAPACK
CL        ELSE                                                   !LAPACK
CL          IF(EU.GE.DZERO)THEN                                  !LAPACK
CL            CRNG='I'                                           !LAPACK
CL            NEIGEN=IU-IL+1                                     !LAPACK
CL          ELSE                                                 !LAPACK
CL            CRNG='V'                                           !LAPACK
CL            NEIGEN=NMAX                                        !LAPACK
CL          ENDIF                                                !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        LIWORK=0                                               !LAPACK
CL        LWORK=0                                                !LAPACK
CLC                                                              !LAPACK
CLC FOR DSYEVD                                                   !DSYEVD
CL        LIWORK=3+5*NMAX                                        !DSYEVD
CL        LWORK=500+6*NMAX+2*NMAX*NMAX                           !DSYEVD
CLC                                                              !LAPACK
CLC FOR DSYEVR                                                   !DSYEVR
CL        LIWORK=MAX(LIWORK,10*NMAX)                             !DSYEVR
CL        LWORK=MAX(LWORK,(512+6)*NMAX)                          !DSYEVR
CLC                                                              !LAPACK
CLC FOR DSYEVX                                                   !DSYEVX
CL        LIWORK=MAX(LIWORK,5*NMAX)                              !DSYEVX
CL        LWORK=MAX(LWORK,(512+3)*NMAX)                          !DSYEVX
CLC                                                              !LAPACK
CL        ALLOCATE (WORK(LWORK),IWORK(LIWORK)                    !LAPACK
CL     X           ,DSV(NMAX,NEIGEN),ISUPP(2*NEIGEN)             !DSYEVR
CL     X           ,DSV(NMAX,NEIGEN),ISUPP(NEIGEN)               !DSYEVX
CL     X           ,STAT=IERR)                                   !LAPACK
CLC                                                              !LAPACK
CL        IF(IERR.NE.0)THEN                                      !LAPACK
CL          WRITE(0,*)                                           !LAPACK
CL     X  ' HDIAG: ALLOCATION FAILS FOR WORK,LWORK'              !LAPACK
CL          GO TO 7500                                           !LAPACK
CL        ENDIF                                                  !LAPACK
CLc                                                              !DGESVD
CLc test SVD (also need DSV ALLOCATED - see DSYEVR above).       !DGESVD
CLc                                                              !DGESVD
CL        do i=1,nmax                                            !DGESVD
CL          do j=i,nmax                                          !DGESVD
CL            du(i,j)=du(j,i)                                    !DGESVD
CL          enddo                                                !DGESVD
CL        enddo                                                  !DGESVD
CLc                                                              !DGESVD
CL        call dgesvd('N','N',NMAX,NMAX,DU,MAXNJ,DEV,DSV,NMAX    !DGESVD
CL     X              ,DSV,NMAX,WORK,LWORK,INFO)                 !DGESVD
CLc                                                              !DGESVD
CL        if(dev(nmax).eq.0)then                                 !DGESVD
CL          write(6,*)' SR.HDIAG: Singular Matrix found...'      !DGESVD
CL          if(info.eq.0)info=1                                  !DGESVD
CL        endif                                                  !DGESVD
CL        if(info.ne.0)go to 100                                 !DGESVD
CLC                                                              !LAPACK
CL        IF(BALL)THEN                                           !LAPACK
CLC                                                              !DSYEVD
CLC DSYEVD - DIVIDE AND CONQUER (MEMORY HOG)                     !DSYEVD
CLC                                                              !DSYEVD
CL          CALL DSYEVD('V','L',NMAX,DU,MAXNJ,DEV                !DSYEVD
CL     X                ,WORK,LWORK,IWORK,LIWORK,INFO)           !DSYEVD
CLC                                                              !DSYEVD
CL          IF(INFO.NE.0)GO TO 100                               !DSYEVD
CLC                                                              !DSYEVD
CLC USE DIAG TO RE-ORDER E-VALUES BASED ON DOMINANT E-VECTOR CPTS!DSYEVD
CLC                                                              !DSYEVD
CL          CALL DIAG(-NMAX,NMAX,IZERO,DU,DEV,WRK,IWRK1,IWRK2    !DSYEVD
CL     X              ,MAXNJ)                                    !DSYEVD
CLC                                                              !DSYEVD
CL          GO TO 100                                            !DSYEVD
CLC                                                              !DSYEVD
CLC END DSYEVD                                                   !DSYEVD
CLC                                                              !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !DSYEVR
CLC DSYEVR (REQUIRES MACHINES TO HANDLE NaNs GRACEFULLY)         !DSYEVR
CLC                                                              !DSYEVR
CL        IEEEOK=ILAENV(ITEN,'DSYEVR','N',IONE,ITWO,ITHREE,IFOUR)!DSYEVR
CL        IF(IEEEOK.NE.1)WRITE(0,*)                              !DSYEVR
CL     X 'WARNING: DSTEBZ/DSTEIN USED, BETTER TO CALL DSYEVD!'   !DSYEVR
CLC                                                              !DSYEVR
CL        CALL DSYEVR('V',CRNG,'L',NMAX,DU,MAXNJ,VL,VU,IL,IU,EPS !DSYEVR
CL     X              ,MSUB,DEV,DSV,NMAX,ISUPP,WORK,LWORK        !DSYEVR
CL     X              ,IWORK,LIWORK,INFO)                        !DSYEVR
CLC                                                              !DSYEVR
CLC END DSYEVR                                                   !DSYEVR
CLC                                                              !DSYEVX
CLC DSYEVX (SLOWER THAN DSYEVR, BUT ROBUST)                      !DSYEVX
CLC                                                              !DSYEVX
CL        CALL DSYEVX('V',CRNG,'L',NMAX,DU,MAXNJ,VL,VU,IL,IU,EPS !DSYEVX
CL     X              ,MSUB,DEV,DSV,NMAX,WORK,LWORK              !DSYEVX
CL     X              ,IWORK,ISUPP,INFO)                         !DSYEVX
CLC                                                              !DSYEVX
CLC END DSYEVX                                                   !DSYEVX
CLC                                                              !LAPACK
CL        IF(CRNG.NE.'V'.AND.MSUB.NE.NEIGEN)THEN                 !LAPACK
CL          WRITE(6,*)' SR.HDIAG: ERROR IN LAPACK DSYEVX, NOT'   !LAPACK
CL     X             ,' ALL E-VALUES FOUND:',MSUB,NEIGEN         !LAPACK
CL          WRITE(0,*)' SR.HDIAG: FAILURE IN LAPACK DSYEVX'      !LAPACK
CL          IF(INFO.EQ.0)INFO=1                                  !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        NEIGEN=MSUB                                            !LAPACK
CL        NE=NEIGEN                                              !LAPACK
CLC                                                              !LAPACK
CL        IF(MSUB.EQ.0)THEN                                      !LAPACK
CL          DO IS=1,NMAX                                         !LAPACK
CL            DEV(IS)=DZERO                                      !LAPACK
CL            DO JS=1,NMAX                                       !LAPACK
CL              DU(JS,IS)=DZERO                                  !LAPACK
CL            ENDDO                                              !LAPACK
CL          ENDDO                                                !LAPACK
CL          GO TO 100                                            !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        IF(INFO.NE.0)GO TO 100                                 !LAPACK
CLC                                                              !LAPACK
CLC USE DIAG TO RE-ORDER E-VALUES BASED ON DOMINANT E-VECTOR CPTS!LAPACK
CLC                                                              !LAPACK
CL        DO IS=1,NEIGEN                                         !LAPACK
CL          DO JS=1,NMAX                                         !LAPACK
CL            DU(JS,IS)=DSV(JS,IS)                               !LAPACK
CL          ENDDO                                                !LAPACK
CL        ENDDO                                                  !LAPACK
CLC                                                              !LAPACK
CL        CALL DIAG(-NMAX,NEIGEN,IZERO,DU,DEV,WRK,IWRK1,IWRK2    !LAPACK
CL     X            ,MAXNJ)                                      !LAPACK
CLC                                                              !LAPACK
CL        IF(INFO.EQ.0)GO TO 100                                 !LAPACK
CLC                                                              !LAPACK
CLC                                                              !LAPACK
CLC ALL LAPACK                                                   !LAPACK
CLC                                                              !LAPACK
CL        WRITE(6,*)                                             !LAPACK
CL     X    'SR.HDIAG: ERROR, NO SUITABLE LAPACK ROUTINE ACTIVE' !LAPACK
CL        WRITE(0,*)                                             !LAPACK
CL     X    'SR.HDIAG: ERROR, NO SUITABLE LAPACK ROUTINE ACTIVE' !LAPACK
CLC                                                              !LAPACK
CLC   THIS MAY BE DUE TO NONE BEING ACTIVE (BALL=.T.) OR         !LAPACK
CLC   DSYEVX/DSYEVR NOT BEING ACTIVE (BALL-.F.)                  !LAPACK
CLC                                                              !LAPACK
CL        GO TO 2000                                             !LAPACK
CLC                                                              !LAPACK
CL  100   IF(WORK(1).GT.LWORK)THEN                               !LAPACK
CL          LWRK=NINT(WORK(1))                                   !LAPACK
CL          IF(BALL)THEN                                         !LAPACK
CL            WRITE(6,*)                                         !DSYEVD
CL     X     '***OPTIMAL USE OF DSYEVD REQUIRES LWORK=',LWRK     !DSYEVD
CL          ELSE                                                 !LAPACK
CL            WRITE(6,*)                                         !DSYEVR
CL     X     '***OPTIMAL USE OF DSYEVR REQUIRES LWORK=',LWRK     !DSYEVR
CL            WRITE(6,*)                                         !DSYEVX
CL     X     '***OPTIMAL USE OF DSYEVX REQUIRES LWORK=',LWRK     !DSYEVX
CL          ENDIF                                                !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        DEALLOCATE (WORK,IWORK                                 !LAPACK
CL     X             ,DSV                                        !DSYEVR
CL     X             ,DSV                                        !DSYEVX
CL     X             ,STAT=IERR)                                 !LAPACK
CLC                                                              !LAPACK
CL        IF(IERR.NE.0)THEN                                      !LAPACK
CL          WRITE(0,*)                                           !LAPACK
CL     X   ' HDIAG: DEALLOCATION FAILS FOR WORK, LWORK'          !LAPACK
CL          GO TO 7500                                           !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        IF(INFO.NE.0)THEN                                      !LAPACK
CLC                                                              !LAPACK
CL          IF(BALL)THEN                                         !LAPACK
CL            WRITE(6,*)                                         !DGESVD
CL     X     ' SR.HDIAG: ERROR IN LAPACK DGESVD: INFO=',INFO     !DGESVD
CL            WRITE(6,*)                                         !DSYEVD
CL     X     ' SR.HDIAG: ERROR IN LAPACK DSYEVD: INFO=',INFO     !DSYEVD
CL          ELSE                                                 !LAPACK
CL            WRITE(6,*)                                         !DSYEVR
CL     X     ' SR.HDIAG: ERROR IN LAPACK DSYEVR: INFO=',INFO     !DSYEVR
CL            WRITE(6,*)                                         !DSYEVX
CL     X     ' SR.HDIAG: ERROR IN LAPACK DSYEVX: INFO=',INFO     !DSYEVX
CL          ENDIF                                                !LAPACK
CLC                                                              !LAPACK
CL          IF(INFO.GT.0)THEN                                    !LAPACK
CLC                                                              !LAPACK
CL            IF(BALL)THEN                                       !LAPACK
CLC                                                              !LAPACK
CL              write(6,*)'Lowest SVDs:'                         !DGESVD
CL              do is=nmax,nmax-10,-1                            !DGESVD
CL                write(6,*)is,dev(is)                           !DGESVD
CL              enddo                                            !DGESVD
CLC                                                              !LAPACK
CL              WRITE(6,*)' DSYEVD: FAILED TO CONVERGE'          !DSYEVD
CL              I1=INFO/(NMAX+1)                                 !DSYEVD
CL              I2=MOD(INFO,NMAX+1)                              !DSYEVD
CL              WRITE(6,1000)I1,I2,NMAX                          !DSYEVD
CLC                                                              !LAPACK
CL            ELSE                                               !LAPACK
CLC                                                              !LAPACK
CL              WRITE(6,*)' DSYEVR: FAILED TO CONVERGE'          !DSYEVR
CL              WRITE(6,*)' NO DETAILS...'                       !DSYEVR
CL              WRITE(6,*)' DSYEVX: FAILED TO CONVERGE'          !DSYEVX
CL              WRITE(6,1010)(ISUPP(I),I=1,INFO)                 !DSYEVX
CLC                                                              !LAPACK
CL            ENDIF                                              !LAPACK
CLC                                                              !LAPACK
CLc            do is=1,nmax                                      !LAPACK
CLc              write(6,1001)is,(du(js,is),js=1,nmax)           !LAPACK
CLc 1001 format(i5,1p,10d12.4/(5x,10d12.4))                      !LAPACK
CLc            enddo                                             !LAPACK
CLC                                                              !LAPACK
CL            RETURN               !RELOAD AND TRY DIAG          !LAPACK
CLC                                                              !LAPACK
CL          ELSE                          !BAILOUT               !LAPACK
CLC                                                              !LAPACK
CL            IF(BALL)THEN                                       !LAPACK
CL              WRITE(0,*)                                       !DSYEVD
CL     X       ' SR.HDIAG: FAILURE IN LAPACK ROUTINE DSYEVD'     !DSYEVD
CL            ELSE                                               !LAPACK
CL              WRITE(0,*)                                       !DSYEVR
CL     X       ' SR.HDIAG: FAILURE IN LAPACK ROUTINE DSYEVR'     !DSYEVR
CL              WRITE(0,*)                                       !DSYEVX
CL     X       ' SR.HDIAG: FAILURE IN LAPACK ROUTINE DSYEVX'     !DSYEVX
CL            ENDIF                                              !LAPACK
CL            GO TO 2000                                         !LAPACK
CLC                                                              !LAPACK
CL          ENDIF                                                !LAPACK
CLC                                                              !LAPACK
CL        ENDIF                                                  !LAPACK
CLC                                                              !LAPACK
CL        IF(ALLOCATED(ISUPP))DEALLOCATE (ISUPP)                 !LAPACK
CLC                                                              !LAPACK
CLC END LAPACK                                                   !LAPACK
CLC                                                              !LAPACK
CL  200   CONTINUE                                               !LAPACK
C
C HOUSEHOLDER+QL DIAGONALIZATION
C
        IF(INFO.GT.0)THEN
          INFO=0                            !RESET
C
          IF(.NOT.BALL.AND.IWARN.EQ.0)THEN
c            WRITE(0,*)'*** ATTENTION: SR.HDIAG COMPUTES ALL E-STATES,'
c     X       ,' REQUIRE LAPACK VERSION TO RESTRICT - NO MORE WARNINGS'
            WRITE(6,*)'*** ATTENTION: SR.HDIAG COMPUTES ALL E-STATES,'
     X       ,' REQUIRE LAPACK VERSION TO RESTRICT - NO MORE WARNINGS'
            IWARN=1
          ENDIF
C
          CALL DIAG(NMAX,NMAX,IZERO,DU,DEV,WRK,IWRK1,IWRK2,MAXNJ)
C
        ENDIF
C
        DEALLOCATE (IWRK1,IWRK2,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)' HDIAG: DE-ALLOCATION FAILS FOR IWRK1,IWRK2'
          GO TO 7600
        ENDIF
C
C DIAG FAILURE, SO RETURN & RELOAD AND USE JACORD
C
        IF(NMAX.EQ.0)RETURN
C
      ENDIF
C
C SLOW BUT ROBUST JACOBI METHOD
C
      IF(IDIAG.GT.0)THEN
C
        ALLOCATE (DSV(MAXNJ,MAXNJ),STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)' HDIAG: ALLOCATION FAILS FOR DSV'
          GO TO 7600
        ENDIF
C
        NMAX=-NMAX
        BEIVEC=.TRUE.
C
        CALL JACORD(NMAX,BEIVEC,DU,DSV,MAXNJ)
C
        DO IS=1,NMAX
          DEV(IS)=DU(IS,IS)
          DO JS=1,NMAX
            DU(JS,IS)=DSV(JS,IS)
          ENDDO
        ENDDO
C
        DEALLOCATE (DSV,STAT=IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)' HDIAG: DEALLOCATION FAILS FOR DSV'
          GO TO 7600
        ENDIF
C
      ENDIF
C
      RETURN
C
CL 2000 NF=-1                                                    !LAPACK
CL      RETURN                                                   !LAPACK
CLC                                                              !LAPACK
CL 7500 NF=0                                                     !LAPACK
CL      RETURN                                                   !LAPACK
C
 7600 NF=0
      RETURN
C
CL 1000 FORMAT                                                   !DSYEVD
CL     X(/'DSYEVD: ALGORITHM FAILED TO COMPUTE AN EIGENVALUE '   !DSYEVD
CL     X,'WHILE WORKING ON THE SUBMATRIX LYING IN ROWS AND '     !DSYEVD
CL     X,'COLUMNS',I5,' THROUGH',I5,' FOR MATRIX OF RANK',I5/)   !DSYEVD
CLC                                                              !LAPACK
CL 1010 FORMAT                                                   !DSYEVX
CL     X(/'DSYEVX: ALGORITHM FAILED TO CONVERGE THE EIGENVECTORS'!DSYEVX
CL     X/(10I8))                                                 !DSYEVX
C
      END SUBROUTINE HDIAG
C
C                             *******************
C
      SUBROUTINE HPSRTI(N,A,IP)
C
C-----------------------------------------------------------------------
C
C SR .HPSRTI CARRIES OUT AN IMPLICIT HEAPSORT  BY *MAGNITUDE*
C
C INPUT:  VECTOR A, LENGTH N.
C OUTPUT: DOWN-ORDERED POINTER IN IP, A IS UNCHANGED.
C        (UP-ORDERED CAN BE OBTAINED BY CHANGING .LT. TO .GT. AS BELOW).
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(*),IP(*)
C
      DO I=1,N
        IP(I)=I
      ENDDO
C
      IF(N.LT.2)RETURN
C
      L=N/2+1
      IT=N
C
  1   IF(L.GT.1)THEN
        L=L-1
        IPT=IP(L)
      ELSE
        IPT=IP(IT)
        IP(IT)=IP(1)
        IT=IT-1
        IF(IT.EQ.1)THEN
          IP(1)=IPT
          RETURN
        ENDIF
      ENDIF
      I=L
      J=L+L
C
  2   IF(J.LE.IT)THEN
        IF(J.LT.IT)THEN
          IF(abs(A(IP(J+1))).lT.abs(A(IP(J))))J=J+1  !.lt. down, .gt .up
        ENDIF
        IF(abs(A(IP(J))).lT.abs(A(IPT)))THEN         !.lt. down, .gt .up
          IP(I)=IP(J)
          I=J
          J=J+J
        ELSE
          J=IT+1
        ENDIF
        GO TO 2
      ENDIF
      IP(I)=IPT
      GO TO 1
C
      END SUBROUTINE HPSRTI
C
C                             *******************
C
      SUBROUTINE INTRPG(ARG,VAL,X,N,Y)
C
C-----------------------------------------------------------------------
C
C  Uses Lagrange interpolation formula to obtain value of VAL(X).
C  ARG(I),VAL(I) ,I=1,N contain the data values.
C
C  No subroutines called.
C
C  PHN's GRASP0 routine
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION ARG(N),VAL(N)
C
      Y=DZERO
      DO L=1,N
        PL=DONE
        DO J=1,N
          IF(L.NE.J)PL=(X-ARG(J))*PL/(ARG(L)-ARG(J))
        ENDDO
        Y=Y+PL*VAL(L)
      ENDDO
C
      END SUBROUTINE INTRPG
C
C                             *******************
C
      SUBROUTINE JACORD(N,BEIVEC,A,V,MXMAT)
C
C-----------------------------------------------------------------------
C
C  SR.JACORD CALCULATES EIGENVALUES AND EIGENVECTORS OF A REAL-SYMMETRIC
C  MATRIX A WITH THE METHOD OF JACOBI. RE-WRITTEN JUN96 NRB.
C
C  INPUT:
C  N=ORDER OF THE MATRIX A TO BE DIAGONALISED.
C  BEIVEC=.TRUE.EIGENVECTORS WANTED,=.FALSE.NO EIGENVECTORS WANTED.
C
C  RESULTS:
C  V(I,K),I=1,N EIGENVECTORS TO A(K,K)=EIGENVALUE.
C  THE ORIGINAL A IS DESTROYED. THE EIGENVALUES WILL BE ORDERED-
C  A(K,K).LT.A(I,I) FOR K.LT.I BUT IF N.LT.0 NO REORDERING TAKES PLACE,
C  IN THAT CASE N=-N AT THE BEGINNING.
C
C  JACORD AND ROTSYM ARE BASED ON ALGOL PROCEDURES WRITTEN BY
C  RUTISHAUSER AT THE ETH (ZURICH, SWITZERLAND). FOR AN IMPROVED
C  VERSION SEE  RUTISHAUSER,NUMER.MATH.9(1966)1-10.
C
C*****IF JACORD FAILS THEN IT IS PROBABLY RETURNING TOO SOON, REDUCE
C*****PARAMETER TOL BELOW, UNLESS NMAX SWEEPS OCCURRED - LOOK FOR
C*****WARNING WRITTEN BY FORMAT 100 - THIS IS EXTREMELY UNLIKELY DUE
C*****TO THE QUADRATIC CONVERGENCE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (EPS=1.0D-11)
      PARAMETER (TOL=EPS*EPS)              ! ***  TOL  ***
      PARAMETER (STOL=1.0D-2*EPS)
      PARAMETER (XBIG=3.16D19)
      PARAMETER (NMAX=50)
C
      DIMENSION A(MXMAT,MXMAT),V(MXMAT,MXMAT)
C
      BNOGT=N.LT.0
      IF(BNOGT) N=-N
C
      IF(BEIVEC)THEN
        DO K=1,N
          DO L=1,N
            V(K,L)=DZERO
          ENDDO
          V(K,K)=DONE
        ENDDO
      ENDIF
C
      I=1
      IF(N.EQ.1)GO TO 9                     !EXIT FAST
C
C
C  NMAX IS THE NUMBER OF SWEEPS
C  IT IS VIRTUALLY INDEPENDENT OF THE ORDER N.
C
      DO I=1,NMAX
C
        SS=DZERO
        DO K=1,N-1
          DO L=K+1,N
            SS=A(K,L)*A(K,L)+SS
          ENDDO
        ENDDO
C
        IF(SS.LT.TOL)GO TO 9                     !EXIT
C
        TRESH=DZERO
        IF(I.LT.4)TRESH=DONE*SQRT(SS)/(DFIVE*N**2)
C
        DO K=1,N-1
C
          DO L=K+1,N
C
            AKK=A(K,K)
            ALL=A(L,L)
            AKL=A(K,L)
            T=ABS(AKL)/STOL
C
            IF(I.GT.4.AND.ABS(AKK).GE.T.AND.ABS(ALL).GE.T)A(K,L)=DZERO
C
            IF(ABS(A(K,L)).GT.TRESH)THEN
C
              THETA=(ALL-AKK)/(DTWO*AKL)
C
              IF(ABS(THETA).GT.XBIG)THEN
                T=DONE/(DTWO*THETA)
              ELSE
                T=ABS(THETA)+SQRT(THETA*THETA+DONE)
                IF(THETA.LE.DZERO) T=-T
                T=DONE/T
              ENDIF
C
              C=DONE/SQRT(T*T+DONE)
              S=T*C
C
              CALL ROTSYM(N,N,BEIVEC,C,S,K,L,A,V,MXMAT)
C
              A(K,L)=DZERO
C
            ENDIF
C
          ENDDO
C
        ENDDO
C
      ENDDO
C
      WRITE(6,100)NMAX,SS
C
    9 CONTINUE                                    !CONVERGED
C
C      WRITE(6,101)N,I-1
C
      IF(BNOGT)RETURN
C
C RE-ORDER INTO ASCENDING E-VALUES (& VECTORS)
C
      DO I=1,N
        K=I
        P=A(I,I)
        DO J=I+1,N
          IF(A(J,J).LT.P)THEN
            K=J
            P=A(J,J)
          ENDIF
        ENDDO
        IF(K.NE.I)THEN
          A(K,K)=A(I,I)
          A(I,I)=P
          DO J=1,N
            P=V(J,I)
            V(J,I)=V(J,K)
            V(J,K)=P
          ENDDO
        ENDIF
      ENDDO
C
C
      RETURN
C
  100 FORMAT(' POSSIBLE INACCURACY IN JACORD, AFTER',I3,' SWEEPS'
     X,' SUM OF OFF-DIAGONAL ELEMENTS IS:',1PD10.2)
C  101 FORMAT(' MATRIX ORDER N=',I5,' REQUIRED',I3,' SWEEPS')
C
      END SUBROUTINE JACORD
C
C                             *******************
C
      SUBROUTINE LAGINT(DE0,DDY,NPOUT1,NPOUT2)
C
C-----------------------------------------------------------------------
C
C SR.LAGINT DETERMINES INTERPOLATION COEFFICIENTS DDY(N=NP1,NP2) FOR
C           BOUND-CONTINUUM INTEGRALS AT ENERGY DE0.
C
C  USES NLAG-POINT LAGRANGE INTERPOLATION FORMULA
C  NLAG MUST BE AN EVEN NUMBER .GE. 4 . READ IN SRADCON.
C  DEFAULT:   NLAG=6.
C  IF MENG.EQ.1 THEN NO INTERPOLATION (& NLAG NOT IUSED)
C
C-----------------------------------------------------------------------
C
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DDY(MENG)
C
      DATA INIT/0/
      SAVE NLAG2,NP1,NP2,NPH,BBC1
C
C INITIALIZE
C
      IF(INIT.EQ.0)THEN
        NLAG2=NLAG-2
        NP1=1
        NP2=MAX(IONE,NLAG)
        NPH=NP2/2
        BBC1=MENG.LE.NP2
        IF(BBC1)NP2=MENG
        DDY(1)=DONE                               !FOR .NOT.BLAG
        INIT=1
      ENDIF
C
      DE=ABS(DE0)
C
      IF(.NOT.BBC1)THEN
        DO L=1,MENG
          IF(DYY(L).GE.DE)THEN
            LP=L
            GO TO 412
          ENDIF
        ENDDO
        LP=MENG
C
  412   IF(.NOT.BBC2)THEN
          NP2=LP+NPH-1
          NP1=LP-NPH
          IF(NP1.LE.0)THEN
            NP2=NP2-NP1+1
            NP1=1
          ELSEIF(NP2.GT.MENG)THEN
            NP1=NP1-NP2+MENG
            NP2=MENG
          ENDIF
        ELSE
          NP2=LP
          NP1=LP-1
          DO M=1,NLAG2
            IF(NP2.EQ.MENG)THEN
              NP1=NP2-NLAG+1
              GO TO 414
            ELSEIF(NP1.LE.1)THEN
              NP2=NLAG
              NP1=1
              GO TO 414
            ELSE
              DD=DYY(NP2+1)-DE
              DSJ=DE-DYY(NP1-1)
              IF(DD.LE.DSJ)NP2=NP2+1
              IF(DD.GT.DSJ)NP1=NP1-1
            ENDIF
          ENDDO
  414     CONTINUE
        ENDIF
      ENDIF
C
      NPOUT1=NP1
      NPOUT2=NP2
C
      IF(DE0.LT.0)RETURN
C
C SET INTERPOLATION COEFFICIENTS
C
      DO L=NP1,NP2
        DD=DONE
        DO M=NP1,NP2
          IF(L.NE.M)THEN
            DD=DD*(DE-DYY(M))
            DD=DD/(DYY(L)-DYY(M))
          ENDIF
        ENDDO
        DDY(L)=DD
      ENDDO
C
      RETURN
C
      END SUBROUTINE LAGINT
C
C                             *******************
C
      SUBROUTINE LDFGX(M,L,DP,DQ,MAXRS,BREL,BREL2)
C
C-----------------------------------------------------------------------
C
C  SR.LDFGX LOADS THE ORBITAL DP INTO DPNL(I,L) AND, IF BREL2,
C  DQ INTO DQNL(I,L) FOR ACCESS BY THE NFS- INTEGRAL ROUTINES.
C  IF BREL BUT .NOT.BREL2 THEN CREATES DQNL FROM DTOT=2(V-Z/X), WILL
C  NEED MODIFYING FOR DIFFERENT DPOT CONTENTS. FINALLY, SETS DEY.
C  COULD BE ADAPTED FOR OTHER USES.
C
C-----------------------------------------------------------------------
C
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DP(*),DQ(*)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
C
      IF(BREL)THEN               !DUY SHOULD BE ZERO, BUT JUST INCASE...
        DEY(L)=DYY(M)/DTWO+DUY(L,L)
        IF(BREL2)THEN
          DO I=1,MAXRS
            DPNL(I,L)=DP(I)
            DQNL(I,L)=DQ(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DPNL(I,L)=DP(I)
            DQNL(I,L)=DP(I)*(DPOT(I)+DYY(M))
          ENDDO
        ENDIF
      ELSE
        DO I=1,MAXRS
          DPNL(I,L)=DP(I)
        ENDDO
      ENDIF
C
      RETURN
C
      END SUBROUTINE LDFGX
C
C                             *******************
C
      SUBROUTINE MESH (NZION,MION,TOLR,DHNS0,DX,IFLAGR)
C
C-----------------------------------------------------------------------
C
C  SR.MESH SETS-UP THE RADIAL MESH - IT IS A DOUBLING MESH.
C
C IFLAGR I/O CONTROLS OPERATION:
C      .GT. 0 FULLY DETERMINES THE MESH VIA /CRAD/ AND DX.
C      .EQ. 0 DOES NOT TOUCH DX, DETERMINES MAXRS FOR ITS ALLOCATION.
C      .LT. 0 DOES NOT CHANGE THE MESH, JUST RESETS IFLAGR TO LAST MAXRS
C      .GE. 0 IS UNCHANGED ON RETURN.
C
C  INPUT:
C      NZION - NUCLEAR CHARGE
C      MION  - TOTAL NUMBER OF ELECTRONS
C      TOLR  - THE VALUE A RADIAL FUNCTION MUST DECAY TO BEFORE TAKEN
C              AS ZERO; THE MOST DIFFUSE ORBITAL (DETERMINED HERE BY
C              THE COULOMB SR.WHITEX) SETS THE MESH EXTENT
C  OUTPUT:
C      DHNS0 - THE INITIAL STEP
C      DX(I),I=1,MAXRS - THE MESH
C      DHNS(I),MNH(I),I=1,MJH - THE STEP LENGTH & NO OF POINTS PER
C                               INTERVAL I IS OUTPUT IN /CRAD/
C
C  IT CALLS:
C    SR.DIMUSE
C    FN.WHITEX
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD12=100)
C
      PARAMETER (DCON0=1.625D0)
      PARAMETER (DCON6=0.2387D0)                       !1/(4*pi/3)
C
      PARAMETER (MAXA=MAXB1)                       !FOR REMAINING COMMON
C      PARAMETER (MAXA=999999)          !EVTLY JUST LIMIT OUT-OF-CONTROL
      PARAMETER (MJH0=10)                      !SEE DATA STATEMENT BELOW
C
      DIMENSION MNH0(MJH0),DX(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CADJ/DAJNEW(MXVAR),DF0,IEQUAL(MXVAR),ICOUNT
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax0
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
C SET UP THE INTERVALS (STEP IS CONSTANT WITHIN AN INTERVAL)
C NOTE: ANY VALUE MNH0(J).LT.9 STEPS PER INTERVAL J WILL CAUSE TROUBLE;
C   SO WILL A NUMBER MJH0.LT.2 OF INTERVALS; MJH0.LE.DIM(MNH0,MNH,DHNS)
C   SR.TFDAPO REQUIRES LAST INTERVAL TO HAVE AT LEAST TWICE AS MANY
C   POINTS AS THE PENULTIMATE.
C
C MJH0=10
C      DATA
C     X   MNH0(1),MNH0(2),MNH0(3),MNH0(4),MNH0(5) /32,32,64,64,64/,
C     X   MNH0(6),MNH0(7),MNH0(8),MNH0(9),MNH0(10)/64,64,64,256,9296/
C MJH0=10
      DATA
     X    MNH0(1),MNH0(2),MNH0(3),MNH0(4),MNH0(5) /32,32,32,32,32/,
     X    MNH0(6),MNH0(7),MNH0(8),MNH0(9),MNH0(10)/32,32,32,512,9232/
C MJH0=11
C      DATA
C     X    MNH0(1),MNH0(2),MNH0(3),MNH0(4),MNH0(5)/16,16,32,32,32/,
C     X    MNH0(6),MNH0(7),MNH0(8),MNH0(9),MNH0(10)/32,32,32,64,128/,
C     X    MNH0(11)/9616/
C
      DATA MXTRA/32/
C
C      DATA H0/-1/,NPOLD/0/                 !OLD COULD RE-USE OLD-L MESH
C
      SAVE H0,NPOLD                          !NOW L-LOOP RE-ALLOCATES DX
      save xmax,V0,mred,MAXRS0
C
      IF(IFLAGR.LT.0)THEN                 !JUST RETURN LAST VALUE SET-UP
        IFLAGR=MAXRS0
        RETURN
      ENDIF
c
c Estimate how far out the radial mesh should extend.
c This is for efficiency as the maximum allowed by dimensions can be
c very large, unnecessarily so in many cases.
c
      IF(IFLAGR.eq.0.and.xmax0.lt.dzero)THEN            !.and..NOT.BJUMP
        BDR=IDR.NE.0
        if(bdr)then
          mred=1
        else
          mred=0
        endif
        nza=max(ione,nzion-mion+1)                   !mion since Rydberg
        bnorm=.false.                          !silence stupid compilers
c
        if(bdr)then
          lm=lnew*2
        else
          lm=0
        endif
        nm=1
        np=0
        do m=1,mxorb
          if(dey(m).ne.dzero)then
            if(bdr)then
              if(ival(m).ne.0)lm=min(lm,INT(ql(m),SP))
            else
              if(abs(qn(m)).lt.80)then
                if(mort.eq.-4.and.dajnew(m).lt.dzero)then           !LPS
c                 lp=min(lp,ql(m))
                  np=max(np,mod(INT(qn(m),SP),i70))
                else
c                  lm=min(lm,ql(m))
                  nm=max(nm,mod(INT(qn(m),SP),i70))
                endif
              else
                mred=1
              endif
            endif
          endif
        enddo
        lm=lm/2
c
        xoutp=dzero
        if(bdr)then
          nout=nmax
          if(jnd.gt.0)nout=ndr(jnd)
          if(nsw.gt.0)nout=min(nout,nsw)
        else
          nout=nm
          if(np.gt.0)then
            xoutp=np
            xoutp=4*xoutp/nza
          endif
        endif
        ll=min(lm,nout-1)
        tl=ll
        tll=ll*(ll+1)
        xout=nout
        xout=xout*xout
        xout=2*xout/nza
c        write(0,*)nout,lm,nza,xout,xoutp
        if(xout.gt.xoutp)then
          xmax=xout
          dza=nza
          e=-2*dza/xout
        else
          xmax=xoutp
          dza=nza*np/2
          e=dza/np
          e=-e*e
        endif
c
        xmax=1.4d0*xmax
  10    xmax=1.1d0*xmax
c        write(0,*)xmax,tl,tll,e,dza,bnorm
        pmax=whitex(xmax,tl,tll,e,dza,bnorm)
        if(.not.bnorm)then
          pmax=dzero
          xmax=1.d10
c         stop 'sr.mesh: radial/whitex/norm'
        endif
c        write(0,*)xout,xmax,pmax,nout
        if(abs(pmax).gt.tolr/10)go to 10
        xmax=max(xmax,rzero)
c
c        if(mden.lt.-1)xmax=1.2*xmax        !self-consistent may expand
c         xmax=max(xmax,-xmax0)
c
        if(mden.gt.0)then
          if(gamq.gt.d1m2)then
            if(mod(mden,iten).eq.1)then
              t=debye
            else
              t=(dcon6/deni)**(done/dthree) !r0
            endif
          else
            t=dzero                         !use zero density...
            if(dene.gt.dzero)then
              write(6,*)
     x       'Plasma density too low, using zero-density radial mesh...'
              write(0,*)
     x       'Plasma density too low, using zero-density radial mesh...'
            endif
         endif
c          write(0,*)mden,gamq,nza,t
c          if(t.lt.100)then                 !don't go mad - use gamq now
          xmax=max(xmax,t)
          xmax0=xmax
c          endif
        endif
      elseif(xmax0.gt.dzero)then
        xmax=xmax0
      ENDIF
C
C SET INITIAL STEP:
C  EXPERIENCE HAS SHOWN THAT THIS LENGTH FOR THE FIRST
C  INTERVAL GIVES IN MOST CASES A REASONABLE INTERVAL SET-UP.
C
C  MSTEP IS SET IN SR.MINIM0 AND DEPENDS ON SCATTERING PROBLEM.
C  IXTRA ADDS EXTRA INTERVALS CLOSE TO THE ORIGIN WHEN KAPPA-AVERAGED
C  RELATIVISTIC ORBITAL ARE IN USE.
C
      IF(DHNS(1).LE.DZERO)THEN                               !FIRST PASS
C
        MJH=MJH0+IXTRA                         !MAX POSS NO OF INTERVALS
        IF(MJH.GT.20)THEN
          WRITE(6,*)'SR.MESH: INCREASE NO OF INTERVALS IN /CRAD/ TO',MJH
          WRITE(0,*)'SR.MESH: INCREASE NO OF INTERVALS IN /CRAD/'
          GO TO 999                                               !ABORT
        ENDIF
C
        H0=-DONE
        NPOLD=0
C
        IF(DHNS(1).EQ.DZERO)THEN
          NZA=NZION-(MION-MRED)                    !IGNORES ANY RYD/CONT
          NZA=NZA+1
C
          DHNS(1)=(DCON0/NZION)**(DONE/DTHREE)/
     X          ((2**(MSTEP+IXTRA))*NZA**(DTWO/DTHREE))
C
c        write(0,*)mstep,ixtra,mion,nza,dhns(1)
c
        ELSE                                        !ALREADY SET BY USER
          DHNS(1)=-DHNS(1)
        ENDIF
C
        V0=DTWO
        IF(ABS(MAUTO).GE.100)THEN
          V0=MAUTO
          V0=V0/D1P2
          IF(V0.LT.DZERO)V0=-V0
        ENDIF
C
      ENDIF
C
      DHNS0=DHNS(1)
      h=dhns0
C
C MAXRS=NUMBER OF POINTS FOR WHICH THE RADIAL FUNCTIONS WILL BE
C  CALCULATED; MJH INTERVALS WITH MNH(I),I=1,MJH STEPS
C***NEED TO RE-DO FOR EACH N (DR-LOOP) BECAUSE RADCON REDUCES MNH(MJH)
C  (AND SO, HISTORICALLY, MAXRS WAS NOT EXPLICITLY SAVED)
C
      MAXRS=0
      x=dzero
c      xmax=1.d10                                  !test
c
      DO IX=1,IXTRA
        MAXRS=MAXRS+MXTRA
        MNH(IX)=MXTRA
        x=x+mnh(ix)*h
        h=v0*h
      ENDDO
      MJH=IXTRA
C
      DO J=1,MJH0
        JX=J+IXTRA
        L=MAXRS
        M=MAXRS+MNH0(J)
        IF(J.EQ.MJH0.OR.M+9.GT.MAXA)M=MAXA
        MAXRS=MIN(M,MAXA)
        MNH(JX)=M-L
        IF(MNH(JX).GT.0)MJH=JX
        x=x+mnh(jx)*h
        if(x.gt.xmax)then
          if(j.lt.mjh0)go to 15                          !simple bailout
          t=(x-xmax)/h
          nxtra=int(t)
          nxtra=mnh(jx)-nxtra
          nxtra=max(nxtra,ININE)
          if(.not.bsto)nxtra=max(nxtra,2*mnh(jx-1))    !to initialize dx
          maxrs=l+nxtra
          if(maxrs.gt.maxa)then
            nxtra=nxtra-maxrs+maxa
            maxrs=maxa
          endif
          mnh(jx)=nxtra
c
c          write(0,*)m-l,nxtra,m,maxrs
c          istep=0
c          do i=1,mjh
c            istep=istep+mnh(i)
c          enddo
c          if(maxrs.ne.istep)write(0,*)maxrs,istep     !shouldn't be so!
c
        endif
        h=v0*h
      ENDDO
C
  15  continue
C
      IF(MJH.EQ.1)THEN            !TOO MANY STEP DOUBLES, OUT OF CONTROL
        WRITE(6,*)'*** SR.MESH: INVALID MESH - OPTIMIZATION UNBOUNDED?'
        WRITE(0,*)'*** SR.MESH: INVALID MESH - OPTIMIZATION UNBOUNDED?'
        GO TO 999
      ENDIF
C
      IF(IFLAGR.EQ.0)GO TO 900                        !FOR ALLOCATE ONLY
C
C NOW SET UP THE X ARRAY:
C  DX=STEP LENGTH IN THE FIRST INTERVAL (I=1)
C  THE STEP LENGTH DOUBLES FROM ONE INTERVAL TO THE NEXT.
C  IF !MAUTO! .LT.100, OTHERWISE STEP INCREASES BY FACTOR MAUTO/100
C
      H=DHNS0
      IF(NINT(H/H0).NE.1.OR.MAXRS.gt.NPOLD)THEN
C
        ISTEP=0
        XB=DZERO
        DO J=1,MJH
          DHNS(J)=H
          II=MNH(J)
          DO I=1,II
            ISTEP=ISTEP+1
            XB=XB+H
            DX(ISTEP)=XB
          ENDDO
c        write(6,*)istep,h,xb
          H=V0*H
        ENDDO
        H0=DHNS0
C
C THE FOLLOWING CHECK IS REDUNDANT HERE...
        IF(MAXRS.LE.0)MAXRS=ISTEP
        IF(ISTEP.NE.MAXRS)THEN
          WRITE(6,992)
          WRITE(0,992)
          GO TO 999
        ENDIF
C
        NPOLD=MAXRS                                !THIS IS NEEDED STILL
      ENDIF
C
C CHECK RZERO
C
      IF(RZERO.GT.DZERO.AND.MXBOX.EQ.0)THEN
        DO I=1,MAXRS
          IF(DX(I).GT.RZERO)THEN
            MXBOX=I-MOD(I+1,ITWO)                     !KEEP ODD
            GO TO 51
          ENDIF
        ENDDO
        MXBOX=MAXRS
C
   51   MAXRS=0
        I0=MJH
        DO I=1,I0
          MAXRS=MAXRS+MNH(I)
          MJH=I
          IF(MAXRS.EQ.MXBOX)GO TO 53
          IF(MAXRS.GT.MXBOX)THEN
            MAXRS=MAXRS-MNH(I)
            MNH(I)=MAX(MXBOX-MAXRS,ININE)
            MAXRS=MAXRS+MNH(I)
            GO TO 53
          ENDIF
        ENDDO
   53   MXBOX=MAXRS
      ENDIF
C
  900 MAXRS0=MAXRS
C
      CALL DIMUSE('MAXB1',MAXRS)
C
      RETURN
C
  999 NF=-1
      RETURN
C
  992 FORMAT('SR.MESH: MAXRS INCOMPATIBLE WITH MNH,MJH')
C
      END SUBROUTINE MESH
C
C                             *******************
C
      SUBROUTINE MINIM
C
C-----------------------------------------------------------------------
C
C  SR.MINIM CONTROLS THE SECOND, ANALYTIC BRANCH VIZ. HAMILTONIAN SET-UP
C  DETERMINATION OF ENERGIES, RADIATIVE & AUTOIONIZATION RATES PLUS
C  PHOTOIONIZATION CROSS SECTIONS AND FINITE ENERGY BORN EXCITATION.
C
C  IT CALLS:
C    SR.CARATE
C    SR.CASC
C    SR.CAVE0
C    SR.CGNA
C    SR.CGNR (INTERFACE ONLY)
C    SR.DIAGFS
C    SR.DIAGON
C    SR.MESH
C    SR.MINIM0
C    SR.RADIAL
C    SR.SOCC
C    SR.VA04A
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CACC,   ONLY: BACC,ACC
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_COEFF,  ONLY: BCOEFF,DRKP,QRLP,IRLP,NRKP,NADP
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: BDMQSS3,DSS,MSS,QSS,NADR
      USE COMMON_DXRL,   ONLY: BDXRL,DRK,QRL,IRL,NRK,NAD
      USE COMMON_INTS,   ONLY: DRL,DOSC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: BRADF,DPNL,DUY,DX,DORIG,MXPIN
      USE COMMON_REL,    ONLY: BNF1,DMASS,DCD,D2LL
      USE COMMON_RELINT, ONLY: BRELINT1,BRELINT2,DRLP1,DNL
      USE COMMON_TRANS,  ONLY: TFU
      USE COMMON_NRBCAS, ONLY: BCASC,AP,MADD,IXNOR
      USE COMMON_NRBDQE, ONLY: BNRBDQE,DQNL,MXQIN
      USE COMMON_NRBEKP, ONLY: BNRBEKP,NED
      USE COMMON_NRBFSI, ONLY: BNRBFSI,DNLI,NLI,IXFSS
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2,IXFSL
      USE COMMON_NRBMKP, ONLY: BNRBMKP,NMD1,NMD2
      USE COMMON_NRBNF1, ONLY: BNRBNF1,DEK,BFALL
      USE COMMON_NRBNF2, ONLY: BNRBNF2,DETA,DXSI,DZL,DXTWO
      USE COMMON_NRBNFI, ONLY: BNRBNFI,DZLI,DXTWOI,DETAI,FRI,GRI
      USE COMMON_NRBOLP, ONLY: BNRBOLP,OVLPGR,OVLPCF,IPAIR
      USE COMMON_NRBORN, ONLY: BNRBORN,BL,OBO,TM2,IXBLM
      USE COMMON_NRBRN1, ONLY: BNRBRN1,SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK
      USE COMMON_NRBRN2, ONLY: BNRBRN2,BINDB,MENGB
      USE COMMON_NRBTS1, ONLY: DFOT,DFOTm,DFOSS,NFOSS,IGAG,IXD24
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C      PARAMETER (MXD09=MXBLM+2)                           !+2 CASE BREL
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
      PARAMETER (MXD15=100)
C
      PARAMETER (DEL=1.D-6)                            !SYNC WITH RADIAL
      PARAMETER (D5M6=5.0D-6)
C
      PARAMETER (DCON2=1.5789D5)                       !1/k (K/Ryd)
      PARAMETER (DCON3=5.29177D-9)                     !a0 (cm)
      PARAMETER (DCON4=3.224D0)                        !(32*pi/3)**1/3
      PARAMETER (DCON5=25.1327D0)                      !8*pi
      PARAMETER (DCON6=0.2387D0)                       !1/(4*pi/3)
C
C ASSIGN UNIT NUMBERS
C
      PARAMETER (MW=7)                                       !ols
      PARAMETER (MWP=MW+1)                                   !oic
      PARAMETER (MWW=MW+10)                                  !opls
      PARAMETER (MWPW=MWP+10)                                !opic
      PARAMETER (MWU=MW+20)                                  !olsu
      PARAMETER (MWPU=MWP+20)                                !oicu
      PARAMETER (MWWU=MWU+2)                                 !oplsu
      PARAMETER (MWPWU=MWPU+2)                               !opicu
C
      CHARACTER(LEN=4) CODE,MBLK
      CHARACTER(LEN=5) NAM0
      CHARACTER(LEN=10) NAM
cparc                                                               !par
cpar      character(len=1) :: num(0:9)                              !par
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      DIMENSION DEXTRE(MXVAR),DACCUR(MXVAR),dum1(1)
C
      COMMON /BASIC/NF,KVAR,MGAP1(5),NLEV,MGAP2(3),IGAUGE
      COMMON /CADJ/DAJNEW(MXVAR),DF0,IEQUAL(MXVAR),ICOUNT
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM4/DUM4(MAXB1)
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRL/IRK,IRK0,IOS,IOS0
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /TRANLS/NADRU(MAXTM),NAI(MAXTM),NC0,IEORD(MAXTM)
      COMMON /WEIGHT/WGHT(MAXTM),INDEXW(MAXTM)
      COMMON /CALAN/DALAN(MXVAR),BALAN
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV0
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBEXT/BHFF
      COMMON /NRBFAN/BFANO
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBFR/FR(MAXB1)
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBNV/MAXNV
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPLS/DENSI(MXD15),DENS(MXD15),TKAYS(MXD15),NDEN
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBPOT/POT(MAXB1,MXPOT),JPOT1
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBSPL/DSP1(MAXB1),DSP2(MAXB1),DSP3(MAXB1),DSP4(MAXB1)
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBTCC/TOLTCC,KTCC,MTCC,NTCC,NNRGLS
      COMMON /NRBTRN/NENERG,JORIG(MAXLV)
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
      COMMON /NRBZSP/ZESP(MAXLL),IZESP,NWRM
c
cpar      common /nrbpar/niam,liam,jiam,lproc,nprocperl,mapiam      !par
      common /nrbone/ione1,ione0
      common /nrbtim/iw,iwp,btime,btimex
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
c
      common /hps/badas
C
      COMMON /PJSLIM/ECNTRB,ITANAL
C
      DATA ICON,IPRINT/2,1/,MBLK/'    '/,BWARN/.TRUE./
C      DATA ECAVX(1)/0.0/,ECAV(1)/0.0/
cparc                                                               !par
cpar      data num/'0','1','2','3','4','5','6','7','8','9'/         !par
c
      btimet=.false.                        !.t. gives more detailed
C
      NF00=NF
      IF(NF.EQ.0)THEN                       !CALL WAS ONLY TO DEALLOCATE
        NF=1
        GO TO 1005                                               !RETURN
      ENDIF
C
C-----------------------------------------------------------------------
C
C SET MAX BORN/RADIATION MULTIPOLE
C
      IXBLM=MAX(IONE,MPOLE/2)
      IXD09=IXBLM
      IF(BREL)IXD09=IXD09+2                                !+2 CASE BREL
      BNRBORN=.FALSE.
      BNRBRN1=.FALSE.
C
C-----------------------------------------------------------------------
C                INTERNAL CONTROLS FOR DR LOOP, NOT DIRECTLY SET BY USER
      BDR=IDR.NE.0                !FOR 'DR' LOOPING OVER DUMMY RYDBERG
      BJUMP=.FALSE.               !.T. FOR SUBSEQUENT LOOPS (SKIP)
      BJUMP2=.FALSE.              !.T. FOR UP/DOWNSCALING 1/N**3
      BRAD=.TRUE.                 !.T. RECALCULATE RADIATIVE DATA.
      NNEW=MAXNV
      LMX0=-999
C
      DO I=1,MXVAR       !NOW SET IN MINIM0
        DAJNEW(I)=DONE   !DEFAULT SCALING PARAMETERS FOR EACH ORBITAL
        DEXTRE(I)=DONE   !               DITTO
      ENDDO
C
      ECAVX(1)=DZERO
      ECAV(1)=DZERO               !INITIALIZE FOR SCCA - SEE ICAV
C
C-----------------------------------------------------------------------
C
C READ USER INPUT AND PERFORM CHECKS ON INITIAL SET-UP
C
      CALL MINIM0(MPRINT,NLAM,NVAR,DEXTRE,IMAXIT,TVARY,ICM,ICP)
C
      IF(NZION.EQ.0.OR.NF.LE.0)GO TO 1005                        !RETURN
C
C-----------------------------------------------------------------------
C
      BORT=MORT.LT.0
      JPRINT=MOD(MPRINT,ITEN)
      NPRNT5=MOD(NPRINT,IFIVE)
      BCONT=MODE.EQ.2.OR.MODE.EQ.3
      BCASC=KUTCAS.GE.0.AND.NJO.GT.0.AND.NPRNT5.GT.-2.AND.
     X                                     .NOT.BCONT.AND..NOT.BDR
C
C-----------------------------------------------------------------------
C
C READ USER INPUT AND SET-UP ENERGY MESH BASED-ON THIS, OR BEST GUESS
C
      IF(BCONT)THEN
C
        ALLOCATE (DYY(MXENG))           !MXENG AS WE DON'T KNOW SIZE YET
C
        CALL RADCN0(MDUM1,MDUM2,MDUM3,-DONE)
C
        IF(NF.LE.0)GO TO 1005                                    !RETURN
C
        IF(BNAME)THEN
          REWIND(5)
        ELSEIF(BHFF)THEN
          WRITE(6,866)
          WRITE(0,*)'MINIM: MUST USE NAMELIST FOR radwin PLUS CONTINUUM'
          NF=-1
          GO TO 1005                                             !RETURN
        ENDIF
C
      ELSE                   !HISTORIC, FOR SAFETY, SHOULD NOT BE NECESS
C
        ACE=D1P10
        MENG=1                                        !FOR ALLOCATED TBD
        NREL=1
C
      ENDIF
C
C-----------------------------------------------------------------------
C
      NP0=0
      IF(IPOLFN.LT.0)NP0=-IPOLFN
      NPARM3=(NP0+1)*NPARAM
C
       DO I=1,NPARM3
         J=IEQUAL(I)
         IF(J.GT.0)THEN
C           IF(J.LE.NLAM)THEN                   !CONTROLLED BY IEQUAL
             IF(DEXTRE(J).LT.DZERO)DAJNEW(I)=-DONE   !JUST FLAG FOR MESH
C           ENDIF
         ENDIF
       ENDDO
C
C-----------------------------------------------------------------------
C
C SET-UP RADIAL MESH FOR ALLOCATION - SEE /CRAD/
C                                     CALLED AGAIN IN SR.RADIAL FOR DX
C
      NZA=MAX(IONE,NZION-MION+1)
      TOLR=DEL/NZA
      IF(ABS(MORT).EQ.5)TOLR=TINORB                    !RZERO
C
      IFLAGR=0                             !DETERMINE MAXRS FOR ALLOCATE
C
      CALL MESH(NZION,MION,TOLR,DHNS0,DUM1,IFLAGR)
c
      maxrs0=maxrs                          !hold for last gasp test
C
      MXPIN=MAXRS
      MXQIN=MAXRS
C
C-----------------------------------------------------------------------
C
C RADIAL ORBITALS ETC. SET-UP   (TBD: ALLOCATE POTENTIAL ARRAYS)
C
      BRADF=.FALSE.
      ALLOCATE (DPNL(MAXRS,MXORB),DUY(MXORB,MXORB),DX(MAXRS)
     X         ,DORIG(MXORB),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DPNL,DUY,DX,DORIG'
        NF=0
        GO TO 1005
      ENDIF
      BRADF=.TRUE.
C
      BNRBDQE=.FALSE.
      ALLOCATE (DQNL(MAXRS,MXORB),STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DQNL'
        NF=0
        GO TO 1002
      ENDIF
      BNRBDQE=.TRUE.
C
      MAXRS=0              !WILL BE RE-SET IN RADIAL, BUT FLAG FOR MAXPS
C
C-----------------------------------------------------------------------
C
C SLATER AND RK (1- & 2-BODY) INTGERAL SET-UP (ALWAYS)
C
      ALLOCATE (DRL(IRL),DOSC(0:IXD09,MXORB,MXORB),STAT=IERR)     !MXD09
      IF(IERR.NE.0)THEN
        WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DRL,DOSC'
        NF=0
        GO TO 1001
      ENDIF
      DO K=1,MXORB
        DO J=1,MXORB
          DO I=0,IXD09                                            !MXD09
            DOSC(I,J,K)=DZERO
          ENDDO
        ENDDO
      ENDDO
C
C - SHOULD REALLY LIMIT THIS TO ACTUAL USE
C
      BACC=.FALSE.
      ALLOCATE (ACC(MXORB,MXORB),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'MINIM: ALLOCATION FAILS FOR ACC'
        NF=0
        GO TO 1000
      ENDIF
      BACC=.TRUE.
C
C-----------------------------------------------------------------------
C
C 1- BODY NON-FINE-STRUCTURE INTGERAL SET-UP (ALWAYS)
C
      BNF1=.FALSE.
      ALLOCATE (DMASS(MXORB,MXORB),DCD(MXORB,MXORB),D2LL(MXORB,MXORB)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DMASS,DCD,D2LL'
        NF=0
        GO TO 999
      ENDIF
      BNF1=.TRUE.
C
C-----------------------------------------------------------------------
C
C OPTIONAL 1- AND 2-BODY FINE-STRUCTURE INTGERAL SET-UP
C
      BRELINT1=.FALSE.
      IF(NJO.GT.0)THEN
        ALLOCATE (DRLP1(IRLP),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DRLP1'
          NF=0
          GO TO 998
        ENDIF
        BRELINT1=.TRUE.
      ENDIF
C
      BRELINT2=.FALSE.
      IAXMI=MAX(NL000,NL)
      IF(IAXMI.GT.0)THEN
        ALLOCATE (DNL(IAXMI),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DNL'
          NF=0
          GO TO 997
        ENDIF
        BRELINT2=.TRUE.
      ENDIF
C
C-----------------------------------------------------------------------
C
C OPTIONAL BOUND-CONTINUUM 1-BODY INTGERAL SET-UP
C
      IF(BFOT)THEN
        IXD24=IXBLM*(MXORB-MB-LCON)*LCON                          !MXBLM
        LHM=MPOLE/4
        IF(BREL)LHM=LHM+1
        ALLOCATE (DFOT(MENG),DFOTm(MENG),DFOSS(IXD24,MENG,2)
     X           ,NFOSS(0:LHM,MXORB,MXORB),IGAG(0:MENG),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DFOT,DFOSS,NFOSS'
          BFOT=.FALSE.
          NF=0
          GO TO 997
        ENDIF
        DO I=1,MXORB
          DO J=1,MXORB
            DO K=0,LHM
              NFOSS(K,J,I)=0        !PI INDEX
            ENDDO
          ENDDO
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C OPTIONAL BOUND-CONTINUUM 2-BODY INTGERAL SET-UP
C
      ALLOCATE (IYY(MXORB))                          !USED GENERALLY NOW
C
      IF(BCONT)THEN
        IX=0
        DO I=1,IRL
          J=QRL(1,I)
          IF(QN(J).GE.90)IX=IX+1
        ENDDO
        IXFSL=MAX(IONE,IX)
        IF(IXFSL.GT.MXFSL)THEN
          IF(MXFSL.GT.0)WRITE(6,877)IXFSL,MXFSL
        ENDIF
        ALLOCATE (DRLI(MENG,IXFSL),NRLI(IRL),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DRLI,NRLI'
          BCONT=.FALSE.
          NF=0
          GO TO 996
        ENDIF
      ELSEIF(MODE.EQ.4)THEN
        ALLOCATE (NRLI(IRL))
      ENDIF
      IF(BCONT.OR.MODE.EQ.4)THEN
        DO I=1,IRL
          NRLI(I)=0
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C OPTIONAL BOUND-CONTINUUM 2-BODY FINE-STRUCTURE INTGERAL SET-UP
C
      BNRBFSI=NL000.GT.0.AND.BCONT                         !2FS B-C
      IF(BNRBFSI)THEN
        IX=0
        DO I=1,NL000
          DO K=1,3
            J=QSS(K,I)
            IF(QN(J).GE.90)THEN
              IX=IX+1
              GO TO 1
            ENDIF
         ENDDO
   1    ENDDO
        IXFSS=MAX(IONE,IX)
        IF(IXFSS.GT.MXFSS)THEN
          IF(MXFSS.GT.0)WRITE(6,876)IXFSS,MXFSS
        ENDIF
        ALLOCATE (DNLI(MENG,IXFSS),NLI(NL000),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DNLI,NLI'
          BNRBFSI=.FALSE.
          NF=0
          GO TO 995
        ENDIF
        DO I=1,NL000
          NLI(I)=0
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C OPTIONAL NON-FINE-STRUCTURE INTGERAL SET-UP
C
      BNRBNF2=.FALSE.
C      IRLO=1                                 !NO NEED TO ALLOC IF FALSE
      IF(KUTOO.NE.0)THEN
        IRLO=IRL                              !=MXRLO
        ALLOCATE (DETA(IRLO),DXSI(MXORB,MXORB),DZL(IRLO),DXTWO(IRLO)
     X          ,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DETA,DXSI,DZL,DXTWO'
          NF=0
          GO TO 994
        ENDIF
        BNRBNF2=.TRUE.
      ENDIF
C
C OPTIONAL BOUND-CONTINUUM 2-BODY NON-FINE-STRUCTURE INTGERAL SET-UP
C
      BNRBNFI=.FALSE.
C      IFOO=1                                 !NO NEED TO ALLOC IF FALSE
      IF(KUTOO.NE.0.AND.BCONT)THEN
        IFOO=IXFSL                            !=MXFOO
        ALLOCATE (DZLI(MENG,IFOO),DXTWOI(MENG,IFOO)
     X          ,DETAI(MENG,IFOO),FRI(MAXB1),GRI(MAXB1),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR DZLI,DXTWOI,DETAI'
          NF=0
          GO TO 993
        ENDIF
        BNRBNFI=.TRUE.
      ENDIF
C
C-----------------------------------------------------------------------
C
C OPTIONAL RELAXED ORBITAL OVERLAP SET-UP
C
      BNRBOLP=.FALSE.
      IF(IRLX.EQ.2)THEN
        IXD25=(MXORB*(MXORB-1))/2
        IXD26=(KMAX*(KMAX-1))/2
        ALLOCATE (OVLPGR(IXD25),OVLPCF(IXD26),IPAIR(IXD26),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: ALLOCATION FAILS FOR OVLPGR,OVLPCF'
          NF=0
          GO TO 992
        ENDIF
        BNRBOLP=.TRUE.
      ENDIF
C
C-----------------------------------------------------------------------
C
C DETRMINE (RELAXED) CONFIGURATION AVERAGE ENERGY
C
      IF(ICAV0.NE.0.and.ecavx(1).eq.dzero)THEN
        ICAV=ABS(ICAV0)                        !>0 RELAXED
C
        CALL CAVE0(ICAV)
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C MINIMALIZATION OF INCLUD TERMS (IN NVAR VARIABLE PARAMETERS WITH NLAM
C SCALING PARAMETERS, DEXTRE=DAJNEW)
C CALL THE MINIMIZATION SR VA04A-WHICH CALLS FUNCTIONAL-SR CALCFX
C (THEY NO LONGER USE NLAM EXPLICITLY, UNLESS ZERO.)
C
C-----------------------------------------------------------------------
C
      IF(INCLUD.NE.0)THEN
C
        IF(NF.LE.0)GO TO 991                    !RETURN
        BPRINT=JPRINT.GE.5                      !FOR DETAILED PRINTOUT
C
        IF(JPRINT.EQ.-2.AND.NPRNT5.EQ.-2)THEN
          WRITE(6,*)'*** SR.MINIM: ERROR, G FUNCTIONAL SPECIFIED FOR'
     X              ,' MINIMIZATION BUT E1 RADIATION IS OFF!'
          WRITE(0,*)'*** G FUNCTIONAL REQUIRES E1 RADIATION!'
          GO TO 911
        ENDIF
C
        IF(JPRINT.EQ.-2.AND.NJO.GT.0)THEN
          WRITE(6,*)'*** SR.MINIM: ERROR, G FUNCTIONAL SPECIFIED FOR ',
     X  'MINIMIZATION IN IC, BUT G IS ONLY AVAILABLE IN LS MINIMIZATION'
          WRITE(0,*)'*** G FUNCTIONAL ONLY AVAILABLE IN LS MINIMIZATION'
          GO TO 911
        ENDIF
C
C SWITCH-OFF QUANTITIES NOT NEEDED DURING OPTIMIZATION, SWITCH-ON AFTER
C
        NPRNT5=NPRINT                                 !TEMP
        IF(JPRINT.NE.-2)THEN                          !SWITCH-OFF RAD
          NPRINT=-2
          IF(NPRNT5.NE.MOD(NPRNT5,IFIVE))NPRINT=-7    !REL WAVEFN
        ENDIF
        MRAD0=MRAD                                    !TEMP
        MRAD=0                                        !SWITCH-OFF RADOUT
        MENGB0=MENGB                                  !TEMP
        MENGB=-2                                      !SWITCH-OFF BORN
        MDEN0=MDEN
        IF(MDEN.LT.0)MDEN=-1
C                                               !DUMP ols/u,oic/u OUTPUT
        IF(BPRINT)THEN
          IF(IUNIT(MW).GT.0)THEN                           !SHOULDN'T BE
            WRITE(6,*)'UNIT=7 ALREADY OPEN'
            WRITE(0,*)'UNIT=7 ALREADY OPEN'
            GO TO 911
          ENDIF
          IUNIT(MW)=1
          OPEN(MW,STATUS='SCRATCH',FORM='FORMATTED')       !DUMP
          IF(NJO.GT.0)THEN
            IF(IUNIT(MWP).GT.0)THEN                        !SHOULDN'T BE
              WRITE(6,*)'UNIT=8 ALREADY OPEN'
              WRITE(0,*)'UNIT=8 ALREADY OPEN'
              GO TO 911
            ENDIF
            IUNIT(MWP)=1
            OPEN(MWP,STATUS='SCRATCH',FORM='FORMATTED')    !DUMP
          ENDIF
        ELSE
          IF(IUNIT(MWU).GT.0)THEN                          !SHOULDN'T BE
            WRITE(6,*)'UNIT=27 ALREADY OPEN'
            WRITE(0,*)'UNIT=27 ALREADY OPEN'
            GO TO 911
          ENDIF
          IUNIT(MWU)=1
          OPEN(MWU,STATUS='SCRATCH',FORM='UNFORMATTED')    !DUMP
          IF(NJO.GT.0)THEN
            IF(IUNIT(MWPU).GT.0)THEN                       !SHOULDN'T BE
              WRITE(6,*)'UNIT=28 ALREADY OPEN'
              WRITE(0,*)'UNIT=28 ALREADY OPEN'
              GO TO 911
            ENDIF
            IUNIT(MWPU)=1
            OPEN(MWPU,STATUS='SCRATCH',FORM='UNFORMATTED') !DUMP
          ENDIF
        ENDIF
C                                                    !DITTO TERMS/LEVELS
        IF(IUNIT(14).GT.0)THEN                             !SHOULDN'T BE
          WRITE(6,*)'UNIT=14 ALREADY OPEN'
          WRITE(0,*)'UNIT=14 ALREADY OPEN'
          GO TO 911
        ENDIF
        IUNIT(14)=1
        OPEN(14,STATUS='SCRATCH',FORM='FORMATTED')         !DUMP
        IF(NJO.GT.0)THEN
          IF(IUNIT(15).GT.0)THEN
            WRITE(0,*)'UNIT=15 ALREADY OPEN'               !SHOULDN'T BE
            GO TO 911
          ENDIF
          IUNIT(15)=1
          OPEN(15,STATUS='SCRATCH',FORM='FORMATTED')       !DUMP
        ENDIF
C
C SET COUNTERS
C
        ICOUNT=-IMAXIT
        IF(IMAXIT.LE.0)IMAXIT=ABS(NVAR)
        IF(ICOUNT.LT.0)ICOUNT=4*ABS(NVAR)*IMAXIT+IMAXIT+2
C
        IF(NVAR.GT.0)THEN
C
C POWELL'S METHOD ("NAG")
C
          T=TVARY                                          !0.01
          DO N=0,NP0
            N0=N*NPARAM
            DO I=1,NPARAM
              I0=IEQUAL(N0+I)
              IF(I0.LE.NVAR)DACCUR(I0)=T !VARY SCALE BY UP TO T PER ITER
            ENDDO
            IF(N.EQ.1)T=T/DTEN
          ENDDO
C
          CALL VA04A(DEXTRE,DACCUR,NVAR,NLAM,DF,DTEN,IPRINT,ICON,IMAXIT)
C
        ELSE
C
C CONJUGATE GRADIENT
C
C   INTERFACE TO NAPACK ROUTINES (CAN BE SUPPLIED)
C
C          CALL CGNA(DEXTRE,NVAR,IMAXIT)
C
C   INTERFACE TO NUMERICAL RECIPES ROUTINES
C   (*NOT* SUPPLIED AS LICENSE REQUIRED - LINK TO YOUR OWN LIBRARY)
C
          CALL CGNR(DEXTRE,NVAR,IMAXIT)           !USE REAL *8 NUM. REC.
C
        ENDIF
C
        IF(NF.LE.0)GO TO 991                                     !RETURN
C
        IF(IMAXIT.LT.0)GO TO 911
C
C NO DETAILED PRINTOUT DURING ITERATION, THEREFORE NOW PRINTOUT THE
C MINIMIZING SCALE FACTORS, HAVING ROUNDED THEM TO 5 DECIMALS
C NOTE: DEXTRE(I.GT.NLAM)=1 DURING OPT, UNLESS "FIXED", SO DO NOT USE
C              IF(I.GT.NLAM)DEXTRE(I)=DEXTRE(NLAM)     !HERE
C
C        WRITE(6,898)(DEXTRE(I),I=1,NVAR)
        DO I=1,NPARM3
          MM=INT(100000*(DEXTRE(I)+D5M6))
          DEXTRE(I)=D1M5*MM
        ENDDO
        DO N=0,NP0
          N0=N*NPARAM
          I0=0
          DO I=1,NPARAM
            J=IEQUAL(N0+I)
            IF(J.LE.NVAR)THEN
              I0=I0+1
              DACCUR(I0)=DEXTRE(J)
            ENDIF
          ENDDO
          IF(N.EQ.0)WRITE(6,898)(DACCUR(I),I=1,I0)
          IF(I0*N.GT.0)WRITE(6,899)N,(DACCUR(I)-DONE,I=1,I0)!DACCUR(I)
        ENDDO
C
C TIDY-UP
C
        NPRINT=NPRNT5                                       !RE-INSTATE
        MRAD=MRAD0
        MENGB=MENGB0
        MDEN=MDEN0
C
        IF(IUNIT(MW).GT.0)THEN                       !CLOSE-OFF SCRATCH
          CLOSE(IUNIT(MW))
          IUNIT(MW)=0
        ENDIF
        IF(IUNIT(MWP).GT.0)THEN
          CLOSE(IUNIT(MWP))
          IUNIT(MWP)=0
        ENDIF
        IF(IUNIT(14).GT.0)THEN
          CLOSE(IUNIT(14))
          IUNIT(14)=0
        ENDIF
        IF(IUNIT(15).GT.0)THEN
          CLOSE(IUNIT(15))
          IUNIT(15)=0
        ENDIF
C
        IF(IUNIT(MWU).GT.0)THEN                      !CLOSE-OFF SCRATCH
          CLOSE(IUNIT(MWU))
          IUNIT(MWU)=0
        ENDIF
        IF(IUNIT(MWPU).GT.0)THEN
          CLOSE(IUNIT(MWPU))
          IUNIT(MWPU)=0
        ENDIF
C
      ENDIF
C
      ICOUNT=0
C
      IF(INCLUD.LT.0)THEN
        INCLUD=-1000000+INCLUD
      ELSE
        INCLUD=1000000+INCLUD
      ENDIF
C
C END MINIMIZATION -----------------------------------------------------
C
C
C MPRINT=AB GIVES LS.JPRINT=B AND IC.JPRINT=A  AND BOTH HAVE
C THE SAME SIGN, THAT OF MPRINT.
C NOT TO BE CONFUSED WITH ALGEBRAIC MPRINT (OR NPRINT)
C
      BPRINT=.TRUE.
      LSPRNT=JPRINT
      ICPRNT=MPRINT/10
C
      NPRNT5=MOD(NPRINT,IFIVE)
      BCPRNT=(MOD(MPNCH,ITWO).NE.0)
C
      IF(MODE.GT.0)THEN                 !OPEN CA/LS FILES
C
        JPRINT=LSPRNT
        BPRNT0=JPRINT.NE.-3
C
        NAM0=''
cparc                                                               !par
cpar        if(idw.eq.0)then                                        !par
cpar          j1=liam/10                                            !par
cpar          j2=liam-(10*(liam/10))                                !par
cpar          if(nprocperl.eq.1)then      !don't extend if 1        !par
cpar            nam0=num(j1)//num(j2)                               !par
cpar          else                                                  !par
cpar            i1=jiam/10                                          !par
cpar            i2=jiam-(10*(jiam/10))                              !par
cpar            nam0=num(j1)//num(j2)//'.'//num(i1)//num(i2)        !par
cpar          endif                                                 !par
cpar        endif                                                   !par
cparc                                                               !par
        IF(BPRNT0)THEN
          IF(MODE.EQ.1.AND..NOT.BDR)THEN          !CASE BOUND-BOUND LOOP
            IF(IUNIT(14).EQ.0)THEN
              IUNIT(14)=1
              IF(NSL0.GT.0)THEN
                NAM='TERMS'
              ELSE
                NAM='CAVES'
              ENDIF
              OPEN(14,FILE=NAM,STATUS='REPLACE')              !TERM LIST
            ENDIF
            IF(ITANAL.NE.0)THEN
              IF(IUNIT(31).EQ.0)THEN
                IUNIT(31)=1
                OPEN(31,FILE='ITANAL',STATUS='REPLACE')     !SMALL TERMS
              ELSE
                IF(IUNIT(31).GT.0)CLOSE(31)
                IUNIT(31)=1
                OPEN(31,FILE='ITANAL',STATUS='OLD'
     X                               ,POSITION='APPEND')
              ENDIF
            ENDIF
          ENDIF
          IF(IUNIT(MW).EQ.0)THEN
            IUNIT(MW)=1
            IF(NSL0.GT.0)THEN
              NAM='ols'//NAM0
            ELSE
              NAM='oca'//NAM0
            ENDIF
            OPEN(MW,FILE=NAM,STATUS='REPLACE')         !RATES & ENERGIES
          ENDIF
        ENDIF
        IF(.NOT.BPRNT0)THEN
          IF(IUNIT(MWU).EQ.0)THEN
            IUNIT(MWU)=1
            IF(NSL0.GT.0)THEN
              NAM='olsu'//NAM0
            ELSE
              NAM='ocau'//NAM0
            ENDIF
            OPEN(MWU,FILE=NAM,FORM='UNFORMATTED'
     X                        ,STATUS='REPLACE')       !RATES & ENERGIES
          ENDIF
        ENDIF
C
        IF(BFOT)THEN
          IF(BPRNT0)THEN
            IF(IUNIT(MWW).EQ.0)THEN
              IUNIT(MWW)=1
              IF(NSL0.GT.0)THEN
                NAM='opls'//NAM0
              ELSE
                NAM='opca'//NAM0
              ENDIF
              OPEN(MWW,FILE=NAM,STATUS='REPLACE')       !PHOTOIONIZATION
            ENDIF
          ENDIF
          IF(.NOT.BPRNT0)THEN
            IF(IUNIT(MWWU).EQ.0)THEN
              IUNIT(MWWU)=1
              IF(NSL0.GT.0)THEN
                NAM='oplsu'//NAM0
              ELSE
                NAM='opcau'//NAM0
              ENDIF
              OPEN(MWWU,FILE=NAM
     X         ,FORM='UNFORMATTED',STATUS='REPLACE')    !PHOTOIONIZATION
            ENDIF
          ENDIF
        ENDIF
C
        IF(ABS(MENGB).EQ.1)THEN
          IF(IUNIT(23).LT.0)THEN
            WRITE(6,*)"TRYING TO RE-OPEN FILE='OMGINFLS'..."
            WRITE(0,*)'TRYING TO RE-OPEN UNIT=23'
            GO TO 911
          ELSEIF(IUNIT(23).EQ.0)THEN
            IF(NSL0.GT.0)THEN
              NAM='LS'
            ELSE
              NAM='CA'
            ENDIF
cpar            if(iam.eq.0)then                                    !par
            IUNIT(23)=2-ABS(IDR)              !only close .gt.1, for par
            OPEN(23,FILE='OMGINF'//NAM,STATUS='REPLACE')     !INF E BORN
cpar            else                                                !par
cpar              IUNIT(23)=1                                       !par
cpar              OPEN(23,STATUS='SCRATCH')                         !par
cpar            endif                                               !par
          ENDIF
        ENDIF
C
        if(.not.badas)then
          INQUIRE(FILE='../adas803.pl',EXIST=BEX)
          badas=BEX
        endif
        IF(ABS(MENGB).EQ.1.or.badas)THEN
          IF(IUNIT(21).LT.0)THEN
            WRITE(6,*)"TRYING TO RE-OPEN FILE='adasex.in.form'..."
            WRITE(0,*)'TRYING TO RE-OPEN UNIT=21'
            GO TO 911
          ELSEIF(IUNIT(21).EQ.0.and.idw.eq.0)THEN
            IUNIT(21)=2-ABS(IDR)
            OPEN(21,FILE='adasex.in.form',STATUS='REPLACE')   !TEMP ADAS
          ENDIF
        ENDIF
C
        IF(MENGB.GE.-1)THEN
          IF(IUNIT(25).LT.0)THEN
            WRITE(6,*)"TRYING TO RE-OPEN FILE='adf04ls'..."
            WRITE(0,*) 'TRYING TO RE-OPEN UNIT=25'
            GO TO 911
          ELSEIF(IUNIT(25).EQ.0)THEN
            IF(NSL0.GT.0)THEN
              NAM='ls'
            ELSE
              NAM='ca'
            ENDIF
cpar            if(iam.eq.0)then    !only used by proc 0            !par
            IUNIT(25)=2-ABS(IDR)
            OPEN(25,FILE='adf04'//NAM,STATUS='REPLACE')   !PWB/DW
cpar            endif                                               !par
          ENDIF
        ENDIF
C
      ENDIF                             !END OF CA/LS FILE OPENING
C
      IF(NJO.GT.0)THEN                  !OPTIONAL FINE-STRUCTURE SET-UP
C
        IF(MODE.GT.0)THEN               !OPEN IC FILES
C
          JPRINT=ICPRNT
          BPRNT0=JPRINT.NE.-3
C
          NAM0=''
cparc                                                               !par
cpar        if(idw.eq.0)then                                        !par
cpar          j1=liam/10                                            !par
cpar          j2=liam-(10*(liam/10))                                !par
cpar          if(nprocperl.eq.1)then      !don't extend if 1        !par
cpar            nam0=num(j1)//num(j2)                               !par
cpar          else                                                  !par
cpar            i1=jiam/10                                          !par
cpar            i2=jiam-(10*(jiam/10))                              !par
cpar            nam0=num(j1)//num(j2)//'.'//num(i1)//num(i2)        !par
cpar          endif                                                 !par
cpar        endif                                                   !par
cparc                                                               !par
          IF(BPRNT0)THEN                  !CASE B-B LOOP
            IF(MODE.EQ.1.AND.IUNIT(15).EQ.0.AND..NOT.BDR)THEN
              IUNIT(15)=1
              OPEN(15,FILE='LEVELS',STATUS='REPLACE')        !LEVEL LIST
            ENDIF
            IF(IUNIT(MWP).EQ.0)THEN
              IUNIT(MWP)=1
              NAM='oic'//NAM0
              OPEN(MWP,FILE=NAM,STATUS='REPLACE')      !RATES & ENERGIES
            ENDIF
c            WRITE(MWP,891)NNEW,LNEW,(I,I=1,20)
          ENDIF
          IF(.NOT.BPRNT0)THEN
            IF(IUNIT(MWPU).EQ.0)THEN
              IUNIT(MWPU)=1
              NAM='oicu'//NAM0
              OPEN(MWPU,FILE=NAM,FORM='UNFORMATTED'
     X                           ,STATUS='REPLACE')    !RATES & ENERGIES
            ENDIF
c            WRITE(MWPU)int(NNEW),int(LNEW)
          ENDIF
C
          IF(BFOT)THEN
            IF(BPRNT0)THEN
              IF(IUNIT(MWPW).EQ.0)THEN
                IUNIT(MWPW)=1
                NAM='opic'//NAM0
                OPEN(MWPW,FILE=NAM,STATUS='REPLACE')    !PHOTOIONIZATION
              ENDIF
c              WRITE(MWPW,891)NNEW,LNEW
            ENDIF
            IF(.NOT.BPRNT0)THEN
              IF(IUNIT(MWPWU).EQ.0)THEN
                IUNIT(MWPWU)=1
                NAM='opicu'//NAM0
                OPEN(MWPWU,FILE=NAM
     X            ,FORM='UNFORMATTED',STATUS='REPLACE') !PHOTOIONIZATION
              ENDIF
c              WRITE(MWPWU)int(NNEW),int(LNEW)
            ENDIF
          ENDIF
C
          IF(ABS(MENGB).EQ.1)THEN
            IF(IUNIT(24).LT.0)THEN
              WRITE(6,*)"TRYING TO RE-OPEN FILE='OMGINFIC'..."
              WRITE(0,*)'TRYING TO RE-OPEN UNIT=24'
              GO TO 911
            ELSEIF(IUNIT(24).EQ.0)THEN
              IUNIT(24)=1
cpar              if(iam.eq.0)then                                  !par
              IUNIT(24)=2-ABS(IDR)            !only close .gt.1, for par
              OPEN(24,FILE='OMGINFIC',STATUS='REPLACE')      !INF E BORN
cpar              else                                              !par
cpar                IUNIT(24)=1                                     !par
cpar                OPEN(24,STATUS='SCRATCH')                       !par
cpar              endif                                             !par
            ENDIF
          ENDIF
C
          IF(ABS(MENGB).EQ.1.or.badas)THEN
            IF(IUNIT(22).LT.0)THEN
              WRITE(6,*)"TRYING TO RE-OPEN FILE='adasexj.in.form'..."
              WRITE(0,*)'TRYING TO RE-OPEN UNIT=22'
              GO TO 911
            ELSEIF(IUNIT(22).EQ.0.and.idw.eq.0)THEN
              IUNIT(22)=2-ABS(IDR)
              OPEN(22,FILE='adasexj.in.form',STATUS='REPLACE')!TEMP ADAS
            ENDIF
          ENDIF
C
          IF(MENGB.GE.-1)THEN
            IF(IUNIT(26).LT.0)THEN
              WRITE(6,*)"TRYING TO RE-OPEN FILE='adf04ic'..."
              WRITE(0,*)'TRYING TO RE-OPEN UNIT=26'
              GO TO 911
            ELSEIF(IUNIT(26).EQ.0)THEN
cpar              if(iam.eq.0)then    !only used by proc 0          !par
              IUNIT(26)=2-ABS(IDR)
              OPEN(26,FILE='adf04ic',STATUS='REPLACE')    !PWB/DW
cpar              endif                                             !par
            ENDIF
          ENDIF
C
        ENDIF                           !END OF IC FILE OPENING
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C PLASMA RE-ENTRY POINT
C
      ND0=1
   2  IF(MDEN.GT.0)THEN
        T=NZION-MION+1            !FOR INFO, EXACT SET IN RADIAL/RADCON
        DENE=DENS(ND0)*DCON3**3
        IF(DENSI(ND0).LE.DZERO)DENSI(ND0)=DENS(ND0)/T         !NOT USED
        DENI=DENSI(ND0)*DCON3**3
        R0=DZERO
        IF(DENI.NE.DZERO)R0=(DCON6/DENI)**D1THRD
        TKAY=TKAYS(ND0)
        IF(TKAY.LT.DZERO)TKAY=-TKAY/DCON2                     !K->RYD
        GAMQ=DZERO
        DEBYE=DZERO
        IF(DENE*TKAY.NE.DZERO)THEN
          DEBYE=SQRT(DCON5*DENE/TKAY)
          DEBYE=DONE/DEBYE
          IF(R0.NE.DZERO)THEN
            GAMQ=DCON4*T*T
            GAMQ=GAMQ*DENI**D1THRD/TKAY
          ENDIF
        ENDIF
        WRITE(6,881)MDEN,DENSI(ND0),DENS(ND0),TKAY,GAMQ,DEBYE,R0
      ENDIF
C
C-----------------------------------------------------------------------
C
C SET-UP LOOP OVER RYDBERG ORBITAL(S), ASSIGN VALUES TO DUMMY
C
      IF(BDR)THEN
        LMX0=LMAX
        IF(KSHIFT.LE.0)THEN
          IJUMP2=-1
        ELSE            !CAN SKIP CONT E=0 GENERATION
          IJUMP2=0
        ENDIF
        IJUMP0=IJUMP2
        IRAD=-1
cparc                                                               !par
cpar        if(mapiam.gt.0)then             !one n per proc         !par
cpar          n=abs(niam)                                           !par
cpar          if(n.le.lnew)go to 9     !case > one l per RESTART    !par
cpar          go to 96                                              !par
cpar        endif                                                   !par
C
        I0=0
cpar        i0=i0+mod(iam,nprocperl)                                !par
        I1=I0+1
C
        IF(NMIN.GT.0.AND.NMIN+i0.LE.NMAX)THEN           !INITIAL N-VALUE
          ND=I0
cpar          nd=nd-nprocperl+1                                     !par
          N=NMIN+I0
        ELSEIF(JND.LE.0)THEN         !FLAG FOR INFO & WRITE A TERMINATOR
          WRITE(6,896)LNEW
          WRITE(0,*)'*** CANNOT ASSIGN ANY N-VALUES TO RYDBERG L=',LNEW
          GO TO 9
        ELSE
          ND=I1
          if(nd.gt.jnd)go to 9                !satsfied by parallel only
          N=NDR(ND)
        ENDIF
        IF(BLOOP.AND.LNEW.GE.N)THEN   !NEED TO INCREMENT NMIN FOR THIS L
cpar          if(nprocperl.gt.1.and.nd.le.0)stop 'nd .le. 0 ....'   !par
          N=LNEW+1
          IF(ND.GT.0)THEN                    !.OR.JND.GT.0.AND.N.GT.NMAX
            WRITE(6,*)'*** NEED NMAX OF AT LEAST:',N
            WRITE(0,*)'*** NEED NMAX OF AT LEAST:',N
            GO TO 911
          ENDIF
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C RYDBERG-N RE-ENTRY POINT
C
  96  IF(BDR)THEN
        DO I=1,MXORB
          IF(IVAL(I).NE.0)THEN          !ASSIGN NL TO RYDBERG ORBITAL(S)
            if(bloop.and.lnew.ne.ql(i)/2)stop 'Rydberg-l mis-alignment'
            QN(I)=N
            IF(N.LT.NSW)THEN
              IF(BORT)THEN
                L=I
              ELSEIF(BLOOP)THEN
                L=LNEW+1
              ELSE
                L=0
              ENDIF
              IF(L.GT.0)DADJUS(L)=DZERO
            ELSEIF(KSHIFT.LE.0)THEN
              IF(IJUMP2.LT.0)SCREEN(I)=6999
              IF(IJUMP2.GE.0)QN(I)=-N
            ENDIF
          ENDIF
        ENDDO
C
        NNOLD=NNEW
        NNEW=N
cold                                              IF(.NOT.BLOOP)LNEW=999
        WRITE(6,894)NNEW,LNEW
c       call flush(6)               !useful for debug large UNFORM cases
C
        IF(NMETAR.NE.0.AND.ECOR1.NE.DZERO.OR.
     X    NMETARJ.NE.0.AND.ECOR2.NE.DZERO)THEN           !BUNDLED AUGERS
          IF(BWARN)THEN
            WRITE(6,860)
            BWARN=.FALSE.
          ENDIF
          T=NZA
          T=T/NNEW
          T=-T*T
          IF(T.GT.2*ECOR1.OR.T.GT.2*ECOR2)THEN
            WRITE(6,861)
            WRITE(0,*)
     X '*** ERROR: BUNDLED AUGERS HAVE MOVED ABOVE THEIR OWN CONTINUUM!'
            GO TO 911
          ENDIF
        ENDIF
C
        BRAD=N.LE.NRAD
        IF(.NOT.BRAD)IRAD=IRAD+1
        IF(IRAD.EQ.0)WRITE(6,892)NRAD
C
        IF(N.GE.NSW)THEN
          IF(IJUMP2.EQ.IJUMP0)WRITE(6,893)NSW
          IJUMP2=IJUMP2+1
          BJUMP2=IJUMP2.GT.0
C         BHFF=.TRUE.
          MAUTO=1
          IF(ICM.LT.0)MAUTO=0
        ENDIF
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C *** COMPUTE NON-RELATIVISTIC CASE
C
C-----------------------------------------------------------------------
C
      JPRINT=LSPRNT
      BPRNT0=JPRINT.NE.-3
C
      IF(MODE.GT.0)THEN                 !WRITE HEADERS TO FILES
        IF(BPRNT0)WRITE(MW,891)NNEW,LNEW,(I,I=1,20)
        IF(.NOT.BPRNT0)WRITE(MWU)int(NNEW),int(LNEW)
        IF(BFOT)THEN
          IF(BPRNT0)WRITE(MWW,891)NNEW,LNEW
          IF(.NOT.BPRNT0)WRITE(MWWU)int(NNEW),int(LNEW)
        ENDIF
      ENDIF                             !END OF HEADERS
C
C-----------------------------------------------------------------------
C
C BEGIN CALCULATIONS: RADIAL
C
C-----------------------------------------------------------------------
C
      IF(.NOT.BJUMP2)THEN                   !UPDATE RADIAL FUNCTIONS
C
        IF(.NOT.BJUMP)THEN                  !ASSIGN SCALING FACTORS
          DO I=1,NPARM3
            J=IEQUAL(I)
            IF(J.GT.0)THEN
C              IF(J.LE.NLAM)THEN            !CONTROLLED BY IEQUAL
                DAJNEW(I)=DEXTRE(J)
                IF(BALAN)DALAN(I)=DEXTRE(J)
C              ENDIF
            ENDIF
          ENDDO
        ENDIF
C
        IF(ISCALR.GT.0)SCALER=DAJNEW(ISCALR)!SLATER SCALING PARAMETER
C
        if(btimet)call cpu_time(timei)
c
        CALL RADIAL(DAJNEW)
c
        if(btimet)then
          call cpu_time(timef)
          times=timef-timei
cpar          if(iam.ge.0)then                                      !par
cpar            write(iwp,*)'proc',iam,' for minim:'                !par
cpar            write(iwp,*)'    radial time=',nint(times),'sec'    !par
cpar            call flush(iwp)                                     !par
cpar          else                                                  !par
            write(iw,*)'radial time=',nint(times),'sec'
cpar          endif                                                 !par
        endif
C
        IF(NF.LE.0)GO TO 991                                     !RETURN
C
        IF(ICAV0.NE.0.and.ecav(1).eq.dzero)THEN   !UNIQUE, ind. of Ryd
          ICAV=-ABS(ICAV0)
C
          CALL CAVE0(ICAV)                 !CONFIGURATION AVERAGE ENERGY
C
        ENDIF
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C BEGIN CALCULATIONS: CONFIGURATION AVERAGE
C
C-----------------------------------------------------------------------
C
      IF(NSL0.LT.0)THEN
C
        if(btime)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(iw,*)'Starting proc',iam,' for carate'        !par
cpar          else                                                  !par
            write(iw,*)'Starting carate'
cpar          endif                                                 !par
          if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
          call cpu_time(timei)
        endif
C
        CALL CARATE(DECORE,DF)
c
        if(btime)then
          call cpu_time(timef)
          times=timef-timei
c
          if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
cpar          if(iam.ge.0)then                                      !par
cpar            write(iw,*)'Ending proc',iam,' for carate:'         !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar            call flush(iw)                                      !par
cpar          else                                                  !par
            write(iw,*)'Ending carate: time=',nint(times),'sec,     '
     x                 ,nint(times/60),'min'
cpar          endif                                                 !par
        endif
C
        GO TO 100                                            ! ALL DONE!
      ENDIF
C
C-----------------------------------------------------------------------
C
C BEGIN CALCULATIONS: DIAGON
C
C-----------------------------------------------------------------------
C
      if(btime)then
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Starting proc',iam,' for diagon'          !par
cpar        else                                                    !par
          write(iw,*)'Starting diagon'
cpar        endif                                                   !par
        if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
        call cpu_time(timei)
      endif
C
      CALL DIAGON(DECORE,DF)                 !DIAG H(LS) & COMPUTE RATES
c
      if(btime)then
        call cpu_time(timef)
        times=timef-timei
c
        if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
cpar        if(iam.ge.0)then                                        !par
cpar          write(iw,*)'Ending proc',iam,' for diagon:'           !par
cpar     x               ,' time=',nint(times),'sec,     '          !par
cpar     x               ,nint(times/60),'min'                      !par
cpar          call flush(iw)                                        !par
cpar        else                                                    !par
          write(iw,*)'Ending diagon: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
C
      IF(NF.LE.0)GO TO 100                            !RETURN EVENTUALLY
C
c      btfu=.true.
      BTFU=ISHFTLS.GT.0.OR.BCPRNT  !TECs or TCCs, hold LS CI for IC
      IF(.NOT.BTFU)THEN               !LS CI NOT NEEDED
        DEALLOCATE (TFU,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR TFU'
          NF=0
          GO TO 991                                              !RETURN
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C *** COMPUTE FINESTRUCTURE
C
C-----------------------------------------------------------------------
C
      IF(NJO.GT.0)THEN
C
        JPRINT=ICPRNT
        BPRNT0=JPRINT.NE.-3
C
C-----------------------------------------------------------------------
C
        IF(MODE.GT.0)THEN               !WRITE HEADERS TO FILES
          IF(BPRNT0)WRITE(MWP,891)NNEW,LNEW,(I,I=1,20)
          IF(.NOT.BPRNT0)WRITE(MWPU)int(NNEW),int(LNEW)
          IF(BFOT)THEN
            IF(BPRNT0)WRITE(MWPW,891)NNEW,LNEW
            IF(.NOT.BPRNT0)WRITE(MWPWU)int(NNEW),int(LNEW)
          ENDIF
        ENDIF                           !END OF HEADERS
C
C-----------------------------------------------------------------------
C
C SET-UP FOR OPTIONAL CASCADE COEFFICIENTS
C
        IF(BCASC)THEN
          IF(MXNOR.GT.1)THEN
            IXNOR=MXNOR
          ELSE
            IXNOR=MAX(NLEV*NLEV/6,600_SP)
          ENDIF
          ALLOCATE (AP(IXNOR),MADD(0:IXNOR),STAT=IERR)
          IF(IERR.NE.0)THEN
            WRITE(0,*)'MINIM: ALLOCATION FAILS FOR AP,MADD'
            NF=0
            GO TO 100                                            !RETURN
          ENDIF
        ENDIF
C
C-----------------------------------------------------------------------
C
C BEGIN CALCULATIONS: SOCC & DIAGFS
C
C-----------------------------------------------------------------------
C
        IF(.NOT.BJUMP2)THEN                 !BLUME & WATSON CONTRIBUTION
c
c             if(btime)call cpu_time(timei)
C
          CALL SOCC
c
c             if(btime)then
c               call cpu_time(timef)
c               write(iw,*)'socc time=',nint(timef-timei),'sec'
c             endif
C
          IF(NF.LE.0)GO TO 100                        !RETURN EVENTUALLY
C
        ENDIF
c
        if(btime)then
cpar          if(iam.ge.0)then                                      !par
cpar            write(iw,*)'Starting proc',iam,' for diagfs'        !par
cpar          else                                                  !par
            write(iw,*)'Starting diagfs'
cpar          endif                                                 !par
          if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
          call cpu_time(timei)
        endif
C
        CALL DIAGFS(DECORE,DFFS)             !DIAG H(IC) & COMPUTE RATES
c
        if(btime)then
          call cpu_time(timef)
          times=timef-timei
c
          if(bdr)write(iw,*)'n=',nnew,'  l=',lnew
cpar          if(iam.ge.0)then                                      !par
cpar            write(iw,*)'Ending proc',iam,' for diagfs:'         !par
cpar     x                 ,' time=',nint(times),'sec,     '        !par
cpar     x                 ,nint(times/60),'min'                    !par
cpar            call flush(iw)                                      !par
cpar          else                                                  !par
            write(iw,*)'Ending diagfs: time=',nint(times),'sec,     '
     x                 ,nint(times/60),'min'
cpar          endif                                                 !par
        endif
C
      ENDIF                              !END OF OPTIONAL FINE-STRUCTURE
C
C-----------------------------------------------------------------------
C
 100  CONTINUE
C
      IF(ALLOCATED(TFU))THEN
C
        DEALLOCATE (TFU,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR TFU'
          IF(NF.GT.0)NF=0
        ENDIF
C
      ENDIF
C
      IF(NF.LE.0)GO TO 991                                       !RETURN
C
C-----------------------------------------------------------------------
C
C
C DETERMINE NEXT N-VALUE FOR RESONANCE (DR/RR/RE ETC) OPERATION
C
      IF(BDR)THEN
cpar        if(mapiam.gt.0)go to 9    !no more, as one n per proc   !par
        ICM=0
        BHFF=.FALSE.
        IF(ICP.GT.0)MAUTO=1
        BJUMP=.TRUE.
        I1=1
cpar        i1=i1+nprocperl-1                                       !par
        N=N+I1
        IF(N.LE.NMAX)GO TO 96 !.AND.ND.le.0     !LOOP BACK-UP WITH NEW N
        ND=ND+I1
        IF(ND.LE.JND)THEN
          N=NDR(ND)
          GO TO 96                              !LOOP BACK-UP WITH NEW N
        ENDIF
      ENDIF
C
C WRITE TERMINATORS
C
   9  IF(MODE.GT.0.AND.LNEW.GE.LMX0)THEN
        IF(BPRNT0)WRITE(MW,512)MBLK
        IF(.NOT.BPRNT0)WRITE(MWU)int(IZERO),int(IZERO)
        IF(BFOT)THEN
          IF(BPRNT0)WRITE(MWW,512)MBLK
          IF(.NOT.BPRNT0)WRITE(MWWU)int(IZERO),int(IZERO)
        ENDIF
C
        IF(NJO.GT.0)THEN                         !RELATIVISTIC
          IF(BPRNT0)WRITE(MWP,512)MBLK
          IF(.NOT.BPRNT0)WRITE(MWPU)int(IZERO),int(IZERO)
          IF(BFOT)THEN
            IF(BPRNT0)WRITE(MWPW,512)MBLK
            IF(.NOT.BPRNT0)WRITE(MWPWU)int(IZERO),int(IZERO)
          ENDIF
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C BEGIN CALCULATIONS: CASCADE COEFFICIENTS
C
C-----------------------------------------------------------------------
C
      IF(BCASC)THEN
C
       CALL CASC
C
       DEALLOCATE (AP,MADD,STAT=IERR)
       IF(IERR.NE.0)THEN
         WRITE(0,*)'MINIM: DEALLOCATION FAILS FOR AP,MADD'
         IF(NF.GT.0)NF=0
       ENDIF
C
       IF(NF.LE.0)GO TO 991                                      !RETURN
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C NEW PLASMA POTENTIAL
C
      IF(NDEN.GT.0)THEN
        NDEN=NDEN-1
        ND0=ND0+1
        DEN0=DENS(ND0)
        TKAY=TKAYS(ND0)
        ZNP0=-999
        DO I=1,NPARM3
          DADJUS(I)=DZERO
        ENDDO
        IF(BCONT)THEN
          DO I=1,MXORB
            IF(QN(I).LT.0.AND.IVAL(I).EQ.0)SCREEN(I)=9999  !RE-INIT CONT
          ENDDO
COLD          DO I=1,MENG
COLD            DYY(I)=DYY(I)*DTWO              !****CONVERT BACK TO RYD
COLD          ENDDO
        ENDIF
        GO TO 2                  !LOOP BACK-UP WITH NEW TEMP AND DENSITY
      ELSE
        GO TO 991                                                !RETURN
      ENDIF
C
C
C-----------------------------------------------------------------------
C
C "LOCAL" DE-ALLOCATES
C
C EX-COMMON/NRBOLP/
  991 IF(BNRBOLP)THEN
       DEALLOCATE (OVLPGR,OVLPCF,IPAIR,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR OVLPGR,OVLPCF'
          NF=0
        ENDIF
        BNRBOLP=.FALSE.
      ENDIF
C
C EX-COMMON/NRBNFI/
  992 IF(BNRBNFI)THEN
        DEALLOCATE (DZLI,DXTWOI,DETAI,FRI,GRI,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DZLI,DXTWOI,DETAI'
          NF=0
        ENDIF
        BNRBNFI=.FALSE.
      ENDIF
C
C EX-COMMON/NRBNF2/
  993 IF(BNRBNF2)THEN
        DEALLOCATE (DETA,DXSI,DZL,DXTWO,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DETA,DXSI,DZL,DXTWO'
          NF=0
        ENDIF
        BNRBNF2=.FALSE.
      ENDIF
C
C EX-COMMON/NRBFSI/
  994 IF(BNRBFSI)THEN
        DEALLOCATE (DNLI,NLI,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DNLI,NLI'
          NF=0
        ENDIF
        BNRBFSI=.FALSE.
      ENDIF
C
C EX-COMMON/NRBINT/
C
  995 IF(BCONT)THEN
        DEALLOCATE (DRLI,NRLI,DYY,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DRLI,NRLI,DYY'
          NF=0
        ENDIF
        BCONT=.FALSE.
      ELSEIF(MODE.EQ.4)THEN
        DEALLOCATE (NRLI)
      ENDIF
C
  996 IF(ALLOCATED(IYY))DEALLOCATE (IYY)             !USED GENERALLY NOW
C
C EX-COMMON/NRBTS1/
      IF(BFOT)THEN
        DEALLOCATE (DFOT,DFOTm,DFOSS,NFOSS,IGAG,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DFOT,DFOSS,NFOSS'
          NF=0
        ENDIF
        BFOT=.FALSE.
      ENDIF
C
C EX-COMMON/EX/
  997 IF(BRELINT2)THEN
        DEALLOCATE (DNL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DNL'
          NF=0
        ENDIF
        BRELINT2=.FALSE.
      ENDIF
C
C EX-COMMON/EX/
      IF(BRELINT1)THEN
        DEALLOCATE (DRLP1,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DRLP1'
          NF=0
        ENDIF
        BRELINT1=.FALSE.
      ENDIF
C
C EX-COMMON/REL/
  998 IF(BNF1)THEN
        DEALLOCATE (DMASS,DCD,D2LL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DMASS,DCD,D2LL'
          NF=0
        ENDIF
        BNF1=.FALSE.
      ENDIF
C
C EX-COMMON/CACC/
  999 IF(BACC)THEN
        DEALLOCATE (ACC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR ACC'
          NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/TRANS/
 1000 IF(ALLOCATED(DRL))THEN
        DEALLOCATE (DRL,DOSC,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DRL,DOSC'
          NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/NRBDQE/                       .or.nsl0.gt.0   !i.e. not CADW
 1001 IF(BNRBDQE.and.idw.eq.0)THEN                  !TBD dump & re-alloc
        DEALLOCATE (DQNL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DQNL'
          NF=0
        ENDIF
        BNRBDQE=.FALSE.
      ENDIF
C
C EX-COMMON/RADF/                         .or.nsl0.gt.0   !i.e. not CADW
 1002 IF(BRADF.and.idw.eq.0)THEN                    !TBD dump & re-alloc
        DEALLOCATE (DPNL,DUY,DX,DORIG,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DPNL,DUY,DX,DORIG'
          NF=0
        ENDIF
        BRADF=.FALSE.
      ENDIF
C
 1005 IF(ALLOCATED(DYY))DEALLOCATE (DYY)
C
C-----------------------------------------------------------------------
C
C "NON-LOCAL" DE-ALLOCATES
C
      IF(IDW.EQ.0.OR.NSL0.GT.0)THEN                !AS CADW  HAS NO DUMP
C EX-COMMON/MQVC/
        DEALLOCATE (NEL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR NEL'
          NF=0
        ENDIF
C EX-COMMON/CCLSH/
        DEALLOCATE (NNL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR NNL'
          NF=0
        ENDIF
C EX-COMMON/DBD2/
        DEALLOCATE (QCG,QL,QN,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR QCG,QL,QN'
          NF=0
        ENDIF
      ENDIF
C
C EX-COMMON/DXRL/
      IF(BDXRL)THEN
        DEALLOCATE (DRK,QRL,NRK,NAD,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR DRK,QRL,NRK,NAD'
          NF=0
        ENDIF
        BDXRL=.FALSE.
      ENDIF
C
      IF(NSL0.GT.0)THEN                              !NOT CA
C
C EX-COMMON/NRBEKP/
      IF(BNRBEKP)THEN
        DEALLOCATE (NED,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR NED'
          NF=0
        ENDIF
        BNRBEKP=.FALSE.
      ENDIF
C
C EX-COMMON/NRBMKP/
      IF(BNRBMKP)THEN
        DEALLOCATE (NMD1,NMD2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR NMD1,NMD2'
          NF=0
        ENDIF
        BNRBMKP=.FALSE.
      ENDIF
C
C EX-COMMON/NRBNF1/
      IF(BNRBNF1)THEN
        DEALLOCATE (DEK,BFALL,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR  DEK, BFALL'
          NF=0
        ENDIF
        BNRBNF1=.FALSE.
      ENDIF
C
      ENDIF
C
C EX-COMMON/NRBORN/
      IF(BNRBORN)THEN
        DEALLOCATE (BL,OBO,TM2,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR BORN'
          NF=0
        ENDIF
        BNRBORN=.FALSE.
      ENDIF
C
C EX-COMMON/NRBRN1/
      IF(BNRBRN1)THEN
        DEALLOCATE (SBL,MB3,MB4,INDX,INDL,INDK,STAT=IERR)      !,DBL
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR BORN1'
          NF=0
        ENDIF
        BNRBRN1=.FALSE.
      ENDIF
C
C EX-COMMON/NRBRN2/
      IF(BNRBRN2)THEN
        DEALLOCATE (BINDB,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MINIM: DE-ALLOCATION FAILS FOR BINDB'
          NF=0
        ENDIF
        BNRBRN2=.FALSE.
      ENDIF
C
      IF(NJO.GT.0)THEN
C
C EX-COMMON/COEFF/
        DEALLOCATE (DRKP,QRLP,NRKP,NADP,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)
     X         'MINIM: DE-ALLOCATION FAILS FOR  DRKP,QRLP,NRKP,NADP'
          NF=0
        ENDIF
        BCOEFF=.FALSE.
C
C EX-COMMON/DMQSS3/
        DEALLOCATE (DSS,MSS,QSS,NADR,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)
     X         'MINIM: DE-ALLOCATION FAILS FOR  DSS,MSS,QSS,NADR'
          NF=0
        ENDIF
        BDMQSS3=.FALSE.
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C
      IF(NF.LE.0)THEN                              !MINIM BRANCH FAILURE
        NF0=NF
      ELSE
        NF=NF00
        NF0=MAX(NF0,NF)                        !MAX CATCH DIMENSION TEST
      ENDIF
c
c test for radial allocation out-of-bounds, better late than never...
c
      iflagr=-1
      call mesh(idum,idum,dum,dum,dum1,iflagr) !get maxrs used by radial
      if(iflagr.gt.maxrs0)then
        write(0,*)'alloc=',maxrs0,'   max used=',iflagr
        nf=-1
      endif
C
      RETURN
C
 911  NF=-1
      if(allocated(tfu))deallocate (tfu)
      GO TO 991                                                  !RETURN
C
C-----------------------------------------------------------------------
C
  899 FORMAT(16X,I1,'-POLE PERTURBATION PARAMETERS:',8F10.5,
     X/((48X,8F10.5)))
  898 FORMAT(//' MINIMIZATION RESULT OF VARIATIONAL PARAMETERS:',8F10.5,
     X/((47X,8F10.5)))
  896 FORMAT(  ' ***NOTE, SR.MINIM IS UNABLE TO ASSIGN ANY N-VALUES'
     X,' FOR RYDBERG L=',I3,' LMAX TOO LARGE?')
  894 FORMAT(' N=',I4,5X,'L=',I3)
  893 FORMAT(25X,'NSW=',I3)
  892 FORMAT(35X,'NRAD=',I5)
  891 FORMAT(2X,'NV=',I5,2X,'LV=',I5,7X,'K',20I5)
  881 FORMAT(/' MDEN=',I2,3X,'ION DENSITY=',1PE9.2,'CM-3',3X,
     X'ELECTRON DENSITY=',1PE9.2,'CM-3',3X,'TEMPERATURE*K=',
     X0PF7.2,'RYD',3X,'GAMMA=',0PF5.2,3X,'DEBYE=',F7.2,3X,'R0=',F7.2/
     X' **** ',5X,'*********** ',16X,'**************** ',
     X16X,'************* ',13X,'***** ',8X,'***** ',10X,'**')
  877 FORMAT('SR.MINIM: ALLOCATION INCREASES NUMBER OF BOUND-CONTINUUM'
     X,' SLATER INTEGRALS IXFSL =',I7,' .GT. MXFSL=',I7/)
  876 FORMAT('SR.MINIM: ALLOCATION INCREASES NUMBER OF BOUND-CONTINUUM'
     X,' 2-BODY FINE-STRUCTURE INTEGRALS IXFSS =',I7,' .GT. MXFSS=',I7/)
  866 FORMAT('SR.MINIM: MUST USE NAMELIST INPUT (SRADWIN,SRADCON) FOR '
     X,'CASE OF EXTERNAL ORBITALS WITH CONTINUUM ORBITALS')
  861 FORMAT(/'*** ERROR: BUNDLED AUGERS HAVE MOVED ABOVE THEIR OWN '
     X,'CONTINUUM AND AS SUCH CANNOT BE LOWERED BY POST-PROCESSING'
     X/'    EITHER RUN UNBUNDLED/NON-HYBRID (IF DISK SPACE ALLOWS) OR'
     X,' "ADJUST" STRUCTURE TO REMOVE THE NEED TO LOWER THE CONTINUUM')
  860 FORMAT(/'*** WARNING: BUNDLED AUGERS AND RADIATIVE RATES'
     X,'    CANNOT BE ADJUSTED AT THE POST-PROCESSOR STAGE'
     X,'    TO TAKE ACCOUNT OF AS RAISING/LOWERING THE CONTINUUM'/)
  512 FORMAT(A4)
C
      END SUBROUTINE MINIM
C
C                             *******************
C
      SUBROUTINE MINIM0(MPRNT0,NLAM0,NVAR0,DEXTRE,IMXIT,TVARY0,ICM,ICP)
C
C-----------------------------------------------------------------------
C
C  SR.MINIM0 READS USER INPUT FOR THE ANAYLTIC BRANCH,
C  PERFORMS CHECKS ON IT AND INITIALIZES A RUN
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBTS1, ONLY: PMIN,IPIG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
      PARAMETER (MXD15=100)
C
      PARAMETER (MJH0=10)                  !*MUST* BE SAME AS IN SR.MESH
C
      PARAMETER (D1P5M7=1.5D-7)
      PARAMETER (DCON1=1.625D0)
      PARAMETER (DELW=D1M5)
C
      PARAMETER (TINORB0=1.D-3)                !R-MATRIX RZERO CRITERION
C
      PARAMETER (DCON2=1.5789D5)                       !1/k (K/Ryd)
      PARAMETER (DCON3=5.29177D-9)                     !a0 (cm)
      PARAMETER (DCON4=3.224D0)                        !(32*pi/3)**1/3
      PARAMETER (DCON5=25.1327D0)                      !8*pi
      PARAMETER (DCON6=0.2387D0)                       !1/(4*pi/3)
C
      CHARACTER(LEN=1) PPP
      CHARACTER(LEN=3) RAD,RADOUT,POTOUT,POTL,ORTHOG,STONLZ,FAC,MIXBV
      CHARACTER(LEN=4) CODE,POTIN,PPOT             !TERMINATOR    ,MYRGE
      CHARACTER(LEN=6) PRINT,TCC
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      DIMENSION DEXTRE(MXVAR),IBUF(MXVAR),DBUF(MXVAR)
     X,IFYX(MXVAR),DUM(MAXGR),IDUM(MAXGR)
C
      COMMON /BASIC/NF,KVAR,MGAP(9),IGAUGE
      COMMON /CADJ/DAJNEW(MXVAR),DF0,IEQUAL(MXVAR),ICOUNT
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TDUM,MEND
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /WEIGHT/WGHT(MAXTM),INDEXW(MAXTM)
      COMMON /CALAN/DALAN(MXVAR),BALAN
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEL/DELELS(MAXTM,2),DELEIC(MAXLV,2),DELECF(MAXCF,2)
     X              ,EFLG0,EFLGJ0,TOLB,TOLE,ISHFTLS,ISHFTIC
     X              ,NOBS,NOBSJ,MDELE,MULTS
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBEXT/BHFF
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBMIX/CMXLSA,CMXLSR,CMXICA,CMXICR,STOLB,XMIX,bnobv
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPLS/DENSI(MXD15),DENS(MXD15),TKAYS(MXD15),NDEN
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBTCC/TOLTCC,KTCC,MTCC,NTCC,NENERG
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBWGT/EIONPOT,EIMXLS,EIMXIC,WLG1,WLG2,IWGHT,IOPTIM,NRSLMX
     X              ,JUPMX,JUPMN,JLOWMX,JLOWMN,LUPMX,LUPMN,LLOWMX,LLOWMN
     X              ,NMETAR,NMETARJ,NMETAP,NMETAPJ
      COMMON /NRBZSP/ZESP(MAXLL),IZESP,NWRM
      common /nrbone/ione1,ione0
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
c
      common /hps/badas
C
      COMMON /PJSLIM/ECNTRB,ITANAL
C
      NAMELIST/SMINIM/
     X AJUSTX,ALAV,ALFD,ATM,badas,
     X BALAN,
     X CMXLSA,CMXLSR,CMXICA,CMXICR,
     X DEFLAM,DHNS0,
     X ECNTRB,ECORR,ECORRJ,EIMXLS,EIMXIC,EIONPOT,ESKPL,ESKPH,
     X FAC,
     X ibreit,IBWRM,ICAV,IDIAG,IFIX,IGAGR,IGAUGE,IMAXIT,INCLUD,INUKE,
     X IOPTIM,IORT,IPOLFN,IREL,irtard,ISHFTLS,ISHFTIC,ITANAL,ITOL,
     X IWGHT,IXTRA,IZESP,
     X JPRINT,JRAD,JLOWMN,JLOWMX,JUPMN,JUPMX,
     X KCUT,KTCC,KUTCA,KUTCAS,KUTLS,
     X LLOWMN,LLOWMX,LUPMN,LUPMX,
     X M,MAXE,MAXLAM,MCFMX,MCFSTO,MDELE,MDEN,MEXPOT,MEXTRE,MGRP,MHF,
     X MIXBV,MPNCH,MPRINT,MPSEUD,MRAD,MRED,MSTEP,MULTS,
     X NDEN,NEIGEN,NEIGENJ,NFIX,NLAM,NLAMD,NLAMQ,NMETAP,NMETAPJ,
     X NMETAR,NMETARJ,NOCC,NPE,NPITER,NRSLMX,NVAR,NVARD,NVARQ,NZION,
     X ORTHOG,
     X POTIN,POTL,POTOUT,PPOT,PRINT,
     X QED                                                   !ANSI LIMIT
      NAMELIST/SMINIM/
     X RAD,RADOUT,RCAV,RCUT,RMIN1,RMIN2,RNUKE,RZERO,
     X SCALER,SKIN,STOLB,STONLZ,
     X TCC,TINORB,TK0,TOLB,TOLE,TOLTCC,TVARY,
     X WLG1,WLG2,
     X xmax,XMIX,
     X ZESP
C
      KCUT0=KCUT                  !HOLD ALGEB KCUT
      PI=ACOS(-DONE)
C TERMS
      NTRMS=0
      DO N=1,NSL0
        NTRMS=NTRMS+NSL(N)
      ENDDO
C LEVELS
      NLVLS=0
      DO N=1,NJO
        NLVLS=NLVLS+NT(N)
      ENDDO
C
C SOME INITIALIZATIONS.
C
      BDR=IDR.NE.0                !'DR' LOOPING OVER DUMMY RYDBERG
      BPASS1=.TRUE.               !.T. FOR FIRST NL-LOOP, THEN .F.
      MAUTO=0                     !CONTROLS ACCESS TO RADWIN/RADCON
      MXBOX=-1                    !BOX ORBITAL POINTS (INTERNAL)
C
      MB0=MB
      IF(IEQ(0).LT.0)MXBORB=-IEQ(0)         !FOR NON-UNIQUE BASIS
      IF(IEQ(0).GT.0)THEN                   !UNPACK
        IF(IRLX.LT.0)MB0=0
        ID=IEQ(0)-MXORB
        NGRP=ID/100000
        ID=ID-100000*NGRP
        MXFORB=ID/10000
        ID=ID-10000*MXFORB
        MXVORB=ID/1000
        ID=ID-1000*MXVORB
        MXBORB=ID
c       write(0,*)'pack:',ngrp,mxborb,mxvorb,mxforb
      ENDIF
C
C SET-UP ORBITAL INFO,SCALING PARAMETERS ETC.
C TYPE OF ORBITAL I FLAGGED BY USER VIA QN(I), CONVERT TO INTERNAL
C SCREEN(I) FLAG.
C
      IV=0                        !INITIALIZE NO. OF RYDBERG ORBS
      NGROUP=0                    !HIGHEST NL-SUBSHELL INDEX OCCUPPIED
      NOLD=0                      !HIGHEST L ORBITAL INDEX
      MION=NW+NF                  !TOTAL NUMBER OF ELECTRONS
      IPIG=1                      !IN CASE RADCON NOT CALLED
      NWRM=NW
      MAXN=0
      ICC=0
      IXTRA=-1
      iswch=0
      bnobv=.true.                !switch-off bound-Rydberg interaction
C
      IF(BDR)THEN
        IF(BLOOP)THEN
          LVP=LNEW
        ELSE
          LVP=0
        ENDIF
      ENDIF
C
      DO I=1,MXORB                !MAXGR
        IVAL(I)=0                 !DUMMY RYDBERG ORBITAL FLAG
        FACT(I)=DONE
        MCFSTO(I)=0               !STO CF NOS.
        TEL(I)=DZERO              !POTL OCCUPATION NOS
C        DORIG(I)=DONE             !TEST
        rnorm(i)=done
C
        IF(DEY(I).NE.DZERO)THEN   !ORBITAL EXISTS IN A CONFIG
          NGROUP=I
          IF(QL(I).GT.NOLD)NOLD=QL(I)
C
          IF(QN(I).LT.70)THEN     !N=1-69, NORMAL INTERNAL BOUND ORBITAL
            NE=QN(I)
            MAXN=MAX(MAXN,NE)
            NE=(NE-1)*NE*(2*NE-1)
            NE=NE/3
            L=QL(I)/2
            LVP=MAX(LVP,L)
            NE=NE+QL(I)+1+L*QL(I)
            IF(NE.GE.MION)NE=MION-1
            SCREEN(I)=NE
          ELSEIF(QN(I).LT.80)THEN !N=70-79: RADWIN EXTERNAL ORBITAL
            SCREEN(I)=3999
          ELSEIF(QN(I).LT.90)THEN !N=80-89: DUMMY RYDBERG ORBITAL
            iswch=1
            IVAL(I)=1
            IV=IV+1
            SCREEN(I)=MION-1
          ELSE                    !N=90-99: CONTINUUM ORBITAL
            iswch=1
            ICC=ICC+1
C            IVAL(I)=0
C            IV=IV-1
            SCREEN(I)=9999
          ENDIF
        ENDIF
      ENDDO
c
      IF(BDR)THEN
        NSW0=LVP*LVP
        NSW0=NSW0/4
        NSW0=NSW0+NS0
        IF(NSW0.GT.NSX)NSW0=NSX
        IF(NSW.LT.NSW0)NSW=NSW0
      ENDIF
C
      IF(ISCALR.GT.0)NGROUP=MAX(NGROUP,ISCALR)    !FOR SLATER SCALING
C
      IOPTIM=0                 !OPTIMIZATION SWITCH
      NOLD=NOLD/2+1            !MAX NO L-DEPENDENT SCALING PARAMETERS
      ITOL0=7          !DEFAULT ACC OF ORBITALS DEL(E)/E.LT.10**(-ITOL0)
      MORT=1                   !ORTHOG SWITCH, RESET BY USER IORT
      INCLUD=0                 !SEE INPUT BELOW
      MEXTRE=0                 !SEE INPUT BELOW
C
C
C  10 OLD ISOELECTRONIC RE-ENTRY POINT
C
      NPARAM=NOLD              !RESET NO SCALING PARAMETERS
      ITOL=0                   !SEE ITOL0 ABOVE
      IMAXIT=0                 !NO OF ITERATIONS IN VA04A
      TVARY=D1M2               !MAX VARY OF SCALE PER ITERATION
      NLSTOE=-18               !STO NL SCREEN BEYOND AR-LIKE
      JUPMX=NLVLS              !MAX UPPER LEVEL FOR RADIATIVE OUTPUT
      JUPMN=1+ione1             !MIN UPPER   "         "        "
      JLOWMX=JUPMX-ione1        !MAX LOWER   "         "        "
      JLOWMN=1                 !MIN LOWER   "         "        "
      LUPMX=max(NTRMS,KMAX)    !MAX UPPER TERM/CF FOR RADIATIVE OUTPUT
      LUPMN=1+ione1             !MIN UPPER   "            "        "
      LLOWMX=LUPMX-ione1        !MAX LOWER   "            "        "
      LLOWMN=1                 !MIN LOWER   "            "        "
      EIMXLS=0                 !MAX LS ION ENERGY FOR AUGER RESOLUTION
      EIMXIC=0                 !MAX IC  "    "          "       "
      NRSLMX=10000             !MAX RESOLVED LOWER N-VALUE IF ABOVE ON
      NMETAR=0                 !MAX NO TERMS FOR AUGER RESOLUTION
      NMETARJ=0                !MAX NO LEVELS FOR AUGER RESOLUTION
      NMETAP=0                 !MAX NO LOWER TERMS FOR PE/PI
      NMETAPJ=0                !MAX NO LOWER LEVELS FPR PE/PI
      ECORRJ=0                 !CORRELATION ABOVE ECORRJ (IC)
      ECORR=0                  !CORRELATION ABOVE ECORR (LS & IC)
      ESKPL=-1                 !CORRELATION BETWEEN ESKPL
      ESKPH=-2                 !AND ESKPH
      NEIGEN=0                 !LOWEST NO ENERGY TERMS PER LSP SYM
      NEIGENJ=0                !LOWEST NO ENERGY LEVELS PER JP SYM
C
      IF(BNAME)THEN            !NO TERMINATOR OR ISOELECTRONIC FOR NAME
C
        IF(INCLUD.EQ.0.AND.MEXTRE.GT.1000)BPASS1=.TRUE.
        IF(.NOT.BPASS1)GO TO 95                        !RETURN
        BPASS1=.FALSE.
C
      ENDIF
C
C FREQUENTLY USED INPUTS
C
      NZION=0                  !NUCLEAR CHARGE (<0 TF, >0 STO, 0 STOP)
      INC0=INCLUD              !NO. TERMS TO INCLUDE IN ENERGY MINIM
      INCLUD=0                 !>0 LOWEST, <0 TERMS TO BE SPECIFIED
      NLAM=0                   !NO. SCALING PARAMETERS
      NVAR=0                   !NO. VARIATIONAL PARAMETERS
      MCFMX=0                  !NO. STO POTENTIAL CF'S
      PRINT='FORM'             !'UNFORM' UNFORMATTED OUTPUT (SHORT)
      MAXE=-1                  !MAX CONTINUUM ENERGY FOR PI (&DW)
C
C OCCASIONALLY NEEDED
C
      MPRINT=-11               !JPRINT PASSED "UP" BY HISTORIC MPRINT
      JPRINT=999               !ALTERNATE (FLAG)
      IGAUGE=0                 !AEK/SEK GAUGE =0 LENGTH, ELSE VEL.
      ICAV=0                   !.NE.0 APPLY CONFIG. AV. ENERGY CORREC
      AJUSTX=DONE              !GLOBAL CONFIG. AV. EXCHANGE SCALING
      DEFLAM=DONE              !DEFAULT LAMBDA
      MSTEP=0                  !INITIAL STEP LENGTH PROP 1/2**MSTEP
      DHNS0=DZERO              !EXACT INITIAL STEP LENGTH
      MRED=0                   !+/- SUBTRACT/ADD ELECTRNS IN MODEL POT
      ORTHOG='  '              !CHANGE DEFAULT ORTHOG. 'YES'='  '
      IORT=-1                  !DITTO
      RADOUT='  '              !OUTPUT RADIAL FILE E.G. FOR R-MATRIX
      NLAMD=0                  !DIPOLE TF PERTBN NLAM
      NLAMQ=0                  !QUAD TF PERTBN NLAM
      NVARD=0                  !DIPOLE TF PERTBN NVAR
      NVARQ=0                  !QUAD TF PERTBN NVAR
      IPOLFN=9999              !TYPE OF POLARIZATION POTENTIAL
      DO I=0,3                 !1-BODY POLARIZATION SPECIFICATION
        ALFD(I)=DZERO
        RCUT(I)=DZERO
      ENDDO
      ALAV=DZERO               !2-BODY POLARIZATION SPECIFICATION
      RCAV=DZERO               !           DITTO
      SCALER=DONE              !COWAN SLATER INTEGRAL SCALE FACTOR
      ISHFTLS=0                !TERM ENERGY CORRECTIONS
      ISHFTIC=0                !PLUS LEVEL ENERGY CORRECTIONS
      RZERO=-DONE              !RADIUS OF BOX STATES
      INUKE=999                !FINITE NUCLEUS TYPE
      RNUK=-DONE               !FINITE NUCLEUS RADIUS
      RNUKE=RNUK               !ALTERNATE
      ATM=-DONE                !NUCLEAR MASS
      IZESP=0                  !ZETA S-O SCREENING PARAMETER
      DO I=1,MAXLL
        ZESP(I)=DONE
      ENDDO
      IBWRM=0                  !MAX R-MATRIX CLOSED SHELL ORB. NO.
      MIXBV='NO'               !ALLOW N+1 AND RYDBERG TO MIX IN DR LOOP
      KUTLSA=KUTLS             !ALGEB VALUE (CURRENTLY NOT RESTARTed)
      KUTLS=KMAX               !FLAG FOR CONFIG MIXING
      MDEN=0                   !TYPE OF PLASMA POTENTIAL
      NDEN=0                   !NO. OF DENSITY/TEMP PAIRS
      PPOT='  '                !PLASMA OR SELF-CONSISTENT POTENTIAL
      NPITER=5                 !NO. PLASMA ITERATIONS
C
C THE REST ARE HARDLY EVER USED OR NEEDED, EXCEPT FOR TESTING
C
      IREL=999                 !SMALL CPT FLAG & TYPE OF S-O SCREENING
      TK0=-DONE                !NON-UNIFORM NUCLEUS SCALING PARAMETER
      SKIN=DZERO               !NUCLEAR SKIN DEPTH
      IGAGR=0                  !NUMERICAL GAUGE FOR RELATIVISTIC ORBS
      irtard=1                 !RETARDATION SWITCH FOR MULTIPOLE RADTN
      ibreit=0                 !GENERALIZED BREIT SWITCH
      QED=0                    !QED CORRECTIONS
      MEXTRE=0                 !HISTORIC MIX OF NLAM AND NVAR
      M=0                      !HISTORIC MSTEP
      MEXPOT=-999              !LOCAL (STO) EXCHANGE POTENTIAL
      NOCC=0                   !NO. OCCUPATION NOS FOR STO/SCF
      STONLZ='   '             !YES/NO: STO NL-SUBSHELL SCREENING
      IWGHT=1                  !TERM WEIGHTING FACTOR FOR ENERGY SUM
      KCUT=-9999               !OVERRIDE ALGEB KCUT...
      NPE=12                   !MIN NUMBER STEPS PER PI FOR CONTINUUM
      ITANAL=0                 !DETAIL CI FOR ITANAL TERMS
      ECNTRB=DZERO             !WHICH CONTRIB ECNTRB WAVE NOS TO TERM
      IFIX=0                   !NO OF ORBS TO BE FIXED IN SCF
      NFIX=0                   !NO OF LAMBDAS TO BE FIXED IN MINIM
      RAD='  '                 !RESTRICT RAD TO 'BB' OR 'BF', SAY
      JRAD=0                   !RAD CHAR CONVERTED TO NUMERICAL
      EIONPOT=DZERO            !IF NO CONTINUUM, SET ABSOLUTE I.P.
      TINORB=-DONE             !MAX ORBITAL AMPLITUDE AT BOX
      xmax=-done               !MAX RADIAL MESH
      XMIX=D1M4                !FOR DWXLS/BP
      WLG1=-DONE               !MIN E1 RATE RETAINED
      WLG2=-DONE               !MIN E2 RATE RETAINED
      RMIN1=WLG1               !ALTERNATE
      RMIN2=WLG2               !ALTERNATE
C
C CAN'T REMEMBER THE LAST TIME THESE WERE USED
C
      MAXLAM=1000              !MAX 2-BODY MULTIPOLE (SEE KUTLS)
      MGRP=0
      FAC='  '
      MPNCH=0
      KUTCAS=-1                !CASCADE
      KUTCA=999                !HISTORIC, NOT CUP='CA', REMOVE TBD
      KTCC=0
      TCC='NO'
      TOLTCC=-DONE
      MDELE=0
      MULTS=0
      MHF=0
      MRAD=0
      POTL='  '
      POTOUT='  '
      POTIN='  '
      BALAN=.false.
      MPSEUD=0
      IDIAG=0
      TOLE=DZERO
      TOLB=-DONE
      STOLB=-DONE
C
C THESE ARE NO LONGER ACTIVE, UNLESS UNCOMMENTED IN DIAGON/DIAGFS
C
      CMXLSA=D1M5              !SMALLEST MIXING COEFFS RETAINED
      CMXLSR=D1M5              !FOR LS AND IC
      CMXICA=D1M5              !AND FOR AUGER
      CMXICR=-D1M5             !AND RADIATIVE RATES
C
C-----------------------------------------------------------------------
C
C NAMELISTED INPUT (PREFERRED)
C
C-----------------------------------------------------------------------
C
      IF(BNAME)THEN
C
C
        READ(5,SMINIM,END=999,ERR=999)  ! <-------------------- NAMELIST
C
        IF(JPRINT.NE.999)MPRINT=JPRINT
        IF(KUTCA.NE.999)KUTCAS=KUTCA
        IF(RNUK.LT.DZERO)RNUK=RNUKE
        IF(WLG1.LT.DZERO)WLG1=RMIN1
        IF(WLG2.LT.DZERO)WLG2=RMIN2
C
      ELSE
C
C-----------------------------------------------------------------------
C HISTORIC NON-NAMELIST FIXED FORMAT INPUT: CAN LOOP OVER MULTIPLE NZION
C     N.B. ISOELECTRONIC LOOP HAS BEEN DISABLED.
C
C     NOTE: FOR THE NEXT ISOEL STRUCTURE RUN ONE CAN START WITH THE OLD
C     SCALING (PUT MEXTRE=-NEXTRE) OR SCREENING PARAMETERS (PUT MGRP=0)
C
C CURRENTLY, THESE VARIABLES CAN ONLY BE CHANGED WITH NAMELIST INPUT.
C-----------------------------------------------------------------------
C
C
        READ(5,995)NZION,INCLUD,MEXTRE,MGRP,MDEN,MPRINT,MEXPOT,MPNCH
     X            ,KUTCAS,MRED,IORT,MDELE,MULTS,M0,MHF,MCFMX
C
C
      ENDIF
C
C
      IF(MPRINT.EQ.0.AND.BDR)MPRINT=-33
      IF(MPRINT.EQ.0)MPRINT=-11
      IF(PRINT.EQ.'UNFORM')MPRINT=-33
      BPRNT0=MOD(MPRINT,ITEN).NE.-3
C
      IF(ICAV.NE.0)THEN
        IF(IEQ(0).NE.0)THEN
          ICAV=0
          WRITE(6,*)
          WRITE(6,*)'*** RE-SETTING ICAV=0 SINCE RELAXED ORBITAL',
     X    ' BASIS PREVIOUSLY SPECIFIED.'
        ENDIF
        IF(INCLUD.NE.0)THEN
          INCLUD=0
          WRITE(6,*)
          WRITE(6,*)'*** RE-SETTING INCLUD=0 SINCE ICAV.NE.0'
        ENDIF
        IF(ICAV.GT.0)THEN                                !BASIC SET-UP
          NZION=-ABS(NZION)                            !MUST HAVE STO
          IF(PPOT.EQ.'   ')PPOT='SCCA'                !SELF-CONSISTENT
          IF(MCFMX.EQ.0)THEN                   !AV. OCC. NOS OVER SPEC
            MCFMX=MIN(KCUT,KCUT0,KMAX)
            IF(MCFMX.LE.0)MCFMX=-KMAX
          ENDIF
        ENDIF
      ENDIF
C
      NRSLMX=MAX(NRSLMX,-KMAX)                     !.LT.0 BUNDLE BY CF
C
      IF(KCUT.GE.0.AND.KCUT.NE.KCUT0)THEN
        IF(KCUT.EQ.0)KCUT=9999
        WRITE(6,*)
        IF(KCUT*KCUT0.GT.KCUT0*KCUT0)THEN
          WRITE(6,*)"*** WARNING: CORRELATION FLAG HAS BEEN REMOVED ",
     X    "FROM CF'S",KCUT0+1," THRU",KCUT,", RATES INCOMPLETE!"
          WRITE(0,*)"*** WARNING: ALGEB CORRELATION SETTING HAS BEEN",
     X    " OVERRIDDEN!"
        ELSE
          WRITE(6,*)"NOTE: CF'S FROM",KCUT+1,"UPWARDS HAVE BEEN ",
     X    "FLAGGED AS CORRELATION - MORE EFFICIENT TO DO SO IN ALGEB!"
        ENDIF
      ELSE
        KCUT=KCUT0                              !RE-INSTATE ALGEB KCUT
      ENDIF
C
      IF(TOLTCC.LT.DZERO)TOLTCC=D1M5
      IF(TCC.EQ.'STGICF')KTCC=1
      IF(TCC.EQ.'JAJOM')KTCC=-1
      IF(KTCC.EQ.0.AND.TCC.NE.'NO'.AND.TCC.NE.'  ')THEN
        WRITE(6,*)"*** UNRECOGNIZED TCC OPTION, TCC='",TCC,"'"
        WRITE(0,*)"*** UNRECOGNIZED TCC OPTION, TCC='",TCC,"'"
      ENDIF
      IF(MPNCH.NE.0)THEN
        MPNCH0=1
        IF(MPNCH.LT.0)MPNCH0=-1
        M0=ABS(MOD(MPNCH,IFOUR))
        IF(KUTCAS.GE.0.AND.M0.EQ.1)MPNCH=MPNCH+2*MPNCH0
        IF(KUTCAS.LT.0.AND.M0.GT.1)KUTCAS=0
        IF(KTCC.NE.0.AND.MOD(M0,ITWO).EQ.0)MPNCH=MPNCH+MPNCH0
        IF(KTCC.EQ.0.AND.MOD(M0,ITWO).NE.0)KTCC=1
      ELSE
        IF(KUTCAS.GE.0)MPNCH=-2
        IF(KTCC.NE.0)MPNCH=MPNCH-1
      ENDIF
C
      M0=MAX(M,MSTEP)
C
C ALIGN SR.ALGEB KUTLS(A) AND SR.MINIM KUTLS
      IF(KUTLS.LT.0)KUTLS=0
      KUTLS=MIN(KUTLS,KMAX)
      IF(KUTLS.NE.KUTLSA)THEN
        IF(KUTLS.LT.KUTLSA)THEN
          WRITE(0,*)
     X      "*** SR.MINIM: ATTENTION, CI-MIXING WITHIN A CONFIG ONLY"
     X     ," FOR CF'S .GT. KUTLS=",KUTLS
          WRITE(6,*)
     X      "*** SR.MINIM: ATTENTION, CI-MIXING WITHIN A CONFIG ONLY"
     X     ," FOR CF'S .GT. KUTLS=",KUTLS
          WRITE(0,*)
     X    '*** NOTE: MORE EFFICIENT TO SET KUTLS IN SR.ALGEB'
          WRITE(6,*)
     X    '*** NOTE: MORE EFFICIENT TO SET KUTLS IN SR.ALGEB'
        ELSE
          IF(KUTLS.LT.KMAX)THEN                                !USER SET
            WRITE(0,*)
     X   '*** CI-MIXING WAS SWITCHED-OFF IN SR.ALGEB, RE-SETTING KUTLS!'
            WRITE(6,*)
     X   '*** CI-MIXING WAS SWITCHED-OFF IN SR.ALGEB, RE-SETTING KUTLS!'
          ENDIF
          KUTLS=KUTLSA
        ENDIF
      ENDIF
C
      IF(MAXLAM.LT.0)THEN                 !HISTORIC USER FLAG NO CF-MIX
        MAXLAM=-MAXLAM
        IF(KUTLS.GT.1.AND.KUTLS.LT.KMAX)THEN
          WRITE(0,*)'NOTE: USER SETTING OF KUTLS OVERRIDES MAXLAM < 0'
          WRITE(6,*)'NOTE: USER SETTING OF KUTLS OVERRIDES MAXLAM < 0'
        ELSEIF(KUTLS.EQ.KMAX)THEN
          KUTLS=0
          WRITE(0,*)
     X'***ATTENTION, USE KUTLS TO SWITCH-OFF CI-MIXING (IN ALGEB) NOW'
          WRITE(6,*)
     X'***ATTENTION, USE KUTLS TO SWITCH-OFF CI-MIXING (IN ALGEB) NOW'
        ENDIF
      ENDIF
C
      TOLE=TOLE/DTWO                      !CONVERT TO A.U.
C
      IF(CMXICR.LT.DZERO)THEN
        IF(MPOLE.GE.4)THEN
          CMXICA=D1M8
          CMXICR=D1M8
        ELSE
          CMXICR=D1M5
        ENDIF
      ENDIF
C
      IF(STOLB.LT.DZERO)STOLB=D1M9       !BORN INTEGRAL TOLERANCE
C
      bnobv=MIXBV.NE.'YES'               !no n+1 Rydberg DR mixing
C
      IF(MPSEUD.GT.0)THEN
        MPSEUD=MB
      ELSEIF(MPSEUD.LT.0)THEN
        MPSEUD=-MB
        IF(IREL.EQ.999)IREL=-1
      ENDIF
C
      IF(IPOLFN.LT.0)THEN
        WRITE(0,*)'*** RESETTING IPOLFN=0 (.LT.0 INTERNALLY RESERVED)'
        WRITE(6,*)'*** RESETTING IPOLFN=0 (.LT.0 INTERNALLY RESERVED)'
        IPOLFN=0
      ENDIF
C
      IF(NLAMD.NE.0.or.nvard.gt.0)IPOLFN=-1
      IF(NLAMQ.NE.0.or.nvarq.gt.0)IPOLFN=-2
      IF(NZION.LT.0.AND.IPOLFN.LT.0)THEN
        WRITE(6,*)' *** SR.MINIM: ERROR, CANNOT USE PERTURBED TF',
     X            ' WITH STO! SET NZION.GT.0, OR SWITCH-OFF PERTURBN.'
        WRITE(0,*)'CANNOT USE PERTURBED TF WITH STO!'
        GO TO 998
      ENDIF
C
      III=INCLUD
      INCLUD=INC0
      IF(NVAR.LT.0)THEN
        ISVAR=-1
        NVAR=-NVAR
      ELSEIF(NVAR.GT.0)THEN
        ISVAR=1
      ELSE
        ISVAR=1
        IF(NVARD.LT.0.OR.NVARQ.LT.0)ISVAR=-1
      ENDIF
      IF(NVARD.LT.0)NVARD=-NVARD             !NVAR OVERRIDES
      IF(NVARQ.LT.0)NVARQ=-NVARQ             ! "      "
      IF(TVARY.LE.D1M5)TVARY=D1M2
C
C INITIALIZE FOR POLARIZATION
C
      IF(ALFD(0).NE.DZERO)THEN              !USER HAS STARTED AT 0
        DO I=3,1,-1
          ALFD(I)=ALFD(I-1)
          RCUT(I)=RCUT(I-1)
        ENDDO
      ENDIF
      IF(ALFD(1).EQ.DZERO)ALFD(1)=ALFD(2)
      IF(ALFD(2).EQ.DZERO)ALFD(2)=ALFD(1)
      IF(ALFD(3).EQ.DZERO)ALFD(3)=ALFD(2)
      IF(RCUT(1).EQ.DZERO)RCUT(1)=RCUT(2)
      IF(RCUT(2).EQ.DZERO)RCUT(2)=RCUT(1)
      IF(RCUT(3).EQ.DZERO)RCUT(3)=RCUT(2)
      IF(ALAV.EQ.DZERO)THEN
        DO I=1,3
          ALAV=ALAV+ALFD(I)
        ENDDO
        ALAV=(DONE/DTHREE)*ALAV
      ENDIF
      IF(RCAV.EQ.DZERO)THEN
        DO I=1,3
          RCAV=RCAV+RCUT(I)
        ENDDO
        RCAV=(DONE/DTHREE)*RCAV
      ENDIF
      IF(ALFD(1)*RCUT(1).NE.DZERO)THEN         !SWITCH-ON POLARIZATION
        IF(IPOLFN.LT.0)THEN
          WRITE(6,*)'***SR.MINIM: CANNOT USE PERTURBED TF WITH',
     X              ' NORCROSS/BAYLISS POLARIZATION POTENTIAL'
          WRITE(0,*)'***CANNOT MIX NORCROSS/BAYLISS WITH PERTURBED TF'
          GO TO 998
        ENDIF
        IF(IPOLFN.EQ.9999)IPOLFN=1                           !NORCROSS
        IPOLF1=MOD(IPOLFN,ITEN)
        IPOLF2=IPOLFN/10
        IF(IPOLF1.GT.2)IPOLF1=2                               !BAYLISS
        IF(BPRNT0)THEN
          IF(IPOLF1.EQ.1)WRITE(6,882)(I-1,ALFD(I),RCUT(I),I=1,3)
          IF(IPOLF1.EQ.2)WRITE(6,883)(I-1,ALFD(I),RCUT(I),I=1,3)
        ENDIF
        IF(IPOLF2.GT.0)THEN
          IF(IPOLF2.GT.2)IPOLF2=2
          IF(BPRNT0)THEN
            IF(IPOLF2.EQ.1)WRITE(6,880)ALAV,RCAV
            IF(IPOLF2.EQ.2)WRITE(6,881)ALAV,RCAV
          ENDIF
        ENDIF
        IPOLFN=10*IPOLF2+IPOLF1
      ELSE
        IF(IPOLFN.GT.0)IPOLFN=0
      ENDIF
      DO I=1,3
        ALFD(I)=ALFD(I)/DTWO
      ENDDO
C
C SET LOW-LEVEL VARIABLES BASED ON USER INPUT
C
      IF(RADOUT.EQ.'YES')THEN
        IF(BDR)THEN
          MRAD=0                                !SET INTERNAL FLAG
          WRITE(6,*)'*** RE-SETTING RADOUT="NO" SINCE &DRR IN USE'
          WRITE(0,*)'*** RE-SETTING RADOUT="NO"'
        ELSE
          MRAD=-13                         !NO LONGER NEED TO SET UNIT
        ENDIF
      ELSEIF(RADOUT.EQ.'NO')THEN
        MRAD=0
      ELSEIF(RADOUT.NE.'  ')THEN
        WRITE(0,*)'*** UNRECOGNIZED OPTION FOR RADOUT...'
        WRITE(6,878)RADOUT
        GO TO 998
      ENDIF
C
      IF(POTOUT.EQ.'YES')THEN               !GIVES RADIAL AS WELL
        IF(BDR)THEN
          MRAD=0                                !SET INTERNAL FLAG
          WRITE(6,*)'*** RE-SETTING POTOUT="NO" SINCE &DRR IN USE'
          WRITE(0,*)'*** RE-SETTING POTOUT="NO"'
        ELSE
          MRAD=MRAD-100
        ENDIF
      ELSEIF(POTOUT.EQ.'NO')THEN
        MRAD=MOD(MRAD,I100)
      ELSEIF(POTOUT.NE.'  ')THEN
        WRITE(0,*)'*** UNRECOGNIZED OPTION FOR POTOUT...'
        WRITE(6,877)POTOUT
        GO TO 998
      ENDIF
C
      IF(POTIN.EQ.'HFFC')THEN
        MHF=1
      ELSEIF(POTIN.EQ.'YES'.OR.POTIN.EQ.'FAC')THEN
        MHF=2
      ELSEIF(POTIN.EQ.'HFNL')THEN
        MHF=3
      ELSEIF(POTIN.EQ.'NO')THEN
        MHF=0
      ELSEIF(POTIN.NE.'  ')THEN
        WRITE(0,*)'*** UNRECOGNIZED OPTION FOR POTIN...'
        WRITE(6,879)POTIN
        GO TO 998
      ENDIF
C
      IF(POTL.EQ.'STO')NZION=-ABS(NZION)
      IF(POTL.EQ.'TF')NZION=ABS(NZION)
C
      IF(ORTHOG.EQ.'L')IORT=1
      IF(ORTHOG.EQ.'NO'.OR.(ORTHOG.EQ.'  '.AND.NZION.LT.0))IORT=-3
      IF(ORTHOG.EQ.'LPS')IORT=-4
      IF(IRLX.EQ.2)IORT=-3         !NON-UNIQUE BASIS='RLX2' IN SALGEB
      IF(ORTHOG.EQ.'BOX')IORT=-5
      IF(IORT.EQ.-5)THEN
        IF(RZERO.LE.DZERO)THEN
          WRITE(6,*)'*** ERROR: USER MUST INPUT RZERO.GT.0 FOR BOX'
          WRITE(0,*)'*** ERROR: USER MUST INPUT RZERO.GT.0 FOR BOX'
          GO TO 998
        ENDIF
        MXBOX=0
        IF(TINORB.LT.DZERO)TINORB=TINORB0
      ENDIF
C
      IF(STONLZ.EQ.'YES')NLSTOE=0
      IF(STONLZ.EQ.'NO')NLSTOE=999
C
C INITIALIZE FOR RELATIVISTIC ORBITALS
C
      IF(BREL)THEN
        IF(IORT.EQ.-4)THEN
          WRITE(6,*)'*** RELATIVISTIC LPS NOT CODED...'
          WRITE(0,*)'*** RELATIVISTIC LPS NOT CODED...'
          GO TO 998
        ENDIF
        IF(IORT.EQ.-5)THEN
          WRITE(6,*)'*** RELATIVISTIC BOX STATES NOT CODED...'
          WRITE(0,*)'*** RELATIVISTIC STATES NOT CODED...'
          GO TO 998
        ENDIF
        IF(ORTHOG.EQ.'  ')IORT=-3
        IF(IORT.LT.0.AND.IORT.NE.-3)THEN
          WRITE(6,*)
     X      '*** WARNING: KAPPA-AVERAGED RADIAL EQUATION IS NON-LINEAR'
          WRITE(6,*)'*** SCHMIDT-ORTHOGONALIZATION IS NOT RECOMMENDED!'
          WRITE(0,*)
     X      '*** WARNING: KAPPA-AVERAGED RADIAL EQUATION IS NON-LINEAR'
          WRITE(0,*)'*** SCHMIDT-ORTHOGONALIZATION IS NOT RECOMMENDED!'
        ENDIF
      ENDIF
C
C-----------------------------------------------------------------------
C
C END OF PRIMARY USER INPUT. SUBSEQUENT READS DEPENDENT ON THIS.
C
C-----------------------------------------------------------------------
C
C
      IF(NZION.EQ.0)GO TO 95        !<---------------------- TRUE RETURN
C
C
      IF(ABS(NZION).GT.118)THEN
        WRITE(6,*)' HERE BE MONSTERS, Z>118 - EXITING...'
        WRITE(0,*)' HERE BE MONSTERS, Z>118 - EXITING...'
        GO TO 998
      ENDIF
C
      WRITE(6,993)
C
C
C FLAG CORRELATION BY ENERGY, THEN NOT NICELY ORDERED AS ALGEBRAIC CORR.
C
      IF(ECORRJ.EQ.DZERO)ECORRJ=ECORR              !HISTORIC, ONLY ECORR
      BECOR=ESKPH.GT.ESKPL.AND.ESKPL.GE.DZERO.OR.
     X      ECORR.NE.DZERO.OR.ECORRJ.NE.DZERO
C
C RELATIVISTIC GAUGE: IGAGR.GT.0 CONVERT 1/R INTEGRALS TO R**2
C                          .LT.0 LEAVE ALONE.
C
      IF(IGAGR.EQ.0)THEN
        IF(BREL)THEN
          IGAGR=1
        ELSE
          IGAGR=-1
        ENDIF
      ENDIF
C
C RADIATIVE RATES: IGAUGE=0 FOR LENGTH GAUGE, ELSE VELOCITY.
C
C      IGAG(0)=IGAUGE                               !SET IN MINIM
C
C RESTRICT RADIATIVE DATA (DEFAULT ALL)
C BOUND MEANS NON-AUTOIONIZING, FREE MEANS AUTOIONIZING
C TREAT STATES WITHIN TOLE RYD OF IONIZATION LIMIT AS EITHER.
C SET EIONPOT IF CONTINUUM NOT PRESENT.
C
C   RAD='BB'  BOUND-BOUND
C   RAD='BF' OR 'FB' BOUND-FREE
C   RAD='FF'  FREE-FREE
C   RAD='BBF' OR 'FBB' BOUND-BOUND + BOUND-FREE
C   RAD='BFF' OR 'FFB' BOUND-FREE + FREE-FREE
C
      IF(RAD.EQ.'BB')JRAD=1
      IF(RAD.EQ.'BF'.OR.RAD.EQ.'FB')JRAD=2
      IF(RAD.EQ.'FF')JRAD=3
      IF(RAD.EQ.'BBF'.OR.RAD.EQ.'FBB')JRAD=4
      IF(RAD.EQ.'BFF'.OR.RAD.EQ.'FFB')JRAD=5
      IF(JRAD.LT.0.OR.JRAD.GT.5)JRAD=0
C
      EIONPOT=EIONPOT/DTWO                      !CONVERT TO A.U.
C
C MINIMUM RADIATIVE RATES RETAINED: E1=(WLG1,RMIN1), E2=(WLG2,RMIN2)
C
C MINIMUM MIXING COEFFICIENTS TREATED AS NON-ZERO (1.E-5 DEFAULT)
C FOR LS AND IC AUTOIONIZATION AND RADIATIVE RATES: CMXLS/IC/A/R
C
C IDIAG .LE. 0 USE HOUSEHOLDER DIAGONALIZATION IN DIAGON/DIAGFS.
C           -1 DOES NOT APPLY TESTS THAT DEPEND ON CF LABEL.
C IDIAG .GT. 0 USE JACOBI METHOD INSTEAD.
C
C MPSEUD .NE. 0 USE MODEL POTENTL FOR CORE DEFINED BY KCOR1,2 IN ALGEB1
C        .GT. 0 SPIN-ORBIT FROM BLUME & WATSON, SO CORE ORBITALS NEEDED.
C        .LT. 0     "           MODEL POTENTIAL DERIVATIVE, UNLESS
C                               IREL.LT.0 WHICH OVERRIDES.
C
C MAXLAM IS MAX LAMDA FOR WHICH SLATER AND TWO-BODY FINE-STRUCTURE
C INTEGRALS ARE EVALUATED (SHOULD BE SET IN ALGEB).
C
C MCFMX .GT. 0, FOR EACH ORBITAL 1,...MCFMX READ CONFIGURATION
C NUMBER TO BE USED BY STOPOT TO GENERATE MODEL POTENTIAL.
C
C MDEN  .GT. 0 GENERATE PLASMA SCREENING POTENTIAL & READ DENSITY+TEMP
C       .EQ. 1  OR PPOT='DH1'  1-BODY DEBYE-HUCKEL MODEL POTENTIAL
C       .EQ. 11 OR PPOT='DH2' inc. 2-BODY DEBYE-HUCKEL MODEL POTENTIAL
C                  PPOT='DH' = 'DH2' NOW (USED TO BE ='DH1').
C                  PPOT='PXXX' TREATS THE 1-BODY AS A PERTURBATION,
C                  2-BODY IS ALWAYS A PERT. XXX=ANY OF ABOVE DH OPTIONS.
C       .EQ. 2  OR PPOT='IS'  ION-SPHERE MODEL POTENTIAL
C       .EQ. 3  OR PPOT='KS' OR 'SC'  SELF-CONSIST ION-SPHERE(KOHN-SHAM)
C       .LT. 0  NO PLASMA POTENTIAL, ITERATES SELF-CONSISTENT(NEEDS STO)
C PPOT  .EQ. 'SCCA' S.C. CONFIGURATION AVERAGE POT (NON-LOCAL EXCHANGE)
C       .EQ. 'SCFM' OR 'SCLX'  " USING FURNESS & MCCARTHY LOCAL EXCHANGE
C NPITER.EQ. NO. OF PLASMA ITERATIONS CASE MDEN=3, CAN ALSO
C            OVERRIDE DEFAULT (10=-MDEN) ITERATIONS CASE MDEN.LT.0
C
      IF(MDEN.LE.0)THEN
        PPP=PPOT(1:1)
        IF(PPP.EQ.'P')THEN              !1-BODY PLASMA IS A PERTURBATION
          PPOT(1:3)=PPOT(2:4)
          PPOT(4:4)=' '
          NPITER=-ABS(NPITER)                         !FLAG FOR SR.VMPOT
        ENDIF
        IF(PPOT.EQ.'SCCA')THEN      !SELF-CONSISTENT CONFIG. AVERAGE POT
          IF(MDEN.EQ.0)MDEN=-10
          IF(MEXPOT.EQ.-999)MEXPOT=0
        ELSEIF(PPOT.EQ.'SCFM'.OR.PPOT.EQ.'SCLX')THEN !FURNESS & MCCARTHY
          IF(MDEN.EQ.0)MDEN=-10
          IF(MEXPOT.EQ.-999)MEXPOT=1
        ELSEIF(PPOT.EQ.'DH1')THEN
          MDEN=1
        ELSEIF(PPOT.EQ.'DH'.OR.PPOT.EQ.'DH2')THEN           !NEW DEFAULT
          MDEN=11
        ELSEIF(PPOT.EQ.'IS')THEN
          MDEN=2
          NPITER=ABS(NPITER)                         !NO PERT FOR IS
        ELSEIF(PPOT.EQ.'KS'.OR.PPOT.EQ.'SC')THEN
          MDEN=3
        ELSEIF(PPOT.NE.'  ')THEN
          WRITE(6,*)'UNRECOGNIZED PPOT OPTION: "',PPOT,'"'
          WRITE(0,*)'UNRECOGNIZED PPOT OPTION: "',PPOT,'"'
          GO TO 998
        ENDIF
      ELSEIF(PPOT.NE.'  ')THEN
        WRITE(6,*)'IGNORING PPOT INPUT: "',PPOT,'", AS MDEN=',MDEN
        WRITE(0,*)'IGNORING PPOT INPUT: "',PPOT,'", AS MDEN=',MDEN
      ENDIF
C
      IF(MDEN.EQ.2)NSW=9999                       !NO E=0 FOR ION-SPHERE
C
      IF(MDEN.NE.0)THEN
C
C MCFMX IGNORED IF NOCC OCCUPATION NOS SPECIFIED
C
        IF(MCFMX.GT.0)THEN                          !CANNOT USE FAC
          IF(MOD(NOCC,I1000).GT.0)THEN
            WRITE(6,*)'*** MCFMX CF SPECIFICATION OVERRIDDEN BY NOCC'
            WRITE(0,*)'*** MCFMX CF SPECIFICATION OVERRIDDEN BY NOCC'
          ELSE
            IF(FAC.EQ.'YES')THEN
              WRITE(6,*)'*** MCFMX.GT.0 CONFLICTS WITH FAC="YES"...'
              WRITE(0,*)'*** MCFMX.GT.0 CONFLICTS WITH FAC="YES"...'
              GO TO 998
            ENDIF
            FAC='NO'
          ENDIF
        ENDIF
C
C FAC='YES' MIRRORS FAC USING SINGLE AVERAGE POTENTIAL
C    ='NO'  USES ORBITAL DEPENDENT, AND OTHOGONALIZES CASE NL.
C
        IF(FAC.EQ.'  ')FAC='NO'
        IF(FAC.EQ.'YES')THEN
          IF(NOCC.LT.0)NOCC=-NOCC                           !SO FLAG>0
          NOCC=NOCC+1000                                    !ALLOW FOR 0
          IF(MEXPOT.EQ.-999)MEXPOT=-1                       !NX DEFAULT?
        ELSEIF(FAC.EQ.'NO')THEN
          IF(NOCC.GT.0)NOCC=-NOCC                           !SO FLAG<0
          NOCC=NOCC-1000                                    !ALLOW FOR 0
        ELSE
          WRITE(6,*)'UNRECOGNIZED FAC OPTION: "',FAC,'"'
          WRITE(0,*)'UNRECOGNIZED FAC OPTION: "',FAC,'"'
          GO TO 998
        ENDIF
C
        IF(IEQ(0).NE.0.AND.NOCC.GT.0)THEN
          WRITE(6,*)'*** RELAXED ORBITALS CONFLICT WITH FAC="YES"...'
          WRITE(0,*)'*** RELAXED ORBITALS CONFLICT WITH FAC="YES"...'
          GO TO 998
        ENDIF
C
C NEED NL-SUBSHELL RESOLUTION FOR SELF-CONSISTENT
C
        IF(MDEN.LT.0.AND.NLSTOE.NE.0)THEN
          IF(NLSTOE.GT.0)THEN
            WRITE(6,*)'*** RESETS FOR NL-SUBSHELL POTENTIAL RESOLUTION'
            WRITE(0,*)'*** RESETS FOR NL-SUBSHELL POTENTIAL RESOLUTION'
          ENDIF
          NLSTOE=0
        ENDIF
C
C IF  MDEN.EQ.0  THEN (ALL STATIC)
C   MEXPOT .LE. 0 HARTREE STO POTENTIAL (I.E. NON-EXCHANGE)
C   MEXPOT .EQ. 1 HARTREE-EXCHANGE LINDGREN & ROSEN (XK=0.65)
C   MEXPOT .EQ. 2 HARTREE-EXCHANGE LINDGREN & ROSEN (XK=1.00)
C   MEXPOT .GE. 3 HARTREE-EXCHANGE COWAN (XK=1.00)
C IF MDEN.NE.0 THE ABOVE IS FIRST ITERATION ONLY. THEREAFTER
C   MEXPOT .LT. 0 HARTREE MULTIPOLE POTENTIAL
C   MEXPOT .EQ. 0 HARTREE- EXCHANGE-CONFIGURATION-AVERAGE
C   MEXPOT .GT. 0 STATIC PLUS FURNESS & MCCARTHY LOCAL EXCHANGE.
C
        IF(MEXPOT.EQ.-999)MEXPOT=1
C
        IF(III.NE.0.AND.MEXPOT.LT.0)THEN        !SINCE WE SCALE EXCHANGE
          WRITE(6,*)'***SR.MINIM: SETTING INCLUD=0 AS NON-EXCHANGE'
     X             ,' SELF-CONSISTENT SOLUTION FLAGGED'
          WRITE(0,*)'***SR.MINIM: SETTING INCLUD=0, AS NX SC'
          III=0
        ENDIF
        IF(MDEN.LT.0.AND.NZION.GT.0)THEN
          WRITE(6,*)'*** SR.MINIM: SELF-CONSISTENT SOLUTION REQUIRES',
     X              ' STO FLAG, SETTING NZION.LT.0'
          WRITE(0,*)'***SR.MINIM: SETTING NZION.LT.0'
          NZION=-NZION
        ENDIF
      ENDIF
C
C MHF .NE. 0 OPERATION SEPARATED INTO
C            MRAD (OLD MHF.LT.0) AND MHF (AS MHF.GT.0)
C            SO THAT THEY CAN BE SET INDEPENDENTLY.
C
      IF(MHF.GT.3)MHF=2                            !FAC DEFAULT
C
C MHF .GT. 0 READ EXTERNAL POTENTIAL FROM FILE hffcin/potin
C             ***CHECK FORMATS IN SR.POTIN***
C     .EQ. 1 ORIGINAL HARTREE-FOCK FROZEN-CORE (UNIQUE, USED FOR ALL)
C     .EQ. 2 FAC (UNIQUE, USED FOR ALL INTERNAL ORBITALS)
C     .EQ. 3 NL-DEPENDENT, IF NL NOT FOUND, THEN REVERT TO INTERNAL
C
C MRAD .LT. 0 WRITE P & Q FUNCTIONS AND MAYBE UNIQUE POTENTIAL TO radout
C
C      IF(MRAD.LT.0)MRAD=100*(MRAD/100)-13     !NOW HARD-WIRED TO UNIT13
C
C SET BREIT SWITCHES, & DEFAULT NUCLEUS:
C
      IF(BREL)THEN
        IF(IREL.EQ.999)THEN
          IREL=1
          IF(BFOT)IREL=2
        ENDIF
        IF(ABS(IREL).EQ.2.AND.MHF.LT.0)THEN
          WRITE(6,*)'*** ILLEGAL INPUT COMBINATION IREL, MHF:',IREL,MHF
          WRITE(0,*)'*** ILLEGAL INPUT COMBINATION IREL, MHF'
          GO TO 998
        ENDIF
c        IBREIT=ABS(IBREIT)                          !.LT.0 TEST MOLLER
        IF(IBREIT.LT.0)THEN
          IFLAGB=0
          IF(KUTSS.NE.-1)THEN
            IFLAGB=1
            WRITE(6,*)'*** RE-SETTING KUTSS=-1 SINCE MOLLER IBREIT='
     X                ,IBREIT
            WRITE(0,*)'*** RE-SETTING KUTSS=-1 SINCE MOLLER IBREIT'
            KUTSS=-1
          ENDIF
          IF(KUTOO.NE.0)THEN          !RECALL -1 -> 0 RE-ALIGNMENT
            IFLAGB=1
            WRITE(6,*)'*** RE-SETTING KUTOO=-1 SINCE MOLLER IBREIT='
     X                ,IBREIT
            WRITE(0,*)'*** RE-SETTING KUTOO=-1 SINCE MOLLER IBREIT'
            KUTOO=0
          ENDIF
          IF(IFLAGB.NE.0)THEN
            WRITE(6,*)'*** BETTER SETTING KUTSS/OO=-1 BACK IN SALGEB'
            WRITE(0,*)'*** BETTER SETTING KUTSS/OO=-1 BACK IN SALGEB'
          ENDIF
        ENDIF
      ELSE
        IF(IREL.EQ.999)IREL=1
        IF(ABS(IREL).EQ.2)THEN
          WRITE(6,*)"*** ILLEGAL INPUT FOR CUP='LS/IC' : IREL=",IREL
          IREL=SIGN(IONE,IREL)
          WRITE(6,*)"*** WILL RE-SET IREL=",IREL
          WRITE(0,*)'*** ILLEGAL INPUT COMBINATION BREL AND IREL'
     X             ,' - RE-SETTING'
        ENDIF
      ENDIF
C
      IF(INUKE.EQ.999)THEN                     !UNSET
        INUKE=-1                               !POINT
        IF(BREL.AND.ABS(NZION).GT.30)INUKE=1   !FINITE, NON-UNIFORM (U6)
      ENDIF
      IF(INUKE.LT.0)THEN   !POINT NUCLEUS
        INUK0=999999
      ELSE                 !FINITE
        INUK0=2
      ENDIF
      IF(IZESP.GT.0)IREL=ABS(IREL)             !SINCE SCREENING NUCLEAR
      IF(IBWRM.GT.0)THEN
        IF(IBWRM.GT.MB)THEN
          IF(NL000.GT.0)THEN
            WRITE(6,*)'*** ERROR, CANNOT RESET BLUME & WATSON, IBWRM='
     X      ,IBWRM,' WHEN TWO-BODY FINE-STRUCTURE PRESET'
            WRITE(0,*)'*** ERROR, CANNOT RESET BLUME & WATSON'
     X      ,' WHEN TWO-BODY FINE-STRUCTURE PRESET'
            GO TO 998
          ENDIF
          WRITE(6,*)'*** WARNING *** WARNING *** WARNING *** WARNING:'
          WRITE(6,*)'*** YOU ARE FORCING BLUME & WATSON CLOSED SHELLS'
     X    ,' TO IBWRM=',IBWRM,' BEYOND THOSE SPECIFIED BY KCOR2=',MB
          WRITE(0,*)'*** WARNING *** WARNING *** WARNING *** WARNING:'
          WRITE(0,*)'*** YOU ARE FORCING BLUME & WATSON CLOSED SHELLS'
     X    ,' BEYOND THOSE SPECIFIED SR.ALGEB'
          DO I=MB+1,IBWRM
            NWRM=NWRM+2*(QL(I)+1)
          ENDDO
        ELSE
          WRITE(6,*)'NOTE: USER IBWRM=',IBWRM,' .LE. KCOR2=',MB
     X    ,' SO BLUME & WATSON UNCHANGED FROM AS DEFAULT'
        ENDIF
      ENDIF
C
C INPUT NUCLEAR CHARGE .LT. 0 IF REQUIRE SLATER-TYPE-ORBITAL POTENTIAL
C INPUT NUCLEAR CHARGE .GT. 0 IF REQUIRE THOMAS-FERMI S.M. POTENTIAL
C
      MSHELL=0
      BSTO=NZION.LT.0
      IF(BSTO)NZION=-NZION
C
C CHANGE NUMBER OF ELECTRONS
C
      MION=NW+NF-MRED
      IF(MRED.NE.0)WRITE(6,990)MION,MRED
C
C SET NOMINAL ASYMPTOTIC CHARGE
C
      NZA=NZION-MION
C
C ADJUST TO TARGET (I.E. REMOVE ANY RYD/CONT)
C
      if(idw.eq.0)then
        DO I=1,MXORB
          IF(DEY(I).NE.DZERO.AND.QN(I).GE.80)THEN
            NZA=NZA+1                           !AS RYD/CONT INC IN MION
            GO TO 50
          ENDIF
        ENDDO
c      else                                     !mion does not inc. cont
      endif
C
  50  IF(NZA.LT.0)THEN
        WRITE(6,*)'*** CANNOT TREAT NEGATIVE IONS, INCREASE NZION TO:'
     X          ,MION                                      !,nzion,nza
        WRITE(0,*)'*** CANNOT TREAT NEGATIVE IONS, INCREASE NZION'
        GO TO 998
      ENDIF
C
C NUMERICAL DEGENERATE ENERGY TOLERANCE (SYNC'ED WITH POST-PROCESSORS)
C
      IF(TOLB.LT.DZERO)THEN
        IF(ICC.GT.0)THEN                         !FOR DRIFT
          DZ=NZA*NZA
          TOLB=MAX(D1P5M7,D1M9*DZ*NZA)
        ELSE                                     !NO DRIFT
          TOLB=D1P5M7
        ENDIF
      ENDIF
C
C MSTEP=M CHANGES INITIAL STEP LENGTH DHNS(1), SEE BELOW,
C MSTEP=10 DEFAULT, INCREASE MSTEP FOR SMALLER STEP
C IXTRA ADDS EXTRA INTERVALS AT ORIGIN, WITH CORRESPONDING SMALLER
C STEP LENGTH BUT DOES NOT CHANGE THE ASYMPTOTIC STEP
C
C      NZA=NZION-MION                                !HISTORIC
C      NZ1=NZA                                       !HISTORIC
      NZ1=NZION                                      !FOR IXTRA
C
      M=10
      IF(NZA.LT.5)M=11
      IF(MDEN.GT.0)M=M+1
      IF(NZA.GT.30)M=11
      IF(BDR)M=11
      IF(IXTRA.LE.0.AND.(BREL.OR.INUKE.GE.0))THEN
        IF(NZ1.GE.88)THEN
          MM=15
          IX=4
        ELSEIF(NZ1.GE.50)THEN
          MM=14
          IX=3
        ELSEIF(NZ1.GE.38)THEN
          MM=13
          IX=2
        ELSEIF(NZ1.GE.28)THEN
          MM=12
          IX=1
        ELSE
          MM=11
          IX=0
        ENDIF
C                                         !FINITE NUCLEUS CANNOT SUPPORT
C        IF(ITOL.GT.ITOL0)IX=IX+IX        !THIS LEVEL OF ACCURACY
        IF(BREL)THEN
          IF(IXTRA.EQ.0)THEN    !ORIGINAL (CAN STILL SET MSTEP MANUALLY)
            M=MM
          ELSE
            IXTRA=IX
          ENDIF
        ELSE                              !NON-KAPPA BUT FINITE NUCLEUS!
          IF(IXTRA.LT.0)IXTRA=IX          !ELSE ORIGINAL
        ENDIF
      ENDIF
C
      IF(MA.EQ.0)THEN
        IF(NZION.GT.6.AND.NZA.LT.5)M=M+1
        IF(NZION.GT.9.AND.NZA.LT.2)M=M+1
      ENDIF
C
      IF(IORT.LE.-4)M=14
C
C NOW SET TO ASYMPTOTIC CHARGE SEEN BY A (TRUE) TARGET ELECTRON
C
      NZA=NZA+1
C
      if(idw.ne.0.and.maxe.le.0)then
        te1=maxn
        te1=nza/te1
        te1=te1*te1
        maxe=nint(te1)
        if(maxn.gt.mb+1)then
          te2=mb+1
          te2=nza/te2
          te2=te2*te2
          maxe=nint(te2-te1)
          maxe=max(maxe,ione)
        else
          maxe=nza
        endif
        maxe=5*maxe
        write(6,*)'*** SR.MINIM WARNING: IT IS STRONGLY RECOMMENDED'
     X    ,' THAT YOU SET THE MAXIMUM RYD SCATTERING ENERGY, MAXE...'
        write(6,*)'    I HAVE GUESSED MAXE=',MAXE
cpar        if(iam.eq.0)then                                        !par
        write(0,*)'*** SR.MINIM WARNING: YOU'
     X    ,' HAVE NOT SET THE MAXIMUM RYD SCATTERING ENERGY, MAXE!'
        write(0,*)'    I HAVE GUESSED MAXE=',MAXE
cpar        endif                                                   !par
      endif
C
      IF(MAXE.GT.0)THEN
        DHNSX=(DCON1/NZION)**(DONE/DTHREE)/
     X        (NZA**(DTWO/DTHREE))                    !/(2**MSTEP)
        TE=MAXE
        TE=SQRT(TE)
        DHNSX=LOG(NPE*DHNSX*TE/PI)/LOG(DTWO)          !NPE=NO PTS PER PI
        MM=INT(DHNSX)+MJH0
c        write(0,*)m,mm,dhns0/2**mm
        M=MAX(M,MM)
      ELSE
        IF(BFOT.AND.M.LT.15)M=15                      !ASSUME WORST CASE
      ENDIF
C
      IF(BREL.AND.IXTRA.GT.0)IXTRA=IXTRA-(M-11)
C
      IF(M0.GT.0)THEN
        IF(M0.LT.M)THEN
          WRITE(6,*)' *** WARNING IN SR.MINIM: YOU ARE REDUCING MSTEP',
     X              ' BELOW THE RECOMMENDED VALUE OF',M
          WRITE(0,*)'*** WARNING: YOU ARE REDUCING MSTEP BELOW DEFAULT'
        ENDIF
        M=M0
      ENDIF
C
C SOME RADIAL INITIALIZATIONS
C
      MSTEP=M                              !INITIAL STEP PROP 1/2**MSTEP
      IF(ITOL.EQ.0)ITOL=ITOL0                           !TF POT ACCURACY
      MAXRS=0                                              !RADIAL INDEX
      IF(IXTRA.LT.0)IXTRA=0           !NO ADDITIONAL INTERVALS AT ORIGIN
      DHNS0=MAX(DZERO,DHNS0)                        !INITIAL STEP LENGTH
      DHNS(1)=-DHNS0                                !FLAG INITIAL SET-UP
C
C
C MULTS=0 DOES NOTHING
C MULTS .LT. 0 APPLIES LS-COUPLING SELECTION RULES TO INTERMEDIATE
C              COUPLING RADIATIVE RATES IN SR.DIAGFS
C MULTS .GT. 0 AS .LT. 0 BUT ONLY EVALUATES INTERMEDIATE COUPLING
C              RADIATIVE RATES FOR TERMS WITH SPIN MULTIPLICITY MULTS
C
C |MDELE|=NUMBER OF TERM ENERGY CORRECTIONS TO BE READ BELOW (DO 92)
C IF .LT. 0  READS/WRITES TFU FROM/TO UNIT MR+1 (DISABLED).
C MDELE IS HISTORICAL, BUT CAN STILL BE USED TO READ TECS FROM
C UNIT6. IT HAS BEEN SUPERCEDED BY ISHFTLS AND ISHFTIC.
C
C ISHFTLS (ISHFTIC) .eq.0, no shifts (default).
C .EQ. 1
C READ TERM (LEVEL) NUMBERS AND ENERGY CORRECTIONS FROM FILE SHFTLS
C (SHFTIC) PRECEDED BY THE NUMBER OF STATE/ENERGY PAIRS TO BE READ AND
C THE ENERGY UNITS USED (AS IP OF H). CAN BE USED TOGETHER IN AN IC RUN,
C THEN LS ENERGY SHIFTS ARE APPLIED AS TERM ENERGY CORRECTIONS TO H(IC)
C BEFORE DIAGONALIZATION AND THE IC SHIFTS AS A FURTHER CORRECTION AFTER
C H(IC) DIAGONALIZATION TO ACHIEVE EXACT LEVEL POSITIONING. THE TERM
C (LEVEL) NUMBERS ARE THE ALGEBRAIC T (LV) NUMBERS, NOT THE ENERGY
C ORDERED.
C  .GT. 1
C THEN ASSUMES OBSERVED ENERGIES, RELATIVE TO THE GROUND (AVERAGED
C -OVER FINE-STRUCTURE FOR TERMS) NOT CORRECTIONS ARE INPUT AND THEN
C ISHFTLS OR ISHFTIC ITERATIONS OF H(IC) ARE CARRIED-OUT. ISHFTLS
C ITERATIONS ARE APPLIED AS TERM ENERGY CORRECTIONS (TEC) TO H(IC).
C THE FINAL TECS CAN THEN BE INPUT IN SHFTLS WITH ISHFTLS=1 AND THEN
C (OPTIONALLY) ISHFTIC ITERATIONS CAN BE APPLIED AS LEVEL ENERGY
C CORRECTIONS TO THE DIAGONAL OF H(IC) BEFORE DIAGONALIZATION. THE
C FINAL LECS CAN THEN BE INPUTIN SHFTIC WITH ISHFTIC=1 TO REGENERATE
C THE FINAL STRUCTURE WITHOUT ITERATION.
C  .LT. 0
C NO ITERATIONS (AS .EQ. 1) BUT ASSUMES INPUT OBSERVED ENERGIES
C (AS .GT. 1).

C
C SEE ALSO SR.RADCON FOR ABSOLUTE SHIFT OF CONTINUUM
C
      BCORR=MDELE.NE.0.OR.ISHFTLS.NE.0.OR.ISHFTIC.NE.0
      IF(ISHFTLS.GT.1.AND.ISHFTIC.GT.1.AND.III.EQ.0)THEN
        WRITE(6,*)' *** SR.MINIM ERROR: CANNOT ITERATE ON TECS AND LECS'
     X           ,' AT THE SAME TIME! ',ISHFTLS,ISHFTIC
        WRITE(0,*)' *** SR.MINIM ERROR: CANNOT ITERATE ON TECS AND LECS'
     X           ,' AT THE SAME TIME!'
        GO TO 998
      ENDIF
      IF(ISHFTLS.NE.0.AND.ISHFTIC.NE.0.AND.III.NE.0)THEN
        IF(NJO.GT.0)THEN
          WRITE(6,*)'*** SR.MINIM: IGNORING SHFTLS, USING SHFTIC FILE'
          WRITE(0,*)'*** SR.MINIM: IGNORING SHFTLS, USING SHFTIC FILE'
          ISHFTLS=0
        ENDIF
      ENDIF
      IF(MDELE.LT.0)MDELE=-MDELE
      IF(MDELE.GE.0)GO TO 11
      IF(MDELE.LT.0)GO TO 11
      WRITE(6,898)
      MDELE=0
C
C MGRP=!MGRP!  SPECIFIES NUMBER OF SIGMA/Q.D. PARAMETERS TO BE REA
C MGRP .GT. 0 SCREENING PARAMETERS
C MGRP .LT. 0 QUANTUM DEFECTS *100 , .LT. 999.0 ONLY.
C SCREEN MUST BE IN RANGE 999 TO 5998 FOR 'REPLACEMENT' IN SR.RADWIN
C AND .GE. 5999 FOR 'REPLACEMENT' IN SR.RADCON, .GE. 7999 EVALUATES
C CONTINUUM FUNCTION AT USER SUPPLIED ENERGY(S) SEE RADCON, OTHERWIS
C EVALUATES CONTINUUM FUNCTION AT THRESHOLD (K=0) FOR EXTRAPOLATION
C TO PRINCIPAL QUANTUM NUMBER SPECIFIED BY GIVEN ORBITAL NUMBER.
C .LT. -999 HAS SPECIAL MEANING, SEE SR.RADIAL.
C
  11  MGRP0=MGRP
      MGRP=ABS(MGRP)
C
C IF BORT .TRUE. REQUIRE SCALING PARAMETERS FOR EACH ORBITAL
C I.E. POTENTIAL nl DEPENEDENT AND ORBITALS ARE ORTHONORMALISED
C AFTER EVALUATION.
C EXCEPTION MORT .EQ. -3, NO ORTHOGONALIZATION IMPOSED, LAM=nl STILL.
C |MORT| .EQ. 2 USES MODIFIED HYDROGENIC ORBITALS WHEN CORRELATION
C               SPECIFIED TO BE CONSISTENT WITH IMPACT, PURE
C               HYDROGENIC OTHERWISE: ZEFF=-LAM*Z0 EXCEPT
C  MORT  .EQ.-4  ZEFF=-N*LAM/2  FOR PSEUDO-STATE BASIS, THEN
C                LAM GENERALLY INDEPENDENT OF NL.
C  MORT  .EQ.-5  USES BOX STATES
C
C |MORT| .GT. 20 RESTARTS CALCULATION OF RADIATIVE RATES IN DIAGFS
C               (I.E. FOR IC AR ONLY) FROM ENERGY ORDER LEVEL !MORT! .
C
      IF(IORT.NE.0)MORT=IORT
      BORT=MORT.LT.0
      IF(BORT)THEN
        NPARAM=NGROUP
        if(idw.ne.0)nparam=max(nparam,nlam)
      ENDIF
C
      IF(NPARAM.GT.MXVAR)THEN               !TOO MANY SCALING PARAMETERS
        WRITE(6,1000)NPARAM,MXVAR
        NF=-1
        GO TO 95
      ENDIF
C
      NP0=0
      IF(IPOLFN.LT.0)NP0=-IPOLFN
      NPARM3=(NP0+1)*NPARAM              !MXVAR
      NPARM2=2*NPARAM
C
      IF(BPRNT0.AND.MXBOX.EQ.0)WRITE(6,777)RZERO
C
C SKIP IF PREVIOUS INPUT WEIGHTS MAY BE USED (TYPICALLY III=-9999):
C IWGHT CONTROLS WEIGHTING:
C IWGHT .EQ. 1  FOR UNIT WEIGHTING
C       .NE. 1  FOR ORIGINAL STATISTICAL WEIGHTING
C
      DF0=DZERO  !INITIALZE CORE FUNCTIONAL ENERGY
      IF(III.GE.-NTRMS)THEN
        INCLUD=III
        IF(III.LT.0)THEN
          NEXTRE=-III
C
C
          READ(5,*)(INDEXW(I),WGHT(I),I=1,NEXTRE)
C
C
        ENDIF
      ENDIF
C
C SWITCH-OFF MINIMIZATION FOR RELATIVISTIC RADIAL FUNCTIONS
C
c      IF(BREL.AND.INCLUD.NE.0)THEN
c        WRITE(6,692)
c        WRITE(0,*)' NO MINIMIZATION BECAUSE RELATIVISTIC ORBITALS'
c     X,' ARE IN USE!'
c        INCLUD=0
c      ENDIF
C
C DEXTRE PROVIDES (INITIAL) DATA FOR DADJUS(I),I=1,NPARAM, THE S.M/STO
C POTENTIAL SCALING PARAMETERS (L- OR NL-DEPENDENT), SEE SR.CALCFX.
C DEXTRE(MIN(I,NEXTRE)) WILL BE ASSIGNED TO DADJUS(I) UNLESS
C REDIRECTED BY IEQUAL; DEXTRE RETAINS ANY PREVIOUS VALUES ELSE.
C
      DO I=1,MXVAR
        DAJNEW(I)=DEFLAM    !DEFAULT SCALING PARAMETERS FOR EACH ORBITAL
        DEXTRE(I)=DEFLAM    !               DITTO
      ENDDO
C
      NVAR0=NVAR
      NVAR=NVAR0+NVARD+NVARQ
      NLAMDQ=ABS(NLAMD)+ABS(NLAMQ)
      NLAM=NLAM+NLAMDQ
C
      IF(NLAM.NE.0)MEXTRE=NLAM          !NLAM TAKES PRIORITY OVER MEXTRE
      NEXTRE=MOD(ABS(MEXTRE)-NLAMDQ,I10000)   !NO OF SCALING PARAMETERS
      IF(MEXTRE.EQ.0)NEXTRE=NPARAM             !DEFAULT IF NOT SPECIFIED
C
      IF(MEXTRE.LE.0)THEN
        IF(NVAR.GT.0)GO TO 33
        GO TO 20
      ENDIF
C
C NON-UNIQUE BASIS LAMBDAS DEFAULT TO UNITY, ** NOT ** PREVIOUS VALUE IF
C DEXTRE NOT SPECIFIED (UNLESS GLOBAL INPUT SPECIFIED - SEE IDUM0.LT.0)
C EXCEPTING RYD/CONT IF AT LEAST ONE RYD/CONT HAS BEEN DEFINED.
C
      IF(IEQ(0).NE.0)THEN         !NON-UNIQUE BASIS
C
        IF(IPOLFN.LT.0)THEN
          WRITE(6,*)'*** SR.MINIM: CANNOT USE PERTURBED TF POT WITH',
     X              ' RELAXED ORBITAL BASIS'
          WRITE(0,*)'***CANNOT USE RELAXED ORBITALS WITH PERTURBED TF'
          GO TO 998
        ENDIF
        IF(NVAR.EQ.0.AND.INCLUD.NE.0)THEN
          WRITE(6,*)'*** SR.MINIM: INCLUD=',INCLUD,' BUT NVAR=0.',
     X            ' RE-SETTING INCLUD=0, ELSE SPECIFY NVAR TO OPTIMIZE.'
          WRITE(0,*)'***INCLUD NE.0 BUT NVAR=0 !'
          INCLUD=0
        ENDIF
C
        WRITE(6,*)
     X        'NOTE: RELAXED LAMBDAS DEFAULT TO UNITY, *NOT* LAST READ.'
        WRITE(0,*)
     X        'NOTE: RELAXED LAMBDAS DEFAULT TO UNITY, *NOT* LAST READ.'
C
        DO I=1,MXORB
          DBUF(I)=DZERO
        ENDDO
C
        DO N=1,NEXTRE                          !NEXTRE SETS
C
          READ(5,*)K,IDUM0                     !CF/GRP AND NO. OF VALUES
C
          IF(K.EQ.0)THEN                       !CORE/GLOBAL
C
            IF(IDUM0.GE.0)THEN
C
              IF(IRLX.GE.0)THEN                !COMMON CORE
                READ(5,*)(DBUF(I),I=1,IDUM0)
              ELSE                             !SO IEQ(0).GT.0
                WRITE(6,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                WRITE(0,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                GO TO 998
              ENDIF
C
            ELSE                               !GLOBAL
C
              READ(5,*)(DUM(I),I=1,-IDUM0)
C
              IF(IEQ(0).LT.0)THEN
                IB=KMAX*MXBORB+MB
              ELSE
                IB=NGRP*MXBORB+MB0
              ENDIF
C
              DO I=1,IB                        !ALL BOUND USE
                DBUF(I)=DUM(1)                 !POSITION ONE
              ENDDO
C
              IF(IDUM0.LT.-1)THEN              !ALL RYD/CONT
                DO I=IB+1,MXORB                !USE
                  DBUF(I)=DUM(2)               !POSITION TWO
                ENDDO
              ENDIF
C
            ENDIF
C
          ELSE                                 !CF/GRP SPECIFIC
C
            READ(5,*)(DUM(I),I=1,abs(IDUM0))
C
            IF(K.GT.NGRP)GO TO 316             !IGNORE
            IB=MIN(abs(IDUM0),MXBORB)
            KK=MXBORB*(K-1)+MB0
            DO I=1,IB
              II=KK+I
              DBUF(II)=DUM(I)
            ENDDO
            IF(IDUM0.LT.0)THEN
              IDUM0=-IDUM0
              DO I=IB+1,MXBORB
                II=KK+I
                DBUF(II)=DUM(IDUM0)
              ENDDO
            ENDIF
C
            IF(IDUM0.GT.MXBORB)THEN
              IF(IEQ(0).LT.0)THEN
                IF(.NOT.BDR)THEN
                  II=KMAX*MXBORB+K+MB   !CONT
                ELSE
                  II=KMAX*MXBORB+K+MB   !VALENCE
                  IF(QN(QCG(NF,K)).GE.90)II=II+KMAX  !CONT
                ENDIF
                I0=MXBORB+1    !RYD/CONT LAMBDA IN FIRST POS AFTER BOUND
                DBUF(II)=DUM(I0)  !SINCE ONLY ONE PER CFG IN GENERAL...
              ELSE
                I0=MXBORB
                IF(MXVORB.GT.0)THEN
                  KK=I0*(NGRP-1)+MXVORB*(K-1)+MB0
                  I0=I0+MXVORB
                  IB=MIN(IDUM0,I0)
                  DO I=MXBORB+1,IB
                    II=KK+I
                    DBUF(II)=DUM(I)
                  ENDDO
                  IF(IDUM0.LT.I0)THEN      !CASE MULTIPLE RYD, COPY LAST
                    DO I=IDUM0+1,I0
                      II=KK+I
                      DBUF(II)=DUM(IDUM0)
                    ENDDO
                  ENDIF
                ENDIF
                IF(MXFORB.GT.0)THEN
                  KK=I0*(NGRP-1)+MXFORB*(K-1)+MB0
                  IF(IDUM0.GT.I0)THEN
                    I0=I0+MXFORB
                    IB=MIN(IDUM0,I0)
                    DO I=MXBORB+MXVORB+1,IB
                      II=KK+I
                      DBUF(II)=DUM(I)
                    ENDDO
                  ELSE
                    I0=I0+MXFORB
                  ENDIF
                  IF(IDUM0.LT.I0)THEN            !COPY LAST RYD/CONT
                    DO I=IDUM0+1,I0
                      II=KK+I
                      DBUF(II)=DUM(IDUM0)
                    ENDDO
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
C
          ENDIF
 316    ENDDO
        NEXTRE=MXORB
        MEXTRE=MXORB
C
      ELSE                        !UNIQUE BASIS
C
        IF(NEXTRE.GT.0)READ(5,*)(DBUF(I),I=1,NEXTRE)
C
        IF(ISCALR.GT.0)THEN            !PROCESS SLATER SCALING PARAMETER
          IF(ABS(SCALER-DONE).GT.D1M5)THEN   !SCALER-> DBUF
            IF(ISCALR.LE.NEXTRE)THEN              !FLAG
              IF(ABS(DBUF(ISCALR)-DONE).GT.D1M5)THEN
                WRITE(6,*)'*** SLATER SCALING SPECIFIED TWICE! USING '
     X                    ,SCALER
                WRITE(0,*)'*** SLATER SCALING SPECIFIED TWICE!'
              ENDIF
            ENDIF
            DBUF(ISCALR)=SCALER
c          ELSEIF(ISCALR.LE.NEXTRE)THEN    !DBUF->SCALER, FOR NON-CALCFX
c            SCALER=DBUF(ISCALR)
          ENDIF
          IF(NEXTRE.LT.0)THEN
            WRITE(6,884)NEXTRE,ISCALR
            WRITE(0,*)'SR.MINIM: CANNOT USE NLAM.LT.0 WITH ISCALR.GT.0'
            GO TO 998
          ENDIF
          DO I=NEXTRE+1,ISCALR-1
            DBUF(I)=DZERO
          ENDDO
          NEXTRE=MAX(NEXTRE,ISCALR)
        ENDIF
C
        IF(IPOLFN.LT.0)THEN
          IF(NPARM3.GT.MXVAR)THEN
            WRITE(6,*)'*** SR.MINIM: INCREASE MXVAR TO',NPARM3
            WRITE(0,*)'*** SR.MINIM: INCREASE MXVAR'
            GO TO 998
          ENDIF
C
          IF(NLAMD.NE.0)THEN
            IF(NLAMD.LT.0)THEN
              WRITE(6,*)
     X        "INPUT DIPOLE PERTURBTN LAMBDA'S TAKEN RELATIVE TO UNITY",
     X        "OUTPUT RELATIVE TO ZERO STILL"
              WRITE(0,*)
     X        "INPUT DIPOLE PERTURBTN LAMBDA'S TAKEN RELATIVE TO UNITY"
              NLAMD=-NLAMD
              TADD=DZERO                       !=0 FOR I/O RELATIVE TO 1
            ELSE
              TADD=DONE                        !=1 FOR I/O RELATIVE TO 0
            ENDIF
            READ(5,*)(DBUF(NPARAM+I),I=1,NLAMD)
            IF(NLAMD.GT.NPARAM.and.idw.eq.0)THEN
              IF(NF.GT.0)WRITE(6,992)NLAMD,NPARAM
              NLAMD=NPARAM
            ENDIF
            DO I=1,NLAMD
              I1=NPARAM+I
              DBUF(I1)=DBUF(I1)+TADD
            ENDDO
          ENDIF
          IF(NLAMQ.NE.0)THEN
            IF(NLAMQ.LT.0)THEN
              WRITE(6,*)
     X     "INPUT QUADRUPOLE PERTURBTN LAMBDA'S TAKEN RELATIVE TO UNITY"
     X        ,"OUTPUT RELATIVE TO ZERO STILL"
              WRITE(0,*)
     X     "INPUT QUADRUPOLE PERTURBTN LAMBDA'S TAKEN RELATIVE TO UNITY"
              NLAMQ=-NLAMQ
              TADD=DZERO                       !=0 FOR I/O RELATIVE TO 1
            ELSE
              TADD=DONE                        !=1 FOR I/O RELATIVE TO 0
            ENDIF
            READ(5,*)(DBUF(NPARM2+I),I=1,NLAMQ)
            IF(NLAMQ.GT.NPARAM.and.idw.eq.0)THEN
              IF(NF.GT.0)WRITE(6,992)NLAMQ,NPARAM
              NLAMQ=NPARAM
            ENDIF
            DO I=1,NLAMQ
              I2=NPARM2+I
              DBUF(I2)=DBUF(I2)+TADD
            ENDDO
          ENDIF
C
        ENDIF
      ENDIF
C
  33  IF(NVAR.GT.0)THEN
        IFABS=0
        IF(IEQ(0).NE.0)THEN         !NON-UNIQUE BASIS
          K0=-1
          II=0
          I0=II
          DO N=1,NVAR               !NVAR SETS
C
            READ(5,*)K,IDUM0        !CF/GRP AND NO. OF VALUES TO READ
C
            IF(K.LE.K0)THEN
              WRITE(6,*)'***ERROR: INPUT NVAR SETS IN INCREASING ',
     X                  'CF/GRP ORDER, NOT:',K0,K
              WRITE(0,*)'***ERROR: INPUT NVAR SETS IN INCREASING ',
     X                  'CF/GRP ORDER'
              GO TO 998
            ENDIF
            IF(K.EQ.0)THEN
C
              IF(IRLX.GE.0)THEN                   !COMMON CORE
                READ(5,*)(IBUF(I),I=1,IDUM0)
              ELSE                                !SO IEQ(0).GT.0
                WRITE(6,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                WRITE(0,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                GO TO 998
              ENDIF
C
              II=IDUM0
              I0=II
            ELSE
C
              READ(5,*)(IDUM(I),I=1,IDUM0)
C
              IF(K.LE.NGRP)THEN                   !ELSE IGNORE
                KK=MXBORB*(K-1)+MB0               !ASSUME VAL ORB NO. IN
                DO I=1,IDUM0
                  IF(IDUM(I).GT.MXBORB)IFABS=1    !FLAG ABSOLUTE
                  II=II+1
                  IBUF(II)=KK+IDUM(I)
                ENDDO
              ENDIF
            ENDIF
          ENDDO
C                                         THIS WON'T CATCH EVERYTHING...
          IF(IFABS.EQ.1)THEN                      !-MB IF ABS ORB NO. IN
            WRITE(0,*)' *** DEFAULT RELAXED ORBITAL INDEX IS RELATIVE ',
     X      'TO THE CLOSED-SHELL CORE, I.E. A VALENCE INDEX;',
     X      ' CONVERTING YOUR ABSOLUTE INDEX INPUT...'
            WRITE(0,*)' *** THIS WILL NOT ALWAYS BE CAUGHT!!!'
            DO I=I0+1,II
              IBUF(I)=IBUF(I)-MB
            ENDDO
          ENDIF
C
          NVAR=II
          NVAR0=NVAR
C
        ELSE                        !UNIQUE BASIS
C
          NVAR=NVAR0
C
          IF(NVAR0.GT.0)READ(5,*)(IBUF(I),I=1,NVAR0)
C
          IF(NVARD.GT.0)THEN
C
            READ(5,*)(IBUF(NVAR+I),I=1,NVARD)
C
            DO I=1,NVARD
              IBUF(NVAR+I)=IBUF(NVAR+I)+NPARAM
            ENDDO
            NVAR=NVAR+NVARD
            if(nlamd.eq.0)nlamd=1   !need non-zero for set-up
          ENDIF
C
          IF(NVARQ.GT.0)THEN
C
            READ(5,*)(IBUF(NVAR+I),I=1,NVARQ)
C
            DO I=1,NVARQ
              IBUF(NVAR+I)=IBUF(NVAR+I)+NPARM2
            ENDDO
            NVAR=NVAR+NVARQ
            if(nlamq.eq.0)nlamq=1   !need non-zero for set-up
          ENDIF
C
        ENDIF
C
        IF(INCLUD.EQ.0)THEN
          NVAR0=0
          NVAR=0
          NVARD=0
          NVARQ=0
        ENDIF
      ENDIF
C
      IF(NVAR.GT.0)THEN
        IBF0=0
        DO K=1,NVAR
          II=IBUF(K)
          IF(K.GT.NVAR0)II=II-NPARAM
          IF(K.GT.NVAR0+NVARD)II=II-NPARAM
          IF(DEY(II).EQ.DZERO)THEN
            WRITE(6,994)II
            WRITE(0,*)'***ERROR, ORBITAL TO BE VARIED DOES NOT EXIST!'
            GO TO 998
          ENDIF
          IF(IBUF(K).LE.IBF0)THEN
            WRITE(6,885)(IBUF(L),L=1,NVAR)
            WRITE(0,*)
     X     '***ERROR, VARIATIONAL PARAMETERS MUST BE IN ASCENDING ORDER'
            GO TO 998
          ENDIF
          IBF0=mod(IBUF(K)-1,nparam)+1
          IF(IBF0.GT.nparam)THEN
            WRITE(6,886)K,IBF0,nparam
            WRITE(0,*)
     X      '***ERROR, INCONSISTENT VARIATIONAL & SCALING PARAMETERS'
            GO TO 998
          ENDIF
          IBF0=IBUF(K)
        ENDDO
        IM=nparm3-NVAR                   !MXVAR-NVAR
        IF(IM.GT.0)THEN
          J=0
          DO I=1,IM
            J=J+1
            DO K=1,NVAR
              IF(IBUF(K).EQ.J)J=J+1      !THIS IS WHY WE NEED ASCENDING
            ENDDO
            IBUF(I+NVAR)=J
          ENDDO
        ENDIF
      ENDIF
C
   20 T=DONE
      NLAM=NEXTRE
      I0=0
      IM=NPARM3-NVAR
C
   21 MEND=0
      DO I=1,nparam                      !MXVAR
        IP=I0+I
        JEND(I)=1
        IEQUAL(IP)=NLAM                  !HOLD LAST
        J=IP
        IF(NVAR*IM.GT.0)J=IBUF(IP)
        IF(J.GT.NLAM)THEN                !USE LAST HELD
          IF(MEXTRE.LT.0)GO TO 25
        ELSE
          IEQUAL(IP)=IP
          IF(MEXTRE.GT.0)THEN
            DEXTRE(IP)=DBUF(J)
            IF(DEXTRE(IP).EQ.DZERO)DEXTRE(IP)=T
            IF(IEQ(0).eq.0)T=DEXTRE(IP)
          ENDIF
        ENDIF
c        write(6,*)i,iequal(ip),dextre(ip),dbuf(j)
        IF(MEXTRE.GE.0)DADJUS(IP)=DZERO
   25 ENDDO
C
      IF(NLAMD.GT.0)THEN
        NLAM=NPARAM+NLAMD
        NLAMD=-NLAMD
        I0=NPARAM
        GO TO 21
      ENDIF
C
      IF(NLAMQ.GT.0)THEN
        NLAM=NPARM2+NLAMQ
        NLAMQ=-NLAMQ
        I0=NPARAM*2
        GO TO 21
      ENDIF
C
      NLAMD=ABS(NLAMD)
      NLAMQ=ABS(NLAMQ)
C
      NVAR=NVAR0+NVARD+NVARQ
      NLAM=NEXTRE
C
      IF(NVAR.GT.0)THEN
        DO I=1,nparm3                    !MXVAR
          DO J=1,nparm3                  !MXVAR
            IF(IBUF(J).EQ.I)IEQUAL(I)=J
          ENDDO
        ENDDO
      ENDIF
C
C INSTEAD OF READING IEQUAL DIRECTLY (SEE BELOW), READ WHICH SCALING
C PARAMETER IS TO BE USED BY EACH L- OR NL-DEPENDENT POTENTIAL.
C THE DEFAULT IS 1,2,3,4,5,6,7 ETC. OBVIOUSLY, THIS IS ONLY NECESSARY
C WHEN MINIMIZATION IS BEING CARRIED-OUT AND YOU WANT TO TIE ONE OR
C MORE POTENTIALS TO ONE OR MORE OF THOSE BEING VARIED. (IF NOT MINI-
C MIZING THEN YOU CAN TRIVIALLY SET THE LAMBDAS THE SAME.)
C TBD: READ NFIXD, NFIXQ FOR PERTURBED TF, ELSE NEED ABSOLUTE POSITION.
C
      IF(NFIX.GT.0)THEN
        IF(IEQ(0).NE.0)THEN
          WRITE(6,*)"***ERROR: CANNOT USE NFIX.GT.0 WITH BASIS='S/RLX'"
          WRITE(0,*)"***ERROR: CANNOT USE NFIX.GT.0 WITH BASIS='S/RLX'"
          GO TO 998
        ENDIF
C
        IF(IPOLFN.LT.0)THEN  !COULD USE IF USER INPUTS ABSOLUTE INDEX
          WRITE(6,*)"***ERROR: CANNOT USE NFIX.GT.0 WITH PERTURBED TF"
          WRITE(0,*)"***ERROR: CANNOT USE NFIX.GT.0 WITH PERTURBED TF"
          GO TO 998
        ENDIF
C
        READ(5,*)(IFYX(I),I=1,NFIX)
C
        DO I=1,NFIX
          IF(IFYX(I).GT.0)IEQUAL(I)=IEQUAL(IFYX(I))
        ENDDO
      ENDIF
C
C REDUCE NEXTRE IF NECESS.
C
      IF(NEXTRE.GT.NPARAM.and.idw.eq.0)THEN
        IF(NF.GT.0)WRITE(6,992)NEXTRE,NPARAM
        NEXTRE=NPARAM
      ENDIF
C
C INITIALZE IF OLD STYLE NEXTRE
C
      IF(INCLUD.NE.0.AND.NVAR.EQ.0)NVAR=NEXTRE
C
C SET IEQUAL RANGE
C
      K=nparam                           !MXVAR
c      IF(BORT)K=NGROUP                  !=NPARAM AGAIN NOW
C
      IF(ABS(MEXTRE).GE.10000)THEN  !HISTORIC SS |MEXTRE|.GE.100 OPTION
        IF(IEQ(0).NE.0)THEN
          WRITE(6,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              " BASIS='S/RLX'",MEXTRE
          WRITE(0,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              " BASIS='S/RLX'"
          GO TO 998
        ENDIF
        IF(IPOLFN.LT.0)THEN
          WRITE(6,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              " PERTURBED TF POTENTIAL",MEXTRE
          WRITE(0,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              " PERTURBED TF"
          GO TO 998
        ENDIF
C
C IEQUAL(I)=J FIXES THAT SCALING FACTOR DADJUS(I), FOR L=I-1, EQUAL
C TO VARIATIONAL PARAMETER DEXTRE(J). SUPPOSE THE SAME POTENTIAL IS
C WANTED FOR P,D AND F ELECTRONS BUT A DIFFERENT POTENTIAL FOR S:
C PUT IEQUAL(1)=1,IEQUAL(2)=IEQUAL(3)=IEQUAL(4)=2.
C THE DIFFICULTY WITH THIS HISTORIC INPUT ARISES WHEN YOU WANT TO FIX/
C VARY OUTER ORBITALS BUT LEAVE INNER ONES AT A PREVIOUSLY DETERMINED
C VALUE. THEN IT IS CUMBERSOME AT BEST TO MAP TO THE INTERNAL ORDER.
C BEST USE NFIX ABOVE SINCE IT IS ALL RELATIVE TO THE EXTERNAL ORDER.
C
        DO I=1,MXVAR
          IEQUAL(I)=0
        ENDDO
C
        READ(5,*)(IEQUAL(I),I=1,K)
C
      ENDIF
C
      IF(MEXTRE.LT.0)THEN
        IF(IPOLFN.LT.0)THEN
          WRITE(6,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              " POLARIZED TF POTENTIAL",MEXTRE
          WRITE(0,*)"***ERROR: CANNOT USE THIS NLAM/MEXTRE WITH",
     X              "POLARIZED TF"
          GO TO 998
        ENDIF
        DO I=1,NEXTRE
          DO J=1,K
            IF(IEQUAL(J).EQ.I)DADJUS(J)=DZERO
          ENDDO
        ENDDO
      ENDIF
C
C SCREEN RELATES TO THE EIGENVALUE E (IN RYDBERGS) OF THE ONE-
C PARTICLE FUNCTIONS THROUGH E=-(Z-SCREEN)**2/(N*N); N=PRINCIPAL
C QUANTUM NUMBER. A GOOD INITIAL VALUE OF SCREEN WILL SPEED UP THE
C COMPUTATION IN RADWAV. IF NO APPROXIMATION IS KNOWN USE STANDARD
C OPTION BY SKIPPING THIS "READ SCREEN" FOR 1S,2S,2P ETC.
C
C
      DO I=1,MXORB
        IF(DEY(I).NE.DZERO)THEN
          IF(QN(I).GE.70.AND.QN(I).LT.80.AND.I.LE.ABS(MPSEUD))
     X       DEY(I)=DZERO
          IF(QN(I).GE.90)SCREEN(I)=9999
        ENDIF
      ENDDO
C
      IF(MGRP.GT.0)THEN             !HISTORIC SCREENING INDEX NOT GROUP!
        IF(IEQ(0).NE.0)THEN         !NON-UNIQUE BASIS
          DO I=1,MXORB
            DBUF(I)=DZERO
          ENDDO
          DO N=1,MGRP               !MGRP SETS
            READ(5,*)K,IDUM0        !CF/GRP AND NO. OF VALUES TO READ
            IF(K.EQ.0)THEN
              IF(IRLX.GE.0)THEN                   !COMMON CORE
                READ(5,*)(DBUF(I),I=1,IDUM0)
              ELSE                                !SO IEQ(0).GT.0
                WRITE(6,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                WRITE(0,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                GO TO 998
              ENDIF
            ELSE
              READ(5,*)(DUM(I),I=1,IDUM0)
              IF(K.GT.NGRP)GO TO 326              !IGNORE
              IB=MIN(IDUM0,MXBORB)
              KK=MXBORB*(K-1)+MB0
              DO I=1,IB
                II=KK+I
                DBUF(II)=DUM(I)
              ENDDO
              IF(IDUM0.GT.MXBORB)THEN
                IF(IEQ(0).LT.0)THEN
                  IF(.NOT.BDR)THEN
                    II=KMAX*MXBORB+K+MB   !CONT
                  ELSE
                    II=KMAX*MXBORB+K+MB   !VALENCE
                    IF(QN(QCG(NF,K)).GE.90)II=II+KMAX  !CONT
                  ENDIF
                  I0=MXBORB+1       !CONT SIGMA IN FIRST POS AFTER BOUND
                  DBUF(II)=DUM(I0)
                ELSE      !"never" needed, else "copy" lambda assignment
                  write(6,*)
     x                   'cannot assign group specific ryd/cont screens'
                  write(0,*)
     x                   'cannot assign group specific ryd/cont screens'
                ENDIF
              ENDIF
            ENDIF
 326      ENDDO
          MGRP=MXORB
        ELSE
          MGRP=MIN(MGRP,MXORB)
          READ(5,*)(DBUF(I),I=1,MGRP)
        ENDIF
C
        DO I=1,MGRP
          IF(DBUF(I).NE.DZERO)THEN
            IF(MGRP0.LE.0.AND.ABS(DBUF(I)).LT.999)THEN
              DBUF(I)=DBUF(I)/D1P2
              T1=QN(I)*(MION-1)
              T0=NZION
              T1=T1-T0*DBUF(I)
              T0=QN(I)
              DBUF(I)=T1/(T0-DBUF(I))
            ENDIF
            SCREEN(I)=DBUF(I)
          ENDIF
        ENDDO
      ENDIF
C
C PERFORM CHECKS ON BOUND, RYDBERG AND CONTINUUM ORBITALS
C
      BHFF=.FALSE.                        !NO EXTERNAL ORBS
      ICP=0
      ICM=0
      MODE=1
C
      DO I=1,MXORB
        IF(I.LE.NGROUP.AND.DEY(I).NE.DZERO.AND.SCREEN(I).GE.999)THEN
COLD      IF(QN(I).GE.80)MODE=2
          IF(SCREEN(I).LT.5999)THEN       !EXTERNAL
            BHFF=.TRUE.                   !FOR RADWIN ENTRY
            ICM=ICM-1
          ELSEIF(SCREEN(I).GT.7999)THEN   !CONTINUUM
COLD      MODE=2
            ICP=ICP+1
            IF(IVAL(I).NE.0)THEN
              WRITE(6,899)I
              IV=IV-1
              IVAL(I)=0
            ENDIF
          ELSE                            !DUMMY RYDBERG
            IV=IV-IVAL(I)
            IVAL(I)=1
            IV=IV+1
            SCREEN(I)=MION-1
          ENDIF
C CLOSED-CORE EXTERNAL ONLY IF RELAXED
          IF(ICM*IEQ(0).NE.0.AND.I.GT.MB0)THEN
            WRITE(6,997)I
            WRITE(0,*)'*** SR.MINIM: ERROR, EXTERNAL ORBITAL CANNOT',
     X                ' BE A RELAXED ONE!'
            GO TO 998
          ENDIF
C DO NOT ITERATE VARIATIONALLY FOR THESE RADIAL FUNCTIONS
          IF(INCLUD*ICP.NE.0)THEN
            WRITE(6,991)I
            WRITE(0,*)" *** WARNING: SR.MINIM RESETS INCLUD=0,",
     X                " BECAUSE YOU'VE FLAGGED CONTINUUM INPUT"
            INCLUD=0
          ENDIF
C DO NOT VARY FIXED INPUT (ERROR)
          IF(INCLUD*ICM.NE.0)THEN
            DO K=1,NVAR
              KK=IBUF(K)
              IF(KK.EQ.I)THEN
                WRITE(6,996)I
                WRITE(0,*)
     X            '*** SR.MINIM: ERROR, TRYING TO VARY EXTERNAL ORBITAL'
                GO TO 998
              ELSEIF(KK.LT.I)THEN
                IF(QL(KK).EQ.QL(I).AND.MORT.NE.-3)THEN
                  WRITE(6,897)I,KK
                  WRITE(0,*)
     X              '*** SR.MINIM: ERROR, INCOMPATIBLE VARIATIONAL AND',
     X              ' EXTERNAL ORBITALS!'
                  GO TO 998
                ENDIF
              ENDIF
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
      IF(ICM.LT.0)MAUTO=-1                         !ENTER SR.RADWIN ONLY
      IF(ICP.GT.0)MAUTO=1                          !ENTER SR.RADCON ONLY
      IF(ICM*ICP.LT.0)MAUTO=0               !ENTER SR.RADCWN & SR.RADCON
      IF(ICP.GT.0.AND.MODE.EQ.1)MODE=2             !NEW
      IF(BDR.AND.IV.LE.0)THEN
        BDR=.FALSE.
        WRITE(6,895)
      ENDIF
C
C CHECK PI/PR SET-UP
C
      IF(MODE.EQ.2.OR.MODE.EQ.3)THEN               !B-C
C
        IF(NMETAR.NE.0.AND.EIMXLS.EQ.DZERO)THEN              !SET EIMXLS
          INQUIRE(FILE='TERMS',EXIST=BEX)
          IF(BEX)THEN
            OPEN(14,FILE='TERMS',STATUS='OLD')
            READ(14,*,END=331)
            E2=DZERO
            DUME=DZERO
            N1=ABS(NMETAR)+1
            DO N=1,NTRMS
              IF(N.EQ.N1)E1=DUME
              READ(14,772,END=331)ISP,NDUM,NDUM,NDUM,NDUM,DUME
              IF(ISP.EQ.0)GO TO 330                !TERMINATOR    ,MYRGE
              IF(N.EQ.N1)E2=DUME
            ENDDO
 330        IF(E2.EQ.DZERO)E2=-DUME
            EIMXLS=(E1+E2)/2                       !RELATIVE TO GROUND
COLD            EIMXLS=EIMXLS+DUME                     !ABSOLUTE
 331        CLOSE(14)
            IUNIT(14)=-1
          ELSE              !WILL STILL USE SIGN AS A FLAG IF EIMXLS SET
            WRITE(0,*)
     X              'NOTE: NMETAR.NE.0 IGNORED AS NO TERMS FILE PRESENT'
            WRITE(6,*)
     X              'NOTE: NMETAR.NE.0 IGNORED AS NO TERMS FILE PRESENT'
            NMETAR=0
          ENDIF
        ENDIF
C
        IF(NMETARJ.NE.0.AND.EIMXIC.EQ.DZERO)THEN             !SET EIMXIC
          INQUIRE(FILE='LEVELS',EXIST=BEX)
          IF(BEX)THEN
            OPEN(15,FILE='LEVELS',STATUS='OLD')
            READ(15,*,END=333)
            E2=DZERO
            DUME=DZERO
            N1=ABS(NMETARJ)+1
            DO N=1,NLVLS
              IF(N.EQ.N1)E1=DUME
              READ(15,773,END=333)NDUM,NDUM,ISP,NDUM,NDUM,NDUM,DUME
              IF(ISP.EQ.0)GO TO 332                !TERMINATOR    ,MYRGE
              IF(N.EQ.N1)E2=DUME
            ENDDO
 332        IF(E2.EQ.DZERO)E2=-DUME
            EIMXIC=(E1+E2)/2                       !RELATIVE TO GROUND
COLD            EIMXIC=EIMXIC+DUME                     !ABSOLUTE
 333        CLOSE(15)
            IUNIT(15)=-1
          ELSE              !WILL STILL USE SIGN AS A FLAG IF EIMXIC SET
            WRITE(0,*)
     X            'NOTE: NMETARJ.NE.0 IGNORED AS NO LEVELS FILE PRESENT'
            WRITE(6,*)
     X            'NOTE: NMETARJ.NE.0 IGNORED AS NO LEVELS FILE PRESENT'
            NMETARJ=0
          ENDIF
        ENDIF
C
C PERFORM CHECKS ON NMETAP/J FOR LOWER RESOLVED PI (BUNDLED CONT):
C N.B. NMETAP/J REFER TO LOWEST DISCRETE STATES ONLY.
C      IF THIS INCLUDES AUTOIONIZING STATES THEN NEED TO SKIP CONTINUUM,
C      I.E. L/JLOWMAX.GT.NMTETAP/J THEN AND SO USER SHOULD NOT RESTRICT
C      THE FORMER. RATHER, SR.DIAGON/DIAGFS WILL DO SO.
C      OBVIOUSLY, RESTRICTING THE RANGE IN ANY OTHER WAY MAY NOT GIVE
C      THE FULL SET OF PI/RADIATIVE DATA, AS IN NON-NMETAP/J OPERATION.
C      BUT JUST FLAG POSSIBLE CONFLICT IN THE CASE OF NMETAP/J.
C
        IF(NMETAP.GT.0)THEN
          NMETAP=MIN(NMETAP,NTRMS-ione1)
          IF(LLOWMX.LT.NTRMS-ione1)THEN
            WRITE(6,*)'*** WARNING: RESTRICTING LLOWMX MAY NOT GIVE '
     X             ,'THE NMETAP IF IT INCLUDES AUTOIONIZING STATES!'
            WRITE(0,*)'*** WARNING: RESTRICTING LLOWMX MAY NOT GIVE '
     X             ,'THE NMETAP IF IT INCLUDES AUTOIONIZING STATES!'
          ENDIF
        ENDIF
        IF(NMETAPJ.GT.0)THEN
          NMETAPJ=MIN(NMETAPJ,NLVLS-ione1)
          IF(JLOWMX.LT.NLVLS-ione1)THEN
            WRITE(6,*)'*** WARNING: RESTRICTING JLOWMX MAY NOT GIVE '
     X             ,'ALL NMETAPJ IF IT INCLUDES AUTOIONIZING STATES!'
            WRITE(0,*)'*** WARNING: RESTRICTING JLOWMX MAY NOT GIVE '
     X             ,'ALL NMETAPJ IF IT INCLUDES AUTOIONIZING STATES!'
          ENDIF
        ENDIF
        IF(NMETAP.GT.0.OR.NMETAPJ.GT.0)THEN
          IF(NRSLMX.LT.0)THEN
            WRITE(6,*)'***RESOLUTION CONFLICT:CANNOT HAVE NMETAP/J.GT.0'
     X               ,' AND NRSLMX.LT.0'
            WRITE(0,*)'***RESOLUTION CONFLICT:CANNOT HAVE NMETAP/J.GT.0'
     X               ,' AND NRSLMX.LT.0'
          ELSEIF(NRSLMX.GE.0.AND.NRSLMX.LE.1000)THEN
            WRITE(6,*)'*** POSSIBLE RESOLUTION CONFLICT: NMETAP/J.GT.0'
     X               ,' AND NRSLMX.GT.0...'
            WRITE(0,*)'*** POSSIBLE RESOLUTION CONFLICT: NMETAP/J.GT.0'
     X               ,' AND NRSLMX.GT.0...'
          ENDIF
        ENDIF
      ENDIF
C
C READ CONFIGURATION NOS FOR STOPOT
C
      IF(MCFMX.GT.0.and.mcfmx.le.1000)THEN
        IF(IEQ(0).NE.0)THEN        !NON-UNIQUE BASIS
          DO I=1,MXORB
            MCFSTO(I)=0
          ENDDO
          DO M=1,MCFMX
            READ(5,*)K,IDUM0
            IF(K.EQ.0)THEN
              IF(IRLX.GE.0)THEN                   !COMMON CORE
                READ(5,*)(MCFSTO(I),I=1,IDUM0)
                IF(IDUM0.LT.MB)THEN               !FILL-IN
                   DO I=IDUM0+1,MB
                     MCFSTO(I)=MCFSTO(IDUM0)
                   ENDDO
                ENDIF
              ELSE                                !SO IEQ(0).GT.0
                WRITE(6,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                WRITE(0,*)'*** ERROR: GROUP=0 (COMMON CORE ORBITALS) ',
     X                    'CONFLICTS WITH NON-UNIQUE FLAG (KCOR1.LT.0)'
                GO TO 998
              ENDIF
            ELSE
              IF(IEQ(0).LT.0)THEN
                WRITE(6,*)"*** ONLY SPECIFY STO CF FOR CORE ORBITALS",
     X                    " WHEN BASIS='RLX'! THUS, MCFMX=1 WITH K=0."
                WRITE(0,*)"*** ONLY SPECIFY STO CF FOR CORE ORBITALS"
                GO TO 998
              ENDIF
              READ(5,*)(IDUM(I),I=1,IDUM0)
              IF(K.GT.NGRP)GO TO 336              !IGNORE
              IB=MIN(IDUM0,MXBORB)
              KK=MXBORB*(K-1)+MB0
              DO I=1,IB
                II=KK+I
                MCFSTO(II)=IDUM(I)
c                write(0,*)k,ii,i,idum(i)
              ENDDO
              IF(IDUM0.GT.MXBORB)THEN
                I0=MXBORB
                IF(MXVORB.GT.0)THEN
                  KK=I0*(NGRP-1)+MXVORB*(K-1)+MB0
                  I0=I0+MXVORB
                  IB=MIN(IDUM0,I0)
                  DO I=MXBORB+1,IB
                    II=KK+I
                    MCFSTO(II)=IDUM(I)
c                write(0,*)k,ii,i,idum(i)
                  ENDDO
                  IF(IDUM0.LT.I0)THEN      !CASE MULTIPLE RYD, COPY LAST
                    DO I=IDUM0+1,I0
                      II=KK+I
                      MCFSTO(II)=IDUM(IDUM0)
c                write(0,*)k,-ii,i,idum(i)
                    ENDDO
                  ENDIF
                ENDIF
                IF(MXFORB.GT.0)THEN
                  KK=I0*(NGRP-1)+MXFORB*(K-1)+MB0
                  IF(IDUM0.GT.I0)THEN
                    I0=I0+MXFORB
                    IB=MIN(IDUM0,I0)
                    DO I=MXBORB+MXVORB+1,IB
                      II=KK+I
                      MCFSTO(II)=IDUM(I)
c                write(0,*)-k,ii,i,idum(i)
                    ENDDO
                  ELSE
                    I0=I0+MXFORB
                  ENDIF
                  IF(IDUM0.LT.I0)THEN            !COPY LAST RYD/CONT
                    DO I=IDUM0+1,I0
                      II=KK+I
                      MCFSTO(II)=IDUM(IDUM0)
c                write(0,*)k,ii,i,idum(i)
                    ENDDO
                  ENDIF
                ENDIF
             ENDIF
            ENDIF
 336      ENDDO
          MCFMX0=MCFMX
          DO I=MXORB,1,-1
            IF(MCFSTO(I).NE.0)THEN
              MCFMX=I
              GO TO 334
            ENDIF
          ENDDO
          MCFMX=MXORB
 334      CONTINUE
        ELSE                                      !UNIQUE BASIS
          MCFMX=MIN(MCFMX,MXORB)
          READ(5,*)(MCFSTO(I),I=1,MCFMX)
          KH=0
          DO I=1,MCFMX
            KS=-MCFSTO(I)
            IF(KS.GT.0)THEN
              KH=MAX(KH,KS)
              MCFSTO(I)=KMAX+KS
            ENDIF
          ENDDO
          IF(KH.GT.0)THEN                         !ADDITIONAL CF OCC NOS
C
            KMH=KMAX+KH
C
            CALL RE_ALLOC2(NEL,IONE,MXORB,IONE,KMAX,MXORB,KMH,IERR)
C
            WRITE(6,695)
            DO I=MXORB,1,-1
              IF(ABS(QN(I)).LT.80)GO TO 335
            ENDDO
 335        MXVORB=I-MB
            DO K=1,KH
              KS=KMAX+K
              READ(5,*)(NEL(MB+N,KS),N=1,MXVORB)
              WRITE(6,694)KS,(NEL(MB+N,KS),N=1,MXVORB)
              DO N=1,MB                            !COPY CLOSED-SHELLS
                NEL(N,KS)=NEL(N,1)
              ENDDO
              DO N=MB+1,MB+MXVORB
                IF(NEL(N,KS).LT.0.OR.NEL(N,KS).GT.2*QL(N)+2)THEN
                  WRITE(6,693)KS,N-MB,NEL(N,KS)
                  GO TO 998
                ENDIF
              ENDDO
              DO N=MB+MXVORB+1,MXORB
                NEL(N,KS)=0
              ENDDO
            ENDDO
          ENDIF
        ENDIF
      ELSEIF(MCFMX.EQ.0.AND.MDEN.NE.0)THEN          !USE FIRST/GROUND CF
        IF(IEQ(0).eq.0)THEN
          IF(NOCC.GT.0)MCFMX=-9999                  !FOR FAC='YES'
        ELSE                                        !SO CORE ONLY
          MCFMX=1
          MCFSTO(1)=1
        ENDIF
      ELSEIF(MCFMX.LT.0.AND.IEQ(0).NE.0)THEN
        WRITE(6,*)"*** MCFMX.LT.0 INCONSISTENT WITH BASIS='S/RLX' - ",
     X            "CANNOT USE A COMMON AVERAGE POTENTIAL"
        WRITE(0,*)"*** MCFMX.LT.0 NOT ALLOWED FOR RELAXED ORBITALS"
        GO TO 998
      ENDIF
C
      NLSTOE=ABS(NLSTOE)
C
C READ UNIQUE SET OF OCCUPATION NUMBERS FOR MODEL STO/SCF POTENTIAL
C VALENCE ORBITALS ONLY, CLOSED-SHELL CANNOT BE CHANGED CURRENTLY, SO NL
C
      NOCC0=NOCC
      NOCC=MOD(NOCC,I1000)
C
      IF(NOCC.NE.0)THEN
C
        NOCC=ABS(NOCC)
C
        READ(5,*)(TEL(I+MB),I=1,NOCC)
C
        WKT=0
        IF(MB.GT.0)THEN
          DO M=MA,MB
            TEL(M)=2*QL(M)+2
            WKT=WKT+TEL(M)
          ENDDO
        ENDIF
C
        DO I=1,NOCC
          IB=I+MB
          IF(BORT)THEN
            WMAX=2*QL(IB)+2
          ELSE
            WMAX=2*QN(IB)**2
          ENDIF
          IF(TEL(IB).GT.WMAX+DELW.OR.TEL(IB).LT.-DELW)THEN
            WRITE(6,*)'*** SR.MINIM: ILLEGAL OCCUPATION NO. INPUT FOR'
     X               ,' ORBITAL',IB,' :',TEL(IB)
            WRITE(0,*)'*** SR.MINIM: ILLEGAL OCCUPATION NO. INPUT'
            GO TO 998
          ELSE
            WKT=WKT+TEL(IB)
          ENDIF
        ENDDO
C
        T=ABS(WKT-MION+iswch)
        IF(T.GT.10*DELW)THEN
          WRITE(6,*)'*** SR.MINIM: SUM OF OCCUPATION NOS NOT EQUAL TO'
     X             ,' MION:',MION,WKT
          WRITE(0,*)'*** SR.MINIM: SUM OF OCCUPATION NOS NOT EQUAL TO'
     X             ,' MION'
          if(t.gt.100*delw)GO TO 998
        ENDIF
C
        NOCC=NOCC+MB
C
        IF(IEQ(0).ne.0)THEN
          WRITE(6,*)'*** SR.MINIM: NOCC IGNORED FOR RELAXED ORBITALS'
          WRITE(0,*)'*** SR.MINIM: NOCC IGNORED FOR RELAXED ORBITALS'
          NOCC=1000
        ENDIF
C
        IF(NOCC0.LT.0)NOCC=-NOCC
C
      ELSE
C
        NOCC=NOCC0
C
      ENDIF
C
C FIX ORBITALS DURING SELF-CONSISTENT OPERATION
C DEFAULT:
C    TRUE FOR CLOSED-SHELLS
C    FALSE FOR VALENCE
C TO OVERRIDE, READ-IN IFIX ORBITAL NUMBERS
C    >0 FOR TRUE
C    <0 FOR FALSE
C
      IF(MB.GT.0)THEN
        DO I=MA,MB
          BFIX(I)=.TRUE.
        ENDDO
      ENDIF
      DO I=MB0+1,MXORB
        BFIX(I)=.FALSE.
      ENDDO
      IF(IFIX.GT.0)THEN
        READ(5,*)(IFYX(I),I=1,IFIX)
        IF(IEQ(0).ne.0)THEN
          WRITE(6,*)'*** SR.MINIM: IFIX IGNORED FOR RELAXED ORBITALS'
          WRITE(0,*)'*** SR.MINIM: IFIX IGNORED FOR RELAXED ORBITALS'
          NOCC=1000
        ELSE
          DO I=1,IFIX
            J=ABS(IFYX(I))
            BFIX(J)=IFYX(I).GT.0
          ENDDO
        ENDIF
      ENDIF
C
C READ DELELS/IC IN UNITS (E.G. FOR TECS AND LECS)
C
      EFLG0=DZERO                 !CAN OVERWRITE ABS GROUND STATE ENERGY
      EFLGJ0=DZERO                !REQUIRED FOR IOPTIM.NE.0
C
      IF(BCORR)THEN
c
        do k=1,kmax
          delecf(k,1)=dzero
        enddo
C
C TERMS
C
        IF(INCLUD.NE.0.AND.ISHFTLS.NE.0)THEN   !RESET
          IF(NJO.GT.0)THEN                     !F-S WEIGHTED LEVELS
            IOPTIM=-2
          ELSE                                 !TERMS
            IOPTIM=1
          ENDIF
          ISHFTLS=2
          IF(INCLUD.GT.0)INCLUD=NTRMS
        ENDIF
C
        I0=1                                   !READ TECS
        DO K=1,NTRMS
          DELELS(K,1)=DZERO
        ENDDO
        IF(ISHFTLS.LT.0.OR.ISHFTLS.GT.1)THEN   !READ OBS WEIGHTED TERM E
          I0=2
          DO K=1,NTRMS
            DELELS(K,2)=-DONE
          ENDDO
          do k=1,kmax
            delecf(k,2)=-done
          enddo
        ENDIF
C
        IF(ISHFTLS.NE.0)THEN
C
          IF(MDELE.NE.0)THEN
            WRITE(6,*)'MDELE DATA IGNORED BECAUSE ISHFTLS .NE. ZERO'
            MD=ABS(MDELE)
            DO K=1,MD                   !SKIP READS
              READ(6,*)
            ENDDO
            MDELE=0                     !ABS(ISHFTLS)
          ENDIF
C
          IUN=19
C          IF(ISHFTLS.GT.0)IUN=5
          IF(ISHFTLS.LT.0)ISHFTLS=-1
C
          IF(IUNIT(IUN).EQ.0)THEN
            WRITE(6,*)"ISHFTLS.NE.0 BUT MISSING FILE='SHFTLS'..."
            WRITE(0,*)'MISSING FILE ON UNIT=19'
            GO TO 998
          ENDIF
          REWIND(IUN)
C
          READ(IUN,*)NOBS,UNITS
          TUNIT=UNITS*DTWO                        !CONVERT TO A.U.
C
          IF(NOBS.LT.0.AND.ISHFTLS.GT.1)THEN
            WRITE(6,*)' *** SR.MINIM: CANNOT ITERATE/OPTIMIZE WITH USER'
     X   ,' INPUT CONFIG ENERGIES,'
            WRITE(0,*)' *** SR.MINIM: CANNOT ITERATE/OPTIMIZE WITH USER'
     X   ,' INPUT CONFIG ENERGIES'
            IF(IOPTIM.EQ.0)THEN
              WRITE(6,*)' *** RE-SETTING ISHFTLS=-1 FOR SINGLE PASS TEC'
              WRITE(0,*)' *** RE-SETTING ISHFTLS=-1 FOR SINGLE PASS TEC'
              ISHFTLS=-1
            ELSE
              GO TO 998
            ENDIF
          ENDIF
C
          IF(IOPTIM.NE.0)ISHFTLS=0          !NOW SWITCH OFF & USE IOPTIM
C
          IFLG0=0
          IF(ISHFTLS.EQ.1)IFLG0=-1                !NO GROUND POSS/NEEDED
C
          DO K=1,abs(NOBS)
C
            READ(IUN,*)I,DEM
C
            IF(I0.EQ.2.AND.DEM.LT.DZERO.AND.DEM.GT.-DONE)THEN
              WRITE(6,*)' *** SR.MINIM INPUT ERROR: OBSERVED ENERGY ',
     X                  '.LT. ZERO, PERHAPS A TEC? ',J,DEM
              WRITE(0,*)' *** SR.MINIM INPUT ERROR: OBSERVED ENERGY ',
     X                  '.LT. 0...'
              GO TO 998
            ENDIF
C
            T=DEM/TUNIT
            IF(IFLG0.EQ.0.AND.T.LE.DZERO)IFLG0=I  !TAKE FIRST SUIT AS E0
C
            if(nobs.gt.0)then                     !term label (T)
              DELELS(I,I0)=T
            else                                  !CF label
              delecf(i,i0)=t
            endif
C
          ENDDO
C
          IF(IFLG0.GT.0)THEN                      !TRANSFER E0
            if(nobs.gt.0)then
              EFLG0=DELELS(IFLG0,I0)              !I0=2 HERE
              DELELS(IFLG0,I0)=DZERO
            else
              eflg0=delecf(iflg0,i0)              !i0=2 here
              delecf(iflg0,i0)=dzero
            endif
          ELSEIF(IOPTIM.NE.0)THEN
            WRITE(6,*)'***SR.MININ: GROUND STATE NOT FOUND IN SHFTLS'
            WRITE(0,*)'***SR.MININ: GROUND STATE NOT FOUND IN SHFTLS'
          ENDIF
c
          if(ishftls.eq.1.and.nobs.lt.0)then!all terms of CF use same dE
            nobs=-nobs
            do i=1,ntrms
              k=nfk(i)
              k=abs(k)
              delels(i,i0)=delecf(k,i0)
            enddo
            do k=1,kmax
              delecf(k,i0)=dzero
            enddo
          endif
C
          IF(NJO.LE.0.AND.ISHFTLS.GT.1)THEN
            WRITE(6,*)'*** NO TEC ITERATION POSSIBLE IN PURE LS RUN, ',
     X                'SET ISHFTLS.LE.1, OR TURN ON IC'
            WRITE(0,*)'*** NO TEC ITERATION POSSIBLE IN PURE LS RUN, ',
     X                'SET ISHFTLS.LE.1, OR TURN ON IC'
            GO TO 998
          ENDIF
C
        ENDIF
C
C LEVELS
C
        IF(INCLUD.NE.0.AND.ISHFTIC.NE.0)THEN   !RESET
          IF(IOPTIM.EQ.-2)THEN                 !IGNORE F-S WGHT LEVS
            WRITE(6,*)' *** IGNORING TERM ENERGIES, USING LEVEL INFO',
     X                ' DURING MINIMIZATION OPERATION'
            WRITE(0,*)' *** IGNORING TERM ENERGIES, USING LEVEL INFO'
          ENDIF
          IF(NJO.LE.0)THEN
            WRITE(6,*)' *** IGNORING LEVEL ENERGIES IN LS-RUN'
            WRITE(0,*)' *** IGNORING LEVEL ENERGIES IN LS-RUN'
          ELSE                                 !LEVELS
            IOPTIM=2
          ENDIF
          ISHFTIC=2
          IF(INCLUD.GT.0)INCLUD=NLVLS
        ENDIF
C
        J0=1                                   !READ LECS
        DO K=1,NLVLS
          DELEIC(K,1)=DZERO
        ENDDO
        IF(ISHFTIC.LT.0.OR.ISHFTIC.GT.1)THEN   !READ OBS LEVEL ENERGIES
          J0=2
          DO K=1,NLVLS
            DELEIC(K,2)=-DONE
          ENDDO
          do k=1,kmax
            delecf(k,2)=-done
          enddo
        ENDIF
C
        IF(ISHFTIC.NE.0)THEN
C
          IUN=20
C          IF(ISHFTIC.GT.0)IUN=5
          IF(ISHFTIC.LT.0)ISHFTIC=-1
C
          IF(IUNIT(IUN).EQ.0)THEN
            WRITE(6,*)"ISHFTIC.NE.0 BUT MISSING FILE='SHFTIC'..."
            WRITE(0,*)'MISSING FILE ON UNIT=20'
            GO TO 998
          ENDIF
          REWIND(IUN)
C
          READ(IUN,*)NOBSJ,UNITS
          TUNIT=UNITS*DTWO                        !CONVERT TO A.U.
C
          IF(NOBSJ.LT.0.AND.ISHFTIC.GT.1)THEN
            WRITE(6,*)' *** SR.MINIM: CANNOT ITERATE/OPTIMIZE WITH USER'
     X   ,' INPUT CONFIG ENERGIES,'
            WRITE(0,*)' *** SR.MINIM: CANNOT ITERATE/OPTIMIZE WITH USER'
     X   ,' INPUT CONFIG ENERGIES'
            IF(IOPTIM.EQ.0)THEN
              WRITE(6,*)' *** RE-SETTING ISHFTIC=-1 FOR SINGLE PASS LEC'
              WRITE(0,*)' *** RE-SETTING ISHFTIC=-1 FOR SINGLE PASS LEC'
              ISHFTIC=-1
            ELSE
              GO TO 998
            ENDIF
          ENDIF
C
          IF(IOPTIM.NE.0)ISHFTIC=0      !NOW SWITCH OFF & USE IOPTIM
C
          IFLGJ0=0
          IF(ISHFTIC.EQ.1)IFLGJ0=-1               !NO GROUND POSS/NEEDED
C
          DO K=1,abs(NOBSJ)
C
            READ(IUN,*)J,DEM
C
            IF(J0.EQ.2.AND.DEM.LT.DZERO.AND.DEM.GT.-DONE)THEN
              WRITE(6,*)' *** SR.MINIM INPUT ERROR: OBSERVED ENERGY ',
     X                  '.LT. ZERO, PERHAPS A LEC? ',J,DEM
              WRITE(0,*)' *** SR.MINIM INPUT ERROR: OBSERVED ENERGY ',
     X                  '.LT. 0...'
              GO TO 998
            ENDIF
C
            T=DEM/TUNIT
            IF(IFLGJ0.EQ.0.AND.T.LE.DZERO)IFLGJ0=J!TAKE FIRST SUIT AS E0
C
            if(nobsj.gt.0)then                    !level label (LV)
              DELEIC(J,J0)=T
            else                                  !CF label
              delecf(j,j0)=t
            endif
C
          ENDDO
C
          IF(IFLGJ0.GT.0)THEN                     !TRANSFER EJ0
            if(nobsj.gt.0)then
              EFLGJ0=DELEIC(IFLGJ0,J0)            !J0=2 HERE
              DELEIC(IFLGJ0,J0)=DZERO
            else
              eflgj0=delecf(iflgj0,j0)            !j0=2 here
              delecf(iflgj0,j0)=dzero
            endif
          ELSEIF(IOPTIM.NE.0)THEN
            WRITE(6,*)'***SR.MININ: GROUND LEVEL NOT FOUND IN SHFTIC'
            WRITE(0,*)'***SR.MININ: GROUND LEVEL NOT FOUND IN SHFTIC'
          ENDIF
c
          if(nobs.lt.-1.and.nobsj.lt.-1)then
            write(6,*)' *** sr.minim: configuration energies found in '
     x      ,'both SHFTLS and SHFTIC files; the latter will supplement'
     x      ,' and/or overwrite the former!'
            write(0,*)' *** sr.minim: configuration energies found in '
     x      ,'both SHFTLS and SHFTIC files; the latter will supplement'
     x      ,' and/or overwrite the former!'
            if(ishftls*ishftic.lt.0)then
              write(6,*)' *** error: inconsistent energies in SHFTLS/IC'
              write(6,*)' could set ishftls=0 to use ishftic=1 here...'
              write(0,*)' *** error: inconsistent energies in SHFTLS/IC'
              write(0,*)' could set ishftls=0 to use ishftic=1 here...'
              go to 998
            endif
          endif
c
          if(ishftic.eq.1.and.nobsj.lt.0)then!all lvls of CF use same dE
            nobsj=-nobsj
            do j=1,nlvls
              i=nrr(j)
              k=nfk(i)
              k=abs(k)
              deleic(j,j0)=delecf(k,j0)
            enddo
            do k=1,kmax
              delecf(k,j0)=dzero
            enddo
          endif
C
        ENDIF
C
C OLD TERMS
C
        IF(MDELE.NE.0.AND.ISHFTLS.EQ.0)THEN
          MD=ABS(MDELE)
          ISHFTLS=1
          DO K=1,MD
C
            READ(5,*)I,DEM
C
            DELELS(I,1)=DEM/(DTWO*DKCM)
          ENDDO
        ENDIF
C
      ELSEIF(INCLUD.NE.0.AND.IOPTIM.EQ.0)THEN
C
C CHECK NOT VARYING SLATER IF NO OBS ENERGIES READ.
C
        DO K=1,NVAR0
          IF(IBUF(K).EQ.ISCALR)THEN
            WRITE(6,*)'***SR.MINIM: VARYING SLATER SCALING TO MINIMIZE'
     X               ,' ABSOLUTE ENERGY SUM WILL NOT CONVERGE!!'
            WRITE(0,*)'***SR.MINIM: SLATER SCALING WILL NOT CONVERGE'
            GO TO 998
          ENDIF
        ENDDO
C
      ENDIF
C
C PLASMA SCREENING:
C   TKAY>0 ELECTRON TEMP*K IN RYD.
C       <0 ELECTRON TEMP IN KELVIN.
C   DENE = ELECTRON DENSITY IN CM-3.
C NDEN<0
C   DENI = ION DENSITY IN CM-3.**** CURRENTLY NOT USED ****
C NDEN>0
C   DENI=DENE/ZN IF NEEDED (MDEN=2 ION-SPHERE)
C        WHERE ZN=Z-N+1 FOR BOUND AND ZN=Z-N FOR CONTINUUM ORBITALS
C        IS SET IN SR.RADIAL AND SR.RADCON (FOR SAFETY) AS INPUT
C        TO SR.VMPOT TO ENSURE CHARGE NEUTRALITY.
C
      ZNP0=-999
      DENE=DZERO
      DENI=DZERO
      TKAY=DONE
C
      IF(MDEN.GT.0)THEN
        NDEN0=NDEN
C        IF(NDEN.EQ.0)NDEN=1                              !HISTORIC...
        NDEN=MIN(ABS(NDEN),MXD15)
C
        IF(NDEN0.GE.0)THEN
          READ(5,*)(DENS(N),TKAYS(N),N=1,NDEN)           !DENE,TKAY
          DO N=1,NDEN
            DENSI(N)=DZERO
          ENDDO
        ELSE
          WRITE(0,*)'*** ATTENTION: USER INPUT ION DENSITIES NOT IN USE'
          WRITE(6,*)'*** ATTENTION: USER INPUT ION DENSITIES NOT IN USE'
          READ(5,*)(DENSI(N),DENS(N),TKAYS(N),N=1,NDEN)  !DENI,DENE,TKAY
        ENDIF
c
C PRE-LOAD MIN DENSITY CASE FOR SR.MESH (SET ALL INFO)
        N0=1
        DO N=2,NDEN
          IF(DENS(N).LT.DENS(N0))N0=N
        ENDDO
C EX-SR.MINIM
        T=NZION-MION+1               !APPROX, EXACT SET IN RADIAL/RADCON
        DENE=DENS(N0)*DCON3**3
        IF(DENSI(N0).LE.DZERO)DENSI(N0)=DENS(N0)/T       !NOT USED
        DENI=DENSI(N0)*DCON3**3
        R0=DZERO
        IF(DENI.NE.DZERO)R0=(DCON6/DENI)**D1THRD
        TKAY=TKAYS(N0)
        IF(TKAY.LT.DZERO)TKAY=-TKAY/DCON2                !K->RYD
        GAMQ=DZERO
        DEBYE=DZERO
        IF(DENE*TKAY.NE.DZERO)THEN
          DEBYE=SQRT(DCON5*DENE/TKAY)
          DEBYE=DONE/DEBYE
          IF(R0.NE.DZERO)THEN
            GAMQ=DCON4*T*T
            GAMQ=GAMQ*DENI**D1THRD/TKAY
          ENDIF
        ENDIF
c                                                  !suppress
        IF(mden.lt.0)
     X            WRITE(6,781)MDEN,DENSI(N0),DENS(N0),TKAY,GAMQ,DEBYE,R0
C
        NDEN=NDEN-1                                !RE-SET FOR INCREMENT
C
      ELSEIF(NDEN.GT.0)THEN                              !READ & SKIP
        READ(5,*)(D,T,N=1,NDEN)
        NDEN=0
      ENDIF
C
C END READ INPUT AND INITIAL SETUP--------------------------------------
C
C
  95  NF0=NF
C
C FOR STUPID G77 COMPILER:
C
      MPRNT0=MPRINT
      NLAM0=NLAM
      NVAR0=NVAR*ISVAR
      IMXIT=IMAXIT
      TVARY0=TVARY
C
      RETURN
C
  999 WRITE(6,1997)
      WRITE(0,*)'*** SR.MINIM0: ERROR READING NAMELIST SMINIM!'   !FATAL
C
  998 NF=-1
      GO TO 95
C
C
 1997 FORMAT('*** SR.MINIM0: ERROR READING NAMELIST SMINIM!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
 1000 FORMAT( ' SR.MINIM REQUIRES  MXVAR =',I4, ' RATHER THAN',I4)
  997 FORMAT(/' *** SR.MINIM: ERROR, YOU HAVE SPECIFIED RELAXED ORBITAL'
     X       ,I3,' AS AN EXTERNAL ORBITAL!')
  996 FORMAT(/' *** SR.MINIM: ERROR, TRYING TO VARY EXTERNAL ORBITAL='
     X        ,I3)
  995 FORMAT(16I5)
  994 FORMAT('***ERROR, ORBITAL K=',I3,' TO BE VARIED DOES NOT EXIST!')
  993 FORMAT(//35X,60('*')/)
  992 FORMAT(' SR.MINIM REDUCES NLAM/NEXTRE=',I3, ' TO ',I3)
  991 FORMAT(" *** WARNING: SR.MINIM RESETS INCLUD=0, BECAUSE YOU'VE "
     X,"FLAGGED CONTINUUM INPUT FOR ORBITAL NO. =",I2)
  990 FORMAT(" SR.MINIM RESETS EFFECTIVE NUMBER OF ELECTRONS TO",I4
     X,", BECAUSE YOU'VE SPECIFIED  MRED =",I3)
  899 FORMAT(' ERROR IN SR.MINIM, YOU HAVE DECLARED ORBITAL',I3
     X,'BOTH AS A VALENCE AND AS A CONTINUUM ORIBTAL' /)
  898 FORMAT(' WARNING, YOU HAVE SPECIFIED MDELE .LT. 0 WITH NO RESTART'
     X,', MDELE HAS BEEN RESET TO ZERO BY SR.MINIM')
  897 FORMAT(' *** SR.MINIM: ERROR, EXTERNAL ORBITAL',I3,' WOULD',
     X       ' BE REPEATEDLY ORTHOGONALIZED TO VARIATIONAL ORBITAL',I3)
  895 FORMAT(' WARNING, SR.MINIM IS UNABLE TO FIND ANY VALENCE ORBITALS'
     X,' SO DR HAS BEEN SWITCHED OFF ')
  886   FORMAT('***ERRROR: VARIATIONAL PARAMETER',I3,' HAS VALUE'
     X  ,I3,' WHICH EXCEEDS NUMBER OF SCALING PARAMETERS',I3)
  885 FORMAT(//' ****ERROR, VARIATIONAL PARAMETERS MUST BE IN ASCENDING'
     X,' ORDER, NOT:',15I3)
  884 FORMAT(' SR.MINIM: CANNOT USE NEXTRE/NLAM.LT.0 WITH ISCALR.GT.0:'
     X,2I5)
  883 FORMAT(///'**** BAYLISS 1-BODY POLARIZATION POTLS IN USE *****'//
     X'  L',5X,'ALFD',6X,'RCUT'/3(I3,2F10.4/))
  882 FORMAT(///'**** NORCROSS 1-BODY POLARIZATION POTLS IN USE *****'//
     X'  L',5X,'ALFD',6X,'RCUT'/3(I3,2F10.4/))
  881 FORMAT(///'**** BAYLISS 2-BODY POLARIZATION POTLS IN USE *****'//
     X7X,'<ALFD>',4X,'<RCUT>'/3X,2F10.4/)
  880 FORMAT(///'**** NORCROSS 2-BODY POLARIZATION POTLS IN USE *****'//
     X7X,'<ALFD>',4X,'<RCUT>'/3X,2F10.4/)
  879 FORMAT(' *** SR:MINIM: UNRECOGNIZED OPTION FOR POTIN:  ',A4)
  878 FORMAT(' *** SR:MINIM: UNRECOGNIZED OPTION FOR RADOUT:  ',A3)
  877 FORMAT(' *** SR:MINIM: UNRECOGNIZED OPTION FOR POTOUT:  ',A3)
  781 FORMAT(/' MDEN=',I2,3X,'ION DENSITY=',1PE9.2,'CM-3',3X,
     X'ELECTRON DENSITY=',1PE9.2,'CM-3',3X,'TEMPERATURE*K=',
     X0PF7.2,'RYD',3X,'GAMMA=',0PF5.2,3X,'DEBYE=',F7.2,3X,'R0=',F7.2/
     X' **** ',5X,'*********** ',16X,'**************** ',
     X16X,'************* ',13X,'***** ',8X,'***** ',10X,'**')
  777 FORMAT(/' **** BOX STATES IN USE WITH BOUNDARY RZERO INPUT AS: '
     X,F5.1/)
  773 FORMAT(2I2,2X,2I2,2I5,F18.8,3X,A4)
  772 FORMAT(3I2,I5,I5,F18.6,3X,A4)
  695 FORMAT(//' CF ADDITIONAL FICTICIOUS CONFIGURATION OCCUPATION'
     X,' NUMBERS FOR STO/SELF-CONSISTENT POTENTIALS:'/)
  694 FORMAT(I3,':',(60I2))
  693 FORMAT(' *** SR.MINIM: ILLEGAL OCCUPATION NUMBER FOR CF=',I3
     X,' VALENCE ORBITAL=',I2,' OF:',I3)
c  692 FORMAT('***SR.MINIM RESETS INCLUD=0 BECAUSE RELATIVISTIC'
c     X,' ORBITALS ARE IN USE')
C
      END SUBROUTINE MINIM0
C
C                             *******************
C
      SUBROUTINE MKALG1(QLMC,MAXEL,DFS,MAM,NAM)
C
C-----------------------------------------------------------------------
C
C  SR.MKALG1 WORKS OUT SLATER-STATE INTERACTIONS CSLJP-C'S'L'J'P FOR
C  RADIATIVE MK ALGEBRA, INCLUDING BP CORRECTIONS TO M1 AND E1VEL.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_COEFF,  ONLY: IXSOC,IXSOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD05=4*(MAXLL+1))
C
      PARAMETER (TYNY=1.D-5)
C      PARAMETER (DTOL=1.0D-8)
      PARAMETER (DFAC1=DTEN/(DTHREE*DTWO**8))
C
      DIMENSION QLMC(MAXEL,*),MAM(*),NAM(*),DFS(*)
      DIMENSION IGAM(5),ILAM(200),CLTM2(200),CLTM(:)
C                                           ,CLTM(10)    !,VVC1(6,MXVAR)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,MGAP(5)
      COMMON /CMKALG1/DVC12,VC1(MXD05),NC0X,MJS1,MJL1,MJS2,MJL2
     X,MJJL,MJJR,NC,ND,ICLR,QLIT(10),BLX1,BLX2,BMSKIP,BOSKIP,BM1BODY
      COMMON /CMKALG2/DVC,MJ1,MJ2,MLAM,BE1CASE
C      COMMON /OUTP1/MPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
C
      POINTER :: CLTM,MCTO
      TARGET :: CLTM2,MLK
C
      CLTM=>CLTM2(1:10)
      MCTO=>MLK
C
c      EQUIVALENCE (MCTO,MLK),(CLTM2(1),CLTM(1))      !,VVC1(1,1),VC1(1)
C
      DATA  BDEBUG1,BDEBUG /.FALSE.,.FALSE./
C
      BPLANT1=MXORB.LT.200
      BPLANT2=MXORB.LT.37
C
      IFOTMX=0
      IF(BFOT)IFOTMX=1
C
      DQ2=SQRT(DTWO)
      DQ3=SQRT(DTHREE)
      DQ3O2=SQRT(DTHREE/DTWO)
      DQ3O4=DQ3/DTWO
C
      MLAM1=MLAM-2
      MLAM2=MLAM+2
      MLAMH=MLAM/2
      MLK=MJ1-MJ2
      MXLL=0
C
      IRLPS1=IRLPS0+1
      NLS01=NLS00+1
C
      IF(ICLR.LT.0)GO TO 40
C      BEQUCFG=KF.EQ.KG
      JBB=JBP
C
C     IN LOOPS 64,65 SCAN THROUGH SLATER STATES IN INITIAL AND
C     FINAL STATES RESP., AND CALCULATE CONTRIBUTIONS DUE TO EACH PAIR.
C
      DO 64 J1=JA,JB                                     !BEGIN 64
C
      L1=MAM(J1)
C
C      IF(BEQUCFG)JBB=J1
      DO 65 J2=JAP,JBB                                   !BEGIN 65
C
      L2=NAM(J2)
C
C     CALCULATE TRANSFORMATION COEFFICIENT FROM THE LS,ML,MS
C     REPRESENTATION TO THE J,MJ REPRESENTATION.
C
      DDH=DVC12
      IF(ABS(DDH).LT.TYNY)GO TO 65    ! DTOL -> TYNY
C
CTHESE NEXT 2 STATEMENTS RESOLVE INTERACTIONS BY SLATER STATE
COLD      IRKPS00=IRKPS+1
COLD      IRSS00=IRSS+1
C
      DO I=IRLPS1,IRLPS
        IORIG1(I)=0
      ENDDO
      DO I=NLS01,NLS
        IORIG2(I)=0
      ENDDO
C
C     NOW COMPARE INITIAL AND FINAL SLATER STATES AND SELECT ONLY THE
C     ONES WHICH DIFFER IN NK=0, 1, OR 2 SETS OF QUANTUM NUMBERS
C
      NK=0
      N2=0
      MU=0
      DO 174 I=1,NF
      N2P=QLMC(I,L1)
      ICG2=QCG(I,KF)
      DO 73 L=1,NF
      IF(QLMC(L,L2).NE.N2P)GO TO 73
      IF(IEQ(QCG(L,KG)).NE.IEQ(ICG2))GO TO 73
      LP=L
      GO TO 74
  73  CONTINUE
      NK=NK+1
      IF(NK.GT.2)GO TO 65
      IF(NK.EQ.2)THEN
        IF(BM1BODY.or.BMSKIP)GO TO 65  !******** ONE-BODY SWITCH *******
        GO TO 76
      ENDIF
      N1=I
  76  N1P=I
      MU=I+MU
      LP=0
  74  QLMC(I,1)=LP
  174 CONTINUE
C
      IF(NK.EQ.0)GO TO 88
      DO 70 L=1,NF
      DO 71 I=1,NF
      IF(QLMC(I,1).EQ.L)GO TO 70
  71  CONTINUE
      N2P=L
      MU=L+MU
      IF(N2.NE.0)GO TO 87
C TMP IF(N2.NE.0)GO TO 65
      N2=N2P
      IF(NK.EQ.1)GO TO 87
C     L1 AND L2 DIFFER IN ONE PAIR, IN POSITIONS NUMBERED N1 AND N2
  70  CONTINUE
C
  88  N2=N2+1
      IF(N2.GT.NF)GO TO 69
      N1=N2
  87  ICG1=QCG(N1,KF)
      ICG2=QCG(N2,KG)
      IFOT1=0
      IF(QN(ICG1).GE.90)IFOT1=1
      IFOT2=0
      IF(QN(ICG2).GE.90)IFOT2=1
C
      IFOT12=IFOT1+IFOT2
      IF(IFOT12.GT.IFOTMX)GO TO 82             !OMIT CONTINUUM-CONTINUUM
C
C     FIND THE AZIMUTHAL COMPONENTS OF L AND S FOR THE INDIVIDUAL
C     ELECTRONS, WHOSE NUMBERS ARE N1,N2.
C
      LR=QL(ICG2)
      LL=QL(ICG1)
      LAM=QLMC(N2,L2)
      QLML2=((LAM+100)/2)*2-100
      QLMS2=(LAM-QLML2)*2-1
      LAM=QLMC(N1,L1)
      QLML1=((LAM+100)/2)*2-100
      QLMS1=(LAM-QLML1)*2-1
C
      IF(BM1BODY)THEN     !************** ONE-BODY SWITCH **************
        IF(BE1CASE)GO TO 49
        IF(ABS(MBP2MX).LT.MLAM)GO TO 42
      ENDIF
C
      IF(QLIT(10).EQ.QCUT)GO TO 49
      IF(BMSKIP)THEN
        IF(MBP1MX.Lt.0)GO TO 42     !for type 9 pure mk
        GO TO 49               !for type 8 etc., i.e. inc. alpha^2 corr.
      ENDIF
      IF((QCUT.EQ.QLIT(8) .OR. NC.NE.ND) .AND. BOSKIP)GO TO 49
C
      LAM=NF
      IF(NK.GT.1)GO TO 46
      IF(NK.EQ.1)GO TO 44
      LAM=N1
  44  N1P=-NW
  45  N1P=N1P+1
      IF(N1P.GT.0)GO TO 77
      KP=N1P+NW
      ICG1P=NNL(KP,1)
      ICG2P=ICG1P
      M1=NNL(KP,2)                                    !M1<-MA (NOT CORE)
      M2=M1                                           !M2<-MC
      GO TO 78
  77  IF(N1P.GT.LAM)GO TO 49
      IF(N1P.EQ.N1)GO TO 45
      N2P=QLMC(N1P,1)
C TST ICG1P=QCG(N1P,KF);  ICG2P=ICG1P
C TST M1=QLMC(N1P,L1);    M2=M1;         GO TO 78     !MC=MA
  46  ICG1P=QCG(N1P,KF)
      ICG2P=QCG(N2P,KG)
      M1=QLMC(N1P,L1)                                 !M1<-MA (NOT CORE)
      M2=QLMC(N2P,L2)                                 !M2<-MC
  78  QLML2P=((M2+100)/2)*2-100                       !M2<-MC
      QLMS2P=(M2-QLML2P)*2-1                          !M2<-MC
      QLML1P=((M1+100)/2)*2-100                       !M1<-MA
      QLMS1P=(M1-QLML1P)*2-1                          !M1<-MA
      LLP=QL(ICG1P)
      LRP=QL(ICG2P)
      KP=1
  47  KO=1
  66  LO=ABS(LL-LR)
      IF(LO.GT.6.OR.MBP2MX.LT.0)GO TO 67  !***** ONE-BODY SWITCH *****
C
      I1P=ABS(LLP-LRP)
C       ETC.............
      ILAM(200)=9999
C +-+   +++++++++++++++++++++++++++++++++++++++
C     CLAUDE, INSERT HSC.CZMAGADD.FORT HERE
C     CLTM2(199)=DDH*KO*KP;  ILAM(199)=-9999
C
      KTERM=200
      MTEST2=QLMS1-QLMS2
      MTES2P=QLMS1P-QLMS2P
      IF(MTEST2.NE.0.AND.MTES2P.NE.0)GO TO 67
      MX=-MTEST2-MTES2P
      MTEST1=QLML1-QLML2
      MTES1P=QLML1P-QLML2P
      MP1=QLML1+QLML2+QLML1P+QLML2P
      DDS=DZERO
      IF(MTES2P.NE.0)GO TO 203
CC    DDS=.5773502691896
      DDS=-DONE/DQ3
CC         -'''             TO ABSORB FACTOR (-1)**(-QLMS1-QLMS2)
      IF(QLMS1+QLMS2.NE.0)GO TO 202
      DDS=SQRT(DTWO/DTHREE)
  202 IF(QLMS1.GT.0)DDS=-DDS
      IF(MTEST2.NE.0)GO TO 204
  203 DD=-DONE/DQ3
      IF(QLMS1P+QLMS2P.NE.0)GO TO 205
      DD=SQRT(DTWO/DTHREE)
  205 IF(QLMS1P.GT.0)DD=-DD
      DDS=DD+DDS
  204 I2P=LLP+LRP
      LP=LL+LR
      LA=LO
C
  255 D2C2=VCC(LR,LA,LL,IZERO,IZERO,IZERO,DFS)
C
      ID=LA+2
      IC=ABS(LA-2)
      LB=MAX(LA-2,LO)
  256 IF(LB.GT.LP)GO TO 206
      IF(ABS(MTEST1).GT.LB)GO TO 207
C
      D2C3=VCC(LL,LB,LR,-INT(QLML1,SP),MTEST1,-INT(QLML2,SP),DFS)
C
      IF(MX.NE.0)GO TO 208
C JJJ  DD   =SJS(LA,ITWO,LB,LR,LL,LR,DFS) *
C JJJ X         SQRT(REAL((LA+1)*(LB+1)*(LR+2)*(LR+1)*LR*3,WP))
      LM=LA+2
      IF(LA.GT.LB)GO TO 233
      IF(LA.LT.LB)GO TO 231
      D2C6J=DZERO
      IF(LA.EQ.0)GO TO 208
      D2C6J=((LL+2)*LL-(LR+2)*LR-LM*LA)*
     X      SQRT(((LA+1)*3)/REAL(LM*LA*4,WP))
      GO TO 220
  231 D2C6J=-SQRT(((LR+LL+LA+4)*(LR-LL+LM)*(LM+LL-LR)*(LR+LL-LA)*3)/
     X       REAL(8*LM,WP))
      GO TO 220
  233 D2C6J=SQRT(((LR+LL+LM)*(LR-LL+LA)*(LA+LL-LR)*(LR+LL-LA+2)*3)/
     X      REAL(8*LA,WP))
  220 CONTINUE
C
C JJJ IF(ABS(D2C6J-DD).GT.1.E-4)WRITE(6,888)LL,LR,LA,LB, D2C6J, DD
C 888 FORMAT( '  *** LL,LR,LA,LB: SJS ***  ',4I4,2F10.5)
C
  208 LC=I1P
C
  257 D2C4=VCC(LRP,LC,LLP,IZERO,IZERO,IZERO,DFS)
C
      IB=LC+2
      IA=ABS(2-LC)
      LD=LC
C 258 IF(LD.LT.I1P.OR.LD.GT.I2P)GO TO 209
      IF(ABS(MTES1P).GT.LD)GO TO 209
C
      D2C5=VCC(LLP,LD,LRP,-INT(QLML1P,SP),MTES1P,-INT(QLML2P,SP),DFS)
C
      IF(LB.NE.LA)GO TO 240
      IF(DDS.EQ.DZERO)GO TO 240
      IF(LA.NE.LC)GO TO 252
      IF(MTEST1.NE.-MTES1P)GO TO 252
      KTERM=KTERM-1
      IF(KTERM.LE.0)GO TO 99
C     CLTM2(KTERM)=(1-MOD(ABS(MCTO+MTEST1),4))*DDS*D2C2*D2C3*
      CLTM2(KTERM)=(MOD(ABS(     MTEST1),IFOUR)-1)*DDS*D2C2*D2C3*
     X              D2C4*D2C5*DQ3
      ILAM(KTERM)=LA
  252 LF=IA
      M1=MTEST1-MX                                    !M1<-MA
      DD=-1
      IF(LC.EQ.0)GO TO 238
      DD=(MOD(LC,IFOUR)-1)/SQRT(REAL(LC+1,WP))
      LM=(LC+1)*(LC-1)
      M2=-600                                         !M2<-MC
      GO TO 250
  238 LM=-(LC+1)*(LC+3)
      M2=600                                          !M2<-MC
  250 IF(ABS(LF-LA).NE.2)GO TO 237
      KTERM=KTERM-1
      IF(KTERM.LE.0)GO TO 99
      II=(LA-LF+2)/4+LF
      KK=(LC-LF+2)/4+LF
      if(ii.gt.nc0x.or.kk.gt.nc0x)stop '*** sr.algeb4: vc1 not set'!temp
ct      mc0x=max(mc0x,ii,kk)
C
C     NOTE: (-1)**((LA+LC)/2)=+1, BECAUSE M1-TRANSITIONS CONSERVE PARITY
C
C
C CLAUDE+  CLTM2(KTERM)=2*LM*D2C2*D2C3*D2C4*D2C5/SQRT(3.)
C CLAUDE, SECTION 'MX.NE.0' BUG FREE I HOPE, SINCE JULY 23. WERNER AUG80
C
      CLTM2(KTERM)=((MOD(ABS(MX-MP1),IFOUR)-1)*LM*2)*D2C2*D2C3*D2C4
     X            *D2C5*DDS*VCC(LF,ITWO,LA,M1,MX,MTEST1,DFS)*VC1(II)
     X            *DD*VCC(LC,LF,ITWO,MTES1P,M1,MCTO,DFS)*VC1(KK) !M1<-MA
C
C     VC1(II)=VCC(LF,ITWO,LA,IZERO,IZERO,IZERO,DFS)
C     VC1(KK)=VCC(LC,LF,ITWO,IZERO,IZERO,IZERO,DFS)
C
      ILAM(KTERM)=SIGN(LC,M2)+M2                      !M2<-MC
  237 LF=LF+4
      IF(LF.LE.IB)GO TO 238
C --- IF(MTEST2.NE.0.OR.MTES2P.NE.0)    I.E.
  240 IF(MX.NE.0)GO TO 209
      IF(MJS2.NE.MJS1)GO TO 209
      IF(LB+LC.EQ.0)GO TO 209
      IF(ABS(LC-LB).GT.2)GO TO 209
C
      D2C0=((MOD(ABS(MTES1P+MP1),IFOUR)-1)*2)*SQRT(REAL((LC+1)*3,WP))*
     X VCC(LC,ITWO,LB,-MTES1P,MCTO,MTEST1,DFS)*D2C2*D2C3*D2C4*D2C5
C
      LE=IA
C
  210 DC1=SJS(ITWO,ITWO,ITWO,LE,LD,LB,DFS)
C
      DL1=DONE/SQRT(REAL(LE+1,WP))
      KK=(LC-LE+2)/4+LE
      LF=IC
  264 II=(LA-LF+2)/4+LF
      if(ii.gt.nc0x.or.kk.gt.nc0x)stop '*** sr.algeb4: vc1 not set'!temp
ct      mc0x=max(mc0x,ii,kk)
      DD1=VC1(II)*VC1(KK)*DC1*D2C0
C
C     VC1(II)=VCC(LF,ITWO,LA,IZERO,IZERO,IZERO,DFS)
C     VC1(KK)=VCC(ITWO,LE,LC,IZERO,IZERO,IZERO,DFS)
C EVT IF(DD1.EQ.0.)  GO TO 268
C
      DC2=SJS(ITWO,ITWO,ITWO,LA,LB,LF,DFS)
C
      DL2=SQRT(REAL(LF+1,WP))
      LG=ABS(2-LE)
      IF(LE.EQ.0)GO TO 262
      LM=(LE+1)*(LE-1)
      M2=- 500-LE                                     !M2<-MC
      M1=-600-LE+2                                    !M1<-MA
      GO TO 261
  262 LM=-(LE+1)*(LE+3)
      M2=LE+2+700                                     !M2<-MC
      M1=LE+2+600                                     !M1<-MA
  261 IF(ABS(LG-LF).NE.2)GO TO 260
      IF(KTERM.LT.5)GO TO 99
      I=(LF-LG+2)/4+LG
      K=(LE-LG+2)/4+LG
      if(i.gt.nc0x.or.k.gt.nc0x)stop '*** sr.algeb4: vc1 not set' !temp
ct      mc0x=max(mc0x,i,k)
C
C     VCC(ITWO,LG,LF,IZERO,IZERO,IZERO,DFS)=VC1(I);VCC(LE,LG,2,..)
C                                      =(MOD(LE,4)-1)* VC1(K)*DL1*SQR(3)
      DD=LM*SJS(LE,LG,ITWO,LF,LB,ITWO,DFS)
     X                                     *DD1*VC1(I)*VC1(K)*DL1*DL2
      KTERM=KTERM-1
      CLTM2(KTERM)=D2C6J*DC2*DD
C
C CLAUDE, I REINTRODUCED, NOW THROUGH D2C0, A PHASE FACTOR (-1)**MP1
C WHICH YOU HAD THROWN OUT WITH PHS0 IN JUL. PLEASE CLARIFY. WERNER 80AU
      ILAM(KTERM)=M1                                  !M1<-MA
      IF(LB.NE.LA)GO TO 260
      KTERM=KTERM-1
      CLTM2(KTERM)=DD*DQ2
      ILAM(KTERM)=M2                                  !M2<-MC
  260 LG=LG+4
      IF(LG.LE.LE+2)GO TO 262
      IF(LF.NE.LE)GO TO 268
C
C     NOTE: LF=LC-2 AND LC+2 (SUBJECT TO .GE.LA-2, .LE.LA+2, SEE IC ID)
C           LE=LC-2 AND LC+2; THUS ALWAYS ONE MATCH FOR LF IN SET LE.
C
      KTERM=KTERM-1
      CLTM2(KTERM)=DC2*D2C6J*DD1
      ILAM(KTERM)=-400-LF
      IF(LB.NE.LA)GO TO 268
      KTERM=KTERM-1
      CLTM2(KTERM)=DD1*DQ2
      ILAM(KTERM)=-300-LF
  268 LF=LF+4
      IF(LF.LE.ID)GO TO 264
      LE=LE+4
      IF(LE.LE.IB)GO TO 210
C
CQ219 IF(MX.NE.0)  GO TO 209
C       ARCHIVED HSC.CZDIRAFS.MAR80.DATA OF MARCH 15TH DOES NOT YET MAKE
C       USE OF PARTICLE SYMMETRY PROPERTIES-HAS OLD BULKY CODE.
C
CO209 LD=LD+2
CO    IF(LD.LE.IB)GO TO 258
  209 LC=LC+4
      IF(LC.LE.I2P)GO TO 257
  207 LB=LB+2
      IF(LB.LE.ID)GO TO 256
  206 LA=LA+4
      IF(LA.LE.LP)GO TO 255
C
C +-+   +++++++++++++++++++++++++++++++++++++++
C
      PHS0=(1-MOD((MU+KO+KP)*2,IFOUR))*DDH
      CLTM2(200)=DZERO
C TST CLTM2(200)=(1-MOD(MJJR-MJ2,IFOUR))*DVC/(17.320508*PHS0)
C
C
C *** STORE TWO-BODY COEFFICIENTS ***
C
      DO 214 K=KTERM,200
C
      DD=CLTM2(K)
      IF(DD.EQ.DZERO)GO TO 214
      LM=ILAM(K)
      M2=(ABS(LM)+2)/100                             !M2<-MC
C XXX IF(M2.NE.0) DD=DD+DD                            !M2<-MC
C XXX CLAUDE HAS NOW ABSORBED FACTORS 2 INTO CLTM2  -- 1980 JULY
      KK=0
      II=0
C-TST IF(M2.GT.4)GO TO 277                            !M2<-MC
      IF(LM.LT.0)GO TO 274
      IF(M2.GT.0)GO TO 277                            !M2<-MC
      IF(ICG1.LE.ICG2)GO TO 277
  274 LM=ABS(LM)
C 275 CONTINUE
      II=1-II
  277 IGAM(1+II+KK)=ICG1
      IGAM(2-II+KK)=ICG1P
      IGAM(3+II-KK)=ICG2
      IGAM(4-II-KK)=ICG2P
CNRB      IF(KK.NE.0)  GO TO 279
C TST IF(LM.EQ.9999)  GO TO 279
CNRB      IF(IGAM(1).LT.IGAM(3))GO TO 279
CNRB      KK=2
CNRB      IF(M2.NE.0)  GO TO 278                      !M2<-MC
CNRB      IF(IGAM(4).LT.IGAM(3))GO TO 275
CNRB  278 IF(MOD(M2,2).EQ.0)  GO TO 277               !M2<-MC
CNRB  279 CONTINUE
      IGAM(5)=LM
C EVT    ADD CODE TO REDUCE NUMBER OF INTEGRALS INVOLVING A DERIVATIVE
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
      IF(BPLANT2)IPLANT=IGAM(5)+
     X((((IGAM(4)*MXORB+IGAM(3))*MXORB+IGAM(2))*MXORB)+IGAM(1))*1000
      DO 272 J=NLS01,NLS
        IF(.NOT.BPLANT2)THEN
          DO I=5,1,-1                                     !1,5 SLOWER
            IF(QSSS(I,J).NE.IGAM(I))GO TO 272
          ENDDO
        ELSE
          IF(IPLANT.NE.JORIG2(J))GO TO 272
        ENDIF
        L=J
        I=IORIG2(L)
        IF(I.GT.0)THEN
          DSSS(I)=DD*PHS0+DSSS(I)
          GO TO 214
        ENDIF
        GO TO 281
  272 ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
      L=NLS+1
      IF(L.GT.IXS2I)THEN                                      !GO TO 495
C
        IXXX=7*(IXS2I/5+1)
C
        WRITE(6,*)'*** MKALG1: increasing MXS2I from ',IXS2I,' to: '
     X            ,IXXX
        WRITE(0,*)'*** MKALG1: increasing MXS2I from ',IXS2I,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QSSS,IONE,IFIVE,IONE,IXS2I,IFIVE,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR QSSS'
          NF=0
          GO TO 90
        ENDIF
C
        IXXX0=MAX(IXS2I,IAXMI)
        IXXX2=MAX(IXXX,IAXMI)
        IF(IXXX2.GT.IXXX0)
     X  CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
        CALL RE_ALLOC(JORIG2,IONE,IXS2I,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR IORIG2,JORIG2'
          NF=0
          GO TO 90
        ENDIF
C
        IXS2I=IXXX
C
      ENDIF
C
      NLS=L
      DO I=1,5
        QSSS(I,L)=IGAM(I)
      ENDDO
      IF(BPLANT2)JORIG2(L)=IPLANT
C
  281 IRSS=IRSS+1
      IF(IRSS.GT.IXS2C)THEN                                   !GO TO 494
C
        IXXX=7*(IXS2C/5+1)
C
        WRITE(6,*)'*** MKALG1: increasing MXS2C from ',IXS2C,' to: '
     X            ,IXXX
        WRITE(0,*)'*** MKALG1: increasing MXS2C from ',IXS2C,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DSSS,IONE,IXS2C,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR DSSS'
          NF=0
          GO TO 90
        ENDIF
C
        CALL RE_ALLOC(MSSS,IONE,IXS2C,IXXX,IERR)
        CALL RE_ALLOC(NSTJ2,IONE,IXS2C,IXXX,IERR)
        CALL RE_ALLOC(NSTJ2D,IONE,IXS2C,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR MSSS,NSTJ2'
          NF=0
          GO TO 90
        ENDIF
C
        IXS2C=IXXX
C
      ENDIF
C
      IORIG2(L)=IRSS
      MSSS(IRSS)=L
      DSSS(IRSS)=DD*PHS0
      NSTJ2(IRSS)=L1
      NSTJ2D(IRSS)=L2
C
  214 ENDDO
C
C *** END STORE TWO-BODY COEFFICIENTS ***
C
C
C *********************** END TWO-BODY SECTION *************************
C
  67  II=ICG1P
      ICG1P=ICG1
      ICG1=II
      LM=LLP
      LLP=LL
      LL=LM
      KK=QLML1P
      QLML1P=QLML1
      QLML1=KK
      KK=QLMS1P
      QLMS1P=QLMS1
      QLMS1=KK
      KO=KO-1
      IF(KO.GE.0)GO TO 66
      II=ICG2P
      ICG2P=ICG2
      ICG2=II
      LM=LRP
      LRP=LR
      LR=LM
      II=QLML2P
      QLML2P=QLML2
      QLML2=II
      II=QLMS2P
      QLMS2P=QLMS2
      QLMS2=II
      KP=KP-1
      IF(KP.GE.0)GO TO 47
      IF(NK.GT.1)GO TO 65
      GO TO 45
  49  IF(NK.GT.1)GO TO 65
      IF(ABS(LL-LR).GT.4)GO TO 82
      MTEST2=QLMS1-QLMS2
      MTEST1=QLML1-QLML2
      DD=DZERO
      IF(MXLL.EQ.-1) DD=DONE
      DO 120 K=1,8
      CLTM(K)=DD
  120 CONTINUE
C
      IF(BDEBUG1)WRITE(6,700) NK, L1,L2, LL,LR
C
C
C CCC DDS=VCC(IONE,ITWO,IONE,-QLMS1,MTEST2,-QLMS2,DFS)
C
      DDS=DONE/DQ3
      IF(QLMS1+QLMS2.NE.0)GO TO 133
      DDS=DONE/DQ3O2
  133 IF(QLMS1.GT.0)DDS=-DDS
      M2=1-ABS(MCTO)                                 !M2<-MC
      LP=1
C
      IF(BE1CASE)GO TO 137 !************** ONE-BODY SWITCH *************
C
      LAM=(LL+2)*LL
      IF(BMSKIP)GO TO 127
      IF(LL+LR.EQ.0)GO TO 150
      M1=1-ABS(MTEST2)                               !M1<-MA
C
      DD=VCC(LR,IFOUR,LL,IZERO,IZERO,IZERO,DFS)
      DL2=VCC(LL,IFOUR,LR,-INT(QLML1,SP),MTEST1,-INT(QLML2,SP),DFS)
      DC2=VCC(ITWO,IFOUR,ITWO,MTEST2,MTEST1,MCTO,DFS)*(M2*M1)     !MC*MA
C
      CLTM(2)=-((LAM-(LR+2)*LR+24))*DL2*DD*DC2*DDS*SQRT(DFAC1)
      CLTM(3)=-((LAM-(LR+2)*LR-24))*DL2*DD*DC2*DDS*SQRT(DFAC1)
      CLTM(4)=-DL2*DD*DC2*DDS*SQRT(DTEN/DTHREE)
      CLTM(5)=CLTM(4)
C *** CLTM(1)=.......                    TERM  LM=MIN(LL,LR)+2
      DL1=6                   !4->6
      LM=LL+2
      IF(LR.GT.LL)GO TO 130
      IF(LR.EQ.LL)GO TO 131
      LM=LR+2
      DC1=(LM-2)* LM
      DD1=(LM+3)*5
      DD2=LM-1
      GO TO 129
C 131 DL1=6
  131 DL1=12
      DC1=-(LM+2)*(LM-2)
      DD1=(LM-3)*(LM-2)*15
      DD2=(LM-1)*LM*2
      GO TO 129
  130 DC1=(LM+2)*(LM+4)
      DD1=(LM-1)*5
      DD2=LM+3
  129 II=(LM-LL+2)/4+LL
      KK=(LR-LM+2)/4+LM
      if(ii.gt.nc0x.or.kk.gt.nc0x)stop '*** sr.algeb4: vc1 not set'!temp
ct      mc0x=max(mc0x,ii,kk)
C
C TST  CLTM(1)=VCC(LL,ITWO,LM,IZERO,IZERO,IZERO,DFS)
C TST X        *VCC(LM,ITWO,LR,IZERO,IZERO,IZERO,DFS)
C TST X        *SJS(LL,LM,ITWO,ITWO,ITWO,LM,DFS)
C TST X        *SJS(LM,LR,ITWO,ITWO,ITWO,LR,DFS)
C TST X        *SJS(LL,LR,IFOUR,ITWO,ITWO,LM,DFS)
C TST X        *((LM+1)*30)*DC2*DL2*DDS
C TST X        *SQRT(REAL((LR+2)*LR*(LL+1)*(LM+2)*LM,WP))+CLTM(1)
C
      CLTM(1)=VC1(II)*VC1(KK)*
     X           SQRT(DD1/DD2)*DC2*DL2*DDS*DC1/DL1+CLTM(1)
C
      IF(LR.NE.LL)GO TO 103
      IF(LM.LT.LL)GO TO 128
      LM=LL-2
      IF(LM.EQ.0)GO TO 128
C *** CLTM(1)=.......+CLTM(1)        TERM  LM=LL-2=LR-2
      DC1=-(LM+4)* LM
      DD1=(LM+5)*(LM+4)*15
      DD2=(LM+3)*(LM+2)* 2
      GO TO 129
  127 LP=8
      IF(MTEST2.NE.0)GO TO 150
  128 IF(ABS(MTEST1).GT.2)GO TO 103
C
  137 DL1=VCC(LL,ITWO,LR,-INT(QLML1,SP),MTEST1,-INT(QLML2,SP),DFS)
C
      IF(BMSKIP.AND..NOT.BE1CASE)GO TO 149
C
      DC1=VCC(ITWO,ITWO,ITWO,MTEST2,MTEST1,MCTO,DFS)
C
      IF(BE1CASE)GO TO 42  !************** ONE-BODY SWITCH *************
C
      DD1=SQRT(REAL(LAM,WP)/6)
      DD2=SQRT(REAL((LL+LR-2)*(LL+LR+6),WP)/24)*(M1*DD)          !M1<-MA
C     CLTM(2)=(DD1*M1-DD2)*DL1*DC1+CLTM(2)                       !M1<-MA
C     CLTM(3)=-(DD1*M2+DD2)*DL1*DC1+CLTM(3)                      !M2<-MC
      DD=(DD1*M1-DD2)*DL1*DC1*M2*DDS                      !M1<-MA,M2<-MC
      CLTM(3)=DD+CLTM(3)
      CLTM(2)=CLTM(2)-DD
      IF(MTEST2.NE.0)GO TO 150
  149 CLTM(8)=(MOD(ABS(INT(QLMS1+QLMS2,SP)),IFOUR)-1)*M2
     X        *SQRT(REAL(LAM/4,WP))*DL1                          !M2<-MC
  150 IF(MTEST1.NE.0)GO TO 126
      DD=DDS*DQ3
      CLTM(8)=CLTM(8)+DD
      IF(BMSKIP)GO TO 126
      CLTM(4)=CLTM(4)+DD/3
      CLTM(5)=CLTM(4)-DD
      IF(LL.NE.0)CLTM(1)=(LAM*DD)/12+CLTM(1)
C OUT IF(QN(ICG2).NE.QN(ICG1))  GO TO 126
      CLTM(6)=DD
  126 IF(BDEBUG)WRITE(6,104) CLTM(6),CLTM(8)
  103 MX=8
      KTERM=8
      CLTM(7)=CLTM(5)
      PHS0=(1-MOD((N1+N2)*2+QLMS1+QLMS2,IFOUR))*DDH
      GO TO 38
C
C ***************** BEGIN NON-BP MK (ONE-BODY) SECTION *****************
C
  42  IF(.NOT.BE1CASE)THEN               ! CASE MK
         DDV = VCC(LL,MLAM1,LR,IZERO,IZERO,IZERO,DFS)
         DD = DZERO
         LP=10
         KTERM = 9
         IF(DDV.EQ.DZERO)GO TO 55
         DDL = DZERO
         IF(QLMS2.EQ.QLMS1)THEN    ! CONTRIBUTION {C[K-1]XL[1]}[K]/DD1
           MMM = (MLAM-LL-LR)/2
           ISGN = 1-2*mod(abs(MMM),ITWO)
C                                                   !SJS: MLAM1,2 WRONG!
           DDL= VCC(LR,MLAM,LL,INT(QLML2,SP),MLK,INT(QLML1,SP),DFS)
     X        * SJS(LL,LR,MLAM,ITWO,MLAM1,LR,DFS)
     X        * SQRT(REAL((MLAM+1)*(LR+1)*LR/2*(LR/2+1),WP))
     X        * ISGN
         ENDIF                        ! PLUS {C[K-1] X (K+1)S[1]}[K]/DD1
C      WRITE(6,*)'L',LR,MLAM,LL,QLML2,MLK,QLML1,DDL
         MMM = (MLAM1-LL-LR)/2                 !-LL-LR
         ISGN = 1-2*mod(abs(MMM),ITWO)
         MQL = QLML1-QLML2
         MQS = QLMS1-QLMS2
         DDS = VCC(LR,MLAM1,LL,INT(QLML2,SP),MQL,INT(QLML1,SP),DFS)
     X       * VCC(IONE,ITWO,IONE,INT(QLMS2,SP),MQS,INT(QLMS1,SP),DFS)
     X       * VCC(MLAM1,ITWO,MLAM,MQL,MQS,MLK,DFS)
     X       * DQ3O4*(MLAMH+1)*ISGN
C      WRITE(6,*)'S',LR,MLAM1,LL,QLML2,MQL,QLML1,QLMS2,MQS,QLMS1,DDS
         DD=DDS+DDL
         IF(DD.NE.DZERO)THEN
           LP = 9
           CLTM(9) = 2*DD*DDV*SQRT(REAL(MLAMH*(MLAM-1),WP))/(MLAMH+1)
C
           DD=-DD*SQRT(REAL(MLAMH*(MLAM-1),WP))/((MLAMH+1)*(MLAM+1))
         ENDIF
C
         IF(MLAM.GT.MBP1MX.AND.IFOT12.eq.0)GO TO 33
C
  55     CONTINUE                            !LOOK FOR LAM+1 IF NO LAM-1
C
C      WRITE(6,*)MJ1,MJ2,LL,LR,QLML1,QLML2,QLMS1,QLMS2,MLAM2,MLAM,MLK
         DDV1 = VCC(LL,MLAM2,LR,IZERO,IZERO,IZERO,DFS)
         IF(ABS(DD)+ABS(DDV1).EQ.DZERO)GO TO 82
         IF(DDV1.EQ.DZERO)GO TO 33
         DDL1 = DZERO
         IF(QLMS2.EQ.QLMS1)THEN    ! CONTRIBUTION {C[K+1]XL[1]}[K]/DD1
           MMM = (MLAM-LL-LR)/2
           ISGN = 1-2*mod(abs(MMM),ITWO)
C                                                   !SJS: MLAM2,2 WRONG!
           DDL1= VCC(LR,MLAM,LL,INT(QLML2,SP),MLK,INT(QLML1,SP),DFS)
     X         * SJS(LL,LR,MLAM,ITWO,MLAM2,LR,DFS)
     X         * SQRT(REAL((MLAM+1)*(LR+1)*LR/2*(LR/2+1),WP))
     X         * ISGN
c      WRITE(6,*)'L1',LR,MLAM,LL,QLML2,MLK,QLML1,DDL1
         ENDIF                        ! PLUS {C[K+1] X (K+1)S[1]}[K]/DD1
         MMM = (MLAM2-LL-LR)/2                 !-LL-LR
         ISGN = 1-2*mod(abs(MMM),ITWO)
         MQL = QLML1-QLML2
         MQS = QLMS1-QLMS2
         DDS1=VCC(LR,MLAM2,LL,INT(QLML2,SP),MQL,INT(QLML1,SP),DFS)
     X       * VCC(IONE,ITWO,IONE,INT(QLMS2,SP),MQS,INT(QLMS1,SP),DFS)
     X       * VCC(MLAM2,ITWO,MLAM,MQL,MQS,MLK,DFS)
     X       * DQ3O4*MLAMH*ISGN
c      WRITE(6,*)'S1',LR,MLAM2,LL,QLML2,MQL,QLML1,QLMS2,MQS,QLMS1,DDS1
         DD1=(DDS1+DDL1)
         DD1=DD1*2*SQRT(REAL((MLAM+3)/(MLAMH+1),WP))/((MLAM+3)*(MLAM+1))
C
         DD=DD+DD1
         IF(DD.EQ.DZERO)GO TO 82
         KTERM=10
         CLTM(10)=DD*DDV1
C  N.B. VC12 ALREADY IN DDH, BUT COUPLED LSJ, NOT SLJ!
  33     PHS0 = DDH
     X    *(1-MOD((N1+N2)*2+MJL1+MJS1+MJJL+MJL2+MJS2+MJJR,IFOUR))
C      WRITE(6,*)MJ1,MJ2,LL,LR,QLML1,QLML2,QLMS1,QLMS2,MLAM2,MLAM,MLK
c      write(6,*)'lam=',mlam/2,'c9=',ddv,ddh,cltm(9)*phs0
      ELSE                           ! CASE E1VEL
        KTERM = 1
        II = (LL-LR+2)/4+LR
        if(ii.gt.nc0x)stop '*** sr.algeb4: vc1 not set' !temp
ct        mc0x=max(mc0x,ii)
        CLTM(1) = DC1*DDS*DL1*VC1(II)*SQRT(REAL(2*(MLAM+1),WP))
        PHS0 = M2 * DDH                               !M2<-MC
      ENDIF
C
C ****************** END NON-BP MK (ONE-BODY) SECTION ******************
C
C *** STORE ONE-BODY COEFFICIENTS ***
C
  38  IGAM(3)=MLAM
      DO 114 K=LP,KTERM
C
      DD=CLTM(K)*PHS0
      IF(DD.EQ.DZERO)  GO TO 114
      M1=ICG1                                         !M1<-MA
      M2=ICG2                                         !M2<-MC
      IF(ICG1.GE.ICG2)  GO TO 124
      IF(K/2.EQ.1)  GO TO 124
      M1=M2                                           !MA=MC
      M2=M2-ICG2+ICG1                                 !MC=MC-...
  124 MX=MX-1
C
      IGAM(1)=M1                                      !M1<-MA
      IGAM(2)=M2                                      !M2<-MC
      IGAM(4)=K
      IF(BPLANT1)
     X   IPLANT=(((IGAM(4)*1000+IGAM(3))*1000+IGAM(2))*MXORB)+IGAM(1)
      DO 72 J=IRLPS1,IRLPS
        IF(.NOT.BPLANT1)THEN
          DO I=4,1,-1
            IF(QRLPS(I,J).NE.IGAM(I))GO TO 72
          ENDDO
        ELSE
          IF(IPLANT.NE.JORIG1(J))GO TO 72
        ENDIF
        I=IORIG1(J)
        IF(I.GT.0)THEN
          DRKPS(I)=DRKPS(I)+DD
          GO TO 114
        ENDIF
        L=J
        GO TO 81
  72  ENDDO
C
C     CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C     MUST START CONSTRUCTING A NEW COEFFICIENT
C
      L=IRLPS+1
      IF(L.GT.IXS1I)THEN                                      !GO TO 493
C
        IXXX=7*(IXS1I/5+1)
C
        WRITE(6,*)'*** MKALG1: increasing MXS1I from ',IXS1I,' to: '
     X            ,IXXX
        WRITE(0,*)'*** MKALG1: increasing MXS1I from ',IXS1I,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC2(QRLPS,IONE,IFOUR,IONE,IXS1I,IFOUR,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR QRLPS'
          NF=0
          GO TO 90
        ENDIF
C
        IXXX0=MAX(IXS1I,IXSOI)
        IXXX1=MAX(IXXX,IXSOI)
        IF(IXXX1.GT.IXXX0)
     X  CALL RE_ALLOC(IORIG1,IONE,IXXX0,IXXX1,IERR)
        CALL RE_ALLOC(JORIG1,IONE,IXS1I,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR IORIG1,JORIG1'
          NF=0
          GO TO 90
        ENDIF
C
        IXS1I=IXXX
C
      ENDIF
C
      IRLPS=L
      DO I=1,4
        QRLPS(I,L)=IGAM(I)
      ENDDO
      IF(BPLANT1)JORIG1(L)=IPLANT
C
  81  IRKPS=IRKPS+1
      IF(IRKPS.GT.IXS1C)THEN                                  !GO TO 492
C
        IXXX=7*(IXS1C/5+1)
C
        WRITE(6,*)'*** MKALG1: increasing MXS1C from ',IXS1C,' to: '
     X            ,IXXX
        WRITE(0,*)'*** MKALG1: increasing MXS1C from ',IXS1C,' to: '
     X            ,IXXX
C
        CALL RE_ALLOC(DRKPS,IONE,IXS1C,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR DRKPS'
          NF=0
          GO TO 90
        ENDIF
C
        CALL RE_ALLOC(NRKPS,IONE,IXS1C,IXXX,IERR)
        CALL RE_ALLOC(NSTJ1,IONE,IXS1C,IXXX,IERR)
        CALL RE_ALLOC(NSTJ1D,IONE,IXS1C,IXXX,IERR)
C
        IF(IERR.NE.0)THEN
          WRITE(0,*)'MKALG1: REALLOCATION FAILS FOR NRKPS,NSTJ1'
          NF=0
          GO TO 90
        ENDIF
C
        IXS1C=IXXX
C
      ENDIF
C
      IORIG1(L)=IRKPS
      NRKPS(IRKPS)=L
      DRKPS(IRKPS)=DD
      NSTJ1(IRKPS)=L1
      NSTJ1D(IRKPS)=L2
C
  114 ENDDO
C
C *** END STORE OF ONE-BODY COEFFICIENTS ***
C
  82  IF(NK.EQ.0)  GO TO 88
C
C     NK.EQ.1 FOR STATES WHICH DIFFER IN ONE SET OF ONE-ELECTRON
C     QUANTUM NOS, THE NECESSARY TERM HAS ALREADY BEEN EVALUATED,
C     THEREFORE PROCEED TO NEXT PAIR OF SLATER STATES.
C
  69  IF(MXLL.NE.-1)  GO TO 65
      IF(MX.NE.0)  GO TO 65
      IF(IRKPS.GE.IRKPS0)  GO TO 39
C
C
  65  ENDDO                                             !END
C
  64  ENDDO                                             !END
C
C IF .T. RETURN AND COMPUTE FOR DIFFERENT MS,ML GIVING THE SAME MS+ML=MJ
C
  39  IF(BLX2) RETURN
C
      IF(BLX1) RETURN
C
C     INSERT ARRAY CLEARING PARAGRAPHS HERE (BLX1 AND BLX2)
C
  40  ICLR=0
      PHS0=(1-MOD(MJJR-MJ2,IFOUR))*SQRT(REAL(MLAM+1,WP))/DVC
C
      IF(IRKPS.LT.IRKPS0)  GO TO 15
C
C     IF THE MATRIX ELEMENT HAS BEEN CALCULATED CLEAR THE ARRAY  DRKPS
C       OF ZEROS AND ADJUST NRKPS.
C
      K=IRKPS0-1
      KP=0
C      IF(IRLPS0+1.NE.IRLPS1)STOP 'IRLPS ERROR'
      DO I=IRLPS1,IRLPS
      IORIG1(I)=0
      ENDDO
C
      DO 91 I=IRKPS0,IRKPS
      JD0=NRKPS(I)
      JD=ABS(JD0)
      IF(ABS(DRKPS(I)).GE.TYNY)   GO TO 97
      IF(IORIG1(JD).GT.0)GO TO 91
      JD0=0               !RE-INDEX QRLPS AS MAY OCCUR LATER
      GO TO 94
   97 K=K+1
      DRKPS(K)=DRKPS(I)*PHS0
      NSTJ1(K)=NSTJ1(I)
      NSTJ1D(K)=NSTJ1D(I)
C
  94  IF(JD.LE.IRLPS0)THEN
        WRITE(6,*)'MKALG1: INFORM NRB OF STOP HERE - 1',JD,IRLPS0
        WRITE(0,*)'MKALG1: INFORM NRB OF STOP HERE - 1'
        NF=-1
        GO TO 90
C      LP=JD
C      GO TO 92
      ENDIF
C
      IF(IORIG1(JD).EQ.0)THEN
      LP=JD-KP
      DO 95  L=1,IRLPS0
      DO 96  J=1,4
      IF(QRLPS(J,JD).NE.QRLPS(J,L))GO TO 95
  96  CONTINUE
      KP=KP+1
      IORIG1(JD)=L
      LP=L
      GO TO 92
  95  CONTINUE
      ELSE
      LP=IORIG1(JD)
      GO TO 92
      ENDIF
C
      IORIG1(JD)=LP
      DO 93  J=1,4
      QRLPS(J,LP)=QRLPS(J,JD)
  93  CONTINUE
C
  92  IF(JD0.EQ.0)GO TO 91
      NRKPS(K)=LP
C      IF(JD0.LT.0)NRKPS(K)=-NRKPS(K)
  91  CONTINUE
C
      IRLPS=IRLPS-KP
      IRKPS=K
C
C     SIMILARLY, CLEAR TWO-BODY ARRAYS
C
  15  IF(IRSS.LT.IRSS0)GO TO 90
C
      K=IRSS0-1
      KP=0
      DO I=NLS01,NLS
        IORIG2(I)=0
      ENDDO
C
      DO 391 I=IRSS0,IRSS
      JD0=MSSS(I)
      JD=ABS(JD0)
      IF(ABS(DSSS(I)).GE.TYNY)GO TO 397
      IF(IORIG2(JD).GT.0)GO TO 391
      JD0=0               !RE-INDEX QSSS AS MAY OCCUR LATER
      GO TO 394
 397  K=K+1
      DSSS(K)=DSSS(I)*PHS0
      NSTJ2(K)=NSTJ2(I)
      NSTJ2D(K)=NSTJ2D(I)
C
 394  IF(JD.LE.NLS00)THEN
        WRITE(6,*)'MKALG1: INFORM NRB OF STOP HERE - 2',JD,NLS00
        WRITE(0,*)'MKALG1: INFORM NRB OF STOP HERE - 2'
        NF=-1
        GO TO 90
C      LP=JD
C      GO TO 392
      ENDIF
C
      IF(IORIG2(JD).EQ.0)THEN
      LP=JD-KP
      DO 395  L=1,NLS00
      DO 396  J=1,5
      IF(QSSS(J,JD).NE.QSSS(J,L))GO TO 395
 396  CONTINUE
      KP=KP+1
      IORIG2(JD)=L
      LP=L
      GO TO 392
 395  CONTINUE
      ELSE
      LP=IORIG2(JD)
      GO TO 392
      ENDIF
C
      IORIG2(JD)=LP
      DO 393  J=1,5
      QSSS(J,LP)=QSSS(J,JD)
 393  CONTINUE
C
 392  IF(JD0.EQ.0)GO TO 391
      MSSS(K)=LP
C      IF(JD0.LT.0)MSSS(K)=-MSSS(K)
 391  CONTINUE
C
      NLS=NLS-KP
      IRSS=K
C
C
  90  RETURN
C
C     E R R O R   M E S S A G E S
C
 492  WRITE(6,992)
      GO TO 99
 493  WRITE(6,993)
      IRLPS=L
      GO TO 99
 494  WRITE(6,994)
      GO TO 99
 495  WRITE(6,995)
C
  99  WRITE(6,990)
C
      WRITE(0,*)'***SR.MKALG1: STORAGE EXCEEDED ***'
      NF=-1
C
      GO TO 90
C
  104 FORMAT(30X,1P,4E16.6,4I5)
  990 FORMAT(' ***SR.MKALG1: STORAGE EXCEEDED - INCREASE DIMENSION',
     X       ' INDICATED OR SWITCH-OFF MK OR BP RADIATIVE CORRECTIONS.')
  992 FORMAT(/' SR.MKALG1:   MXS1C TOO SMALL, ARRAYS DRKPS AND NRKPS')
  993 FORMAT(/' SR.MKALG1:   MXS1I TOO SMALL, ARRAYS DRLP1 AND QRLPS')
  994 FORMAT(/' SR.MKALG1:   MXS2C TOO SMALL, ARRAYS DSSS AND MSSS')
  995 FORMAT(/' SR.MKALG1:   MXS2I TOO SMALL, ARRAYS DNLS AND QSSS')
C  400 FORMAT(A1,59X,4I6,3(I7,F9.4)/(84X,3(I7,F9.4)))
  700 FORMAT(1X,I5,2X,2(I5,I4),I6)
C
      END SUBROUTINE MKALG1
C
C                             *******************
C
      SUBROUTINE MKALG2(mam,nam,KK)
C
C-----------------------------------------------------------------------
C
C  SR.MKALG2 APPLIES SLATER-STATE ALGEBRA TO INDIVIDUAL LEVELS FOR
C  RADIATIVE MK ALGEBRA, INCLUDING BP CORRECTIONS TO M1 AND E1VEL.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_COEFF,  ONLY: DRKP,QRLP,IRLP,NRKP,N81,IXSOC,IXSOI
     X                        ,IPLANT_SOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DMQSS3, ONLY: DSS,MSS,QSS,N82,IXRSS,IAXMI,IPLANT_MI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
      USE COMMON_NRBRN2, ONLY: BINDB
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.D-5)
      PARAMETER (DTOL=1.0D-8)
C
      CHARACTER(LEN=1) MP
C
      DIMENSION mam(*),nam(*)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,JGAP,ND1,NDP1,ND2,NDP2
      COMMON /CMKALG2/DVC,MJ1,MJ2,MLAM,BE1CASE
      COMMON /NXRLP/IRKP,IRKP0
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP1/MPRINT
      COMMON /NRBAL4/MBP1MX,MBP2MX,MEKVMX,KUTM1,MPOLM,QCUT
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
C
      DATA  MG/-2/,IRLP0/0/
C
      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
C
      BFAST=DC(0).LT.DZERO                 !ELSE OPT MEMORY
C
      BLPT=MPRINT.GT.0
      MLAMH=MLAM/2
C      EQUCFG=KF.EQ.KG
C
C BEGIN MAIN LOOP 165 OVER 1-BODY SLATER STATE INTERACTIONS
C
      N81=(NDP1-1)
C
      IF(IRLP.LE.0)THEN                 !FLAG END OF STRUCTURE INTEGRALS
        IRLP=-IRLP
        IRLP0=IRLP
      ENDIF
      IRLP11=IRLP
      IRLP1=IRLP0+1
      K0=NADS1(KK-1)+1
C
      DO J=1,IRLPS
        JORIG1(J)=0
      ENDDO
C
      DO KS=K0,NADS1(KK)
C
        L1=NSTJ1(KS)
        L2=NSTJ1D(KS)
C
        IF(BFAST)THEN
C
          DDH=DC(L1+ND2)*DC(L2+NDP2)*DRKPS(KS)
C
C          IF(EQUCFG.AND.L1.NE.L2)DDH=DDH+DC(L1+NDP2)
C                                        *DC(L2+ND2)*DRKPS(KS)
        ELSE
c
          m1=mam(l1)
          if(m1.eq.0)go to 165
c
          m2=nam(l2)
          if(m2.eq.0)go to 165
C
          DDH=DC(m1)*DC(m2)*DRKPS(KS)
C
C          IF(EQUCFG.AND.L1.NE.L2)then       !& suppress go to 165 above
C            m2=mam(l2)
C            m1=nam(l1)
C            if(m1*m2.gt.0)then
C              DDH=DDH+DC(m2)*DC(m1)*DRKPS(KS)
C            endif
C          endif
c
        ENDIF
C
        IF(ABS(DDH).LT.DTOL)GO TO 165
C
        N=NRKPS(KS)
        L=JORIG1(N)
C
        IF(L.GT.0)THEN
          K=IORIG1(L)
          DRKP(K)=DRKP(K)+DDH
        ELSE
C
C CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          L=IRLP+1
          IF(L.GT.IXSOI)THEN                                   !GO TO 93
C
            IXXX=7*(IXSOI/5+1)
C
            WRITE(6,*)'*** MKALG2: increasing MXSOI from ',IXSOI,' to: '
     X                ,IXXX
            WRITE(0,*)'*** MKALG2: increasing MXSOI from ',IXSOI,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRLP,IONE,IFOUR,IONE,IXSOI,IFOUR,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR QRLP'
              NF=0
              GO TO 900
            ENDIF
C
            IXXX0=MAX(IXS1I,IXSOI)
            IXXX1=MAX(IXS1I,IXXX)
            IF(IXXX1.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG1,IONE,IXXX0,IXXX1,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR IORIG1'
              NF=0
              GO TO 900
            ENDIF
C
            IXSOI=IXXX
C
            IF(IXSOI.GT.IPLANT_SOI)THEN
              WRITE(0,*)'MKALG2:I*4/SP TOO SHORT FOR 1-BODY M_K RAD'
              WRITE(6,*)'MKALG2:CHANGE TO I*8/EP IN MODULE COMMON_COEFF'
              NF=0
              GO TO 900
            ENDIF
C
          ENDIF
C
          IRKP=IRKP+1
          IF(IRKP.GT.IXSOC)THEN                                !GO TO 92
C
            IXXX=7*(IXSOC/5+1)
C
            WRITE(6,*)'*** MKALG2: increasing MXSOC from ',IXSOC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** MKALG2: increasing MXSOC from ',IXSOC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRKP,IONE,IXSOC,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR DRKP'
              NF=0
              GO TO 900
            ENDIF
C
            CALL RE_ALLOC(NRKP,IONE,IXSOC,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR NRKP'
              NF=0
              GO TO 900
            ENDIF
C
            IXSOC=IXXX
C
          ENDIF
C
          IRLP=L
          DO I=1,4
            QRLP(I,L)=QRLPS(I,N)
          ENDDO
          JORIG1(N)=L
          IORIG1(L)=IRKP
          NRKP(IRKP)=L
          DRKP(IRKP)=DDH
        ENDIF
C
  165 ENDDO
C
C CLEAR THE ARRAY DRKP OF ZEROS AND ADJUST NRKP ACCORDINGLY.
C
      IF(IRKP.LT.IRKP0)GO TO 200
      K=IRKP0-1
      N1=0
C
      DO I=IRKP0,IRKP
C
        IF(ABS(DRKP(I)).LT.TYNY)GO TO 190
C
        K=K+1
        DRKP(K)=DRKP(I)
        N2=INT(NRKP(I))
        LP=N2-N1
C
        DO L=IRLP1,IRLP11
          DO J=1,4
            IF(QRLP(J,N2).NE.QRLP(J,L))GO TO 194
          ENDDO
          LP=L
          GO TO 191
  194   ENDDO
C
        N1=N1-1
        DO J=1,4
          QRLP(J,LP)=QRLP(J,N2)
        ENDDO
C
  191   NRKP(K)=LP+N81*IPLANT_SOI                                 !MXSOI
C
        if(abs(mbp2mx).le.2)then
          ma=qrlp(1,lp)
          mc=qrlp(2,lp)
          mlamh=qrlp(3,lp)/2       !magnetic multipole
          mlamh=mlamh-1            !electric multipole integral required
          mn=min(ma,mc)
          mx=max(ma,mc)
          in=icol(mn,mx,izero)
c          write(6,*)'bindb:',in,ma,mc,mlamh
          if(abs(mbp2mx).lt.2)bindb(in,mlamh/2)=.true.
          if(abs(mbp2mx).eq.2)bindb(in,mlamh/2+1)=.true.
        endif
C
        IF(BLPT)THEN
          MP='M'
          IF(BE1CASE.and.QRLP(3,LP).eq.2)MP='E'
          MM=QRLP(3,LP)/2
          IF(ABS(MBP2MX).LT.2)THEN
            DD=DRKP(K)*DVC
            IF(MM.LT.10)THEN
              WRITE(6,700)K,ND1,NDP1,MA,MC,LP,DRKP(K),
     X                    DD,DVC,MJ1,MJ2,MP,MM,QRLP(4,LP)
            ELSE
              WRITE(6,701)K,ND1,NDP1,MA,MC,LP,DRKP(K),
     X                    DD,DVC,MJ1,MJ2,MP,MM,QRLP(4,LP)
            ENDIF
          ELSE
            IF(MM.LT.10)THEN
              WRITE(6,702)K,ND1,NDP1,(QRLP(J,LP),J=1,2),LP,DRKP(K)
     X                   ,MP,MM,QRLP(4,LP)
            ELSE
              WRITE(6,703)K,ND1,NDP1,(QRLP(J,LP),J=1,2),LP,DRKP(K)
     X                   ,MP,MM,QRLP(4,LP)
            ENDIF
          ENDIF
        ENDIF
C
  190   N1=N1+1
C
      ENDDO
C
      IRLP=IRLP-N1
      IRKP=K
C
C
C BEGIN MAIN LOOP 265 OVER 2-BODY SLATER STATE INTERACTIONS.
C
 200  CONTINUE
C
      N82=(NDP1-1)
C
      NL00=NL
      NL1=NL000+1
      K0=NADS2(KK-1)+1
C
      DO J=1,NLS
        JORIG2(J)=0
      ENDDO
C
      DO KS=K0,NADS2(KK)
C
        L1=NSTJ2(KS)
        L2=NSTJ2D(KS)
C
        IF(BFAST)THEN
C
          DDH=DC(L1+ND2)*DC(L2+NDP2)*DSSS(KS)
C
C          IF(EQUCFG.AND.L1.NE.L2)DDH=DDH+DC(L1+NDP2)
C                                        *DC(L2+ND2)*DSSS(KS)
        ELSE
c
          m1=mam(l1)
          if(m1.eq.0)go to 265
c
          m2=nam(l2)
          if(m2.eq.0)go to 265
C
          DDH=DC(m1)*DC(m2)*DSSS(KS)
C
C          IF(EQUCFG.AND.L1.NE.L2)then       !& suppress go to 265 above
C            m2=mam(l2)
C            m1=nam(l1)
C            if(m1*m2.gt.0)then
C              DDH=DDH+DC(m2)*DC(m1)*DSSS(KS)
C            endif
C          endif
c
        ENDIF
C
        IF(ABS(DDH).LT.DTOL)GO TO 265
C
        M=MSSS(KS)
        L=JORIG2(M)
        IF(L.GT.0)THEN
          K=IORIG2(L)
          DSS(K)=DSS(K)+DDH
        ELSE
C
C CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          L=NL+1
          IF(L.GT.IAXMI)THEN                                   !GO TO 95
C
            IXXX=7*(IAXMI/5+1)
C
            WRITE(6,*)'*** MKALG2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
            WRITE(0,*)'*** MKALG2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR QSS'
              NF=0
              GO TO 900
            ENDIF
C
            IXXX0=MAX(IXS2I,IAXMI)
            IXXX2=MAX(IXS2I,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR IORIG2'
              NF=0
              GO TO 900
            ENDIF
C
            IAXMI=IXXX
C
            IF(IAXMI.GT.IPLANT_MI)THEN
              WRITE(0,*)'MKALG2:I*4/SP TOO SHORT FOR 2-BODY M_K RAD'
             WRITE(6,*)'MKALG2:CHANGE TO I*8/EP IN MODULE COMMON_DMQSS3'
              NF=0
              GO TO 900
            ENDIF
C
          ENDIF
C
          IRS=IRS+1
          IF(IRS.GT.IXRSS)THEN                                 !GO TO 94
C
            IXXX=7*(IXRSS/5+1)
C
            WRITE(6,*)'*** MKALG2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
            WRITE(0,*)'*** MKALG2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR DSS'
              NF=0
              GO TO 900
            ENDIF
C
            CALL RE_ALLOC(MSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'MKALG2: REALLOCATION FAILS FOR MSS'
              NF=0
              GO TO 900
            ENDIF
C
            IXRSS=IXXX
C
          ENDIF
C
          NL=L
          DO K=1,5
           QSS(K,L)=QSSS(K,M)
          ENDDO
          JORIG2(M)=L
          IORIG2(L)=IRS
          MSS(IRS)=L
          DSS(IRS)=DDH
C
        ENDIF
C
 265  ENDDO
C
C CLEAR THE ARRAY DSS OF ZEROS AND ADJUST MSS(K) ACCORDINGLY.
C
      IF(IRS.LT.IRS0)GO TO 900
      K=IRS0-1
      KP=0
C
      DO I=IRS0,IRS
C
        IF(ABS(DSS(I)).LT.TYNY)GO TO 290
C
        K=K+1
        DSS(K)=DSS(I)
        JD=INT(MSS(I))
        LP=JD-KP
C
        DO L=NL1,NL00
          DO J=1,5
            IF(QSS(J,JD).NE.QSS(J,L))GO TO 294
          ENDDO
          LP=L
          GO TO 291
 294    ENDDO
C
        KP=KP-1
        DO J=1,5
          QSS(J,LP)=QSS(J,JD)
        ENDDO
 291    MSS(K)=LP+N82*IPLANT_MI                                   !MAXMI
C
 290    KP=KP+1
C
      ENDDO
C
      NL=NL-KP
      IRS=K
C
      IF(BLPT)THEN
        IF(IRS.GE.IRS0)THEN
          WRITE(6,400)ND1,NDP1,IRS,NL,(MSS(I)-N82*IPLANT_MI
     X               ,DSS(I),I=IRS0,IRS)
        ENDIF
      ELSE
        IF(MPRINT.EQ.-3) WRITE(6,704)IRKP,ND1,NDP1,MG,MG,IRLP,
     X                               ND1,NDP1,IRS,NL
      ENDIF
C
C
 900  RETURN
C
C E R R O R   M E S S A G E S
C
  92  WRITE(6,992)
      GO TO 99
  93  WRITE(6,993)
      IRLP=L
      GO TO 99
  94  WRITE(6,994)
      GO TO 99
  95  WRITE(6,995)
C
  99  WRITE(6,999)
      WRITE(6,704)  IRKP, ND1,NDP1, MG,MG, IRLP,
     X              ND1,NDP1,IRS,NL
C
      WRITE(0,*)'***SR.MKALG2: STORAGE EXCEEDED ***'
      NF=-1
C
      GO TO 900
C
  999 FORMAT(' ***SR.MKALG2: STORAGE EXCEEDED - INCREASE DIMENSION',
     X' INDICATED OR REDUCE/SWITCH-OFF MK OR BP RADIATIVE CORRECTIONS.')
  992 FORMAT(/' SR.MKALG2:   MXSOC TOO SMALL, ARRAYS DRKP AND NRKP')
  993 FORMAT(/' SR.MKALG2:   MXSOI TOO SMALL, ARRAYS DRLP1 AND QRLP')
  994 FORMAT(/' SR.MKALG2:   MXRSS TOO SMALL, ARRAYS DSS AND MSS')
  995 FORMAT(/' SR.MKALG2:   MAXMI TOO SMALL, ARRAYS DNL AND QSS')
  400 FORMAT(57X,2I6,I9,I6,3(I7,F9.4)/(84X,3(I7,F9.4)))
  700 FORMAT(I9,3I6,I4,I6, F13.5,2F19.5, 6X,2I4, 3X,A1,I1,I4)
  701 FORMAT(I9,3I6,I4,I6, F13.5,2F19.5, 6X,2I4, 3X,A1,I2,I3)
  702 FORMAT(I9,3I6,I4,I6, F13.5,3X,A1,I1,I4)
  703 FORMAT(I9,3I6,I4,I6, F13.5,3X,A1,I2,I3)
  704 FORMAT(I9,3I6,I4,I6,31X,2I6,I9,I6)
C
      END SUBROUTINE MKALG2
C
C***********************************************************************
C
      SUBROUTINE MULTS(Y,X,A,N)
C
C      ________________________________________________________
C     |                                                        |
C     |         SYMMETRIC MATRIX MULTIPLICATION: Y=AX          |
C     |                                                        |
C     |NRB: ADAPTED FROM SYMMETRIC MATRIX TIMES VECTOR: MULTSV |
C     |                                                        |
C     |    INPUT:                                              |
C     |                                                        |
C     |         A,X   --ARRAYS PACKED WITH ELEMENTS CONTAINED  |
C     |                 IN EACH ROW, ON DIAGONAL AND TO RIGHT, |
C     |                 OF COEFFICIENT MATRIX                  |
C     |                                                        |
C     |         N     --MATRIX DIMENSION                       |
C     |                                                        |
C     |    OUTPUT:                                             |
C     |                                                        |
C     |         Y     --PRODUCT BETWEEN A AND X    (PACKED)    |
C     |________________________________________________________|
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(*),X(*),Y(*)
C
      NN=N*(N+1)/2
      DO I=1,NN
        Y(I)=DZERO
      ENDDO
C
      LM=0
      DO M=1,N
C
      K=1
      L=0
      KM=1
      IF(N.EQ.1)GO TO 40
      DO J=2,M
        T=X(M+L)
        IM=LM
        DO I=M,N
          IM=IM+1
          Y(IM)=Y(IM)+T*A(I+L)
        ENDDO
        L=L+N-K
        K=J
      ENDDO
      LM=LM+N-M+1
      KM=K+L
      DO J=M+1,N
        T=X(KM)
        S=A(K+L)*T
        IM=KM
        DO I=J,N
          IM=IM+1
          R=A(I+L)
          S=S+R*X(IM)
          Y(IM)=Y(IM)+R*T
        ENDDO
        Y(KM)=Y(KM)+S
        L=L+N-K
        K=J
        KM=KM+1
      ENDDO
40    Y(KM)=Y(KM)+A(K+L)*X(KM)
C
      ENDDO
C
      RETURN
C
      END SUBROUTINE MULTS
C
C                             *******************
C
      SUBROUTINE MVDINT(K,DE,MRED,MAXPS)
C
C-----------------------------------------------------------------------
C
C  SR.MVDINT DETERMINES THE MASS-VELOCITY AND DARWIN INTEGRALS,
C  ALSO THE M1BP INTEGRALS D2LL, FOR ALL BOUND ORBITALS L.LE.K WHERE K
C  IS THE PRESENT ONE BEING DETERMINED.
C
C  IT CALLS:
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
      COMMON /COM6/DA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/DP(MAXB1),DERV1(MAXB1),DERV2(MAXB1),DQ(MAXB1)
C
      DZ=NZION
      BORT=MORT.LT.0
      BREL2=ABS(IREL).EQ.2
C
      bm1bp=NL.GE.NL000         !.eq. allows for .true. but no coeffs...
      tz=dzero
      dee=dzero
      if(.not.bm1bp)then
        igagr=-1
      else
        dza=nzion-mion+1+mred
        if(igagr.gt.0)tz=dza
      endif
      tt=dz-tz
C
C LOOP OVER ALL OTHER COMPUTED ORBITALS L.LE.K, FOR CURRENT ORBITAL K.
C
      DO L=1,K
C
      DD3=DZERO  !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
      DD2=DZERO
      DD1=DZERO
C
      IF(DEY(L).EQ.DZERO)GO TO 614                               !613
      IF(QL(L).NE.QL(K))GO TO 614               !check rad/diagfs 613
c      if(ql(k).ne.ql(l).and.(.not.bm1bp.or.igagr.lt.0))go to 614!613
      IF(BREL.AND..not.bm1bp)GO TO 614          !only radiative
C                            .AND.L.EQ.K .OR.BREL2
      IF(K.LE.ABS(MPSEUD))GO TO 614
C
      IF(BORT.AND..NOT.BREL)THEN
C        IF(MORT.EQ.-3.AND.BREL)GO TO 614
c
c        dee=dzero
c        if(igagr.gt.0.and.ql(l).ne.ql(k))dee=dey(l)-duy(l,l)
c        write(0,*) 'dqnl',dza,tz
c
        DO I=1,MAXPS
          DS=DZ/DX(I)
          DD3=DPNL(I,L)*(tt/dx(i)-dee)+DQNL(I,L)/DTWO
          DD4=DPNL(I,K)
          DA(I)=DD4*DD3
          DD3=DPNL(I,L)*DS+DQNL(I,L)/DTWO
          DD4=DD4*DS+DQNL(I,K)/DTWO
          DP(I)=DD4*DD3
        ENDDO
        GO TO 645
      ENDIF
C
      IF(BREL)THEN
c       write(0,*) 'rel',dza,tz
        DO I=1,MAXPS
          DA(I)=DPNL(I,L)*(DPOT(I)-tz/dx(i)+VSC(I))*DPNL(I,K)
        ENDDO
        IF(BREL2)THEN
          DO I=1,MAXPS
            DA(I)=DA(I)+DQNL(I,K)*(DPOT(I)-tz/dx(i)+VSC(I))*DQNL(I,L)
          ENDDO
        ENDIF
      ELSE
c       write(0,*) 'non-rel',dza,tz
        DO I=1,MAXPS
          DA(I)=DPNL(I,L)*(DPOT(I)-tz/dx(i)+VSC(I))*DPNL(I,K)
        ENDDO
        DS=DEY(L)-DUY(L,L)
        DO I=1,MAXPS
          T=DPOT(I)+VSC(I)
          DP(I)=DPNL(I,L)*(DE+T)*(DS+T)*DPNL(I,K)
        ENDDO
      ENDIF
C
  645 CALL WEDDLE(DD2,DA,DD3,MNH,DHNS,MJH,MAXPS)
C
      IF(L.EQ.K)DD3=DE+DD3
C
      IF(BREL              )GO TO 516
C            .AND..NOT.BORT
C
C CALCULATE VALUE OF THE INTEGRAND AT THE ORIGIN.
      IF(QL(K).EQ.0.AND..NOT.BREL)DD2=DORIG(K)*DORIG(L)*DZ*DZ
c
c      if(.not.brel)then           !test Darwin with small-r factor
c        call diff(dpnl(1,k),da,mnh,dhns,mjh)
c        call diff(dpot,derv1,mnh,dhns,mjh)
c        ds=dey(l)-duy(l,l)
c        de=dey(k)-duy(k,k)
cc        write(0,*)l,k,ds,de,dpot(maxps)*dx(maxps)
c        do i=1,maxps
c          da(i)=dpnl(i,l)*derv1(i)*(dpnl(i,k)/dx(i)-da(i))
c          t1=done+dalf*(de+dpot(i))/dtwo
c          t3=done+dalf*(ds+dpot(i))/dtwo
c          da(i)=da(i)/sqrt(t1*t3)
c        enddo
c        call weddle(dd2,da,ddd,mnh,dhns,mjh,maxps)
c      endif
C
      CALL WEDDLE(DD2,DP,DD1,MNH,DHNS,MJH,MAXPS)
C
      DD2=DD2*DALF/(DZ*DEIGHT)
c      dd2=-ddd*dalf/dfour           !test Darwin with small-r factor
  516 DD1=-DD1*DALF/DTWO
C
  614 DMASS(K,L)=DD1                      !N.B. SWAPPED DMASS, DCD ORDER
      DCD(K,L)=DD2
      D2LL(K,L)=2*DD3                           !M1BP RADIATIVE INTEGRAL
C
      ENDDO                           !END RELATIVISTIC CORRECTIONS !613
C
      RETURN
C
      END SUBROUTINE MVDINT
C
C                             *******************
C
      FUNCTION NCHAJK(KX,KIN,JGIN,LIN,NCJ,NTGJ,DFS)
C
C-----------------------------------------------------------------------
C
C  FN.NCHAJK:
C     SETS-UP THE JK-COUPLING CHANNEL LIST FOR JP SYMMETRY INDEX KX
C     AND RETURNS THE NUMBER OF CHANNELS.
C     (THIS IS MAINLY FOR INFO SINCE SR.DWXBP REPLICATES IT.)
C  IT CALLS:
C    FN.SJS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      INTEGER(SP) SA
C
      DIMENSION NTGJ(*),DFS(*)
C
      COMMON /BASIC/NF,NCHSJ,MGAP(10)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRJ/NSLJ(MAXSL,MAXJG),NGSLJ(MAXJG)     !target
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
C
      DATA MTJOLD/-1/,MTPOLD/-1/
C
      BPRNT0=JPRINT.NE.-3
C
      MTJ=JPI(KX)/10
      MTP=JPI(KX)-MTJ*10
      MTP=MTP+MTP
C
      BFIRST=MTJOLD.NE.MTJ.OR.MTPOLD.NE.MTP
C
      IF(BFIRST.AND.BPRNT0)WRITE(6,100)
C
      MTJOLD=MTJ
      MTPOLD=MTP
C
      INASTX=NCHGJ(KX)
C
      NCHJ=0
      nchsj=0
C
      KAY2=MTJ+1
      IF(MTJ.GT.0)THEN
        KAY1=MTJ-1
      ELSE
        KAY1=KAY2
      ENDIF
C
      DO KAY=KAY1,KAY2,2                            !LOOP OVER CHANNEL K
C
        BLASTK=KAY.EQ.KIN
C
        DO JIG=1,NJO                         !LOOP OVER TARGET JP GROUPS
C
          BLASTJ=BLASTK.AND.JIG.EQ.JGIN
C
          NC=NSLJ(1,JIG)
          JIP=QPI(NC)
          LV0=NTGJ(JIG)+1
          JI=JN(LV0)
          L1=ABS(KAY-JI)
          IF(MOD(JIP+L1,IFOUR).NE.MTP)L1=L1+2
          L2=KAY+JI
          IF(MOD(JIP+L2,IFOUR).NE.MTP)L2=L2-2
C
          NCN0=NGSLJ(JIG)
C
          DO LI=L1,L2,4                             !LOOP OVER CHANNEL L
C
            BLASTL=BLASTJ.AND.LI.EQ.LIN
C
            LV0=NTGJ(JIG)
            NCHI=0
C
            DO NC00=1,NCN0             !BEGIN LOOP OVER TARGET SL GROUPS
C
              NC=NSLJ(NC00,JIG)
              MC=NSL(NC)
              SA=QSI(NC)
              LA=QLI(NC)
              MCI=NGRPI(NC)
              BLS=.FALSE.
C
              DO IXX=1,INASTX                        !LOOP OVER LS SYMMS
C
                IX=JSYMM(IXX,KX)
                NCN=NCHG(IX)
C
                DO NC0=1,NCN                       !FIND TARGET SL GROUP
                  IF(NC.EQ.ITARG(NC0,IX))THEN        !MATCHED
                    LL1=LLCH(1,NC0,IX)
                    LL2=LLCH(2,NC0,IX)
                    IF(LI.LT.LL1.OR.LI.GT.LL2)GO TO 715
                    GO TO 720
                  ENDIF
                ENDDO
C
 715            CONTINUE
c                write(6,*)'NO CONTRIB. FROM LS SYM',IXX,' IX=',IX
                GO TO 750                       !SLP DOES NOT CONTRIBUTE
C
 720            IS=LSPI(IX)/10000
                IP=LSPI(IX)-IS*10000
                IL=IP/10
                IP=IP-IL*10
C
                IF(MTP.NE.IP+IP)STOP 'IXX ERROR'      !REMOVE
                MTS=IS-1
                MTL=IL+IL
C
                IF(KAY.LT.ABS(MTL-SA).OR.KAY.GT.MTL+SA)GO TO 750  !LAST
C
C               CHECK RECOUPLING COEFFICIENT (TRIANGLE SHOULD'VE CAUGHT)
C
                IF(BFIRST)THEN
C
                  S61=SJS(MTS,MTL,MTJ,KAY,IONE,SA,DFS)
c
c                  if(abs(s61).lt.1d-70)
c     x                              write(0,*)'1:',mts,mtl,mtj,kay,1,sa
c
                  S62=SJS(LA,LI,MTL,KAY,SA,JI,DFS)
c
c                  if(abs(s62).lt.1d-70)
c     x                               write(0,*)'2:',la,li,mtl,kay,sa,ji
c
                  S6=S61*S62
C
                  BLS=BLS.OR.ABS(S6).GT.1.D-70
                ELSE
                  BLS=.TRUE.
                  GO TO 800
                ENDIF
C
 750          ENDDO                              !END LOOP OVER LS SYMMS
C
 800          IF(BLS)THEN                    !THIS TARGET SL CONTRIBUTES
                LV=LV0
c                write(6,*)jig,ji,nc,jip
                DO MD1=1,MC                     !LOOP OVER TARGET LEVELS
                  IT=MD1+MCI
                  LV=LV+1
                  if(it.ne.nrr(lv))stop 'nchajk???'    !test
                  NCHJ=NCHJ+1
                  if(jndxj(lv).gt.0)nchsj=nchsj+1
                  IF(BFIRST.AND.BPRNT0)WRITE(6,101)NCHJ,LV,IT,LI/2,KAY
                  IF(BLASTL.AND.MD1+NCHI.EQ.NCJ)GO TO 900
                ENDDO                       !END LOOP OVER TARGET LEVELS
              ENDIF
C
              LV0=LV0+MC
              NCHI=NCHI+MC
C
            ENDDO                        !END LOOP OVER TARGET SL GROUPS
C
          ENDDO                                 !END LOOP OVER CHANNEL L
C
        ENDDO                            !END LOOP OVER TARGET JP GROUPS
C
      ENDDO                                     !END LOOP OVER CHANNEL K
C
 900  NCHAJK=NCHJ
C
      RETURN
C
 100  FORMAT(/9X,'CH',8X,'LV',9X,'T',5X,'SMALL L',6X,'2K')
 101  FORMAT(I11,I10,I10,I12,I8)
C
      END FUNCTION NCHAJK
C
C                             *******************
C
      SUBROUTINE NLAM(M0,K1,K2,K3,K4,K,DK)
C
C-----------------------------------------------------------------------
C
C  SR.NLAM EVALUATES THE N-INTEGRALS OF THE SPIN-ORBIT AND SPIN-SPIN
C  INTERACTIONS.
C
C  IT CALLS:
C    SR.DIFF
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      DZ=NZION
      DD=DONE
      D00=DZERO
      INUKP=INUK+1
C
      DO I=1,MAXRS
        DPA(I)=DPNL(I,K2)*DPNL(I,K4)
      ENDDO
C
      I=(QL(K2)+QL(K4))/2+2
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DEL=DE2-DE4                                   ! A.U.
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=INUKP,MAXRS
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
C            DD2=DONE+T*(DE2+POT(I,1))
C            DD4=DONE+T*(DE4+POT(I,1))
            D24=DD2*DD4
            d24=abs(d24)
            DPA(I)=DPA(I)/SQRT(D24)
          ENDDO
        ELSE
          DO I=INUKP,MAXRS
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c            dd2=done+t*(de2+dz/dx(i))
c            dd4=done+t*(de4+dz/dx(i))
            D24=DD2*DD4
            d24=abs(d24)
            DPA(I)=DPA(I)/SQRT(D24)
          ENDDO
          dd=dd*rnorm(k2)*rnorm(k4)
        ENDIF
        DO I=1,INUK
          DD2=DONE+T*(DE2+DNUK0(I))
          DD4=DONE+T*(DE4+DNUK0(I))
          DPA(I)=DPA(I)/SQRT(DD2*DD4)
        ENDDO
        CALL YLAMKR(K,I,DEL,DPA,DP,DD2,DD4,MNH,DHNS,MJH,M0)
      ELSE
        CALL YLAMK(K,I,DPA,DP,DD2,DD4,MNH,DHNS,MJH,M0)
      ENDIF
C
      DO I=1,MAXRS
        DP(I)=DP(I)*DPNL(I,K1)*DPNL(I,K3)
      ENDDO
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DEL=DE1-DE3                                   ! A.U.
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=INUKP,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
C            DD1=DONE+T*(DE1+POT(I,1))
C            DD3=DONE+T*(DE3+POT(I,1))
            D13=DD1*DD3
            d13=abs(d13)
            DP(I)=DP(I)/SQRT(D13)
          ENDDO
        ELSE
          DO I=INUKP,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            D13=DD1*DD3
            d13=abs(d13)
            DP(I)=DP(I)/SQRT(D13)
          ENDDO
          dd=dd*rnorm(k1)*rnorm(k3)
        ENDIF
        DO I=1,INUK
          DD1=DONE+T*(DE1+DNUK0(I))
          DD3=DONE+T*(DE3+DNUK0(I))
          DP(I)=DP(I)/SQRT(DD1*DD3)
        ENDDO
      ENDIF
C
      CALL WEDDLE(D00,DP,DKU,MNH,DHNS,MJH,MAXRS)
C
      DK=DKU*DD*DALF4
C
      RETURN
C
      END SUBROUTINE NLAM
C
C                             *******************
C
      SUBROUTINE NORMS(IR,H,L,F1,F2,F12,Y11,Y22,Y12,TM12,VMAX)
C
C-----------------------------------------------------------------------
C
C  SR.NORMS EVALUATES THE INTERGALS:
C  Y11=F1*F1, Y22=F2*F2, Y12=F1*F2 AND TM12=F1*F2*R**L,
C  USING SIMPSON'S RULE.
C  VMAX IS THE MAX VALUE OF THE INTEGRAND TM12.
C  A. BURGESS, DAMTP, CAMBRIDGE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (C1=1.85575D0)
      PARAMETER (C2=1.03315D0)
C
      DIMENSION F1(0:*),F2(0:*),F12(0:*)
C
      R=DZERO
      X=DZERO
      S1=DZERO
      S2=DZERO
      S=DZERO
      TM12=DZERO
C
      DO I=1,IR
        R=R+H
        P1=F1(I)
        P2=F2(I)
        F=P1*P2
        T=ABS(F)*R
        IF(T.GT.X)THEN
          X=T
          RM=R
        ENDIF
        F12(I)=F
        T=MOD(I,ITWO)+1
        S1=T*P1*P1+S1
        S2=T*P2*P2+S2
        T=T*F
        S=T+S
        TM12=TM12+T*R**L
      ENDDO
C
      T=DTWO*H/DTHREE
      Y11=T*S1
      Y22=T*S2
      Y12=T*S
      TM12=T*TM12
      X=L+DHALF
      T=X**(DONE/DTHREE)
      VMAX=(C1*T+C2/T+X)*DHALF/RM
C
      RETURN
C
      END SUBROUTINE NORMS
C
C                             *******************
C
      SUBROUTINE NUMERO(XA,XB,Y,IND,N,XY)
C
C-----------------------------------------------------------------------
C
C  SR.NUMERO INTEGRATES SCHRODINGER EQUATION (WITH POTENTIAL POT)
C  USING REDUCED NUMEROV (G=0, D.R. HARTREE: NUMERICAL ANALYSIS P.142)
C  A SECOND ORDER DIFFERENTIAL EQUATION Y2=F(X)*Y+G(X) FROM
C  XA TO XB IN NSTEPS.  THE VALUES F,Y,G FOR THE FIRST 2 POINTS
C  ARE TO BE GIVEN IN F(2),F(3),Y(2),Y(3),G(2),G(3). THE VALUES AT
C  THE N POINTS XA+I*DX I=1,N ARE WRITTEN INTO XY(I),I=1,N.
C  E =EBOUND/RY FOR BOUND, =(K*A0)**2 FOR FREE WAVES; LL=L*(L+1).
C
C  IT CALLS:
C    FN.PMVDAR
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION Y(3),F(3),IND(3),XY(N)
C
      COMMON /COM1/POT(MAXB1),DTOL,IEND
      COMMON /COM3/E,ZN,TLL
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      DX=(XB-XA)/N
      X=XA
      DO I=2,3
        IF(IND(1).EQ.0)THEN                  !NOT USED BY AS
C          A=DTWO*ZN/X
          stop 'sr.numero: case ind(1)=0 commented-out'
        ELSE
          INDEX2=IND(I)
          A=DTWO*(POT(INDEX2)+VSC(INDEX2))
          IF(BREL)A=A+PMVDAR(INDEX2,X)
        ENDIF
        F(I)=TLL/X**2-A-E
        X=X+DX
      ENDDO
C
      D12=DX*DX/DTWELV
      D56=DTEN*D12
      XY(1)=Y(3)
C
      DO I=2,N
        F(1)=F(2)
        F(2)=F(3)
        Y(1)=Y(2)
        Y(2)=Y(3)
C
C        IF(IND(1).EQ.0)THEN                 !NOT USED BY AS
C          A=DTWO*ZN/X
C        ELSE
C
          INDEX2=IND(1)+INDEX2
          A=DTWO*(POT(INDEX2)+VSC(INDEX2))
          IF(BREL)A=A+PMVDAR(INDEX2,X)
C
CC          IND(2)=IND(3)                    !NOT NEEDED/USED BY AS
CC          IND(3)=INDEX2
C        ENDIF
C
        F(3)=TLL/X**2-A-E
        A=DONE-D12*F(3)
        D=(DTWO+D56*F(2))*Y(2)
        C=(DONE-D12*F(1))*Y(1)
        Y(3)=(D-C)/A
        XY(I)=Y(3)
        X=X+DX
      ENDDO
C
      RETURN
C
      END SUBROUTINE NUMERO
C
C                             *******************
C
      SUBROUTINE NUMSYM(JTOT,JPAR,JCUNT0)
C
C-----------------------------------------------------------------------
C
C  SR.NUMSYM
C     DETERMINES THE LSP SYMMETRIES WHICH CONTRIBUTE TO THE INPUT J,P.
C  IF JCOUNT
C    =0 IT RETURNS THE NUMBER OF LSP
C    >0 IT SEARCHES THE INAST LSPI SYMMETRIES IN /NRBLS/ AND FLAGS
C       ANY THAT ARE NOT PRESENT IN THE INAST.
C    <0 IT EXTENDS THE INAST LSPI SYMMETRY LIST FOR ANY NOT PRESENT.
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
C
      SAVE QSMIN,QSMAX
      DATA IFIRST/0/
C
C MAX TARGET LS IS IN QCL0,QCS0
C
      IF(IFIRST.EQ.0)THEN                       !DETERMINE MIN,MAX TOT S
        QSMIN=999
        DO I=1,NSL0
          IF(QSI(I).LT.QSMIN)QSMIN=QSI(I)
        ENDDO
        QSMIN=ABS(QSMIN-1)
        QSMAX=QCS0+1
        IFIRST=1
      ENDIF
C
      JCOUNT=JCUNT0
      BTEST1=JCUNT0.NE.0
      IF(BTEST1)JCOUNT=0
      BTEST2=JCUNT0.LT.0
C
      DO MTS=QSMIN,QSMAX,2
        QLMIN=ABS(JTOT-MTS)
        QLMAX=JTOT+MTS
        DO MTL=QLMIN,QLMAX,2                     !RANGE OF LTOT FOR JTOT
          IL=MTL/2
          DO N=1,NSL0
            IF(ABS(QSI(N)-MTS).gt.1)GO TO 60
            if(il.gt.maxlx.and.qsi(n).gt.mts)go to 60                !nx
            LMIN=ABS(QLI(N)-MTL)
            LMAX=QLI(N)+MTL
            DO L=LMIN,LMAX,2
              LP=(L+QPI(N))/2
              IF(MOD(LP,ITWO).EQ.JPAR)THEN             !WE HAVE A WINNER
                JCOUNT=JCOUNT+1
                IF(BTEST1)THEN                           !SEE IF PRESENT
                  LSPIT=10000*(MTS+1)+IL*10+JPAR
                  DO K=1,INAST
                    IF(LSPIT.EQ.LSPI(K))GO TO 100
                  ENDDO
                  IF(BTEST2)THEN
                    INAST=INAST+1
                    LSPI(INAST)=LSPIT
                  ELSE
                    WRITE(6,*)'*** MISSING SYM   (2S+1)  L  P='
     X                        ,MTS+1,IL,JPAR,'  FOR 2J P =',JTOT,JPAR
                    WRITE(0,*)'*** MISSING SYM   (2S+1)  L  P='
     X                        ,MTS+1,IL,JPAR,'  FOR 2J P =',JTOT,JPAR
                    ENDIF
                  ENDIF
                  GO TO 100
                ENDIF
              ENDDO
  60      ENDDO
 100    ENDDO
      ENDDO
C
      IF(.NOT.BTEST2)JCUNT0=JCOUNT
C
      RETURN
C
      END SUBROUTINE NUMSYM
C
C                             *******************
C
      FUNCTION PHASEX(E,C,Q,U,L,Z,X)
C
C-----------------------------------------------------------------------
C
C  N.R.BADNELL D.A.M.T.P. CAMBRIDGE
C
C  FN.PHASEX CALCULATES THE PHASE ASSOCIATED WITH A MODIFIED COULOMB
C  POTENTIAL -2Z/X -C/X**2 -Q/X**3 -U/X**4  (Z<0)
C  L .GE. 0, L DENOTES NON-RELATIVISTIC ANG. MOM.
C  L .LT. 0, A.M.=-(L+1) I.E. L=KAPPA (J=A.M.+DHALF)
C            RELATIVISTIC COULOMB PHASE, ASSUMES E,C,Z
C            CONTAIN THE MODIFIED COULOMB POTENTIAL.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP) Q
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (DFIFTN=15.0D0)
      PARAMETER (D24=24.0D0)
c      PARAMETER (D8TH=0.125D0)
C
      PI=ACOS(-DONE)
      EL=L
      ZZ=Z*Z
      CK=SQRT(E)
      XK=X*CK
      XZ=X*Z
      C1=XK*XK-XZ-XZ-C
      IF(C1.LT.D1M10)THEN
        WRITE(6,100)E,C,Q,U,L,Z,X
C
        PHASEX=DQUART*PI
        RETURN
      ENDIF
C
      CHI=SQRT(C1)
      IF(CHI.LT.DFIVE)WRITE(6,101)E,C,Q,U,L,Z,X,CHI
C
      PHI=DZERO
      C1=DONE/CHI
      P=CHI-D8TH*C1
C
      IF(ABS(Z)+ABS(C).GT.D1M15)THEN
        D=E*C+ZZ
        A=ZZ*(CHI-XK)-CK*C*Z
        P=P-(A/(D24*D*(CHI+XK))+DFIVE*(XZ+C)*C1*C1/D24)*C1
      ENDIF
C
      IF(E.LT.D1M10)THEN
        P=P+CHI
      ELSE
        A=Z/CK
        P=P+A*(DONE-LOG(CHI+XK-A))
      ENDIF
C
      IF(L.LT.0)THEN                          !RELATIVISTIC
        T=SQRT(DONE+DALF*E)
        T=DTWO*(T-DONE)/DALF
        Z0=Z/(DONE+DHALF*DALF*T)
        G=-EL+DHALF*DALF*Z0*Z0/EL
        ETA=DZERO
        IF(E.GT.D1M10)ETA=ATAN(Z0/(CK*EL))+ATAN(Z/(CK*G))
        ETA=ETA*DHALF
        EL=G-DONE
        P=P+ETA
      ENDIF
C
      IF(E.LT.D1M10)THEN
        P=P-(EL+DQUART)*PI
      ELSE
        P=P-DHALF*EL*PI+ARGAM(EL,A)
      ENDIF
C
      IF(L.EQ.-1111)THEN                    !TEST RELATIVISTIC S-ORBITAL
        C1=SQRT(-C)
        T=DFSC*Z0
        IF(ABS(C1+T).GT.DALF)THEN
          WRITE(6,102)C,Z0
          WRITE(0,102)C,Z0
          PHASEX=DZERO
          RETURN
        ENDIF
        T0=CHI+XK
        T1=DONE+T0*DALF/(DTWO*X)
        T2=DONE+DALF*CK
        Y=DTWO*T1/(T2*T0)
      ELSEIF(C.LT.-D1M10)THEN
        C1=SQRT(-C)
        T1=C1*CHI-C-XZ
        T2=C1*XK-XZ
        Y=LOG(T1/T2)/C1
      ELSE
C
        IF(C.LT.D1M10)THEN
          T0=CHI+XK
          IF(ABS(Q).GT.D1M15)PHI=Q*(T0+XK)/(DTHREE*X*T0**2)
          IF(ABS(U).GT.D1M15)PHI=PHI+U*(DNINE*XK*CHI+DELEVN*XK*XK
     X                              -DSIX*XZ)/(DFIFTN*X*X*T0**3)
C
          PHASEX=P+DONE/(DFOUR*(CHI+XK))+PHI
          RETURN
C
        ENDIF
C
        T=CK*C*CHI+ZZ*X+C*Z
        T1=(ZZ+E*C)*X
        Y=ACOS(T/T1)/SQRT(C)
C
      ENDIF
C
      IF(ABS(Q).GT.D1M15)PHI=Q*((XZ+XZ+C)/(X*(CHI+XK))-Z*Y)/C
      IF(ABS(U).GT.D1M15)THEN
        T1=DTHREE*Z*(XZ+XZ+C)/(X*(CHI+XK))+C*CHI/(X*X)
        PHI=PHI+U*(Y*(DTHREE*ZZ+E*C)-T1)/(DTWO*C*C)
      ENDIF
C
      PHASEX=P+(C+D8TH)*Y+PHI/DTWO
      RETURN
C
  100 FORMAT('*** FAILED IN PHASEX:  E=',1PE10.2,' C=',1PE10.2,' Q=',
     X1PE10.2,' U=',1PE10.2,' L=',I3,' Z=',1PE10.2,' X=',1PE10.2)
  101 FORMAT('*** INACCURACY IN PHASEX FOR E=',1PE10.2,' C=',1PE10.2,
     X' Q=',1PE10.2,' U=',1PE10.2,' L=',I3,' Z=',1PE10.2,' X=',1PE10.2,
     X'CHI=',1PE10.2)
  102 FORMAT('*** FAILED IN PHASEX FOR RELATIVISTIC S-ORBITAL:' ,
     X' C=',1PE10.2,' Z=',1PE10.2)
C
      END FUNCTION PHASEX
C
C                             *******************
C
      FUNCTION PMVDAR(J,X)
C
C-----------------------------------------------------------------------
C
C  FN.PMVDAR EVALUATES THE MASS-VELOCITY AND DARWIN POTENTIALS
C  AT RADIAL COORDINATE X(J).
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /COM1/POT(MAXB1),ZDUM,IEND
      COMMON /COM3/E,DZ,ELLP           !,EQ,ZQ,CQ
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/DPT0(MAXB1),DERV1(MAXB1),DERV2(MAXB1),DPT3(MAXB1)
C
C
      TKAP=-DONE                          !(2J+1)-WEIGHTED KAPPA-AVERAGE
      IF(KAPPA.NE.0)TKAP=KAPPA
C
      if(j.lt.0)then                                !Darwin only (asymp)
        t=dz/x                                            !dz=asymp here
        dv1=-t/x
        dv2=-dtwo*dv1/x
        t=e+dtwo*t
        tt=done+dquart*dalf*t
        tt=done/tt
        if(kappa.eq.0)then
          a=-tt*(dv1*d3qrt*dalf*tt*dv1)
        else
          a=tt*(dv1*(-dtwo*tkap/x-d3qrt*dalf*tt*dv1)+dv2)
        endif
        pmvdar=dquart*dalf*a
        return
      endif
C
C MASS-VELOCITY
C
      IF(E.LT.DZERO)T=E+DTWO*POT(J)            !HISTORIC POT DIFF E<,>=0
      IF(E.GE.DZERO)T=E+POT(J)+DTWO*DZ/X                !DZ=nuclear here
      T=T+DTWO*VSC(J)                                   !+PLASMA POT
C
C DARWIN
C
c      w=done                                           !standard Darwin
c      if(kappa.ne.0)w=-2.                         !see also radwav/fcf6
c
      TT=DONE+DQUART*DALF*T
      TT=DONE/TT
      A=TT*(DERV1(J)*(-DTWO*TKAP/X-D3QRT*DALF*TT*DERV1(J))+DERV2(J))
c
c      a=tt*(derv1(j)*(-dtwo*tkap/x-(w+dtwo)*dalf*tt*derv1(j)/dfour)
c     x     +derv2(j))*w
c
c      if(kappa.ne.0)then
c        l=sqrt(ellp)
c        a=-(2*l)*a                          !c.f. bound case correction
c      endif
C
      PMVDAR=DQUART*DALF*(T*T+A)
C
      RETURN
C
      END FUNCTION PMVDAR
C
C                             *******************
C
      SUBROUTINE PNL(IR,H,L,X,P,JMAX,F)
C
C-----------------------------------------------------------------------
C
C  SR.PNL INTERPOLATES THE INPUT RADIAL FUNCTION P(X) TO OUTPUT F(Y)
C  FOR SUBSEQUENT USE BY SR.ROMB AND SR.FILON.
C  A. BURGESS DAMTP CAMBRIDGE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (J0=1)
C
      DIMENSION X(J0:*),P(J0:*),F(0:*)
C
      FLAGR(X1,X2,X3,X4,Z1,Z2,Z3,Z4,Z) =
     X   ((Z-X2)*(Z-X3)*(Z-X4)/((X1-X2)*(X1-X3)*(X1-X4)))*Z1
     X + ((Z-X1)*(Z-X3)*(Z-X4)/((X2-X1)*(X2-X3)*(X2-X4)))*Z2
     X + ((Z-X1)*(Z-X2)*(Z-X4)/((X3-X1)*(X3-X2)*(X3-X4)))*Z3
     X + ((Z-X1)*(Z-X2)*(Z-X3)/((X4-X1)*(X4-X2)*(X4-X3)))*Z4
C
      R=DZERO
      F(0)=DZERO
      M=L+1
      J=J0
      DO I=1,IR
        R=R+H
    1   IF(R.GT.X(J).AND.J.LT.JMAX)THEN
          J=J+1
          GO TO 1
        ENDIF
        IF(J.LT.3)THEN
          Y1=P(1)/X(1)**M
          Y2=P(2)/X(2)**M
          Y3=P(3)/X(3)**M
          T=FLAGR(DZERO,X(1),X(2),X(3),DZERO,Y1,Y2,Y3,R)*R**M
        ELSE
          IF(J.LT.JMAX)THEN
            T=FLAGR(X(J-2),X(J-1),X(J),X(J+1),P(J-2)
     X             ,P(J-1),P(J),P(J+1),R)
          ELSE
            T=P(J)*EXP((X(J)-R)*LOG(P(J-1)/P(J))/(X(J)-X(J-1)))
          ENDIF
        ENDIF
        F(I)=T
      ENDDO
C
      RETURN
C
      END SUBROUTINE PNL
c
c                             *******************
c
      subroutine pomrecv(nomt,omv,nr,omx)
c
c-----------------------------------------------------------------------
c
c sr.pomrecev transfers a slice of a vector (omv) to omega matrix (omx)
c where the slice may include part of a column.
c
c-----------------------------------------------------------------------
c
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
c
      real(rp) omx(*),omv(*)
c
      do n=1,nomt
        nr=nr+1
        omx(nr)=omv(n)
      enddo
c
      return
c
      end subroutine pomrecv
c
c                             *******************
c
      subroutine pomsend(ns,omx,nomt,omv)
c
c-----------------------------------------------------------------------
c
c sr.pomsend transfers a slice of omega matrix (omx) to a vector (omv)
c where the slice may include part of a column.
c
c-----------------------------------------------------------------------
c
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
c
      real(rp) omx(*),omv(*)
c
      do n=1,nomt
        ns=ns+1
        omv(n)=omx(ns)
      enddo
c
      return
c
      end subroutine pomsend
C
C                             *******************
C
      SUBROUTINE POTIN(Z,MIONX,MK,MPOT,X,POT,MEND)
C
C-----------------------------------------------------------------------
C
C  SR.POTIN READS EXTERNAL POTENTIAL AND INTERPOLATES ONTO INTERNAL GRID
C   ATTEMPTS TO ADJUST NORMALIZATION BY EXAMINING LARGE R.
C   (CANNOT CHECK R=0 SINCE MAY BE FINITE NUCLEUS.)
C   SINCE NO STANDARD FORMAT EXISTS, ADJUST IT AS NEEDED.
C   CURRENT DEFAULT IS POTIN='FAC', SET IN NAMELIST SMINIM.
C  N.B. MIONX CAN IN PRINCIPAL BE N- (SR.RADIAL) OR N+1 (SR.RADCON).
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD14=100)
C
      ALLOCATABLE :: XIN(:),PIN(:),KHLP(:)
C
      DIMENSION POT(*),X(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C
      DATA MHFR/9/
C
      IF(IUNIT(MHFR).EQ.0)THEN
        WRITE(6,*)"MISSING INPUT FILE='hffcin/potin'..."
        WRITE(0,*)'MISSING FILE ON UNIT=9'
        GO TO 999
      ENDIF
C
      REWIND(MHFR)
C
      IF(MHF.EQ.2.OR.MHF.EQ.3)THEN
        IBUFIN=2*MPOT                                  !INPUT BUFFER
        ALLOCATE (XIN(IBUFIN),PIN(IBUFIN))
        ALLOCATE (KHLP(MPOT))
      ENDIF
C
      TOLH=D1M2
C
C DETERMINE INITIAL ASYMPTOTIC CHARGE
C
c      N=MIONX
      ZN=1-MIONX
      ZN=Z+ZN
      ZN1=ZN
      IF(NINT(ZN1).EQ.0)ZN1=DONE
C
      IF(MHF.EQ.1)THEN
C
C  USE ORIGINAL AS GRID (STILL SO FOR TF)
C
        READ(MHFR,*)MPIN
        IF(MPIN.GT.MPOT)MPIN=MPOT
        DO J=1,MPIN
          READ(MHFR,*)POT(J)
          T=POT(J)*X(J)-ZN
          IF(ABS(T/ZN1).GT.TOLH)MEND=J
        ENDDO
        L=MPIN+1
        GO TO 6
C
      ELSEIF(MHF.EQ.2)THEN
C
C FAC (UNIQUE)
C
        DO J=1,IBUFIN
          READ(MHFR,*,END=80)ICARD,XXX,DUMZ,PPP              !FAC FORMAT
          XIN(J)=XXX
          PIN(J)=PPP
          PIN(J)=PIN(J)*XIN(J)              !COMMENT OUT IF R*V(R) INPUT
        ENDDO
C
   80   MPIN=J-1
C
      ELSEIF(MHF.EQ.3)THEN
C
C NL-DEPENDENT
C
   77   READ(MHFR,*,END=998)MPIN,MYN,MYL
C
        IF(MYN.NE.QN(MK).OR.MYL*2.NE.QL(MK))THEN
C
          DO I=1,MPIN
            READ(MHFR,*)
          ENDDO
C
          GO TO 77
C
        ELSE
C
          MHLP=-1                               !SINCE WE WANT TO RETURN
C
          IF(MPIN.GT.IBUFIN)MPIN=IBUFIN
          DO I=1,MPIN
            READ(MHFR,*)XIN(I),PIN(I)
            PIN(I)=PIN(I)*XIN(I)            !COMMENT OUT IF R*V(R) INPUT
          ENDDO
C
        ENDIF
C
      ELSE
        WRITE(0,*)'***SR.POTIN: ILLEGAL INPUT VALUE FOR MHF'
        WRITE(6,*)'***SR.POTIN: ILLEGAL INPUT VALUE FOR MHF: ',MHF
        GO TO 999
      ENDIF
C
C CHECK NORM
C
      PNORM=PIN(MPIN)/ZN
      INORM=NINT(PNORM)
      IF(ABS(PNORM-REAL(INORM,WP)).GT.D1M1.or.inorm.eq.0)THEN
        WRITE(6,1004)PIN(MPIN)
        WRITE(0,1004)PIN(MPIN)
        GO TO 999
      ENDIF
C
C HELP INTERPOLATE
C
      II=1
      DO K=1,MPOT
        KHLP(K)=0
        GO TO 82
  81    II=II+1
  82    IF(II.GT.MPIN)GO TO 85
        IF(II.EQ.MPIN)GO TO 84
        IF(XIN(II+1)+XIN(II).LT.X(K)*DTWO)GO TO 81
  84    IF(X(K).GT.XIN(MPIN))GO TO 81
        KHLP(K)=II
  85  ENDDO
C
C LAGRANGE INTERPOLATION (NLAG+1 POINTS) FROM ARGUMENTS XIN TO X
C
      NLAG=4
C
      DO L=1,MPOT
        IF(X(L).GT.XIN(MPIN))GO TO 6
        DD1=DZERO
        M=KHLP(L)-NLAG/2
        I1=MAX(M,IONE)
        I2=I1+NLAG
        IF(I2.GT.MPIN)I2=MPIN
        DO I=I1,I2
          DD=DONE
          DM=DONE
          DO J=I1,I2
            IF(J.NE.I)THEN
              DM=(X(L)-XIN(J))*DM
              DD=(XIN(I)-XIN(J))*DD
            ENDIF
          ENDDO
          DD1=PIN(I)*DM/DD+DD1
        ENDDO
        DD1=DD1*PNORM
c        j=khlp(l)
c        write(6,1005)l,x(l),j,i1,i2,xin(j),dd1
c 1005 format(5x,i4,e14.7,14x,3i4,2e14.7)
        POT(L)=DD1/X(L)
        T=DD1-ZN
        IF(ABS(T/ZN1).GT.TOLH)MEND=L
      ENDDO
C
C FILL THE REMAINING POTENTIAL AS A COULOMB POTENTIAL
C
    6 DO J=L,MPOT
        POT(J)=ZN/X(J)
      ENDDO
C
  300 IF(ALLOCATED(KHLP))DEALLOCATE (KHLP,XIN,PIN)
C
      RETURN
C
  998 NF=0                                            !NOT FOUND
      GO TO 300
C
  999 NF=-1
      GO TO 300
C
 1004 FORMAT(' *** SR.STOPOT: UNABLE TO DETERMINE NORM OF EXTERNAL'
     X           ,' POTENTIAL, R*V=',F8.2)
C
      END SUBROUTINE POTIN
C
C                     *******************
C
      SUBROUTINE PQ(NCHLT,RHO,TP,TQ,WORK,NF)
C
C-------------------------------------------------------------------
C
C  SR.PQ DETERMINES THE P AND Q MATRICES, WHICH ARE RELATED
C    TO THE REAL AND IMAGINARY PARTS OF THE T-MATRIX BY
C      T=-2(P+I*Q), I=SQRT(-1)
C    USING THE FULL RHO-MATRIX,
C      P=-RHO^2/(1+RHO^2)
C      Q=RHO/(1+RHO^2)
C    I.E. THE S-MATRIX IS UNITARY
C  N.B. STGICF SR.TMTRIX DETERMINES -TR=P AND TI=Q
C       STGF SR.PQ DETERMINES P=Q AND Q=-P
C    THIS IS THE NON-LAPACK VERSION
C    IT REQUIRES NO ADDITIONAL INTERNAL MEMORY
C
C  IT CALLS:
C    SR.MULTS
C    SR.VERTS
C
C-------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION RHO(*),TP(*),TQ(*),WORK(*)
C
      CALL MULTS(TP,RHO,RHO,NCHLT)
C
      N=1
      DO J=NCHLT,1,-1
        TP(N)=TP(N)+DONE
        N=N+J
      ENDDO
C
      CALL VERTS(TP,-NCHLT,NCHLT,WORK,IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(6,1004)
        WRITE(0,*) '***SR.PQ: NO INVERSE FOUND'
        NF=-1
        GO TO 700
      ENDIF
C
      CALL MULTS(TQ,RHO,TP,NCHLT)
C
      N=1
      DO J=NCHLT,1,-1
        TP(N)=TP(N)-DONE
        N=N+J
      ENDDO
C
 700  RETURN
C
 1004 FORMAT(' ***SR.PQ: THE MATRIX: 1 + K^2 HAS NO INVERSE'
     X  ,' - MUST ABORT')
C
      END SUBROUTINE PQ
C
C                     *******************
C
      SUBROUTINE PQLAP(NCHLT,RHO,TP,TQ,WORK,NF)
C
C-------------------------------------------------------------------
C
C  SR.PQ DETERMINES THE P AND Q MATRICES, WHICH ARE RELATED
C    TO THE REAL AND IMAGINARY PARTS OF THE T-MATRIX BY
C      T=-2(P+I*Q), I=SQRT(-1)
C    USING THE FULL RHO-MATRIX,
C      P=-RHO^2/(1+RHO^2)
C      Q=RHO/(1+RHO^2)
C    I.E. THE S-MATRIX IS UNITARY.
C  N.B. STGICF SR.TMTRIX DETERMINES -TR=P AND TI=Q
C       STGF SR.PQ DETERMINES P=Q AND Q=-P
C    THIS IS THE LAPACK VERSION
C    IT IS A MEMORY HOG
C
C  IT CALLS:
C    SR.DGEMM
C    SR.DSYTRF
C    SR.DSYTRI
C    SR.DSYTRS
C
C-------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION RHO(*),TP(*),TQ(*),WORK(*)
C
      ALLOCATABLE :: TEMP(:),TEMP2(:),IPIVOT(:)
C
      NCHSQ=NCHLT*NCHLT
C
      ALLOCATE (TEMP(NCHSQ),TEMP2(NCHSQ),IPIVOT(NCHLT)
     X        ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*) 'SR.PQLAP: ALLOCATION FAILS FOR TEMP'
        NF=0
        RETURN
      ENDIF
C
      N=0
      NI=0
      NJ0=0
      DO J=1,NCHLT
        NJ=NJ0+J
        DO I=J,NCHLT
          N=N+1
          NI=NI+1
          TEMP(NI)=RHO(N)
          TEMP(NJ)=RHO(N)
          NJ=NJ+NCHLT
        ENDDO
        NI=NI+J
        NJ0=NJ0+NCHLT
      ENDDO
CLC                                                              !LAPACK
CL      CALL DGEMM('N','N',NCHLT,NCHLT,NCHLT,DONE,TEMP           !LAPACK
CL     X           ,NCHLT,TEMP,NCHLT,DZERO,TEMP2,NCHLT)          !LAPACK
C
      N=0
      DO I=1,NCHLT
        N=N+1
        TEMP2(N)=TEMP2(N)+DONE
        N=N+NCHLT
      ENDDO
CLC                                                              !LAPACK
CL      CALL DSYTRF('L',NCHLT,TEMP2,NCHLT,IPIVOT,WORK,NCHLT      !LAPACK
CL     X           ,INFO)                                        !LAPACK
CLC                                                              !LAPACK
CL      IF(INFO.NE.0)THEN                                        !LAPACK
CL        WRITE(6,602)INFO                                       !LAPACK
CL        WRITE(0,*)                                             !LAPACK
CL     X       'SR.PQLAP: FAILURE IN LAPACK ROUTINE DSYTRF'      !LAPACK
CL        NF=-1                                                  !LAPACK
CL        GO TO 700                                              !LAPACK
CL      ENDIF                                                    !LAPACK
CLC                                                              !LAPACK
CL      CALL DSYTRS('L',NCHLT,NCHLT,TEMP2,NCHLT,IPIVOT,TEMP      !LAPACK
CL     X           ,NCHLT,INFO)                                  !LAPACK
CLC                                                              !LAPACK
CL      IF(INFO.NE.0)THEN                                        !LAPACK
CL        WRITE(6,603)INFO                                       !LAPACK
CL        WRITE(0,*)                                             !LAPACK
CL     X       'SR.PQLAP: FAILURE IN LAPACK ROUTINE DSYTRS'      !LAPACK
CL        NF=-1                                                  !LAPACK
CL        GO TO 700                                              !LAPACK
CL      ENDIF                                                    !LAPACK
CLC                                                              !LAPACK
CL      CALL DSYTRI('L',NCHLT,TEMP2,NCHLT,IPIVOT,WORK,INFO)      !LAPACK
CLC                                                              !LAPACK
CL      IF(INFO.NE.0)THEN                                        !LAPACK
CL        WRITE(6,604)INFO                                       !LAPACK
CL        WRITE(0,*)                                             !LAPACK
CL     X       'SR.PQLAP: FAILURE IN LAPACK ROUTINE DSYTRI'      !LAPACK
CL      ENDIF                                                    !LAPACK
C
      N=0
      DO I=1,NCHLT
        N=N+1
        TEMP2(N)=TEMP2(N)-DONE
        N=N+NCHLT
      ENDDO
C
      N=0
      NI=0
      DO J=1,NCHLT
        DO I=J,NCHLT
          N=N+1
          NI=NI+1
          TP(N)=TEMP2(NI)
          TQ(N)=TEMP(NI)
        ENDDO
        NI=NI+J
      ENDDO
CLC                                                              !LAPACK
CL  700 CONTINUE                                                 !LAPACK
C
      DEALLOCATE (TEMP,TEMP2,IPIVOT,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*) 'SR.PQLAP: DEALLOCATION FAILS FOR TEMP'
        NF=0
      ENDIF
C
      RETURN
CLC                                                              !LAPACK
CL  602 FORMAT(//10X,10('*'),                                    !LAPACK
CL     X' SR.PQLAP: DSYTRF RETURNED WITH INFO =',I6)             !LAPACK
CL  603 FORMAT(//10X,10('*'),                                    !LAPACK
CL     X' SR.PQLAP: DSYTRS RETURNED WITH INFO =',I6)             !LAPACK
CL  604 FORMAT(//10X,10('*'),                                    !LAPACK
CL     X' SR.PQLAP: DSYTRI RETURNED WITH INFO =',I6)             !LAPACK
C
      END SUBROUTINE PQLAP
c
c                             *******************
c
      subroutine pcasym(iam,nproc)
c
c-----------------------------------------------------------------------
c
c *** parallel *** may only be called by the parallel version.
c
c sr.pcasym distributes l-symmetries over the nproc processors
c by defining local inast, l-values, based on the global
c value. attempts to load balance exchange and non-exchange,
c in the case of inast.le.0. up to user in case of inast.gt.0.
c there is no allowance for scaling from one-l to the other
c since at best there is likely to be a few l per-processor.
c
c only called in ca-coupling.
c - see psymls for ls-coupling.
c - see psymj for lsj-coupling.
c
c-----------------------------------------------------------------------
c
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
c
C      INCLUDE './INCLUDE'
c
      COMMON /BASIC/NF,MGAP(2),J1,J2,J1P,J2P,ND1,NDP1,LL(2),MAXLX0
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
c
c inast=inast0 here
c
      if(inast0.gt.0)then
c
c just extract an iam subset of pre-defined global lspi
c
        lmin=1
        lrange=inast0                             !global
        if(nproc.gt.lrange)then
          write(6,*)'too many processors for specified inast,'
     x             ,' use nproc=',lrange
          if(iam.eq.0)write(0,*)
     x               'too many processors for specified inast'
          nf=-1
          go to 999
        endif
        lperproc=lrange/nproc
        lxtra=lrange-lperproc*nproc
c
        lmin=lmin+iam*lperproc+min(lxtra,iam)
        lmax=lmin+lperproc-1
        if(iam.lt.lxtra)lmax=lmax+1
        write(0,*)iam,lmin,lmax
c
c shift down global lspi symms to form local
c
        i=0
        do l=lmin,lmax
          i=i+1
          lspi(i)=lspi(l)
        enddo
        inast=i                                   !local
c
      else
c
c set-up a global set of lspi and then extract an iam subset
c (not the most elegant way of doing it, perhaps, but makes
c  it easier to play around with the local distribution
c  because the complete global distribution is present to
c  select from. of course, at the end of the day, each lspi
c  must be selected once.)
c
c defaults (see/sync. sr.casym)
C n.b.exchange settings redundant here for ca since no x/nx partition...
c
        if(mxlamx.eq.1000)then                   !max exchange multipole
          if(maxlx.ge.100)then
cx            mxlamx=nxll+3                  !twice max orb l+3 (was +1)
            mxlamx=nxll/2+nmulte-1           !nmulte=no. lambdas:  gefgw
          else
c            mxlamx=(maxlx+1)/2
            mxlamx=maxlx-nxll/2
          endif
        endif
c        if(maxlx.ge.100)maxlx=2*mxlamx              !max l for exchange
        if(maxlx.ge.100)maxlx=mxlamx+nxll/2          !max l for exchange
ct      if(maxlx.lt.maxlt+2)then      !ca only for comparison with ls/bp
ct        maxlx=max(maxlx,QCL0/2-1)   !need all channels to scale direct
ct      endif
        maxlx0=maxlx                               !pass thru to caflglx
c
        if(lvmax.ge.0)then                                !bthrsh=.true.
c
          maxl=lvmax+QCL0/2
          if(maxlt.eq.1000)maxlt=maxl
          if(maxlt.gt.maxl)then
            write(6,1007)
            write(6,1008)maxl,lvmax
            write(6,1007)
            maxlt=maxl
          elseif(maxlt.lt.maxl)then
            write(6,1007)
            write(6,1009)maxlt,lvmax,maxl
            write(6,1007)
c            maxlt=maxl                       !allow user to restrict...
          endif
c
          minl=lvmin-QCL0/2
          minl=max(izero,minl)
          if(minlt.gt.minl)then
            write(6,1007)
            write(6,1010)minlt,lvmin,minl
            write(6,1007)
c            minlt=minl                       !allow user to restrict...
          elseif(minlt.lt.minl)then
            write(6,1007)
            write(6,1011)minl,lvmin
            write(6,1007)
            minlt=minl
          endif
c
        else
c
          if(maxlt.eq.1000)maxlt=30
          if(maxlt.gt.100)maxlt=100
          if(minlt.lt.0)minlt=0
c
        endif
c
        if(lrglam.gt.maxlt)then
          lrglam=-1                                        !so no top-up
        else
          if(lrglam.eq.-999)lrglam=maxlt
        endif
        if(lrglam.eq.0)lrglam=-1
c
c global no. symms,
c   check dimension & if too many processors assigned.
c
        lrange=maxlt-minlt+1
c
        if(lrange.gt.maxsl)then
          write(6,194)lrange
          write(0,194)lrange
          go to 999
        endif
c
        if(nproc.gt.lrange)then
          write(6,*)'too many processors for l-symmetries,'
     x             ,' use nproc=',lrange
          if(iam.eq.0)write(0,*)'too many processors for l-symmetries'
          nf=-1
          go to 999
        endif
c
c attempt to balance low- and high-l, case more l's than proc's.
c
        ngrpl=nproc              ! =nproc, or =1 for sequential l
c
c assign global exchange lsp
c
        i=0
        do n=0,ngrpl-1
          il0=minlt+n
          do il=il0,maxlt,ngrpl
            i=i+1
            lspi(i)=il
          enddo
        enddo
c
        if(lrange.ne.i)then
          if(iam.eq.0)write(0,*)'ca l:',lrange,i
          nf=-1
          go to 999
        endif
        inast0=i                                  !global
c
c shift down global lspi symms to form local
c
        lperproc=lrange/nproc
        lxtra=lrange-lperproc*nproc
c
        lmin=1
        lmin=lmin+iam*lperproc+min(lxtra,iam)
        lmax=lmin+lperproc-1
        if(iam.lt.lxtra)lmax=lmax+1
c        write(0,*)iam,lmin,lmax
c
        i=0
        do l=lmin,lmax
          i=i+1
          lspi(i)=lspi(l)
c          write(0,*)iam,i,lspi(i)
        enddo
        inast=i                                   !local
c
      endif
c
      inast0=inast                                !re-sync.
c
 999  return
c
  194 format('***sr.pcasym: too many symmetries, increase maxsl',
     x              ' to:',i4)
 1007 format(//1x,136('-')//)
 1008 format(/' note: reducing maxlt to',i3,', that needed by lvmax='
     x,i3)
 1009 format(/' ***warning: you have set maxlt=',i3,', less than that'
     x,' formally needed by lvmax=',i3/22x,'set maxlt=',i3
     x,', to satisfy triangle relation')
 1010 format(/' ***warning: you have set minlt=',i3,', greater that'
     x,' formally needed by lvmin=',i3/22x,'set minlt=',i3
     x,', to satisfy triangle relation')
 1011 format(/' note: increasing minlt to',i3,', that needed by lvmin='
     x,i3)
c
      end subroutine pcasym
C
C                             *******************
C
      SUBROUTINE POTF(ZN,NPOINT,X,POT,TOL,IEND)
C
C-----------------------------------------------------------------------
C
C  SR.POTF CALCULATES THE R-MATRIX PARAMETRIC POTENTIAL.
C   DEFINED IN CPC 92,290(1995) EQS (79) & (80) BUT *NOT* (81)
C   BUT IS ASYMPTOTIC TO ZN/R, NOT 2*ZN/R.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION POT(*),X(*)
C
      COMMON /PARPOT/CPOT(6),XPOT(6),IPOT(6),NPOT
C
      DTOL=TOL
      IF(ZN.GT.DZERO)DTOL=DTOL*ZN
C
      IEND=1
      DO I=1,NPOINT
        P=DZERO
        DO K=1,NPOT
          P=CPOT(K)*X(I)**IPOT(K)*EXP(-XPOT(K)*X(I)) + P
        ENDDO
c        write(6,*)x(i),p,p*x(i)
        P=P/2                                          !AS RM 2V
        IF(ABS(P*X(I)-ZN).GT.DTOL)IEND=I
        POT(I)=P
      ENDDO
C
      RETURN
C
      END SUBROUTINE POTF
c
c                             *******************
c
      subroutine psymj(iam,nproc)
c
c-----------------------------------------------------------------------
c
c *** parallel *** may only be called by the parallel version.
c
c sr.psymj distributes jp symmetries over the nproc processors
c by defining local inastj, jpi values, based on the global
c values. attempts to load balance 2-body fine-structure with rest,
c in the case of inast.le.0. up to user in case of inast.gt.0.
c all lspi values that are needed for the jpi on each processor
c are calculated independently by said processor. there is no
c read of a common calculated set from disk (currently).
c
c only called in lsj-coupling.
c - see psymls for ls-coupling.
c
c-----------------------------------------------------------------------
c
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
c
C      INCLUDE './INCLUDE'
c
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
c
c inastj=inastj0 here
c
      if(inastj0.gt.0)then
c
c just extract an iam subset of pre-defined global jpi
c
        jmin=1
        jrange=inastj0                             !global
        if(nproc.gt.jrange)then
          write(6,*)'too many processors for specified inastj,'
     x             ,' use nproc=',jrange
          if(iam.eq.0)write(0,*)
     x               'too many processors for specified inastj'
          nf=-1
          go to 999
        endif
        jperproc=jrange/nproc
        jxtra=jrange-jperproc*nproc
c
        jmin=jmin+iam*jperproc+min(jxtra,iam)
        jmax=jmin+jperproc-1
        if(iam.lt.jxtra)jmax=jmax+1
        write(0,*)iam,jmin,jmax
c
c shift down global jpi symms to form local
c
        i=0
        do j=jmin,jmax
          i=i+1
          jpi(i)=jpi(j)
        enddo
        inastj=i                                   !local
c
      else
c
c set-up a global set of jpi and then extract an iam subset
c (not the most elegant way of doing it, perhaps, but makes
c  it easier to play around with the local distribution
c  because the complete global distribution is present to
c  select from. of course, at the end of the day, each jpi
c  must be selected once.)
c
c defaults (lsp & jp - see/sync. sr.symls/j)
c
        if(inast0.le.0)then
c          if(maxlt.eq.1000)maxlt=30
c          if(maxlt.gt.100)maxlt=100
          if(minlt.lt.0)minlt=0
          if(minsp.lt.1)minsp=1
          i1=mod(INT(QCS0,SP),ITWO)
          i0=mod(minsp-1,itwo)
          if(i0.eq.i1)minsp=minsp+1
          maxsp=min(maxsp,INT(QCS0+2,SP))
        endif
c
        ipar=abs(ipar)
        ipar=mod(ipar,ithree)
        ip0=mod(ipar,itwo)
        ip1=min(ipar,ione)
        ipart=max(ione,ipar)
c
        if(maxjt.gt.200)maxjt=60
        if(minjt.lt.0)minjt=0
        mtest=mod(int(QCS0,sp),ITWO)
        if(mod(minjt,itwo).eq.mtest)minjt=minjt+1
        if(mod(maxjt,itwo).eq.mtest)maxjt=maxjt-1
        if(mod(maxjfs,itwo).eq.mtest)maxjfs=maxjfs-1
c
        if(lrglam.gt.maxjt)then
          lrglam=-1                                        !so no top-up
        else
          if(lrglam.eq.-999)lrglam=maxjt
        endif
        if(lrglam.eq.0)lrglam=-1
c
        jfs=min(maxjfs,maxjt)
        jj=max(minjt,maxjfs+2)
c
c global no. symms,
c   check dimension & if too many processors assigned.
c
        jrngfs=max(ipart*(jfs-minjt+2)/2,izero)
        jrng=max(ipart*(maxjt-jj+2)/2,izero)
        jrange=jrngfs+jrng
c
        if(jrange.gt.maxjg)then
          write(6,194)jrange
          write(0,194)jrange
          go to 999
        endif
c
        if(nproc.gt.jrange)then
          write(6,*)'too many processors for jp symmetries,'
     x             ,' use nproc=',jrange
          if(iam.eq.0)write(0,*)'too many processors for jp symmetries'
          nf=-1
          go to 999
        endif
c
c assign global fine-structure jpi
c (want same parity and adjacent j on same processor so as to minimize
c  the ls recomputation.)
c
        i=0
            do ip=ip0,ip1
        do ij=minjt,jfs,2
              i=i+1
              jpi(i)=10*ij+ip
            enddo
        enddo
c
        if(jrngfs.ne.i)then
          write(6,*)'sr.psymj: mis-match fine-structure j:',jrngfs,i
          if(iam.eq.0)write(0,*)'sr.psymj: mis-match fine-structure j'
          nf=-1
          go to 999
        endif
        inastj0=i                                  !global
c
c shift down global jpi symms to form local
c
        jrange=jrngfs
        jperproc=jrange/nproc
        jxtra=jrange-jperproc*nproc
c
        jmin=1
        jmin=jmin+iam*jperproc+min(jxtra,iam)
        jmax=jmin+jperproc-1
        if(iam.lt.jxtra)jmax=jmax+1
c        write(6,*)iam,jmin,jmax
c
        i=0
        do j=jmin,jmax
          i=i+1
          jpi(i)=jpi(j)
        enddo
        inastj=i                                   !local
c
c assign global ordinary jpi
c
        i=inastj0
            do ip=ip0,ip1
        do ij=jj,maxjt,2
              i=i+1
              jpi(i)=10*ij+ip
            enddo
        enddo
c
        if(jrng.ne.i-inastj0)then
          if(iam.eq.0)write(0,*)'ordinary j:',jrng,i-inastj0
          nf=-1
          go to 999
        endif
        inastj0=i                                  !global
c
c shift down global jpi symms to form local
c
        jrange=jrng
        jperproc=jrange/nproc
        jxtra=jrange-jperproc*nproc
c
        jmin=jrngfs+1
        jmin=jmin+iam*jperproc+min(jxtra,iam)
        jmax=jmin+jperproc-1
        if(iam.lt.jxtra)jmax=jmax+1
c        write(6,*)iam,jmin,jmax
c
        i=inastj
        do j=jmin,jmax
          i=i+1
          jpi(i)=jpi(j)
        enddo
        inastj=i                                   !local
c
      endif
c
      inastj0=inastj                               !re-sync.
c
c now, given the jp set on each processor, we need to assign all of the
c necessary local lsp. since currently there is no passing file, and we
c don't want to message pass the ls algebra (!), this means lsp symmetry
c algebra is being multiplicated. however, since the jk-coupling problem
c is an order of magnitude more demanding than the ls-coupling one, this
c may not be critical. eventually, will code a restartx file(s), along
c the lines of the target algebra restart file. then, each processor can
c read the appropriate lsp symmetry data it needs for its jp.
c
      jcount=-1
      inast=0
      do i=1,inastj
        ij=jpi(i)/10
        ipj=jpi(i)-ij*10
        call numsym(ij,ipj,jcount)
      enddo
      inast0=inast                                 !re-sync.
c
 999  return
c
  194 format('***sr.psymj: too many symmetries, increase maxjg',
     x              ' to:',i4)
c
      end subroutine psymj
c
c                             *******************
c
      subroutine psymls(iam,nproc)
c
c-----------------------------------------------------------------------
c
c *** parallel *** may only be called by the parallel version.
c
c sr.psymls distributes lsp symmetries over the nproc processors
c by defining local inast, lspi values, based on the global
c values. attempts to load balance exchange and non-exchange,
c in the case of inast.le.0. up to user in case of inast.gt.0.
c there is no allowance for scaling from one-l to the other
c since at best there is likely to be a few l per-processor.
c
c only called in ls-coupling.
c - see psymj for lsj-coupling.
c
c-----------------------------------------------------------------------
c
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
c
C      INCLUDE './INCLUDE'
c
      COMMON /BASIC/NF,MGAP(11)
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
c
c inast=inast0 here
c
      if(inast0.gt.0)then
c
c just extract an iam subset of pre-defined global lspi
c
        lmin=1
        lrange=inast0                             !global
        if(nproc.gt.lrange)then
          write(6,*)'too many processors for specified inast,'
     x             ,' use nproc=',lrange
          if(iam.eq.0)write(0,*)
     x               'too many processors for specified inast'
          nf=-1
          go to 999
        endif
        lperproc=lrange/nproc
        lxtra=lrange-lperproc*nproc
c
        lmin=lmin+iam*lperproc+min(lxtra,iam)
        lmax=lmin+lperproc-1
        if(iam.lt.lxtra)lmax=lmax+1
        write(0,*)iam,lmin,lmax
c
c shift down global lspi symms to form local
c
        i=0
        do l=lmin,lmax
          i=i+1
          lspi(i)=lspi(l)
        enddo
        inast=i                                   !local
c
      else
c
c set-up a global set of lspi and then extract an iam subset
c (not the most elegant way of doing it, perhaps, but makes
c  it easier to play around with the local distribution
c  because the complete global distribution is present to
c  select from. of course, at the end of the day, each lspi
c  must be selected once.)
c
c defaults (see/sync. sr.symls)
c
        if(mxlamx.eq.1000)then                   !max exchange multipole
          if(maxlx.ge.100)then
            mxlamx=nxll+3                    !twice max orb l+3 (was +1)
          else
c            mxlamx=(maxlx+1)/2
            mxlamx=maxlx-nxll/2
          endif
        endif
c        if(maxlx.ge.100)maxlx=2*mxlamx              !max l for exchange
        if(maxlx.ge.100)maxlx=mxlamx+nxll/2          !max l for exchange
        maxlx=max(maxlx,INT(QCL0/2-1,SP))  !all channels to scale direct
c
        if(maxloo.ge.100)maxloo=maxlx
c
        if(lvmax.ge.0)then                                !bthrsh=.true.
c
          maxl=lvmax+QCL0/2
          if(maxlt.eq.1000)maxlt=maxl
          if(maxlt.gt.maxl)then
            write(6,1007)
            write(6,1008)maxl,lvmax
            write(6,1007)
            maxlt=maxl
          elseif(maxlt.lt.maxl)then
            write(6,1007)
            write(6,1009)maxlt,lvmax,maxl
            write(6,1007)
c            maxlt=maxl                       !allow user to restrict...
          endif
c
          minl=lvmin-QCL0/2
          minl=max(izero,minl)
          if(minlt.gt.minl)then
            write(6,1007)
            write(6,1010)minlt,lvmin,minl
            write(6,1007)
c            minlt=minl                       !allow user to restrict...
          elseif(minlt.lt.minl)then
            write(6,1007)
            write(6,1011)minl,lvmin
            write(6,1007)
            minlt=minl
          endif
c
        else
c
          if(maxlt.eq.1000)maxlt=30
          if(maxlt.gt.100)maxlt=100
          if(minlt.lt.0)minlt=0
c
        endif
c
        if(lrglam.gt.maxlt)then
          lrglam=-1                                        !so no top-up
        else
          if(lrglam.eq.-999)lrglam=maxlt
        endif
        if(lrglam.eq.0)lrglam=-1
c
        if(minsp.lt.1)minsp=1
        i1=mod(INT(QCS0,SP),ITWO)
        i0=mod(minsp-1,itwo)
        if(i0.eq.i1)minsp=minsp+1
        maxsp=min(maxsp,INT(QCS0+2,SP))
c
        ipar=abs(ipar)
        ipar=mod(ipar,ithree)
        ip0=mod(ipar,itwo)
        ip1=min(ipar,ione)
        ipart=max(ione,ipar)
c
        qsrngx=(maxsp-minsp+2)/2
        lx=min(maxlx,maxlt)
        if(minsp.eq.1)then
          is1=3
          is2=max(ithree,maxsp)
        else
          is1=minsp
          is2=maxsp
        endif
        qsrngnx=(is2-is1+2)/2
        lnx=max(minlt,maxlx+1)
c
c global no. symms,
c   check dimension & if too many processors assigned.
c
        lrngx=max(ipart*(lx-minlt+1)*qsrngx,izero)
        lrngnx=max(ipart*(maxlt-lnx+1)*qsrngnx,izero)
        lrange=lrngx+lrngnx
c
        if(lrange.gt.maxsl)then
          write(6,194)lrange
          write(0,194)lrange
          go to 999
        endif
c
        if(nproc.gt.lrange)then
          write(6,*)'too many processors for lsp symmetries,'
     x             ,' use nproc=',lrange
          if(iam.eq.0)write(0,*)'too many processors for lsp symmetries'
          nf=-1
          go to 999
        endif
c
c attempt to balance low- and high-l, case more l's than proc's.
c
        ngrpl=nproc              ! =nproc, or =1 for sequential l
c
c assign global exchange lsp
c
        i=0
        do n=0,ngrpl-1
          il0=minlt+n
          do il=il0,lx,ngrpl
            do is=minsp,maxsp,2
              do ip=ip0,ip1
                i=i+1
                lspi(i)=10000*is+10*il+ip
              enddo
            enddo
          enddo
        enddo
c
        if(lrngx.ne.i)then
          if(iam.eq.0)write(0,*)'exchange:',lrngx,i
          nf=-1
          go to 999
        endif
        inast0=i                                  !global
c
c shift down global lspi symms to form local
c
        lrange=lrngx
        lperproc=lrange/nproc
        lxtra=lrange-lperproc*nproc
c
        lmin=1
        lmin=lmin+iam*lperproc+min(lxtra,iam)
        lmax=lmin+lperproc-1
        if(iam.lt.lxtra)lmax=lmax+1
c        write(6,*)iam,lmin,lmax
c
        i=0
        do l=lmin,lmax
          i=i+1
          lspi(i)=lspi(l)
        enddo
        inast=i                                   !local
c
c assign global non-exchange lsp
c
        i=inast0
        do il=lnx,maxlt
          do is=is1,is2,2
            do ip=ip0,ip1
              i=i+1
              lspi(i)=10000*is+10*il+ip
            enddo
          enddo
        enddo
c
        if(lrngnx.ne.i-inast0)then
          if(iam.eq.0)write(0,*)'non-exchange:',lrngnx,i-inast0
          nf=-1
          go to 999
        endif
        inast0=i                                  !global
c
c shift down global lspi symms to form local
c
        lrange=lrngnx
        lperproc=lrange/nproc
        lxtra=lrange-lperproc*nproc
c
        lmin=lrngx+1
        lmin=lmin+iam*lperproc+min(lxtra,iam)
        lmax=lmin+lperproc-1
        if(iam.lt.lxtra)lmax=lmax+1
c        write(6,*)iam,lmin,lmax
c
        i=inast
        do l=lmin,lmax
          i=i+1
          lspi(i)=lspi(l)
        enddo
        inast=i                                   !local
c
      endif
c
      inast0=inast                                !re-sync.
c
 999  return
c
  194 format('***sr.psymls: too many symmetries, increase maxsl',
     x              ' to:',i4)
 1007 format(//1x,136('-')//)
 1008 format(/' note: reducing maxlt to',i3,', that needed by lvmax='
     x,i3)
 1009 format(/' ***warning: you have set maxlt=',i3,', less than that'
     x,' formally needed by lvmax=',i3/22x,'set maxlt=',i3
     x,', to satisfy triangle relation')
 1010 format(/' ***warning: you have set minlt=',i3,', greater that'
     x,' formally needed by lvmin=',i3/22x,'set minlt=',i3
     x,', to satisfy triangle relation')
 1011 format(/' note: increasing minlt to',i3,', that needed by lvmin='
     x,i3)
c
      end subroutine psymls
C
C                             *******************
C
      FUNCTION QBINOM(N0,M0)
C
C-----------------------------------------------------------------------
C
C DETERMINE BINOMIAL COEFFICIENT: N!/(N-M)!*M!
C RETURNS ZERO SILENTLY IF ARGUMENT(S) OUT OF RANGE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      INTEGER(SP) QBINOM                       !DO NOT USE SHORT INTEGER
C
      IF(M0.LT.0.OR.M0.GT.N0)THEN
        I8=0
      ELSE
        N=N0
        M=M0
        IF(2*M0.GT.N0)M=N-M
        N=N+1
        I8=1
        DO J=1,M                  !J=1 CATCHES M=0
          I8=I8*(N-J)
          I8=I8/J
        ENDDO
      ENDIF
C
      QBINOM=I8
C
      RETURN
C
      END FUNCTION QBINOM
C
C                             *******************
C
      SUBROUTINE QEDINT(MAXPS)
C
C-----------------------------------------------------------------------
C
C  This routine evaluates the QED corrections to the energy levels
C  due to vacuum polarisation (correct to first order) and a crude
C  approximation to the self energy.
C  The V.P. contribution is calculated using the results of Fullerton
C  and Rinker Phys. Rev. A  Vol 13  P 1283 (1976) while the S.E.
C  contribution is estimated for S, P- and P orbitals by interpolating
C  among the values given by P. Mohr for Coulomb type wavefunctions
C  after an effective nuclear charge, ZEFF, is obtained by finding the
C  ZEFF required to give a Coulomb orbital with the same average R
C  as the MCDF orbital.
C
C  Very loosely adapted from PHN's GRASP0 routine by NRB.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (DKEY=999.D0)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
      COMMON /COM6/DA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
c      write(6,3000)
C
      PI=ACOS(-DONE)
C
      BREL2=ABS(IREL).EQ.2

C  Calculate the vacuum polarisation potential at each of the grid
C  points
C
      Z=NZION
C
      CALL VACPOL(Z,DX,MAXPS,DPOT)
C
C  Obtain contribution from each orbital
C
      DO K=1,MXORB
C
        IF(DEY(K).EQ.DZERO)GO TO 100
        IF(BJUMP.AND.IVAL(K).EQ.0)GO TO 100
        IF(SCREEN(K).GE.DKEY)GO TO 100                 !NOT YET COMPUTED
C
C  Obtain v.p. contribution for orbital K
C
        DO I=1,MAXPS
          DA(I)=DPNL(I,K)*DPNL(I,K)*DPOT(I)
        ENDDO
C
        IF(BREL2)THEN
          DO I=1,MAXPS
            DA(I)=DA(I)+DQNL(I,K)*DQNL(I,K)*DPOT(I)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DZERO,DA,ALLINT,MNH,DHNS,MJH,MAXPS)
C
        VPINT(K)=ALLINT
C
C  Obtain s.e. contribution for orbital I
C
        IF(QL(K).GT.2)THEN
C
C  No estimate for other than s, p- or p states
C
          VALU=DZERO
C
        ELSE
C
          IF(BREL)THEN
C
C  ...find average R for Dirac orbital...
C
            DO I=1,MAXPS
              DA(I)=DPNL(I,K)*DPNL(I,K)*DX(I)
            ENDDO
C
            IF(BREL2)THEN
              DO I=1,MAXPS
                DA(I)=DA(I)+DQNL(I,K)*DQNL(I,K)*DX(I)
              ENDDO
            ENDIF
C
            CALL WEDDLE(DZERO,DA,RAV,MNH,DHNS,MJH,MAXPS)
C
C  ...find effective Z of Coulomb orbital with same average R...
C
            CALL ZEFR(K,RAV,ZEFF)
C
            IF(ZEFF.LE.DZERO)ZEFF=Z
C
          ELSE
C
            ZEFF=Z-SCREEN(K)
C
          ENDIF
C
C  ...interpolate among P. Mohr data...
C
          CALL FZALF(ZEFF,K,VALU)
C
C  ...scale as required...
C
c          VALU=(ZEFF**4/XCL**3)*VALU/(PI*REAL(QN(K)**3,WP))
          VALU=ZEFF*(ZEFF*DFSC/REAL(QN(K),WP))**3*VALU/PI
C
        ENDIF
C
        SLFINT(K)=VALU
C
C  Print contributions if requested
C
c        write (6,3010) k,qn(k),ql(k)/2,vpint(k),slfint(k)
c     x                ,vpint(k)+slfint(k)
c     x                ,zeff,rav
C
  100 ENDDO
C
      RETURN
C
c 3000 FORMAT (/25X,' Q.E.D. CONTRIBUTIONS /2RY'/8X,'  GAM    N    L',
c     +1X,' VACUUM POLARIZ.',5X,'SELF ENERGY',8X,'TOTAL')
c 3010 FORMAT (8X,3I5,3(2X,D15.8),2f10.5)
C
      END SUBROUTINE QEDINT
C
C                             *******************
C
      FUNCTION QPTLS(IX,NC00,ND00,LI0,LF0)
C
C-----------------------------------------------------------------------
C
C  FN.QPTLS INITIALIZES THE POINTER FOR DETERMINING THE 2-BODY
C           NFS INTERACTIONS (ALGEBRA) FOR:
C  INPUT:
C    IX IS THE LSP SYMMETRY INDEX
C    NC0 IS THE INITIAL TARGET LSP INDEX
C    ND0 IS THE FINAL TARGET LSP INDEX
C    LI IS THE INITIAL CONTINUUM ORBITAL ANG. MOM.
C    LF IS THE FINAL CONTINUUM ORBITAL ANG. MOM.
C    bcorr flags if correlation may be present (then corr-corr was
c    omitted from algebra - default, anyway - see algxls to sync.)
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      INTEGER(SP) QPTLS                        !DO NOT USE SHORT INTEGER
C
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                    !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD(NCOR)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
C
      IF(NC00.GT.ND00)THEN
        IREV=1
        NC0=NC00
        ND0=ND00
        LI=LI0
        LF=LF0
      ELSEIF(NC00.LT.ND00)THEN
        IREV=-1
        NC0=ND00
        ND0=NC00
        LI=LF0
        LF=LI0
      ELSE
        NC0=NC00
        ND0=ND00
        IF(LI0.GE.LF0)THEN
          IREV=1
          LI=LI0
          LF=LF0
        ELSE
          IREV=-1
          LI=LF0
          LF=LI0
        ENDIF
      ENDIF
C
      NNN=0
C      NCN=NC0
      ncorr=0
C
      DO N=1,NC0
        NC=ITARG(N,IX)
        MC=NSL(NC)
        L1=LLCH(1,N,IX)
        L2=LLCH(2,N,IX)
        LD=((L2-L1)/4+1)
        NCH=MC*LD
        if(bcorr)mci=ngrpi(nc)
C
        NCNP=N
        IF(N.EQ.NC0)NCNP=ND0
C
        DO NP=1,NCNP
          ND=ITARG(NP,IX)
          beqgrp=nc.eq.nd
          beqgrpl=beqgrpl0.and.beqgrp
          IF(NMETAG(NC)+NMETAG(ND).LT.2)THEN
            IF(beqgrp)THEN
              L1P=L1
              LDP=(LD*(LD+1))/2
              LD=1
              NCH=MC
            ELSE
              L1P=LLCH(1,NP,IX)
              L2P=LLCH(2,NP,IX)
              LDP=((L2P-L1P)/4+1)
            ENDIF
            MCP=NSL(ND)
            NCHP=MCP*LDP
            NNN=NNN+NCH*NCHP
C
            if(bcorr)then
              nco=0
              nce=0
c            do lli=l1,l2,4
c              lf2=l2p
c              if(nc.eq.nd)lf2=lli
c              do llf=l1p,lf2,4
              mcip=ngrpi(nd)
              do m=1,mc
                j1=m+mci
                j=jndex(j1)
                do mp=1,mcp
                  j1p=mp+mcip
c                  if(j1p.gt.j1-ione0.and.lli.eq.llf)go to 61
                  jp=jndex(j1p)
                  if(j.lt.0.and.jp.lt.0)then
                    nco=nco+1                         !corr.-corr.
                    if(j1.eq.j1p)nce=nce+1
                  endif
                enddo
c   61           continue
              enddo
              ncorr=ncorr+nco*ld*ldp
            endif
          ENDIF
        ENDDO
C
        IF(beqgrpl.and.NMETAG(NC).LT.1)THEN
          LDD=(L2-L1)/4+1
          MM=MC+ione0
          NNN=NNN-LDD*(MM*(MM-1))/2                   !FOR LI.EQ.LF
          if(bcorr)ncorr=ncorr-ldd*(nco-nce)/2        !for li.eq.lf
c          write(0,*)-nadg(ix)-nnn,-ldd*(mm*(mm-1))/2,ldd,mc
        ENDIF
C
      ENDDO
C                                                     !ADJUST LAST BLOCK
      IF(beqgrpl.and.NMETAG(NC).LT.1)THEN
        NNN=NNN+LDD*(MM*(MM-1))/2                     !FOR LI.EQ.LF
        if(bcorr)ncorr=ncorr+ldd*(nco-nce)/2          !for li.eq.lf
      ENDIF
C
      IF(NMETAG(NC)+NMETAG(ND).LT.2)THEN
        NNN=NNN-NCH*NCHP
        if(bcorr)ncorr=ncorr-nco*ld*ldp
C
c          write(0,*)'nadg',nadg(ix)
        IF(beqgrp)THEN
          LD=(LI-L1)/4
          LDP=(LD*(LD+1))/2
          NNN=NNN+MC*MC*LDP
          if(bcorr)ncorr=ncorr+nco*ldp
c          write(0,*)nadg(ix)+nnn,ldp,mc
          if(beqgrpl)then
            MM=MC+ione0
            NNN=NNN-LD*(MM*(MM-1))/2                  !FOR LI.EQ.LF
            if(bcorr)ncorr=ncorr-ld*(nco-nce)/2       !for li.eq.lf
c            write(0,*)nadg(ix)+nnn,-ld,mm
          endif
          LDP=(LF-L1P)/4
          NCHP=MCP*LDP
          NNN=NNN+MC*NCHP
          if(bcorr)ncorr=ncorr+nco*ldp
c          write(0,*)nadg(ix)+nnn,ldp
        ELSE
          LD=(LI-L1)/4
          NCH=MC*LD
          NNN=NNN+NCH*NCHP
          if(bcorr)ncorr=ncorr+nco*ld*ldp
          LDP=(LF-L1P)/4
          NCHP=MCP*LDP
          NNN=NNN+MC*NCHP
          if(bcorr)ncorr=ncorr+nco*ldp
c          write(0,*)-nadg(ix)-nnn
        ENDIF
c
      ENDIF
C
      IADD=NADG(IX)+NNN-ncorr              !assuming corr.-corr. omitted
c
c      write(0,*)irev*ix,nc00,nd00,li0,lf0,nadg(ix),nnn,-ncorr,iadd
c      write(6,*)irev*ix,nc00,nd00,li0,lf0,nadg(ix),nnn,-ncorr,iadd
c
      if(irev.lt.0)iadd=iadd+1         !for case iadd=0 (e.g. bp nmetag)
C
      QPTLS=IADD*IREV
C
      RETURN
C
      END FUNCTION QPTLS
C
C                             *******************
C
      FUNCTION QPTLSJ(KX,IX00,JX00,NC00,ND00,LI0,LF0)
C
C-----------------------------------------------------------------------
C
C  FN.QPTLSJ INITIALIZES THE POINTER FOR DETERMINING THE 2-BODY
C           FS INTERACTIONS (ALGEBRA) FOR:
C  INPUT:
C    KX IS THE JP SYMMETRY INDEX
C    IX0 IS THE INITIAL LSP SYMMETRY INDEX
C    JX0 IS THE FINAL LSP SYMMETRY INDEX
C    NC0 IS THE INITIAL TARGET LSP INDEX
C    ND0 IS THE FINAL TARGET LSP INDEX
C    LI IS THE INITIAL CONTINUUM ORBITAL ANG. MOM.
C    LF IS THE FINAL CONTINUUM ORBITAL ANG. MOM.
C    bcorr flags if correlation may be present (then corr-corr was
c    omitted from algebra - default, anyway - see algxls to sync.)
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      INTEGER(SP) QPTLSJ                       !DO NOT USE SHORT INTEGER
C
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                    !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD/J(NCOR/J)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
C
      IJ=JPI(KX)/10
      if(ij.gt.maxjfs)stop 'qptlsj called for 2j>maxjfs!'  !shouldn't be
C
      IF(IX00.GT.JX00)THEN
        IREV=1
        IX0=IX00
        JX0=JX00
        NC0=NC00
        ND0=ND00
        LI=LI0
        LF=LF0
      ELSEIF(IX00.LT.JX00)THEN
        IREV=-1
        IX0=JX00
        JX0=IX00
        NC0=ND00
        ND0=NC00
        LI=LF0
        LF=LI0
      ELSE        !THEN AS LS CASE, LIKELY NCOR WILL FLAG BUT TO BE SAFE
        IX0=IX00
        JX0=JX00
        IF(NC00.GT.ND00)THEN
          IREV=1
          NC0=NC00
          ND0=ND00
          LI=LI0
          LF=LF0
        ELSEIF(NC00.LT.ND00)THEN
          IREV=-1
          NC0=ND00
          ND0=NC00
          LI=LF0
          LF=LI0
        ELSE
          NC0=NC00
          ND0=ND00
          IF(LI0.GE.LF0)THEN
            IREV=1
            LI=LI0
            LF=LF0
          ELSE
            IREV=-1
            LI=LF0
            LF=LI0
          ENDIF
        ENDIF
      ENDIF
C
      NNN2=0
      ncorr2=0
C
      DO NX=1,IX0
        IX=JSYMM(NX,KX)
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        NCN=NCHG(IX)
C
        MXP=NX
        IF(NX.EQ.IX0)MXP=JX0
C
        DO MX=1,MXP
          JX=JSYMM(MX,KX)
          ISP=LSPI(JX)/10000
          IPP=LSPI(JX)-ISP*10000
          ILP=IPP/10
          IF((IS+ISP-2)*(IL+ILP).GT.0)THEN
C
            BSYM=NX.EQ.IX0.AND.MX.EQ.JX0
            IF(BSYM)NCN=NC0
            NCNP=NCHG(JX)
C
c          write(0,*)'q-start',kx,nx,mx,nadgj(kx)+nnn2-ncorr2
            DO N=1,NCN
              NC=ITARG(N,IX)
              MC=NSL(NC)
              L1=LLCH(1,N,IX)
              L2=LLCH(2,N,IX)
              LD=((L2-L1)/4+1)
              NCH=MC*LD
              if(bcorr)mci=ngrpi(nc)
C
              IF(IX.EQ.JX)NCNP=N
              IF(BSYM.AND.N.EQ.NC0)NCNP=ND0
C
              DO NP=1,NCNP
                ND=ITARG(NP,JX)
                beqgrp=ix.eq.jx.and.nc.eq.nd
                beqgrpl=beqgrpl0.and.beqgrp
                IF(abs(NMETAG(NC))+abs(NMETAG(ND)).LT.2)THEN
                  IF(beqgrp)THEN
                    L1P=L1
                    LDP=(LD*(LD+1))/2
                    LD=1
                    NCH=MC
                  ELSE
                    L1P=LLCH(1,NP,JX)
                    L2P=LLCH(2,NP,JX)
                    LDP=((L2P-L1P)/4+1)
                  ENDIF
                  MCP=NSL(ND)
                  NCHP=MCP*LDP
                  NNN2=NNN2+NCH*NCHP
C
                  if(bcorr)then
                    nco=0
                    nce=0
c            do lli=l1,l2,4
c              lf2=l2p
c              if(nc.eq.nd)lf2=lli
c              do llf=l1p,lf2,4
                    mcip=ngrpi(nd)
                    do m=1,mc
                      j1=m+mci
                      j=jndex(j1)
                      do mp=1,mcp
                        j1p=mp+mcip
c                if(ix.eq.jx.and.j1p.gt.j1-ione0.and.lli.eq.llf)go to 61
                        jp=jndex(j1p)
                        if(j.lt.0.and.jp.lt.0)then
                          nco=nco+1                         !corr.-corr.
                          if(j1.eq.j1p)nce=nce+1
                        endif
                      enddo
c   61                 continue
                    enddo
                    ncorr2=ncorr2+nco*ld*ldp
                  endif
                ENDIF
              ENDDO
C
              IF(beqgrpl.and.NMETAG(NC).eq.0)THEN
                LDD=(L2-L1)/4+1
                MM=MC+ione0
                NNN2=NNN2-LDD*(MM*(MM-1))/2                !FOR LI.EQ.LF
                if(bcorr)ncorr2=ncorr2-ldd*(nco-nce)/2     !for li.eq.lf
              ENDIF
C
            ENDDO
c          write(0,*)'q-end',kx,nx,mx,nadgj(kx)+nnn2-ncorr2
          ENDIF
        ENDDO
      ENDDO
C                                                     !ADJUST LAST BLOCK
      IF(beqgrpl.and.abs(NMETAG(NC)).lt.1)THEN
        NNN2=NNN2+LDD*(MM*(MM-1))/2                        !FOR LI.EQ.LF
        if(bcorr)ncorr2=ncorr2+ldd*(nco-nce)/2             !for li.eq.lf
      ENDIF
C
      IF(abs(NMETAG(NC))+abs(NMETAG(ND)).LT.2)THEN
        NNN2=NNN2-NCH*NCHP
        if(bcorr)ncorr2=ncorr2-nco*ld*ldp
C
c          write(0,*)'nadg',nadg(ix)
        IF(beqgrp)THEN
          LD=(LI-L1)/4
          LDP=(LD*(LD+1))/2
          NNN2=NNN2+MC*MC*LDP
          if(bcorr)ncorr2=ncorr2+nco*ldp
c          write(0,*)nadgj(kx)+nnn2,ldp,mc
          if(beqgrpl)then
            MM=MC+ione0
            NNN2=NNN2-LD*(MM*(MM-1))/2                     !FOR LI.EQ.LF
            if(bcorr)ncorr2=ncorr2-ld*(nco-nce)/2          !for li.eq.lf
c            write(0,*)nadgj(kx)+nnn2,-ld,mm
          endif
          LDP=(LF-L1P)/4
          NCHP=MCP*LDP
          NNN2=NNN2+MC*NCHP
          if(bcorr)ncorr2=ncorr2+nco*ldp
c          write(0,*)nadgj(kx)+nnn2,ldp
        ELSE
          LD=(LI-L1)/4
          NCH=MC*LD
          NNN2=NNN2+NCH*NCHP
          if(bcorr)ncorr2=ncorr2+nco*ld*ldp
          LDP=(LF-L1P)/4
          NCHP=MCP*LDP
          NNN2=NNN2+MC*NCHP
          if(bcorr)ncorr2=ncorr2+nco*ldp
c          write(0,*)-nadgj(kx)-nnn2
        ENDIF
c
      ENDIF
C
      IADJ=NADGJ(KX)+NNN2-ncorr2           !assuming corr.-corr. omitted
c
      if(irev.lt.0)iadj=iadj+1            !for case iadj=0 (e.g. nmetag)
C
      QPTLSJ=IADJ*IREV
C
      RETURN
C
      END FUNCTION QPTLSJ

C
C                             *******************
C
      SUBROUTINE RADBP1(K2,K4,KTYPE,DK,M00)
C
C-----------------------------------------------------------------------
C
C  SR.RADBP1 CALCULATES MAGNETIC ONE-BODY RADIATIVE INTEGRALS:
C  M1+BP  FOR KTYPE=1-8, OR
C  M_K FOR KTYPE=9,10 (SEE BELOW FOR DEFINITIONS).
C
C  IT CALLS:
C    FN.SBESS
C    SR.DIFF
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_INTS,   ONLY: DOSC
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      ALLOCATABLE :: DWRK1(:),DWRK2(:),DWRK3(:)
C
      DIMENSION CON(10)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      ALLOCATE (DWRK1(MAXRS),DWRK2(MAXRS),DWRK3(MAXRS))
C
      BREL2=ABS(IREL).EQ.2
C
      CON(1)=DALF4
      CON(2)=CON(1)
      CON(3)=CON(1)
      CON(4)=CON(1)
      CON(5)=DALF/DTWO
      CON(6)=DALF/DEIGHT
      CON(7)=CON(5)
      CON(8)=DONE
      CON(9)=DONE
      CON(10)=CON(1)
C
      N=KTYPE
      M0=MOD(M00,I1000)
c
      if(m0.ne.0.or.m0.eq.0.and.n.eq.0)then      !should not occur (now)
        write(6,*)'radbp1, what are we doing here?',m0,m00,n
        write(0,*)'radbp1, what are we doing here?'
        go to 999
      endif
C
      JSWTCH=1
C
C COMPUTE M1BP RADIATIVE ONE-BODY INTEGRALS
C
C  P1(R)*P2(R)*F(R) WHERE F(R) DEPENDS ON THE TYPE
C
c      N=ABS(N)
      if(n.lt.0)then                             !should not occur (now)
        write(6,*)'radbp1: ktype.lt.0!!',m0,m00,n
        write(0,*)'radbp1: ktype.lt.0!!'
        go to 999
      endif
c
      DKU=DZERO
      D00=DZERO
C
C      GO TO (31,32,33,34,35,36,37,35,50,51),N
C
      IF(N.EQ.1)THEN
        GO TO 31
      ELSEIF(N.EQ.2)THEN
        GO TO 32
      ELSEIF(N.EQ.3)THEN
        GO TO 33
      ELSEIF(N.EQ.4)THEN
        GO TO 34
      ELSEIF(N.EQ.5)THEN
        GO TO 35
      ELSEIF(N.EQ.6)THEN
        GO TO 36
      ELSEIF(N.EQ.7)THEN
        GO TO 37
      ELSEIF(N.EQ.8)THEN
        GO TO 35
      ELSEIF(N.EQ.9)THEN
        GO TO 50
      ELSEIF(N.EQ.10)THEN
        GO TO 50
      ELSE
        write(6,*)'Index error in SR.RADBP1: N.gt.10:',n
        write(0,*)'Index error in SR.RADBP1'
        go to 999
      ENDIF
C
C TYPE-1: P1*P2/X**2
C
   31 DO I=1,MAXRS
        DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)/(DX(I)*DX(I))
      ENDDO
C
      IF(BREL2)THEN
        DO I=1,MAXRS
          DWRK1(I)=DWRK1(I)+DQNL(I,K2)*DQNL(I,K4)/(DX(I)*DX(I))
        ENDDO
      ENDIF
      GO TO 49
C
C TYPE-2: (P1/X)*P2'
C
   32 DO I=1,MAXRS
        DWRK2(I)=DPNL(I,K2)/DX(I)
        DWRK1(I)=DPNL(I,K4)
      ENDDO
      GO TO 39
C
C TYPE-3: P1*(P2/X)'
C
   33 DO I=1,MAXRS
        DWRK2(I)=DPNL(I,K2)
        DWRK1(I)=DPNL(I,K4)/DX(I)
      ENDDO
      GO TO 39
C
C TYPE-4: P1'*P2'
C
   34 if(igagr.gt.0.and.ql(k2).eq.ql(k4))then         !see radial/diagfs
        DKU=D2LL(K2,K4)
c        write(0,*)k2,k4,dku
        IF(QL(K2)+QL(K4).GT.0)THEN
          DO I=1,MAXRS
            DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)/(DX(I)*DX(I))
          ENDDO
          CALL WEDDLE(D00,DWRK1,DKU0,MNH,DHNS,MJH,MAXRS)
          TL=QL(K2)*(QL(K2)+2)+QL(K4)*(QL(K4)+2)
          DKU=-DKU0*TL/8+DKU
          IF(QL(K2).NE.QL(K4))THEN                    !see radial/diagfs
            DS=DEY(K2)-DUY(K2,K2)
            DE=DEY(K4)-DUY(K4,K4)
            DO I=1,MAXRS
              DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)
            ENDDO
            CALL WEDDLE(D00,DWRK1,OVL,MNH,DHNS,MJH,MAXRS)
            DKU=DKU+OVL*(DE+DS)
c            write(0,*)ds,de,k2,k4,ovl
          ENDIF
        ENDIF
c        write(0,*)k2,k4,dku,dku0
        GO TO 52
      endif
C
      DO I=1,MAXRS
        DWRK3(I)=DPNL(I,K2)
        DWRK1(I)=DPNL(I,K4)
      ENDDO
C
      IF(QL(K2)+QL(K4).EQ.0)D00=DORIG(K2)*DORIG(K4)
C
      CALL DIFF(DWRK3,DWRK2,MNH,DHNS,MJH)
C
C ENTRY POINT FOR TYPES-2 AND-3
C
   39 CALL DIFF(DWRK1,DWRK3,MNH,DHNS,MJH)
C
      DO I=1,MAXRS
        DWRK1(I)=DWRK2(I)*DWRK3(I)
      ENDDO
      GO TO 49
C
C TYPES-5 & -8: P1*P2*X**2
C
   35 DO I=1,MAXRS
        DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)*DX(I)*DX(I)
      ENDDO
C
      IF(BREL2)THEN
        DO I=1,MAXRS
          DWRK1(I)=DWRK1(I)+DQNL(I,K2)*DQNL(I,K4)*DX(I)*DX(I)
        ENDDO
      ENDIF
      GO TO 49
C
C TYPE-6: P1*P2
C
   36 IF(QL(K2).EQ.QL(K4))THEN
        DKU=DZERO
        IF(K2.EQ.K4)DKU=DONE
        GO TO 52
      ELSE        !not allowed?
c       write(0,*)'rad:',k2,k4
        DO I=1,MAXRS
          DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)
        ENDDO
C
        IF(BREL2)THEN
          DO I=1,MAXRS
            DWRK1(I)=DWRK1(I)+DQNL(I,K2)*DQNL(I,K4)
          ENDDO
        ENDIF
        GO TO 49
      ENDIF
C
C TYPE-7: P1*P2/X
C
   37 if(igagr.gt.0.and.ql(k2).eq.ql(k4))then         !see radial/diagfs
        n=5                                      !not actually used then
        go to 35
      endif
c
      DO I=1,MAXRS
        DWRK1(I)=DPNL(I,K2)*DPNL(I,K4)/DX(I)
      ENDDO
C
      IF(BREL2)THEN
        DO I=1,MAXRS
          DWRK1(I)=DWRK1(I)+DQNL(I,K2)*DQNL(I,K4)/DX(I)
        ENDDO
      ENDIF
C
C **********************************************
C
   49 CALL WEDDLE(D00,DWRK1,DKU,MNH,DHNS,MJH,MAXRS)
C
C **********************************************
C
      GO TO 52
C
C TYPES-9 AND -10 (FOR 1-BODY M_K) P1*P2*X**(K-1) AND P1*P2*X**(K+1)
C
   50 MGROUP=M00/2000                                !magnetic multipole
c
      if(n.eq.9)then
        ml=mgroup
      else                                           !n=10
        ml=mgroup+2
      endif
C
      IF(BREL2)THEN
        TJ=-2/(DFSC*(ml+2))
        IF(qn(k2).EQ.qn(k4).OR.irtard.eq.0.AND.ml.GT.1)THEN
          DO I=1,MAXRS
            DWRK1(I)=(DPNL(I,K2)*DQNL(I,K4)+DQNL(I,K2)*DPNL(I,K4))
     X            *DX(I)**ml
          ENDDO
        ELSEIF(irtard.lt.0.or.qn(k2).lt.0)THEN
          DEL=DEY(K2)-DUY(K2,K2)-DEY(K4)+DUY(K4,K4)  !A.U.
          TE=abs(DFSC*DEL)
          TJ=TJ*3/TE**ml
          DO I=2,ml
            TJ=TJ*(2*I+1)
          ENDDO
          DO I=1,MAXRS
            TZ=DX(I)*TE
            DWRK1(I)=DPNL(I,K2)*DQNL(I,K4)+DQNL(I,K2)*DPNL(I,K4)
            DWRK1(I)=DWRK1(I)*SBESS(ml,TZ,JSWTCH)
          ENDDO
        ELSE                                     !ml.eq.1.or.irtard.gt.0
          DEL=DEY(K2)-DUY(K2,K2)-DEY(K4)+DUY(K4,K4)  !A.U.
          TE=DFSC*DEL
          TE=TE*TE/(2*(2*ml+3))
          DO I=1,MAXRS
            DWRK1(I)=(DPNL(I,K2)*DQNL(I,K4)+DQNL(I,K2)*DPNL(I,K4))
     X            *DX(I)**ml*(DONE-TE*DX(I)*DX(I))
          ENDDO
        ENDIF
C
        CALL WEDDLE(D00,DWRK1,DKU,MNH,DHNS,MJH,MAXRS)
C
        DKU=DKU*TJ
c
ctest compare with e_k integral
c        kx=min(k2,k4)
c        if(ml.eq.1)then
c          t=dosc(ml+1,k2+k4-kx,kx)
c          del=dey(k2)-duy(k2,k2)-dey(k4)+duy(k4,k4)  !a.u.
c          te=dfsc*del
c          t=t*2*te*te/6
c        else
c          t=dosc(ml-1,k2+k4-kx,kx)
c        endif
c        write(0,*)'bess',n,ml,k2,k4,dku,t
c
      ELSE
        IF(ml.GT.1)THEN
          KX=MIN(K2,K4)
          DKU=DOSC(ml-1,K2+K4-KX,KX)
c          write(0,*)'DOSC',k2,k4,dku
        ELSE
          IF(K2.EQ.K4)THEN
            DKU=DONE
          ELSE
            DKU=DZERO
          ENDIF
        ENDIF
      ENDIF
C
   52 CONTINUE
C
      DK=DKU*CON(N)
C
  900 IF(ALLOCATED(DWRK1))DEALLOCATE (DWRK1,DWRK2,DWRK3)
C
      RETURN
C
  999 M00=-1
      GO TO 900
C
      END SUBROUTINE RADBP1
C
C                             *******************
C
      SUBROUTINE RADBP2(BPRNT0)
C
C-----------------------------------------------------------------------
C
C  SR.RADBP2 CALCULATES THE TWO-BODY M1+BP RADIATIVE INTEGRALS
C
C  IT CALLS:
C    SR.DIFF
C    SR.YLAMK
C    SR.YLAMKR
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: QSS
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_RELINT, ONLY: DRLP1,DNL
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=4) MBLK
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      DATA MBLK/'    '/
C
C
      NN=NL000+1
C
      IF(BPRNT0)THEN
        IF(NN.EQ.1)THEN
          WRITE(6,610)
        ELSE
          WRITE(6,982)MBLK
        ENDIF
      ENDIF
C
      BREL2=ABS(IREL).EQ.2
C
      IF(BJUMP)THEN                        !JUST SCALE EXISTING
        DO L=NN,NL
          M=0
          DD=DONE
          DO I=1,4
            N=QSS(I,L)
            M=M+IVAL(N)
            DD=DD*FACT(N)
          ENDDO
          IF(M.GT.0)THEN
            IF(.NOT.BJUMP2)DNL(L)=DZERO
            DNL(L)=DNL(L)*DD
          ENDIF
          IF(BJUMP2.AND.BPRNT0)WRITE(6,140)L,(QSS(I,L),I=1,5),DNL(L)
        ENDDO
        IF(.NOT.BJUMP2)GO TO 121
        GO TO 500                                                !RETURN
      ENDIF
C
      DO L=NN,NL
        DNL(L)=DZERO
      ENDDO
C
  121 K=0
C
      DO J=NN,NL                     !START MAGNETIC TWO-BODY OUTER LOOP
C                                    !OVER INNER ORBITAL PAIR (YLAMK)
        IF(DNL(J).NE.DZERO)GO TO 127
C
        M=QSS(5,J)
        MM=(M+2)/100
        BAUX=MM.EQ.7
        BINT=MOD(MM,ITWO).EQ.0.OR.BAUX             !FALSE FOR 1,3,5
C
        M1=(M-100*MM)/2
        IF(M1.GT.MAXLAM)GO TO 127
C
        MJ0=0
        IF(MM.GT.4)THEN
          K=1
          MJ0=3
        else
          k=0
        ENDIF
C
        N1=QSS(K+1,J)
        N2=QSS(K+3,J)
        IF(MODE.LT.3)THEN
          IMT=0
          IF(IYY(N1).GT.0)IMT=IMT+1
          IF(IYY(N2).GT.0)IMT=IMT+1
          IF(IMT.GT.1)GO TO 127
        ENDIF
C
        M2=(QL(N1)+QL(N2))/2+2
        IF((MM+1)/2.EQ.2)THEN         !3,4
          M2=M2+1
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N2)*DX(I)
          ENDDO
        ELSEIF(.NOT.BINT)THEN         !1,5
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N2)/DX(I)
          ENDDO
        ELSE       !IF(MM.NE.4)THEN   !0,2,6,7
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N2)*DPNL(I,N1)
          ENDDO
c        ELSE
c          DO I=1,MAXRS
c            DPA(I)=DPNL(I,N2)*DPNL(I,N1)/DX(I)
c          ENDDO
        ENDIF
C
        IF(.NOT.BINT)THEN
          IF(QL(N2).GT.0)M2=M2-1
C
          CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N1)*DP(I)*DX(I)
          ENDDO
        ENDIF
C
        IF(BREL)THEN
          DE1=DEY(N1)-DUY(N1,N1)
          DE2=DEY(N2)-DUY(N2,N2)
          DEL=DE1-DE2                                   ! A.U.
          T=DALF4*DTWO
          DZ=NZION
          IF(BREL2)THEN
            DO I=1,MAXRS
              DD1=DONE+T*(DE1+DZ/DX(I))
              DD2=DONE+T*(DE2+DZ/DX(I))
C              DD1=DONE+T*(DE1+POT(I,1))
C              DD2=DONE+T*(DE2+POT(I,1))
              D12=DD1*DD2
              d12=abs(d12)
              DPA(I)=DPA(I)/SQRT(D12)
            ENDDO
          ELSE
            dd=rnorm(n1)*rnorm(n2)
            DO I=1,MAXRS
              DD1=DALF4*(DQNL(I,N1)/DPNL(I,N1)+DTWO*DZ/DX(I))
              IF(DD1.GT.-DONE)DD1=DONE+DD1         !HIGH-Z POINT NUCL.
              DD2=DALF4*(DQNL(I,N2)/DPNL(I,N2)+DTWO*DZ/DX(I))
              IF(DD2.GT.-DONE)DD2=DONE+DD2         !HIGH-Z POINT NUCL.
c              dd1=done+t*(de1+dz/dx(i))           !alt
c              dd2=done+t*(de2+dz/dx(i))           !alt
              D12=DD1*DD2
              d12=abs(d12)
              DPA(I)=DPA(I)*dd/SQRT(D12)
            ENDDO
          ENDIF
          CALL YLAMKR(M1,M2,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ELSE
          CALL YLAMK(M1,M2,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
        ENDIF
C
        KX=QSS(4-K,J)
        IF(MM.EQ.1.OR.MM.EQ.2)THEN
          WRITE(6,*)'RADBP2 ERROR: KX=',KX
          WRITE(0,*)'RADBP2 KX ERROR'
          NF=-1
          GO TO 500                                              !RETURN
        ELSEIF(MM.EQ.0)THEN
C SKIP
        ELSEIF(MM.EQ.3.OR.MM.EQ.4)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)/DX(I)
          ENDDO
        ELSEIF(MM.EQ.6)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)*DX(I)*DX(I)
          ENDDO
        ELSE                     !MM=5,7
          IF(BAUX)THEN           !MM=7 ONLY
            DO I=1,MAXRS
              DPA(I)=-DPNL(I,KX)*DP(I)*DX(I)**4
            ENDDO
          ENDIF
          DO I=1,MAXRS
            DP(I)=DP(I)*DX(I)**3
          ENDDO
        ENDIF
C
        IF(BAUX)CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
        DO L=J,NL                             !START INNER MAGNETIC LOOP
C                                             !OVER OUTER ORBITAL PAIR
          IF(QSS(5,L).NE.M)GO TO 602
          IF(QSS(K+1,L).NE.N1.OR.QSS(K+3,L).NE.N2)GO TO 602
          IF(BAUX.AND.QSS(4-K,L).NE.KX)GO TO 602
C
          L1=QSS(2-K,L)
          L2=QSS(4-K,L)
          JMT=0
          IF(MODE.LT.3)THEN
            IF(IYY(L1).GT.0)JMT=JMT+1
            IF(IYY(L2).GT.0)JMT=JMT+1
            IF(IMT+JMT.GT.1)GO TO 602
          ENDIF
C
          IF(BAUX)THEN
            DO I=1,MAXRS
              DPA(I)=DPNL(I,L1)*DP(I)/DX(I)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DPA(I)=DPNL(I,L1)*DP(I)*DPNL(I,L2)
            ENDDO
          ENDIF
C
          IF(BREL)THEN
            DE1=DEY(L1)-DUY(L1,L1)
            DE2=DEY(L2)-DUY(L2,L2)
C            DEL=DE1-DE2                                   ! A.U.
            T=DALF4*DTWO
            DZ=NZION
            IF(BREL2)THEN
              DO I=1,MAXRS
                DD1=DONE+T*(DE1+DZ/DX(I))
                DD2=DONE+T*(DE2+DZ/DX(I))
C                DD1=DONE+T*(DE1+POT(I,1))
C                DD2=DONE+T*(DE2+POT(I,1))
                D12=DD1*DD2
                d12=abs(d12)
                DPA(I)=DPA(I)/SQRT(D12)
              ENDDO
            ELSE
              dd=rnorm(l1)*rnorm(l2)
              DO I=1,MAXRS
                DD1=DALF4*(DQNL(I,L1)/DPNL(I,L1)+DTWO*DZ/DX(I))
                IF(DD1.GT.-DONE)DD1=DONE+DD1         !HIGH-Z POINT NUCL.
                DD2=DALF4*(DQNL(I,L2)/DPNL(I,L2)+DTWO*DZ/DX(I))
                IF(DD2.GT.-DONE)DD2=DONE+DD2         !HIGH-Z POINT NUCL.
c                dd1=done+t*(de1+dz/dx(i))           !alt
c                dd2=done+t*(de2+dz/dx(i))           !alt
                D12=DD1*DD2
                d12=abs(d12)
                DPA(I)=DPA(I)*dd/SQRT(D12)
              ENDDO
            ENDIF
          ENDIF
C
          DS=DZERO
C
          CALL WEDDLE(DS,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
          OVL=DONE
          IF(IRLX.EQ.2)THEN        !OVERLAPS
            KF=IGRCF(N1)
            KG=IGRCF(N2)
            IF(KG.EQ.0)KG=IGRCF(L1)
            IF(KF.NE.KG.AND.KG.GT.0)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              OVL=OVLPCF(KK)
              IF(IPAIR(KK).EQ.1)THEN!SURELY THIS CAN BE SIMPLIFIED...
                IF(IEQ(N1).EQ.IEQ(N2))THEN
                  K1=MIN(N1,N2)
                  K2=MAX(N1,N2)
                ELSEIF(IEQ(L1).EQ.IEQ(L2))THEN
                  IF(IGRCF(L1).EQ.0)GO TO 611
                  K1=MIN(L1,L2)
                  K2=MAX(L1,L2)
                ELSEIF(KF.NE.IGRCF(L1))THEN
                  IF(IEQ(N1).EQ.IEQ(L1))THEN
                    K1=MIN(N1,L1)
                    K2=MAX(N1,L1)
                  ELSEIF(IEQ(L2).EQ.IEQ(N2))THEN
                    IF(IGRCF(L2).EQ.0)GO TO 611
                    K1=MIN(L2,N2)
                    K2=MAX(L2,N2)
                  else
                    write(6,*)'radbp2: why are we here?',
     x                      kf,kg,n1,l1,n2,l2
                    write(0,*)'radbp2: why are we here?'
                    nf=-1
                    go to 500                                    !return
                  ENDIF
                ELSE
                  IF(IEQ(N1).EQ.IEQ(L2))THEN
                    K1=MIN(N1,L2)
                    K2=MAX(N1,L2)
                  ELSEIF(IEQ(L1).EQ.IEQ(N2))THEN
                    K1=MIN(L1,N2)
                    K2=MAX(L1,N2)
                  else
                    write(6,*)'radbp2: why are we here?',
     x                      kf,kg,n1,l1,n2,l2
                    write(0,*)'radbp2: why are we here?'
                    nf=-1
                    go to 500                                    !return
                  ENDIF
                ENDIF
                KK=((K2-1)*(K2-2))/2+K1
                OVL=OVL/OVLPGR(KK)
              ENDIF
            ENDIF
          ENDIF
C
  611     DNL(L)=DD*DALF4*OVL
C
  602   ENDDO                                            !END INNER LOOP
C
  127   IF(BPRNT0)WRITE(6,140)J,(QSS(I,J),I=1,5),DNL(J)
C
      ENDDO                                              !END OUTER LOOP
C
  500 RETURN
C
  140 FORMAT(I5,3X,2(I5,I4),I6,F14.8)
  610 FORMAT(//5X,"N&V(   A   B    C   D  2LBD') = MAGNETIC INTEGRALS")
  982 FORMAT(A4,26X,4I4,2X,7F9.4)
C
      END SUBROUTINE RADBP2
C
C                             *******************
C
      SUBROUTINE RADCN0(MYMO,MYNO,MPO,DHNSX)
C
C-----------------------------------------------------------------------
C
C  SR.RADCN0 READS USER INPUT FOR RADCON BRANCH AND SETS-UP AN
C  ENERGY MESH ACCORDINGLY.
C
C  IT IS CALLED BY:
C    SR.MINIM
C    SR.RADCON
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
C                              DRLI,    IYY,NRLI,
      USE COMMON_NRBINT, ONLY:      DYY,         MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBTS1, ONLY: PMIN,IPIG,IGAG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXTABF=41)        !NO OF FINE PRE-TAB'D ENERGIES FOR PI
      PARAMETER (MXTABC=25)      !NO OF COARSE PRE-TAB'D ENERGIES FOR PI
C      PARAMETER (MXFOTE=2*MXENG)          !BUFFER SPACE FOR PI ENERGIES
      PARAMETER (MXFOTE=2*MXTABF)          !BUFFER SPACE FOR PI ENERGIES
C
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
C
      PARAMETER (DTON=100.0D0)
      PARAMETER (DTHIRD=DONE/DTHREE)
      PARAMETER (D0PT85=0.85D0)
      PARAMETER (D0PT9=0.9D0)
      PARAMETER (D1PT05=1.05D0)
      PARAMETER (D1PT5=1.5D0)
      PARAMETER (D1M24=1.0D-24)
C
      CHARACTER(LEN=3) PIG
C
      LOGICAL BEX                         !INQUIRE REQUIRES DEFAULT KIND
C
      DIMENSION EFOT(MXFOTE),EDUMF(MXTABF),EDUMC(MXTABC)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /COM3/DDY,DZ,TM
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBTAR/ETAR(MAXTM),ISTAR(MAXTM),LTAR(MAXTM),JTAR(MAXTM)
     X              ,NTAR,IGAPE
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /PARPOT/CPOT(6),XPOT(6),IPOT(6),NPOT
C
      SAVE MYM,MYN,MP
CMOD      SAVE MOD,MDUM
C
      NAMELIST/SRADCON/
     X ACE,
     X ECOR1,ECOR2,ECORCA,ECORIC,ECORLS,EMIN,EMAX,MIONQ,
     X KSHIFT,MKMAX,MXEP,
     X MDECP,MENG,MENGP,MP,MYN,MYM,
     X NLAG,NREL,NLAGP,
     X NPOT,
     X PIG,PMIN,
     X DELTAX,DEMIN,DEMAX,NDE,NIDX,
     X EMINI,EMAXI,MENGI,
     X TEAPOT,TOLDE
     x,ilog,nbund,nskpi,tolp,bnointerp
CMOD    X  ,MOD,MDUM
C NOT ALL VARIABLES USED BY RADCN0, BUT PRESENT FOR RADCX0 COMPATIBILITY
C (DELTAX,...,bnointerp)
C
C DEFAULT MESH MXTABC=25
C
      DATA EDUMC/0.0D+0,2.1D-6,4.6D-6,1.0D-5,2.1D-5,4.6D-5,
     X           1.0D-4,2.1D-4,4.6D-4,1.0D-3,2.1D-3,4.6D-3,
     X           1.0D-2,2.1D-2,4.6D-2,1.0D-1,2.1D-1,4.6D-1,
     X           1.0D+0,2.1D+0,4.6D+0,1.0D+1,2.1D+1,4.6D+1,1.0D+2/
C
C TEST FINE MESH MXTABF=41 (OR 45)
C
      DATA EDUMF/0.0D+0,1.6D-6,2.5D-6,4.0D-6,6.3D-6,
     X           1.0D-5,1.6D-5,2.5D-5,4.0D-5,6.3D-5,
     X           1.0D-4,1.6D-4,2.5D-4,4.0D-4,6.3D-4,
     X           1.0D-3,1.6D-3,2.5D-3,4.0D-3,6.3D-3,
     X           1.0D-2,1.6D-2,2.5D-2,4.0D-2,6.3D-2,
     X           1.0D-1,1.6D-1,2.5D-1,4.0D-1,6.3D-1,
     X           1.0D+0,1.6D+0,2.5D+0,4.0D+0,6.3D+0,
     X           1.0D+1,1.6D+1,2.5D+1,4.0D+1,6.3D+1,1.0D+2/
C     X,1.6D+2,2.5D+2,4.0D+2,6.3D+2/
C
C EDUMC/F ARE Z-SCALED RYD.
C
C
C PRELIMINARY INITIALIZATIONS
C
      BDR=IDR.NE.0
      PI=ACOS(-DONE)
C
      MION1=NW+NF                !TOTAL NUMBER OF ELECTRONS (=MION+MRED)
      NZA=MAX(NZION-MION1+1,IONE)
      DZ=NZION
      DZA=MION1-NZION-1
      DZA2=NZA*NZA                   !=DZA*DZA EXCEPT CASE DZA=0, THEN 1
      TQD=DZERO
C
      IF(DHNSX.GT.DZERO)GO TO 1000               !AS ALREADY READ/SET-UP
C
C NAMELIST INITIALIZATIONS
C
C ********** ALL INPUT ENERGIES MUST BE IN RYDBERGS ***********
C
      NPOT=0                              !R-MATRIX PARAMETRIC POTENTIAL
C
      MIONQ=44                                       !MAX MION1 FOR BTWO
      DYY(1)=DZERO
      EMIN=-1
      EMAX=-2
      EMINI=EMIN                                     !ALTERNATE
      EMAXI=EMAX                                     !ALTERNATE
      IF(BFOT)THEN                                   !OLD DEFAULT
        IPIG=1                                       !LENGTH
        PMIN=-DONE
      ENDIF
C
      ECOR1=DZERO
      ECOR2=DZERO
      ECORCA=DZERO
      ECORLS=DZERO
      ECORIC=DZERO
      MENG=-1984
      MENGI=-999
      MENGP=0
      NREL=0
      ACE=DZERO
      MYN=0
      MYM=0
      MP=0
      NLAG=-1
      NLAGP=-1
      PIG='   '                                      !NEW DEFAULT
      PMIN=D1M24                                     !VARIABLE GAUGE
      MDECP=0
      KSHIFT=-999              !<0 FOR DOWN,>0 FOR UP,=0 MIXED RYD SCALE
      MKMAX=-999               !MAX PI MULTIPOLE FOR DOWNSCALING
      MXEP=-1                  !SWITCH-OVER FROM DOWN TO UP, KSHIFT=0
C
CMOD    MDUM=0
CMOD    MOD=0
C
      IF(BNAME)THEN
C
C
        READ(5,SRADCON,END=998,ERR=998)     ! <---------------- NAMELIST
C
        IF(EMIN.LT.DZERO)EMIN=EMINI
        IF(EMAX.LT.DZERO)EMAX=EMAXI
C
      ELSE                                        !HISTORIC FIXED FORMAT
C
        READ(5,590)ECOR1,ECOR2,MENG,NREL,ACE,MYN,MYM,MP
CMOD     X,MDUM,MOD                               !COULD ADD/ADJUST
C
      ENDIF
C
      IF(MENG.EQ.-1984)MENG=MAX(MENGI,IZERO)
C
      IF(BDR.AND.KSHIFT.EQ.-999)KSHIFT=0
      IF(KSHIFT.GT.0)MKMAX=0                     !SAVE USER JOE..
C
      BZSCLE=MENGP.NE.0.
C
      IF(BFOT)THEN
C
        IF(BZSCLE)THEN
          IF(MENG.NE.0)THEN
            WRITE(6,*)' *** SR.RADCN0: MENGP.NE.0 OVERRIDES MENG...'
            WRITE(0,*)' *** SR.RADCN0: MENGP.NE.0 OVERRIDES MENG...'
          ENDIF
          MENG=MENGP
        ENDIF
C
        IF(MKMAX.LT.0)THEN     !SET MAX K-POLE FOR DOWNSCALING FROM CONT
          IF(KSHIFT.EQ.0)THEN                    !DOWN TO MKMAX, THEN UP
            MKMAX=1
          ELSEIF(KSHIFT.LT.0)THEN                        !ALL DOWNSCALED
            MKMAX=999
          ELSE                                             !ALL UPSCALED
            MKMAX=0
          ENDIF
        ENDIF
C
        IF(PMIN.LE.DZERO.OR.
     X    PIG.NE.'   '.AND.PIG.NE.'VAR')THEN         !USE FIXED PI GAUGE
          PMIN=-DONE
          IF(PIG.EQ.'LEN')THEN
            IPIG=1
          ELSEIF(PIG.EQ.'VEL')THEN
            IPIG=0
          ELSEIF(PIG.EQ.'ACC')THEN
            IPIG=-2
          ELSE
            WRITE(0,607)PIG
            WRITE(6,607)PIG
            NF=-1
            GO TO 999
          ENDIF
        ELSE                                      !USE VARIABLE PI GAUGE
          PMIN=D1P18*PMIN/DZA2
        ENDIF
C
        IF(MENG.LE.-10000)THEN
          MDECP=MAX(MDECP,-MENG/10000,7_SP)
          MENG=-10000
        ENDIF
        IF(MENG.LE.-1000.OR.MENG.EQ.0)THEN
          IF(MDECP.GT.3)THEN
            MENG=-10000
          ELSE
            IF(MENG.NE.0)MENG=-1000
          ENDIF
        ENDIF
C
      ELSE
C
        IF(BZSCLE)THEN
            WRITE(6,*)
     X         ' *** SR.RADCN0: MENGP.NE.0 FLAGS Z-SCALED MENG ENERGIES'
            WRITE(0,*)
     X         ' *** SR.RADCN0: MENGP.NE.0 FLAGS Z-SCALED MENG ENERGIES'
        ENDIF
C
      ENDIF
C
      IF(BFOT)THEN
        NLAG0=2
      ELSE
        NLAG0=4
      ENDIF
      ISGN=1-2*mod(abs(NLAG),ITWO)              !(-1)**NLAG
      IF(NLAG.LT.NLAG0.OR.NLAG.GT.10.OR.ISGN.LT.0)THEN
        IF(NSL0.LT.0)THEN                     !CA INTERP MORE INACCURATE
          NLAG=4
        ELSE
          NLAG=6
        ENDIF
      ENDIF
      ISGNP=1-2*mod(abs(NLAGP),ITWO)             !(-1)**NLAGP
      IF(NLAGP.LT.NLAG0.OR.NLAGP.GT.10.OR.ISGNP.LT.0)NLAGP=NLAG
      IF(.NOT.BFOT.AND.MENG.EQ.0)MENG=-2*NLAG
C
      IF(ECORCA.NE.DZERO)ECOR1=ECORCA
      IF(ECORLS.NE.DZERO)ECOR1=ECORLS
      IF(ECORIC.NE.DZERO)ECOR2=ECORIC
C
C
CMOD      IF(MOD.GT.0)MODE=MOD
C
C CORRECTION TO ABSOLUTE POSITION OF CONTINUUM (MODE=2) IN DIAGON AND
C DELEN APPLIES RELATIVE TERM CORRECTION TO TARGET (SEE SR.MINIM) IN AU.
C
      ECOR1=ECOR1/DTWO                                      !RYD TO A.U.
      ECOR2=ECOR2/DTWO                                      !RYD TO A.U.
      IF(ABS(ECOR1).GT.DTON)ECOR1=ECOR1/DKCM
      IF(ABS(ECOR2).GT.DTON)ECOR2=ECOR2/DKCM
C
      IF(MODE.LT.1.OR.MODE.GT.4)THEN
        WRITE(6,593)MODE
        NF=-1
      ENDIF
C
C MYN, MYM CONTROL PRINT OPTION FOR ORBITALS ]MYN] TO MYM.
C MYN .LT.-10 CHECKS ORTHOGONALITY OF SUPPOSEDLY ORTHOG ORBITALS
C AND PRINTS OUT DETAILS OF CONTINUUM ORBITALS AT EACH ENERGY.
C
      IF(MYN.EQ.0)MYN=1
      IF(MYM.EQ.0)MYM=-1
C
      IF(ACE.LT.D1M10)ACE=D1P9               !CAN RESTRICT EXTRAPOLATION
      ACE=ACE/DTWO                                          !RYD TO A.U.
C
C SAME MENG INTERPOLATION POINTS ARE USED IN DIAGON AND DIAGFS.
C
      MRDE=MENG
      MRDE0=mod(MRDE,I1000)
      IF(MRDE.LT.0)MENG=-MIN(-NLAG,MRDE0)
C
      CALL DIMUSE('MXENG',MENG)
C
      IF(MENG.GT.MXENG)THEN
        WRITE(6,251)MXENG,MENG
        NF=-1
        GO TO 999
C        MENG=MXENG
      ENDIF
C
      IF(MRDE.GT.0)GO TO 208
C
C
      IF(MRDE0.LT.0.AND.EMAX.LT.EMIN)THEN
C
        READ(5,*,END=22,ERR=22)EMIN0,EMAX0
C
        EMIN=EMIN0
        EMAX=EMAX0
C
      ENDIF
C
      IF(EMAX.GT.EMIN.AND.EMIN.LT.DZERO)EMIN=DZERO           !ALLOW EMAX
C
      IF(BZSCLE)THEN
        EMIN=EMIN*DZA2
        EMAX=EMAX*DZA2
      ENDIF
C
  22  IF(NF.LE.0)GO TO 999
C
      BBC2=.FALSE.
C
C
C MENG.LE.0   : USE INTERNAL ENERGIES FOR "PHOTOIONIZATION" (PREFERABLY)
C               REALLY INTENDED FOR RADIATIVE RECOMBINATION RATE COEFFS.
C               CRUDE FOR INTERPOLATION OF PARTIAL PI TO DELIVER TOTALS.
C
C     .EQ.     0 USES COARSE DEFAULT ENERGY MESH
C     .EQ. -1000 USES FINE DEFAULT ENERGY MESH
C     .EQ.-10000 USES MAX(MDECP,-MEMG/10000,7) POINTS PER ENERGY DECADE
C                OVER EMIN, EMAX
C
      IF(BFOT.AND.MRDE0.eq.0)THEN
        EMIN=EMIN/DZA2                        !PI ONLY
        EMAX=EMAX/DZA2
        MFOT=MXFOTE
        IF(MRDE.GT.-1000)THEN                 !USE COARSE PI ENERGY MESH
          IF(MFOT.LT.MXTABC)THEN
            T=EDUMC(MFOT)*DZA2
            WRITE(6,333)T,MXTABC
          ELSE
            MFOT=MXTABC
          ENDIF
          DO I=1,MFOT
            EFOT(I)=EDUMC(I)
          ENDDO
        ELSEIF(MRDE.GT.-10000)THEN              !USE FINE PI ENERGY MESH
          IF(MFOT.LT.MXTABF)THEN
            T=EDUMF(MFOT)*DZA2
            WRITE(6,333)T,MXTABF
          ELSE
            MFOT=MXTABF
          ENDIF
          DO I=1,MFOT
            EFOT(I)=EDUMF(I)
          ENDDO
        ELSE
          DT=DONE/MDECP
          IF(EMIN.GT.DZERO)THEN
            EFOT(1)=EMIN
            T=LOG10(EMIN)
          ELSE
            IF(EMAX.GT.DZERO)THEN
              TT=LOG10(EMAX)
              T=TT-(MXFOTE/2-1)*DT                    !MXENG -> MXFOTE/2
            ELSE
              T=-DSIX
            ENDIF
            EFOT(1)=DZERO
          ENDIF
          IF(EMAX.GT.DZERO)THEN
            TT=LOG10(EMAX)
            TT=(TT-T)/DT
            M=INT(TT)
            MFOT=MIN(M+2,MFOT)
          ENDIF
          DO I=2,MFOT
            T=T+DT
            EFOT(I)=DTEN**T
          ENDDO
        ENDIF
C
        IF(EMIN.GT.DZERO.AND.EMAX.LT.DZERO)EMAX=EFOT(MFOT)   !ALLOW EMIN
C
C        MFOT=MAX(MRDE0,-MFOT)          !RESTRICTION NOT IMPOSED
C
        I0=1
        I1=MFOT
        IF(EMAX.GT.EMIN.AND.EMIN.GE.DZERO)THEN
          DO I=1,MFOT
            IF(EFOT(I).LE.EMIN)I0=I
            IF(EFOT(I).LT.EMAX)I1=I+1
          ENDDO
          IF(I1.GT.MFOT)THEN
            IF(EFOT(MFOT).LT.EMAX*D0PT9)THEN
              WRITE(6,713)EFOT(MFOT)*DZA2
              WRITE(0,*)'***SR.RADCON: EMAX TOO LARGE FOR DIMEN. MXENG'
              NF=-1
              GO TO 999
            ELSE                               !CLOSE ENOUGH
              I1=MFOT
            ENDIF
          ENDIF
        ENDIF
        MFOT=I1-I0+1
C
        CALL DIMUSE('MXENG',MFOT)
C
        IF(MFOT.GT.MXENG)THEN
          I1=I0+MXENG-1
          T=EFOT(I1)*DZA2
          WRITE(6,333)T,MFOT
          WRITE(0,*)
     X'*** WARNING SR.RADCON: INTERNAL PI ENERGY MESH TRUNCATED ***'
        ENDIF
C
        M=0
        DO I=I0,I1
          M=M+1
          DYY(M)=EFOT(I)*DZA2
        ENDDO
        MENG=M
        GO TO 206
      ENDIF
C
C SET-UP INTERPOLATION ENERGIES FOR AUTOIONIZATION (PREFERABLY).
C
      IF(MENG.EQ.0)THEN
        WRITE(6,606)
        WRITE(0,*)'***ERROR, MUST SPECIFY NON-ZERO MENG ENERGIES FOR DR'
        NF=-1
        GO TO 999
      ENDIF
C
      BTWO=.FALSE.
      IF(EMAX.LT.DZERO.OR.EMIN.LT.DZERO)THEN           !GET TARGET INFO
        IF(NJO.LE.0)THEN
          IF(NSL0.LT.0)THEN                                    !CA
            INQUIRE(FILE='CAVES',EXIST=BEX)
            IF(.NOT.BEX)GO TO 820
            IUNIT(14)=1
            IRDE=14
            OPEN(IRDE,FILE='CAVES')
            READ(IRDE,*,END=820)
            DO I=1,MAXTM
              READ(IRDE,990,END=821)ISTAR(I),IP,ICF,ETAR(I)      !*->990
              IF(ICF.EQ.0)GO TO 821
              LTAR(I)=0                      !SO W=ISTAR*(2LTAR+1) AS LS
              ISTAR(I)=(1-2*MOD(IP,ITWO))*ISTAR(I)
              EMXX=ETAR(I)
            ENDDO
            WRITE(6,*)'**ERROR: TOO MANY TERMS, INCREASE MAXTM'
            WRITE(0,*)'**ERROR: TOO MANY TERMS, INCREASE MAXTM'
            NF=-1
            GO TO 999
          ELSE                                                 !LS
            INQUIRE(FILE='TERMS',EXIST=BEX)
            IF(.NOT.BEX)GO TO 820
            IUNIT(14)=1
            IRDE=14
            OPEN(IRDE,FILE='TERMS')
            READ(IRDE,*,END=820)
            DO I=1,MAXTM                                       !*->991
              READ(IRDE,991,END=821)ISTAR(I),LTAR(I),IP,ICF
     X                             ,NDUM,ETAR(I)
              IF(ICF.EQ.0)GO TO 821
              ISTAR(I)=(1-2*MOD(IP,ITWO))*ISTAR(I)
              EMXX=ETAR(I)
            ENDDO
            WRITE(6,*)'**ERROR: TOO MANY TERMS, INCREASE MAXTM'
            WRITE(0,*)'**ERROR: TOO MANY TERMS, INCREASE MAXTM'
            NF=-1
            GO TO 999
          ENDIF
        ELSE                                                   !IC
          INQUIRE(FILE='LEVELS',EXIST=BEX)
          IF(.NOT.BEX)GO TO 820
          IUNIT(15)=1
          IRDE=15
          OPEN(IRDE,FILE='LEVELS')
          READ(IRDE,*,END=820)
          DO I=1,MAXTM                                         !*->992
            READ(IRDE,992,END=821)JTAR(I),IP,ISTAR(I),LTAR(I)
     X                           ,ICF,NDUM,ETAR(I)
            IF(ICF.EQ.0)GO TO 821
            EMXX=ETAR(I)
          ENDDO
          WRITE(6,*)'*ERROR: TOO MANY LEVELS, INCREASE MAXTM'
          WRITE(0,*)'**ERROR: TOO MANY LEVELS, INCREASE MAXTM'
          NF=-1
          GO TO 999
        ENDIF
C
C DETERMINE ENERGY RANGE(S) FOR AUTOIONIZATION
C
  821   NTAR=I-1
        IF(NTAR.LT.2)GO TO 820
C
        CLOSE(IRDE)
        IUNIT(IRDE)=-1
C
        IF(BDR)THEN             !FIRST CHECK FOR ANY CORE RE-ARRANGEMENT
          DO K=1,KMAX
            M=QCG(NF,K)
            IF(QN(M).GE.90)THEN          !CONT: NORMALLY N=99 FOR   "  "
              M=QCG(NF-1,K)
              IF(IVAL(M).GT.0)THEN                              !RYDBERG
                IF(EMIN.LT.DZERO)EMIN=DZERO
                IF(EMAX.LT.DZERO)EMAX=EMXX
                GO TO 822                                   !WE ARE DONE
              ENDIF
            ENDIF
          ENDDO
        ENDIF
C
        IF(MION1-1.GT.MIONQ)THEN             !TOO MANY ELEC FOR BTWO=.T.
          IF(EMIN.LT.DZERO)EMIN=DZERO
          IF(EMAX.LT.DZERO)EMAX=EMXX
        ENDIF
C
  822   IGAPE=0
C
        IF(EMAX.LT.DZERO.AND.EMIN.LT.DZERO.AND.MENG.GE.2*NLAG)THEN !TWO,
          DE=DZERO                                               ! MAYBE
          IE=0
          DO I=2,NTAR
            IF(ETAR(I)-ETAR(I-1).GT.DE)THEN
              IE=I
              DE=ETAR(I)-ETAR(I-1)
            ENDIF
          ENDDO                     !2*
          BTWO=IE.GT.2.AND.DE.GT.D1PT5*(ETAR(NTAR)-ETAR(IE)).AND.
     X         DE.GT.2*ETAR(IE-1)                              !how big?
        ELSE                                                        !ONE
          BTWO=.FALSE.
        ENDIF
        IF(EMAX.LT.DZERO)THEN
          IF(BDR)THEN
            NXX=NMAX
            IF(JND.GT.0)NXX=NDR(JND)
          ELSE
            NXX=NNEW
          ENDIF
          TN=DZA/NXX
          TN=TN*TN
          EMXX=EMXX-TN
          EMXX=EMXX*D1PT05
          IF(EMXX.LE.DZERO)THEN
            WRITE(6,*)'*** SR.RADCN0 WARNING: CHECK/SET INTERPOLATION',
     X                ' ENERGIES; POSSIBLE/PROBABLE INACCURACY'
            WRITE(0,*)'*** SR.RADCN0 WARNING: CHECK/SET INTERPOLATION',
     X                ' ENERGIES; POSSIBLE/PROBABLE INACCURACY'
            EMXX=-TN
            IF(NXX.GT.1)TN=DZA/(NXX-1)
            TN=TN*TN
            EMXX=EMXX+TN
            EMXX=EMXX*D0PT85
          ENDIF
          EMAX=EMXX
        ENDIF
        IF(EMIN.LT.DZERO)THEN
          NEQ=0
          IF(LNEW.LT.0)THEN
            IF(NNEW.EQ.2)NEQ=MION1-2
            IF(NNEW.EQ.3)NEQ=MION1-10
            IF(NNEW.EQ.4)NEQ=MION1-28
            IF(NEQ.LT.0)NEQ=0
          ENDIF
          DZM=DZA-NEQ
          DUM=TQDT(TQD,NZION,MION1-NEQ,NNEW,MAX(IZERO,LNEW))
c          write(0,*)'qd=',tqd
          N00=0
          IF(MB.EQ.0.AND.MION1.Gt.10)N00=2                          !MB0
          IF(MB.LE.1.AND.MION1.Gt.28)N00=3                          !MB0
          IF(N00.EQ.0)THEN
            IF(BDR)THEN
              N00=NMIN
            ELSE
              N00=NNEW
            ENDIF
          ENDIF
          IF(BTWO)THEN
            TM=DZM/(N00-TQD)
            TM=TM*TM
            EMAX2=EMAX
            EMIN=ETAR(IE)-ETAR(IE-1)-TM
            EMAX1=MAX(ETAR(IE-1),ETAR(NTAR)-ETAR(IE))
            EMAX1=EMAX1-TN
            IF(EMAX1.LT.D1M2*DZA2)EMAX1=D1M2*DZA2
            EMAX1=EMAX1*D1PT05
            EMIN1=DZERO
          ELSE
            IF(BDR)THEN
              NLOOP=NMAX
              IF(JND.GT.0)NLOOP=NLOOP+JND
            ELSE
              NLOOP=N00
            ENDIF
            EMIN=EMAX/D1PT05
            DO N=N00,NLOOP
              NXX=N
              IF(BDR.AND.N.GT.NMAX)NXX=NDR(NXX-NMAX)
              TM=DZM/(NXX-TQD)
              TM=TM*TM
              TN=DZA/NXX
              TN=TN*TN
              DO I=NTAR,2,-1
                DO J=I-1,1,-1
                  IF(ETAR(I)-ETAR(J)-TN*D0PT9.GE.DZERO)THEN
                    EMIN=MIN(EMIN,ETAR(I)-ETAR(J)-TM)
c                    write(0,*)n,i,j,emin
                    GO TO 824
                  ENDIF
                ENDDO
  824         ENDDO
            ENDDO
          ENDIF
C
          EMIN=EMIN*D0PT9
C          IF(LNEW.LT.0)EMIN=EMIN*D0PT9
          IF(EMIN.LT.D1M2*DZA2)EMIN=DZERO
        ENDIF
        IF((EMAX-EMIN).LT.D1M5)GO TO 820
      ENDIF
C
C SET UP ENERGY GRID FOR INTERPOLATION
C
      IF(.NOT.BTWO)GO TO 825
      BBC2=.TRUE.
      EMIN2=EMIN                            !TWO RANGES
      IF(EMAX2-EMIN2.LT.D1M5)THEN
        EMAX=EMAX2
        EMIN=EMIN2
        GO TO 820
      ENDIF
      IF(EMAX1-EMIN1.LT.D1M5)THEN
        EMAX=EMAX1
        EMIN=EMIN1
        GO TO 820
      ENDIF
      IF(EMIN2-EMAX1.LT.D1M5)THEN
        EMAX=EMAX2
        EMIN=EMIN1
        BTWO=.FALSE.
        GO TO 825
      ENDIF
c      write(6,*)'emin,emax1,2=',emin1,emax1,emin2,emax2
      MN2=MENG/2
      DD=MN2-1
      EMAX=EMAX1+DONE
      EMIN=EMIN1+DONE
      DO M=1,MN2
        DM=M-1
        T=EMAX/EMIN
        T=T**(DM/DD)
        DYY(M)=EMIN*T-DONE
      ENDDO
      IGAPE=MN2+1
      MN1=MN2
      MN2=MENG-MN2
      DD=MN2-1
      EMAX=EMAX2+DONE
      EMIN=EMIN2+DONE
      DO M=1,MN2
        DM=M-1
        T=EMAX/EMIN
        T=T**(DM/DD)
        DYY(MN1+M)=EMIN*T-DONE
      ENDDO
C
      GO TO 206
C
  825 CONTINUE                              !ONE RANGE (ALSO OPT. PI)
C
      IF(EMAX.LT.EMIN)GO TO 820
C
      IF(MENG.LE.1)THEN                     !CASE MXENG=1
        WRITE(6,605)-MENG,MXENG
        WRITE(0,*)'****ERROR IN SR.RADCON, REQUIRE AT LEAST TWO',
     X            ' INTERPOLATION ENERGIES'
        NF=-1
        GO TO 999
      ENDIF
      DD=MENG-1
      EMAX=EMAX+DONE
      EMIN=EMIN+DONE
      DO M=1,MENG
        DM=M-1
        T=EMAX/EMIN
        T=T**(DM/DD)
        DYY(M)=EMIN*T-DONE
      ENDDO
C
      GO TO 206
C
  820 WRITE(6,604)EMIN,EMAX
      WRITE(0,*)'****ERROR IN SR.RADCON, UNSUITABLE ENERGY RANGE'
      NF=-1
      GO TO 999
C
C READ USER SUPPLIED INTERPOLATION ENERGIES (RYD)
C
C
  208 READ(5,*)(DYY(I),I=1,MENG)
C
C
      IF(NF.LE.0)GO TO 999
C
      IF(BZSCLE)THEN
        DO I=1,MENG
          DYY(I)=DYY(I)*DZA2
        ENDDO
      ENDIF
C
      BBC2=.TRUE.
      IF(MENG.EQ.1)GO TO 206
C
C RE-ORDER INTO ASCENDING ENERGIES
C
      DO I=2,MENG
        IM=I-1
        IF(DYY(I).GT.DYY(IM))GO TO 205
        T=DYY(I)
        DYY(I)=DYY(IM)
        DYY(IM)=T
        IT=NREL
        IF(NREL.EQ.I)NREL=IM
        IF(IT.EQ.IM)NREL=I
        IF(IM.EQ.1)GO TO 205
C
        DO J=2,IM
          JM=I-J
          JJ=JM+1
          IF(DYY(JJ).GT.DYY(JM))GO TO 205
          T=DYY(JJ)
          DYY(JJ)=DYY(JM)
          DYY(JM)=T
          IT=NREL
          IF(NREL.EQ.JJ)NREL=JM
          IF(IT.EQ.JM)NREL=JJ
        ENDDO
  205 ENDDO
C
C DISCARD EQUAL ENERGY ENERGIES
C
      MX=MENG
      DO I=2,MX
        IF(I.GT.MENG)GO TO 206
        T=ABS(DYY(I)-DYY(I-1))
        IF(T.LT.D1M10)THEN
          IP=I+1
          DO J=IP,MENG
            DYY(J-1)=DYY(J)
          ENDDO
          MENG=MENG-1
          IF(NREL.GE.I)NREL=NREL-1
        ENDIF
      ENDDO
C
  206 IF((MION1-NZION.EQ.1.OR.MDEN.GT.0).AND.DYY(1).LT.D1M2)THEN
        IF(MION1-NZION.EQ.1)THEN
          WRITE(0,*)'*** RE-SETTING E=0 TO 1.D-2 FOR NEUTRALS...'
          WRITE(6,*)'*** RE-SETTING E=0 TO 1.D-2 FOR NEUTRALS...'
        ENDIF
        IF(MDEN.GT.0)THEN
          WRITE(0,*)'*** RE-SETTING E=0 TO 1.D-2 FOR NEUTRALIZATION...'
          WRITE(6,*)'*** RE-SETTING E=0 TO 1.D-2 FOR NEUTRALIZATION...'
        ENDIF
        DYY(1)=D1M2
      ENDIF
      IF(NREL.LT.1.OR.NREL.GT.MENG)THEN
        NREL=1
        IF(.NOT.BFOT)NREL=NREL+MENG/2
      ENDIF
C
      IF(DYY(1).EQ.DZERO.AND.MENG.EQ.NLAG)THEN          !WARNING
        WRITE(0,*)'*** WARNING SR.RADCON: CHECK INTERPOLATION ACCURACY'
        WRITE(6,250)MENG,NLAG
      ENDIF
C
C SET SWITCH-OVER POINT FROM DOWN TO UPSCALING FOR RYD.
C
      IF(BFOT.AND.BDR)THEN
        IF(MXEP.GT.MENG)THEN
          MXEP=MENG
        ELSEIF(MXEP.LT.0)THEN
          ETEST=50*(DZA/(NSW-1))**2
          DO I=1,MENG
            IF(DYY(I).GT.ETEST)GO TO 207
          ENDDO
          I=MENG
  207     MXEP=I
        ENDIF
      ENDIF
C
C CONVERT FROM RYDBERGS TO ATOMIC UNITS FOR STRUCTURE BRANCH.
C
      DO I=1,MENG
        DYY(I)=DYY(I)/DTWO
      ENDDO
C
C SET-UP R-MATRIX CONTINUUM BASIS PARAMETRIC POTENTIAL
C (NOTE DIFFERENT NPOT FLAGS FROM STG1 - JUST USE ACTUAL TFDAPO,
C                                        CASE NPOT(RM)<0)
C
      IF(NPOT.GT.0)THEN                                        !STO-FORM
        IF(NPOT.GT.6)THEN
          WRITE(0,801)NPOT
          WRITE(6,801)NPOT
          NF=-1
          GO TO 999
        ENDIF
        READ(5,*)(IPOT(I),I=1,NPOT)
        READ(5,*)(CPOT(I),I=1,NPOT)
        READ(5,*)(XPOT(I),I=1,NPOT)
      ELSEIF(NPOT.LT.0)THEN              !NUMERICAL, *NOT* SCALED TFDAPO
        NELCOR=MION1-1
        NPOT=1
        CPOT(1)=2*NELCOR
        XPOT(1)=NZION
        XPOT(1)=XPOT(1)**DTHIRD
        IPOT(1)=-1
        IF(NZION.GT.NELCOR)THEN
          NPOT=2
          CPOT(2)=(NZION-NELCOR)*2
          XPOT(2)=DZERO
          IPOT(2)=-1
        ENDIF
      ENDIF
      IF(NPOT.GT.0)THEN
        WRITE(6,800)NPOT
        WRITE(6,802)(IPOT(I),I=1,NPOT)
        WRITE(6,803)(CPOT(I),I=1,NPOT)
        WRITE(6,804)(XPOT(I),I=1,NPOT)
      ENDIF
C
      IF(DHNSX.LT.DZERO)GO TO 999                 !NOT YET SET SO RETURN
C
C-----------------------------------------------------------------------
C
C RE-ENTRY POINT
C
 1000 CONTINUE
C
C TEST RADIAL MESH FOR INTEGRALS INVOLVING CONTINUUM FUNCTIONS
C
      DRY=2*DYY(MENG)                                !AS DYY IN A.U. NOW
      T=SQRT(DRY)
      IF(T.NE.DZERO)THEN
        T=PI/T
        T=T/DHNSX
        IF(T.LT.DTWELV)THEN
          IF(T.LT.DSIX)THEN
            M0=MSTEP+1
            WRITE(6,1222)DRY,M0
            WRITE(0,*)'RADIAL MESH TOO COARSE'
            NF=-1
            GO TO 999
          ELSE
            IF(BFOT)THEN
              M0=MSTEP+1
              WRITE(6,1223)DRY,M0
              IF(DRY.GT.DFOUR*DZA2)THEN
                WRITE(0,*)'RADIAL MESH TOO COARSE'
                NF=-1
                GO TO 999
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
C
      IF(BFOT)THEN        !INITIALIZE FOR GAUGE
        DO I=1,MENG
          IGAG(I)=1
        ENDDO
      ENDIF
C
      MYMO=MYM            !FOR ANNOYING COMPILERS
      MYNO=MYN
      MPO=MP
C
      DUM=NDUM*DUM        !SUPRESS WARNINGS ABOUT UNUSED DUMMY VARIABLES
C
  999 RETURN
C
  998 WRITE(6,1997)
      WRITE(0,*)'*** SR.RADCN0: ERROR READING NAMELIST SRADCON!'  !FATAL
      NF=-1
      GO TO 999
C
C
  250 FORMAT(//'*** WARNING SR.RADCON: CHECK INTERPOLATION ACCURACY ***'
     X/4X,'THE NUMBER OF INTERPOLATIONS ENERGIES (MENG=',I3,') IS'
     X,' LIKELY TOO SMALL FOR THE LAGRANGE ORDER (NLAG=',I2,')'//)
  251 FORMAT(  ' TOO MANY INTERPOLATION ENERGIES REQUESTED: REDUCE MENG'
     X,' OR INCREASE MXENG FROM',I5,' TO',I5/)
  333 FORMAT('*** WARNING SR.RADCON: INTERNAL PI ENERGY MESH TRUNCATED'/
     X       4X,'EMAX=',1PD12.2,' INCREASE MXENG TO:',I3,
     X      ' TO OBTAIN FULL ENERGY MESH, E.G. FOR RATE COEFFICIENTS')
  590 FORMAT(2F10.1,2I5,F10.4,5I5)
C 591 FORMAT(7F10.4)
  593 FORMAT('  YOUR VALUE OF',I3,' FOR MODE IN SR.RADCON IS NOT WITHIN'
     X,' THE CURRENT VALID RANGE')
  604 FORMAT(/' ****ERROR IN SR.RADCON, UNSUITABLE ENERGY RANGE FOR ',
     X'INTERPOLATION, EMIN=',F10.4,3X,'EMAX=',F10.4/)
  605 FORMAT('****ERROR IN SR.RADCON, REQUIRE AT LEAST TWO',
     X            ' INTERPOLATION ENERGIES BUT MENG=',I4/
     X            ' DIMENSION PROBLEM? MXENG=',I6)
  606 FORMAT(/' ***ERROR, MUST SPECIFY NON-ZERO MENG ENERGIES FOR DR')
  607 FORMAT(/'*** UNRECOGNIZED PI GAUGE: PIG=',A3)
  713 FORMAT('*** SR.RADCON: REQUESTED MAX PI ENERGY TOO LARGE'/
     X'*** EITHER REDUCE EMAX TO .LT.',1PD11.2/
     X'*** OR INCREASE DIMENSION PARAMETER MXENG'/
     X'*** OR INPUT  0 .LT. MENG .LE. MXENG  ENERGIES EXPLICITLY')
  800 FORMAT(/' SR.RADCON: PARAMETRIC POTENTIAL NPOT =',I3)
  801 FORMAT(/' SR.RADCON: NO. OF PARAMETRIC POT COEFFS MUST BE .LE. 6;'
     X,' NPOT=',I3)
  802 FORMAT (' IPOT=',9I12)
  803 FORMAT (' CPOT=',9F12.7)
  804 FORMAT (' XPOT=',9F12.7)
  990 FORMAT(I9,I2,I5,F18.6,3X,A4)
  991 FORMAT(3I2,I5,I5,F18.6,3X,A4)
  992 FORMAT(2I2,1X,I3,I2,2I5,F18.8,3X,A4)
 1222 FORMAT(/' SR.RADCON: EMAX=',1PD9.2,' MESH TOO COARSE, BOUND-',
     X'CONTINUUM INTEGRALS IN ERROR.'/'*** REDUCE EMAX IN NAMELIST ',
     X'SRADCON OR INCREASE MSTEP TO',I3,' IN NAMELIST SMINIM')
 1223 FORMAT(/' SR.RADCON: WARNING, EMAX=',1PD9.2,' MESH MAYBE TOO '
     X,'COARSE, BOUND-CONTINUUM INTEGRALS MAYBE IN ERROR.'
     X/' *** TRY REDUCING EMAX IN NAMELIST SRADCON OR INCREASING MSTEP '
     X,'TO',I3,' IN NAMELIST SMINIM')
 1997 FORMAT('*** SR.RADCN0: ERROR READING NAMELIST SRADCON!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
C
      END SUBROUTINE RADCN0
C
C                             *******************
C
      SUBROUTINE RADCNX(FRX,PSHFTX,PSHFT0,MDIM1,MDIM2,MDIM3,LNEW,LOLD
     X          ,LCDW,MPOSC0)
C
C-----------------------------------------------------------------------
C
C  SR.RADCNX CALCULATES/UPDATES THE DEIE DW CONTINUUM BASIS
C
C  IT CALLS:
C    SR.FCF6
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
c      use common_nrbdqe, only: dqnl
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3),PSHFT0(0:*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
C      COMMON /COM3/DDY,DZ,TM                    !SET IN FCF6 FOR PMVDAR
c      common /com6/da(maxb1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBFR/GR(MAXB1)
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      BPRNT0=JPRINT.GE.3                      !FOR DETAILED PRINTOUT
c      BPRNT0=JPRINT.NE.-3
      BORT=MORT.LT.0
      IORT=ABS(MORT)
      BREL2=ABS(IREL).EQ.2
      BTHRSH=LCDW.LT.0
      IF(BTHRSH)LCDW=-LCDW
C
C FOR TOTAL LNEW THERE ARE LCDW CONTINUUM ORBITAL ANGULAR MOMENTA
C OF LNEW-LCDW/2 THRU LNEW+LCDW/2.
C QPOS(L), L=1,LCDW GIVE THE LOCATION OF THE ASSOCIATED ANG. MOM.
C ORBITAL. THIS ENABLES US TO RE-USE ANY COMMON ORBITALS FROM LOLD.
C THUS, SHOULD GROUP ALL S,PI TOGETHER FOR A GIVEN LTOT AND LOOP
C OVER LTOT SEQUENTIALLY, AS IS DONE BY USE OF MINLT,MAXLT.
C
      MPOSC=ABS(MPOSC0)
      MPOSQ=(LCDW+1)/2-LNEW
C
      IF(LOLD.LT.0)THEN             !FIRST TIME
        DO L=1,LCDW
          I=MPOSC+L
          QPOS(L)=L
          QN(I)=-90
C          IVAL(I)=0                !NOT USED
C          DORIG(I)=DZERO           !NOT USED
C          DUY(I,I)=DZERO           !NOT USED: DEY HOLDS ENERGY
          DEY(I)=DZERO
          SCREEN(I)=DZERO           !SHOULD NOT BE USED
        ENDDO
        IFLAG=0
      ELSE
        DO L=1,LCDW
          QPOS0(L)=ABS(QPOS(L))
          QPOS(L)=0
        ENDDO
        ML=-2*(MPOSQ-1)
        MU=2*(LNEW+LCDW/2)
        DO L=1,LCDW
          I=MPOSC+L
          IF(QL(I).GE.ML.AND.QL(I).LE.MU)THEN         !RE-USE
            K=MPOSQ+QL(I)/2
            QPOS(K)=-QPOS0(L)                         !FLAG OLD
          ELSE
            QPOS0(L)=-QPOS0(L)                        !NOT WANTED
          ENDIF
        ENDDO
        IFLAG=1
      ENDIF
C
C-----------------------------------------------------------------------
C
      MYL2=-2*MPOSQ
C                                   !LABEL & FLAG EXISTENCE
      DO L=1,LCDW
        I=MPOSC+L
        MYL2=MYL2+2
        QL(I)=MYL2
        IF(QPOS(L).EQ.0)THEN                          !NEW
          IFLAG=0
          DO K=1,LCDW                                 !LOOK FOR SPACE
            IF(QPOS0(K).LT.0)THEN
              QPOS(L)=-QPOS0(K)
              QPOS0(K)=0
              GO TO 100
            ENDIF
          ENDDO
          WRITE(6,*)' SR.RADCNX: QPOS INDEX ERROR...'
          WRITE(0,*)' SR.RADCNX: QPOS INDEX ERROR...'
          NF=-1
          GO TO 999
        ENDIF
  100   CONTINUE
c        write(0,*)i,l,qpos(l),ql(i),myl2             !debug print
      ENDDO
C
      IF(IFLAG.NE.0)GO TO 999                         !QUICK RETURN
C
C-----------------------------------------------------------------------
C
C NOW GENERATE UPDATED CONTINUUM BASIS FOR QPOS(L).GT.0, L=1,LCDW
C
C-----------------------------------------------------------------------
C
      IF(BPRNT0)THEN
        IF(MPOSC0.GT.0)THEN
          WRITE(6,998)LNEW
        ELSE
          JNEW=2*LNEW+MOD(LCDW+1,ITWO)
          WRITE(6,996)JNEW       !ASSUMES USER HASN'T RESTRICTED LCONDWJ
        ENDIF
      ENDIF
C
      NZA=NZION-MION
c      DZ=NZION
      DZ0=-NZION                              !CHARGES .LT. ZERO IN FCF6
      DZA=-NZA
      DD0=DZERO
C
      MK=MXORB+1                               !NOMINAL ORBITAL POSITION
      IF(BORT)THEN                               !FIND SCALING PARAMETER
        IC=MIN(NPARAM,MK)                              !NPARAM=MK NOW...
      ELSE
        IC=NPARAM
      ENDIF
      DJ=DADJUS(IC)
      MEND=JEND(IC)
      MZNM=5                            !MAX NON-REL ORB POTL PARAMETERS
C
      DO L=1,LCDW
C
        I=MPOSC+L
        MYL=QL(I)/2
C
        L0=QPOS(L)
C
        IF(L0.GT.0.AND.MYL.GE.0)THEN
C
          DO M=1,MENG
C
            DDY=DYY(M)
C
            IF(DJ.GT.DZERO.OR.IORT.EQ.2.OR.BREL)THEN    ! DW
C
              CALL FCF6(FRX(1,M,L0)
     X                 ,DP0,TM,MYL,DDY,DZ0,DZA,DD0,DD0,DD0,ZS,MZNM
     X                 ,DPOT,MEND,DNUK,MJH,MNH,DHNS,DX,GR,MAXRS)
C
              IF(MYL.LT.0)THEN
                WRITE(6,*)'*** FCF6 FAILURE...'
                WRITE(0,*)'*** FCF6 FAILURE...'
                NF=-1
                GO TO 999
              ENDIF
c
c test
c              do k=1,mxorb
cc
c                if(2*myl.ne.ql(k))go to 63
c                if(dorig(k).eq.dzero)go to 63
cc
c                if(brel2)then
c                  do i=1,maxrs
c                    da(i)=dpnl(i,k)*frx(i,m,l0)+dqnl(i,k)*gr(i)
c                  enddo
c                else
c                  do i=1,maxrs
c                    da(i)=dpnl(i,k)*frx(i,m,l0)
c                  enddo
c                endif
cc
c                call weddle(dzero,da,dd,mnh,dhns,mjh,maxrs)
cc
c                if(brel2)then
c                  do i=1,maxrs
c                    frx(i,m,l0)=frx(i,m,l0)-dd*dpnl(i,k)
c                    gr(i)=gr(i)-dd*dqnl(i,k)
c                  enddo
c                else
c                  do i=1,maxrs
c                    frx(i,m,l0)=frx(i,m,l0)-dd*dpnl(i,k)
c                  enddo
c                endif
cc
c 63           enddo
C
              IF(BREL2)THEN
                DO I=1,MAXRS
                  FRX(MAXRS+I,M,L0)=GR(I)
                ENDDO
              ENDIF
C
            ELSE                                        !COULOMBIC
C
              CALL FCF4(FRX(1,M,L0)
     X                 ,DP0,DDY,DZA,MYL,MJH,MNH,DHNS,DX)
C
              TM=DZERO
C
            ENDIF
C
            PSHFTX(M,L0)=TM
C
            IF(BPRNT0)WRITE(6,997)MYL,DDY,TM
C
          ENDDO
C
          IF(BTHRSH)PSHFT0(MYL)=PSHFTX(1,L0)
C
        ENDIF
C
      ENDDO
C
C
  999 RETURN
C
  998 FORMAT(//' *** UPDATING CONTINUUM ORBITAL BASIS FOR LTOT=',
     X       I3/1X,49('-')/)
  997 FORMAT(' L=',I2,3X,'E=',F10.5,' RYD',3X,'DEL/PI=',F9.4)
  996 FORMAT(//' *** UPDATING CONTINUUM ORBITAL BASIS FOR 2*JTOT=',
     X       I3/1X,51('-')/)
C
      END SUBROUTINE RADCNX
C
C                             *******************
C
      SUBROUTINE RADCON(MAXPS)
C
C-----------------------------------------------------------------------
C
C              N.R.BADNELL  D.A.M.T.P. CAMBRIDGE
C              *********************************
C
C  SR.RADCON DETERMINES A SET OF RADIAL CONTINUUM FUNCTIONS.
C
C  MODE=1, SUPERSTRUCTURE MODE.
C  MODE=2, SETS C-C INTERACTIONS TO ZERO, STORES B-C SEPARATELY AND
C            SETS THEM TO ZERO IN H BEFORE DIAGONALIZATION.
C  MODE=3, ALL B-B, B-C AND C-C INTERACTIONS EVALUATED AND PUT IN
C            H FOR DIAGONALIZATION.
C  MODE=4, NOT USED BY RADCON, RADIAL SHIFTS ENERGIES OF CERTAIN
C               BOUND ORBITALS TO SUPRESS MIXING.
C
C  IT IS CALLED BY:
C    SR.RADIAL
C
C  IT CALLS:
C    SR.DIFF
C    SR.DIMUSE
C    SR.FCF4
C    SR.FCF6
C    SR.FIT
C    SR.RK4PI
C    SR.FSINTI
C    SR.POTF
C    SR.SLATRI
C    SR.STOPOT
C    SR.TFDAPO
C    SR.VMPOT
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: QSS
      USE COMMON_DXRL,   ONLY: QRL,IRL
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBFSI, ONLY: DNLI,NLI,IXFSS
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2,IXFSL
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
      USE COMMON_NRBTS1, ONLY: IXD24
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      PARAMETER (MXD12=100)
C
      PARAMETER (DTOL=0.01D0)
      PARAMETER (D99=99.0D0)
C
      CHARACTER(LEN=4) MCF4,MCF6,MCF
      CHARACTER(LEN=14) F588
C
      ALLOCATABLE  :: DORIGZ(:)
C
      DIMENSION MNH0(20)                    !SYNC. WITH /CRAD/ & SR.MESH
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CADJ/DAJNEW(MXVAR),DF0,IEQUAL(MXVAR),IDUM !USE ONLY DAJNEW
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DL2(MAXB1),TOL,MEND
      COMMON /COM3/DDY,DZ,TM
      COMMON /COM6/DA(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBCOR/ECOR1,ECOR2,ECORR,ECORRJ,ESKPL,ESKPH,BECOR
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBPOT/POT(MAXB1,MXPOT),JPOT1
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /PARPOT/CPOT(6),XPOT(6),IPOT(6),NPOT
C
      DATA MCF6/'FCF6'/,MCF4/'FCF4'/,IDERV/0/
C
      IF(NF.LE.0)GO TO 70
C
      ALLOCATE (DORIGZ(MXORB))          !LOCAL
C
C SOME INITIALIZATIONS
C
      PI=ACOS(-DONE)
      PIH=PI/DTWO
C
      MRP=10+1                          !SCRATCH UNIT
      MR5=5
C
      MION1=NW+NF                !TOTAL NUMBER OF ELECTRONS (=MION+MRED)
      NZA=MAX(NZION-MION1+1,IONE)       !CHARGES
      DZ=NZION
      DZ0=-NZION                        !CHARGES .LT. ZERO IN FCF6
      DZA=MION1-NZION-1
      DZA2=NZA*NZA                   !=DZA*DZA EXCEPT CASE DZA=0, THEN 1
      TOLR=D1M6/NZA
C
      MB0=MB
      IF(IEQ(0).LT.0)MXBORB=-IEQ(0)     !FOR NON-UNIQUE BASIS
      IF(IEQ(0).GT.0)THEN               !UNPACK
        IF(IRLX.LT.0)MB0=0
        ID=IEQ(0)-MXORB
        NGRP=ID/100000
        ID=ID-100000*NGRP
        MXFORB=ID/10000
        ID=ID-10000*MXFORB
        MXVORB=ID/1000
        ID=ID-1000*MXVORB
        MXBORB=ID
c       write(0,*)ngrp,mxborb,mxvorb,mxforb
      ENDIF
C
      BDR=IDR.NE.0                      !LOGICALS
      BCONT=MODE.EQ.2.OR.MODE.EQ.3
      BHF=MHF.GT.0
      IF(BJUMPR)BREL=.FALSE.            !BJUMPR=.FALSE. FIXED IN RADIAL
      BREL2=ABS(IREL).EQ.2
      BORT=MORT.LT.0
      IORT=ABS(MORT)
      BKUTOO=KUTOO.NE.0
      BXTRP=.FALSE.
      BPRNT0=JPRINT.NE.-3
C
      MYN=1                             !MESH PRINTOUT
      MYM=-1
      II=1
      MP=-1
C
      MZNM=5                            !POTENTIAL PARAMETERS
CTEST     MEND=0
      JPOT=-1
      DJ=DZERO
      TOL=DONE/10**ITOL
      INUKP=INUK+1                      !FOR FINITE NUCLEUS
      NP0=0
      IF(IPOLFN.LT.0)NP0=-IPOLFN
C      NPARM3=(NP0+1)*NPARAM
C
      MPP=1                             !PLASMA POTENTIAL
      IF(MDEN.LT.0)MPP=2
      MDEN10=MOD(MDEN,ITEN)
      ZNP0=-D99
C
      TM=DONE                           !OLD PHASE - NEEDED?
      MINK=0                            !OLD E SHIFT - COULD REMOVE USE
      MSHIFT=10000
C
      KK=0                              !INTERPOLATION COUNTERS
      KFS=0
      M8=0
C
C SEE WHICH ORBITALS TO COMPUTE
C
      K0=-1
      KSTORE=0
      MAXL=0
      IVM=100000
      IVP=0
C
      DO K=1,MXORB
        DORIGZ(K)=DZERO
        IF(DEY(K).NE.DZERO)THEN
          IF(IVAL(K).GT.0)THEN
            IF(K.GT.IVP)IVP=K
            IF(K.LT.IVM)IVM=K
          ENDIF
          IF(SCREEN(K).LT.5999)THEN     !BOUND (CORE)
            DORIGZ(K)=DORIG(K)*DZ
          ELSE
            IF(K0.LT.0)K0=K
            IF(SCREEN(K).LT.7999)THEN   !RYDBERG
              BXTRP=.TRUE.
              KSTORE=K                  !NSTORE=QN(K)
              IF(QL(K).GT.MAXL)MAXL=QL(K)
            ENDIF
          ENDIF
        ENDIF
      ENDDO
C
      IF(K0.LT.0)GO TO 133   !NO NEW ORBITALS TO CALC, RECOVER FROM FILE
      MAXL=1+MAXL/2
C
      IF(BJUMP.OR.MODE.EQ.1)GO TO 113       !NOT FIRST TIME, SKIP SET-UP
C
C READ USER INPUT AND SET-UP ENERGY MESH BASED-ON THIS, OR BEST GUESS
C
  70  CALL RADCN0(MYM,MYN,MP,DHNS(MJH))
C
      IF(NF.LE.0)GO TO 1000                                      !RETURN
C
      BLAG=MENG.GT.1
C
C INITIALIZE CONTUNUUM INTERPOLATION INTEGRAL ARRAYS
C
C *** SLATER (2-BODY NON-FINE STRUCTURE USE SLATER SWITCH SO NOT NECESS)
C
      DO J=1,IXFSL
        DO I=1,MENG
          DRLI(I,J)=DZERO
        ENDDO
      ENDDO
C
C *** 2-BODY FINE-STRUCTURE
C
      IF(NL000.GT.0)THEN
        DO J=1,IXFSS
          DO I=1,MENG
            DNLI(I,J)=DZERO
          ENDDO
        ENDDO
      ENDIF
C
C RE-ALIGN FINITE NUCLEUS FOR FCF6
C
      DO I=1,INUK
        DNUK(I)=DTWO*(DNUK0(I)-DZ/DX(I))
      ENDDO
C
      ZS(0)=DTWO*ZS0(0)
      IF(BREL)THEN
        DO J=1,JZNM                         !JZNM.LT.MZMN
          ZS(J)=DTWO*ZS0(J)
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C FOR CONTINUUM WAVEFUNCTION WE DROP ALL POINTS PAST INPUT MAXPS
C SINCE ALL INTEGRALS P*F, P*P SHOULD HAVE CONVERGED BY THEN.
C
C HOWEVER, IF BXTRP=TRUE (RYDBERG APPROX BY A CONTINUUM) THEN NEED TO
C EVALUATE OUT TO POINT WHERE  AMP. PHASE CAN BE USED, FOR WORST CASE
C E=0, L=MAXL, AND RESET MAXPS ACCORDINGLY.
C
C ALSO, IF BDR=TRUE THEN MUST EVALUATE ALL ORBITALS OUT TO X(MAXRS0)
C WITH ORIGINAL GRID MJH->MJH0, MNH->MNH0, MAXRS->MAXRS0.
C
C HOWEVER, INTEGRALS STILL NEED ONLY BE EVALUATED OUT TO MAXPS.
C N.B. WE NEED TO ALIGN MAXPS->MAXRS WITH MJH, MNH SINCE WE HAVE
C 2-BODY INTEGRALS (SR.YLAMK), UNLIKE RADIAL WHERE WE ONLY USE WEDDLE.
C SO WE BACK-UP AND TRUNCATE THE GRID MJH, MNH AT THIS POINT, RATHER
C THAN AT THE END WHEN WE NO LONGER NEED ORIGINAL (HENCE SET MJH0, MNH0)
C
 113  IF(BXTRP)THEN
        DTH=3*MAXL*(MAXL+1)+60
        DD0=DTH/(DTWO*SQRT(DZA2))
        dd0=max(dd0,rzero)
C
        DO I=1,MAXRS
          IF(DX(I).GT.DD0)THEN
            IF(I.GT.MAXPS)MAXPS=I
            GO TO 202
          ENDIF
        ENDDO
        MAXPS=MAXRS
      ENDIF
C
 202  DHNS0=DHNS(1)
      MJH0=MJH                                   !BACK-UP ORIGINAL
      MAXTS=MAXPS                      !MAX BOUND ORB EXTENT FROM RADIAL
      IF(BDR)THEN
        IF(.NOT.BJUMP)THEN
          MAXTS=MAXRS
        ELSE
          IF(BREL)MAXTS=MAXRS                    !AS NO DARWIN IN WHITEX
        ENDIF
      ENDIF
      IF(DENE.GT.DZERO)MAXTS=MAXRS               !PLASMA POT MAY EXPAND
      MAXRS0=0
C
C SEE IF WE CAN TRIM INPUT MESH (MJH0<-MJH, MNH0<-MNH, MAXRS0<-MAXRS)
C
      DO I=1,MJH0
        MNH0(I)=MNH(I)                           !BACK-UP ORIGINAL
        MAXRS0=MNH0(I)+MAXRS0
        MJH0=I
        IF(MAXRS0.EQ.MAXTS)GO TO 18              !MAXIMAL MESH FOR CONT.
        IF(MAXRS0.GT.MAXTS)THEN
          MAXRS0=MAXRS0-MNH0(I)
          nxtra=9
c          if(.not.bsto)nxtra=max(nxtra,2*mnh(i-1))                !test
          MNH0(I)=MAX(MAXTS-MAXRS0,nxtra)
          MAXRS0=MAXRS0+MNH0(I)
          GO TO 18
        ENDIF
      ENDDO
C
C SET-UP MESH FOR INTEGRALS (FINAL TRUNCATION OF MJH, MNH, MAXRS)
C
  18  MAXTS=MAXPS
      MAXPS=0
      DO I=1,MJH0
        MAXPS=MNH(I)+MAXPS
        MJH=I
        IF(MAXPS.EQ.MAXTS)GO TO 111            !MAX NEEDED FOR INTEGRALS
        IF(MAXPS.GT.MAXTS)THEN
          MAXPS=MAXPS-MNH(I)
          MNH(I)=MAX(MAXTS-MAXPS,ININE)       !since for integrals only
          MAXPS=MAXPS+MNH(I)
          GO TO 111
        ENDIF
      ENDDO
C
  111 MAXRS=MAXPS                              !TRUNCATE
C
      IF(MYN.LT.0)WRITE(6,250)MAXRS,MAXRS0
C
C-----------------------------------------------------------------------
C
C START LOOP TO EVALUATE ALL CONTINUUM ORBITALS
C
 72   DO K=K0,MXORB
        IF(DORIGZ(K).EQ.DZERO.AND.DEY(K).NE.DZERO)THEN
          N=K
          MI=QN(N)
          QN(N)=-ABS(MI)
          MYL=QL(N)/2
          MNN=-QN(N)
          DDY=DZERO
          IF(SCREEN(N).LT.7999)GO TO 444
C WE USE IMPLICIT DSHIFT VIA INTERPOLATION TO AVOID RECOMPUTING CONT.
C TEST EXPLICIT DSHIFT (FOR FIRST N ONLY!) BY COMMENTING-OUT IF(BDR).
          IF(BDR)GO TO 69
          IF(BXTRP)THEN                   !EXPLICIT ON CONTINUUM N
            if(kstore.eq.0)stop'kstore=0...'
            DDY=2*QN(KSTORE)*QN(KSTORE)
            DSHIFT(N)=DZA*DZA/DDY         !A.U. (HYDROGENIC)
            write(*,*)'explicit shift: ',n,dshift(n),k,dshift(kstore)
            DSHIFT(KSTORE)=DZERO          !ZERO-OUT RYD IMPLICIT
          ENDIF
          GO TO 69
        ENDIF
      ENDDO
C
      IF(BJUMP)GO TO 133
      GO TO 138                           !NO CONTINUUM TO CALCULATE
C
  69  IYY(N)=1
      IYY(IEQ(N))=1                       !IEQ(0).GT.0 NOT IN GROUP 1
C
      DDY=2*DYY(NREL)                     !A.U. TO RYD
      IF(DDY.LE.DZERO)THEN                !CHECK FOR NON-NEGATIVE ENERGY
        IF(DDY.LT.-D1M40)THEN
          WRITE(6,401)N,DDY
          IF(N.EQ.MXORB)GO TO 138
          GO TO 72
        ENDIF
        DDY=D1M50
      ENDIF
C
      DDY=DDY+DTWO*DSHIFT(N)
C
  444 DD0=DZERO
      K0=N+1
      IF(K0.GT.MXORB)K0=N
C
      IF(.NOT.BORT)THEN                       !HISTORIC L-DEPENDENT POTS
        JOLD=JPOT
        JPOT=MYL+1
        IF(JPOT.GT.MXPOT)JPOT=MXPOT
        IF(JPOT.EQ.JOLD)GO TO 99
        DJ=DAJNEW(JPOT)
        MEND=JEND(JPOT)
        GO TO 618
      ENDIF
C
      DADJUS(N)=DAJNEW(N)
      JEND(N)=MEND                      !CASE RYD LAMBDA NL.NE.CONTINUUM
C
      IF(BDR.and.ieq(0).eq.0)THEN
        IF(.NOT.BSTO.OR.DDY.LE.DZERO)THEN
          IF(DAJNEW(N).EQ.DJ)GO TO 99
          IF(JPOT1.GT.0.AND.ABS(DX(MAXRS0)*POT(MAXRS0,1)+DZA)
     X                                                     .LT.D1M2)THEN
           IF(DAJNEW(N).EQ.DAJNEW(JPOT1))THEN    !WE HAVE A POTL
            JPOT=1
            DJ=DAJNEW(N)
            MEND=JEND(N)
            GO TO 618
           ENDIF
          ENDIF
        ENDIF
      ENDIF
C
      IF(.NOT.BSTO.AND.DAJNEW(N).EQ.DJ.AND.IPOLFN.eq.0
     x                                )GO TO 99 !.and.mden.le.0
      IF(BSTO.AND.N*MCFMX.GT.MCFMX**2.AND.DJ.NE.DZERO)GO TO 99
C
      DJ=DAJNEW(N)
      DJ0=DJ
      IF(.NOT.BSTO)THEN
        DJ1=DONE
        DJ2=DONE
        IF(NP0.GT.0)DJ1=DAJNEW(NPARAM+N)
        IF(NP0.EQ.2)DJ2=DAJNEW(2*NPARAM+N)
      ENDIF
C
      JPOT=2
      CALL DIMUSE('MXPOT',JPOT)
C
      IF(NPOT.GT.0)THEN               !USE R-MATRIX PARAMETRIC POTENTIAL
        CALL POTF(-DZA,MAXRS0,DX,POT(1,JPOT),DTOL,MEND)
        JEND(N)=MEND
        WRITE(6,776)QN(N),MYL,DONE,MEND,DX(MEND)
        GO TO 618
      ENDIF
C
      MK=N
      MMM=MION1
      DS=DZ
      IF(DJ.GT.DZERO)GO TO 611
      IF(IORT.EQ.2)GO TO 611
      IF(BREL)GO TO 611
C
C FOR HYDROGENIC WAVE FUNCTIONS:  USE FOLLOWING POTENTIAL CALL:
C
      DS=DZA
      MMM=1
      DJ0=DONE
C
  611 IF(.NOT.BSTO)CALL TFDAPO(DS,MMM,MK,DJ0,DJ1,DJ2,DHNS0,MAXRS0,MJH0
     X                ,MNH0,DHNS,DX,POT(1,JPOT),TOL,MEND,CRRCT1,CRRCT2)
C
      IF(BSTO)CALL STOPOT(DS,MMM,MK,DJ0,DHNS0,MAXRS0,MJH0,MNH0,DHNS,DX
     X                   ,POT(1,JPOT),DTOL,MEND,MPP)
C
      IF(NF.LE.0)GO TO 1000                                    !RETURN
C
      IF(DHNS(1).NE.DHNS0)THEN
        WRITE(6,710)MSTEP+1
        GO TO 999
      ENDIF
C
      JEND(N)=MEND
      IF(BPRNT0)THEN
        IF(BHF)WRITE(6,773)QN(N),MYL,MHF,MEND,DX(MEND)
        IF(.NOT.BSTO.AND..NOT.BHF)THEN
          IF(IEQ(0).EQ.0)THEN
            WRITE(6,774)QN(N),MYL,DJ,MEND,DX(MEND)
            IF(NP0.GT.0)WRITE(6,1774)1,DJ1-DONE,CRRCT1              !DJ1
            IF(NP0.EQ.2)WRITE(6,1774)2,DJ2-DONE,CRRCT2              !DJ2
          ELSE
            WRITE(6,2774)N,IGRCF(N),QN(N),MYL,DJ,MEND,DX(MEND)
          ENDIF
        ENDIF
        NP=N
        IF(MCFMX.GT.0)NP=MIN(N,MCFMX)
        IF(BSTO.AND..NOT.BHF)WRITE(6,775)QN(N),MYL,MCFSTO(NP),DJ,MEND
     X  ,DX(MEND)
      ENDIF
C
C RE-ENTRY POINT IF USING A (DIFFERENT) PRE-EXISTING POTENTIAL
C
 618  CONTINUE
C
      DO I=1,MAXRS0
        DL2(I)=POT(I,JPOT)
      ENDDO
C
C ADD-IN ANY MODEL POTENTIAL (PLASMA, POLARIZATION, C60 ETC)
C
      ZNP=DX(MAXRS0)*DL2(MAXRS0)
C
      MML=MYL
CORE              IF(BORT.AND.IEQ(MK).GE.MA.AND.IEQ(MK).LE.MB)MML=-MML
      IF(MDEN.GT.2.AND.MPP.GT.1)ZNP0=ZNP
C
      CALL VMPOT(ZNP,MML,MAXRS0,DX,DZ,MAXRS,MPP,-MK,MXORB)
C
      IF(NF.LE.0)GO TO 1000                                     !FAILURE
C
      IF(MDEN.GT.2)MPP=MPP+1
C
      IF(BFOT.AND.IDERV.EQ.0)THEN
        IDERV=1
        CALL DIFF(POT(1,JPOT),DERV,MNH0,DHNS,MJH0)
      ENDIF
C
C NOTE DIFFERENCE OF /COM1/DL2 POTENTIAL TO SR.RADIAL/RADWAV USE
C
      DO I=1,MAXRS0
        DL2(I)=DL2(I)-DZ/DX(I)                           !SUBTRACT POINT
        DL2(I)=DL2(I)+DL2(I)
      ENDDO
C
      IF(BREL)THEN
C
        DO I=1,MAXRS0
          DA(I)=DL2(I)
          DA(I)=DA(I)+DTWO*VSC(I)                        !+PLASMA POT
        ENDDO
C
C SET-UP POTENTIAL DERIVATIVES FOR DARWIN
C
        CALL DIFF(DA,DERV1,MNH0,DHNS,MJH0)
        CALL DIFF(DERV1,DERV2,MNH0,DHNS,MJH0)
C
        DO I=INUKP,MAXRS0                                !ADD POINT BACK
          T=DX(I)**2
          DERV1(I)=DHALF*DERV1(I)-DZ/T
          DERV2(I)=DHALF*DERV2(I)+DTWO*DZ/(T*DX(I))
        ENDDO
C
C ADD-IN FINITE NUCLEUS
C
        DO I=1,INUK
          DERV1(I)=DHALF*DERV1(I)+DNUK1(I)
          DERV2(I)=DHALF*DERV2(I)+DNUK2(I)
c          write(6,*)i,dx(i),dnuk(i),derv1(i),derv2(i)
        ENDDO
C
      ELSE
C
        M1=0
        DD=DZERO
C
        CALL FIT(DD,M1,DHNS(1),DL2,ZS(1))
C
        IF(RNUK.GT.DZERO)THEN                 !ADD-IN FINITE NUCLEUS
          DO J=1,JZNM                         !JZNM.LT.MZMN
            ZS(J)=ZS(J)+DTWO*ZS0(J)
          ENDDO
        ENDIF
C
      ENDIF
C
C RE-ENTRY POINT IF POTENTIAL UNCHANGED FROM PREVIOUS CALL TO FCF6
C
  99  IF(DJ.GT.DZERO.OR.IORT.EQ.2.OR.BREL)THEN     !DW
C
c        MEND=JEND(N)
        if(bort.and.mend.ne.jend(n))stop 'mend.ne.jend'
        if(mend.eq.0)stop 'sr.radcon: mend=0'
C
C
        CALL FCF6(FR,DP0,TM,MYL,DDY,DZ0,DZA,DD0,DD0,DD0,ZS,MZNM,DL2,MEND
     X           ,DNUK,MJH0,MNH0,DHNS,DX,GR,MAXRS)
C
C
        IF(MYL.LT.0)THEN
          WRITE(6,*)'*** FCF6 FAILURE...'
          WRITE(0,*)'*** FCF6 FAILURE...'
          GO TO 999
        ENDIF
c
        if(mden.gt.0.and.ddy.eq.dzero)then         !Ryd approx in plasma
          if(bjump)then
            t=2*(duy(n,n)-dey(n))
            t=dza/sqrt(t)
            tm=nnold+t
          else
            tm=dzero
          endif
        endif
C
      ELSE                                         !COULOMBIC
        TM=DZERO
C
        CALL FCF4(FR,DP0,DDY,DZA,MYL,MJH0,MNH0,DHNS,DX)
C
      ENDIF
C
      IF(MYN.LT.0)WRITE(6,997)MYL,DDY,TM
C
C NOTE DDY OMITTED FROM DQNL(K,I) FOR K=CONTINUUM (MODE.GT.2 ONLY)
C REMEMBER THIS WHEN LOOKING AT RELATIVISTIC INTEGRALS
C
      DD3=DZERO
      IF(DDY.LT.DZERO)DD3=DDY
      IF(BORT.AND.MODE.LE.2)DD3=DDY
CT      IF(BREL)DD3=DZERO
C
      IF(.NOT.BREL2)THEN
        DO I=1,MAXRS0
          GR(I)=(DL2(I)+VSC(I)+DD3)*FR(I)
        ENDDO
      ENDIF
C
      IF(RZERO.GT.DZERO)THEN                           !BOX STATE NORM=1
        IF(BREL2)THEN
          DO I=1,MAXRS0
            DA(I)=FR(I)*FR(I)+GR(I)*GR(I)
          ENDDO
        ELSE
          DO I=1,MAXRS0
            DA(I)=FR(I)*FR(I)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD0,DA,DD,MNH0,DHNS,MJH0,MAXRS0)   !BOX MAXRS=MAXRS0
C
        DD=SQRT(DD)
        DNORM=DONE/DD
C
        DO I=1,MAXRS0
          FR(I)=DNORM*FR(I)
          GR(I)=DNORM*GR(I)
        ENDDO
        DP0=DNORM*DP0
      ENDIF
C
      DO I=1,MAXRS0
        DPNL(I,N)=FR(I)
        DQNL(I,N)=GR(I)
      ENDDO
C
      IF(MP.GT.0)THEN
        DO I=1,MAXRS0
          WRITE(6,998)I,DX(I),DPNL(I,N),DQNL(I,N)
        ENDDO
      ENDIF
C
      DD3=DZERO
      MCF=MCF6
      IF(DJ.LT.DZERO)MCF=MCF4
      IF(.NOT.BORT.AND.MYN.GE.-10.AND.MAUTO.GT.0)GO TO 26
cccccc      IF(BREL)GO TO 26
      IF((MORT.EQ.-3             ).AND.IRLX.NE.2)GO TO 26
C                   .OR..NOT.BSTO
C
C ORTHONORMALIZE (SCHMIDT PROCEDURE DO63, NORMALIZATION DO64-65)
C ONLY ATTEMPT TO ORTHOG TO FUNCTIONS K .LT. N
C
      K1=1                                   !LOWER ORB BOUND FOR ORTHOG
      K2=N                                   !UPPER ORB BOUND FOR ORTHOG
c
      if(ieq(0).ne.0.and.irlx.ne.2)then         !FIND ORB GROUP BOUNDARY
        ng=igrcf(n)
        k1=mxborb*(ng-1)+mb0+1
        k2=k1+mxborb-1
c       write(0,*)'orthog',ng,':',k1,k2,n
      endif
C
      DO K=1,N   !K2?
C
        IF(2*MYL.NE.QL(K))GO TO 63
        IF(DORIGZ(K).EQ.DZERO)GO TO 63
        IF(K.LT.K1.AND.K.GT.MB0)GO TO 63               !CASE IEQ(0).GT.0
        IF(K.GT.K2.AND.K.LT.N)GO TO 63                 !CASE IEQ(0).GT.0
        IF(IRLX.EQ.2.AND.K.NE.N.AND.QN(K).EQ.QN(N))THEN
          KKK=((N-1)*(N-2))/2+K
          OVLPGR(KKK)=DONE
          GO TO 63
        ENDIF
C
C AVOID TRYING TO ORTHOG TO CONTINUUM WAVEFUNCTION
C
        IF(QN(K).LT.0)GO TO 63
C
C AVOID ORTHOG TO CORRELATION ORBITAL (except box orbitals
C
        IF(BORT.AND.DAJNEW(K).LT.DZERO.and.RZERO.LE.DZERO)GO TO 63
C
C AVOID ORTHOG TO VALENCE ORBITAL DURING DR OPERATION
C
        IF(BDR.AND.IVAL(K).GT.0)GO TO 63
C
        IF(BREL2)THEN
          DO I=1,MAXRS
            DA(I)=DPNL(I,K)*DPNL(I,N)+DQNL(I,K)*DQNL(I,N)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DA(I)=DPNL(I,K)*DPNL(I,N)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD0,DA,DD,MNH,DHNS,MJH,MAXRS)
C
        I=QL(K)/2
        IF(BPRNT0)WRITE(6,960)QN(N),MYL,QN(K),I,DD
c        if(rzero.gt.0)go to 63
C
        IF(IRLX.EQ.2)THEN
          KKK=((N-1)*(N-2))/2+K
          OVLPGR(KKK)=DD
          GO TO 63
        ENDIF
C
        DO I=1,MAXRS0
          DPNL(I,N)=DPNL(I,N)-DD*DPNL(I,K)
          DQNL(I,N)=DQNL(I,N)-DD*DQNL(I,K)
        ENDDO
C
        DP0=DP0-DD*DORIGZ(K)/DZ
C       DD3=DZERO FOR MODES 1&2,=SUM OVRLAP**2 FOR MODE GT 2 (CONTINUUM)
        IF(DDY.GE.DZERO.AND.MODE.GT.2)DD3=DD3+DD*DD
C
  63  ENDDO
C
C
  26  DNORM=DONE
      IF(DP0.LT.DZERO)THEN
C        WRITE(6,781 N,(DPNL(M,N),M=1,50)
C        DNORM=-DNORM
C        TM=TM+DONE                                !FOR ASSX
C        WRITE(6,781)
        IF(DDY.NE.DZERO)GO TO 9
      ENDIF
C
      IF(DDY.GT.DZERO.and.RZERO.LE.DZERO)GO TO 1
      IF(DDY.EQ.DZERO)THEN
        DNORM=MNN
        DNORM=DNORM-TM
        DNORM=DZA*DZA/(PIH*DNORM**3)
        DNORM=SQRT(DNORM)
C        IF(DP0.LT.DZERO)DNORM=-DNORM
c        dnorm=1             !<<<<<<<<<<<<<<<<<<<<<<<<<<<<TEST CONT-CONT
      ENDIF
   9  MAXTS=MAXRS
C
      IF(RZERO.GT.DZERO)THEN                           !BOX STATE NORM=1
        IF(BREL2)THEN
          DO I=1,MAXRS0
            DA(I)=DPNL(I,N)*DPNL(I,N)+DQNL(I,N)*DQNL(I,N)
          ENDDO
        ELSE
          DO I=1,MAXRS0
            DA(I)=DPNL(I,N)*DPNL(I,N)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD0,DA,DD,MNH0,DHNS,MJH0,MAXRS0)   !BOX MAXRS=MAXRS0
C
        DD=SQRT(DD)
        IF(DNORM.LT.DZERO)DD=-DD
        DNORM=DONE/DD
        IF(BPRNT0)WRITE(6,961)QN(N),MYL,DNORM
      ENDIF
C
      DO M=1,MAXRS0
        DD1=DNORM*DPNL(M,N)
        IF(ABS(DD1).GT.TOLR)MAXTS=MAX(M,MAXTS)
C        FR(M)=FR(M)*DNORM
        DPNL(M,N)=DD1
        DQNL(M,N)=DNORM*DQNL(M,N)
      ENDDO
C
      IF(DDY.LT.DZERO)MAXRS=MAXTS
      DP0=DNORM*DP0
C
   1  DORIG(N)=DP0
      DORIGZ(N)=DP0*DZ
C
      IF(MYN.LT.0)WRITE(6,100)DDY,MCF,MP,MNN,MYL
C
      KN=N
      IF(BJUMP)KN=MXORB
C
C EVALUATE SOME ONE-BODY INTEGRALS
C
      DO K=1,KN
C
        DD2=DZERO    !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
C
        IF(QL(K).NE.QL(N))GO TO 93                                   !94
        IF(DORIGZ(K).EQ.DZERO)GO TO 93
C           QN(K).LT.0
        IF(IYY(K).GT.0.AND.DDY.GT.DZERO.AND.MODE.LE.2)GO TO 93
C       IF(K.NE.N.AND.DDY.EQ.DZERO.AND.MODE.LE.2)GO TO 93
C
        IF(.NOT.BORT.AND.MAUTO.GT.0)GO TO 78
C C.F. SR.RADIAL
        IF(BREL2)GO TO 78                                          !BREL
        IF(MORT.EQ.-3.AND.BREL)GO TO 78
C
        IF(K.LT.N)THEN
          L1=K
          L2=N
        ELSE
          L1=N
          L2=K
        ENDIF
C
        IF(BDR.AND.IVAL(L1).GT.0.AND..NOT.BJUMP.AND..NOT.BREL)THEN
           IF(ABS(DADJUS(N)-DADJUS(K)).GT.D1M3)THEN
              WRITE(6,777)K,DADJUS(K),N,DADJUS(N)
              WRITE(0,*)'*** ATTENTION: RYDBERG AND CONTINUUM ORBITALS '
     X                 ,'ARE NOT ORTHOGONAL!'
           ENDIF
        ENDIF
C
C MUST ENSURE THAT USE DQNL(*,L1) FOR VALENCE ELECTRON WHEN APPROXIMATED
C BY A CONTINUUM SINCE THIS HAS EPSILON=0 AND WE MUST ONLY EVALUATE
C SHORT-RANGE AND 1/R CONTRIBUTIONS, 1/R CANCELS WITH SLATER
C INTEGRALS C.F. SCATTERING PROBLEM BUT ELEMENTS OFF-DIAGONAL IN
C ENERGY NOW EXIST.
C
        DO I=1,MAXRS
          DA(I)=DQNL(I,L1)*DPNL(I,L2)
ct          da(i)=dqnl(i,l2)*dpnl(i,l1)
ct          da(i)=(dqnl(i,l1)-2*dey(l1)*dpnl(i,l1))*dpnl(i,l2)
        ENDDO
        IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN!PERT DH1
          DO I=1,MAXRS
            T=EXP(-DX(I)/DEBYE)
            DA(I)=DA(I)+DTWO*DPNL(I,L1)*DPNL(I,L2)*(DONE-T)*DZ/DX(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DA(I)=DA(I)-DTWO*DPNL(I,L1)*DPNL(I,L2)*VSC(I)
          ENDDO
        ENDIF
        IF(MPSEUD.NE.0)THEN
          DO I=1,MAXRS
            DA(I)=DA(I)+DTWO*DPNL(I,L1)*DPNL(I,L2)*(DZ/DX(I)-POTHAM(I))
          ENDDO
        ENDIF
        GO TO 77
C
C BREL2 REALLY REQUIRES SMALL OVERLAPS SINCE USES UNMODIFIED POTENTIAL
C
  78    IF(BREL2)THEN
          DO I=1,MAXRS
            DD2=DPNL(I,K)*DPNL(I,N)+DQNL(I,N)*DQNL(I,K)
            DA(I)=DD2*DL2(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DA(I)=DPNL(I,K)*DPNL(I,N)*DL2(I)
          ENDDO
        ENDIF
        IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN!PERT DH1
          DO I=1,MAXRS
            T=EXP(-DX(I)/DEBYE)
            DA(I)=DA(I)+DTWO*DA(I)*((DONE-T)*DZ/DX(I)+VSC(I))/DL2(I)
          ENDDO
C        ELSEIF(MDEN10.EQ.2)THEN                           !IS NO 2-BODY
        ENDIF
        IF(MPSEUD.NE.0)THEN
          DO I=1,MAXRS
            DA(I)=DA(I)+DTWO*DA(I)*(DZ/DX(I)-POTHAM(I))/DL2(I)
          ENDDO
        ENDIF
C
  77    CALL WEDDLE(DD0,DA,DD,MNH,DHNS,MJH,MAXRS)
C
        DD2=DD/DTWO
        DD2=DD2*SCALER                   !C.F. COWAN SLATER SCALE FACTOR
C
  93    DUY(N,K)=DD2
        DUY(K,N)=DD2
        DCD(N,K)=DZERO
        DCD(K,N)=DZERO
C
      ENDDO                                                          !94
C
C UPDATE ONE-BODY ENERGY
C
      IF(DDY.LT.DZERO)THEN           !NOT ACTIVE
C
        DDY=DDY/DTWO                 !RYD TO A.U. FOR BOUND
CT           (BREL).OR.
        IF(
     X               (.NOT.BORT.AND.MAUTO.GT.0))
     X  DUY(N,N)=DUY(N,N)+DDY*SCALER
        DEY(N)=DUY(N,N)
        DUY(N,N)=DUY(N,N)-DDY*SCALER
C
        WRITE(6,*)'*** SR.RADCON: ENERGY .LT. 0 !',N
        WRITE(0,*)'*** SR.RADCON: ENERGY .LT. 0 !'
        GO TO 999
C
      ELSEIF(DDY.EQ.DZERO)THEN       !RYDBERG APPROX BY K=0 CONT
C
        DD1=MNN
        DD1=DD1-TM
        DDY=DZA/DD1
        DDY=DDY*DDY                  !COULOMB
        IF(BREL)THEN
          T=DTWO*DD1/(QL(N)+1)-DTHREE/DFOUR
          TMV=T*DDY*DDY              !M-V
          IF(QL(N).EQ.0)THEN         !DARWIN
            TT=dza/DD1               !DZ0->dza since large n
            TT=TT*TT
            TD=-TT*TT*DD1
          ELSE
            TD=DZERO
          ENDIF
          T=(TMV+TD)*DALF
c          write(6,*)-ddy/2,-tmv*dalf/2,-td*dalf/2,-t/2
          if(ddy+t.lt.dzero)t=dzero  !use non.rel.
          DDY=DDY+T
        ENDIF
        DDY=-DDY/DTWO                !BOUND A.U. NON-HYDROGENIC
        IF(BDR)DSHIFT(N)=-DDY        !IMPLICIT RYD SHIFT (INTERP.)
        DEY(N)=DUY(N,N)+DDY
c
        if(irlx.ne.0.and.n.ne.kstore)
     x  write(*,*)'we have more than one ryd orbital?'
c
        if(qed.ne.0)then             !just re-scale old bound
          factn=nnold
          factn=(factn-tm)/dd1
          factn=factn**3
          vpint(n)=vpint(n)*factn
          slfint(n)=slfint(n)*factn
        endif
C
      ELSE                           !DDY.GT.DZERO
C
        MINK=0
        DD1=-MSHIFT*MINK
        DDY=DDY-DSHIFT(N)*DTWO       !CONTINUUM RYD
        DEY(N)=DUY(N,N)+DD1+DDY*(DONE+DD3)/DTWO
        IF(DEY(N).EQ.DZERO)DEY(N)=D1M10
        DUY(N,N)=DUY(N,N)+DDY*DD3/DTWO
C
      ENDIF
C
      IF(MYN.LT.0)WRITE(6,300)N,QN(N),MYL,MION1,NZION,TM,MR5,DP0
     X                   ,DX(MAXRS0),DD0,(DPNL(I,N),I=II,MAXRS0),DEY(N)
C
      SCREEN(N)=TM
C
C TEST HERE EVALUATION OF SPIN-ORBIT: WITH FULL POTENTIAL IN SMALL-R
C CORRECTION FOR FULL RELATIVISTIC WAVEFUNCTIONS, SINCE WE ONLY RETAIN
C DIAGONAL IN NL AND CORRECTION DEPENDS ON E-V, AND/OR POTENTIAL
C DERIVATIVE - DO NOT USE CLOSED SHELLS THEN!
C STORED TEMPORARILY IN DARWIN ARRAY DCD.
C ***SEE ALSO SOCC TO SWITCH-OFF CALCULATION THERE.
C
      IF(DDY.LT.DZERO)THEN              !REL. SPIN-ORBIT FOR K=0 NL
        IF(.NOT.BREL2.OR.QL(N).EQ.0)GO TO 72    !TEST: IF(.NOT.BREL)
        IF(BREL2)THEN
          DO I=1,MAXRS
            GR(I)=DPNL(I,N)*DPNL(I,N)+DQNL(I,N)*DQNL(I,N)
            DA(I)=DONE+DALF*(DDY+POT(I,JPOT))/DTWO
          ENDDO
        ELSE
          DO I=1,MAXRS
            GR(I)=DPNL(I,N)*DPNL(I,N)
            DA(I)=DONE+DALF*(DQNL(I,N)/DPNL(I,N)+DTWO*DZ/DX(I))/DFOUR
          ENDDO
        ENDIF
        IF(IREL.GE.0)THEN               !NUCLEAR
          DO I=1,MAXRS
            GR(I)=GR(I)/(DX(I)*DX(I)*DX(I))
            GR(I)=GR(I)/DA(I)
          ENDDO
        ELSE                            !POTENTIAL DERIV
          DO I=1,MAXRS
            GR(I)=GR(I)*DERV1(I)/DX(I)
            GR(I)=GR(I)/DA(I)
          ENDDO
        ENDIF
        DD1=DZERO
        CALL WEDDLE(DD1,GR,DD3,MNH,DHNS,MJH,MAXRS)
        IF(IREL.LT.0)DD3=-DD3/(2*DZ)    !POTENTIAL DERIV
        DCD(N,N)=DALF*DD3/DFOUR
        GO TO 72                    !GO BACK-UP TO GENERATE NEXT ORBITAL
      ENDIF
C
C SET UP ARRAY NRLI FOR CASE BLAG=FALSE
C
      ICOUNT=1
      IF(.NOT.BLAG)GO TO 327
C
C-----------------------------------------------------------------------
C CALCULATE CONTINUUM ORBITALS AT INTERPOLATION ENERGIES
C-----------------------------------------------------------------------
C
      ICOUNT=0
  46  ICOUNT=ICOUNT+1
C
      IF(ICOUNT.EQ.NREL)THEN
        IF(BFOT.AND.BLAG)THEN
          DDY=2*DYY(NREL)                     !A.U. TO RYD
          CALL RK4PI(NREL,N,M8)               !JUST GET GAUGE
        ENDIF
        ICOUNT=ICOUNT+1
      ENDIF
      IF(ICOUNT.GT.MENG)GO TO 72
C
      DDY=DYY(ICOUNT)+DSHIFT(N)
      DDY=DDY+DDY                             !A.U. TO RYD
C
      IF(DJ.GT.DZERO.OR.IORT.EQ.2.OR.BREL)THEN      !DW
        DD0=DZERO
c        MEND=JEND(N)
        if(bort.and.mend.ne.jend(n))stop 'mend.ne.jend on interp'
        if(mend.eq.0)stop 'sr.radcon: mend=0 on interp'
C
C
        CALL FCF6(FR,DP0,TM,MYL,DDY,DZ0,DZA,DD0,DD0,DD0,ZS,MZNM,DL2,MEND
     X           ,DNUK,MJH0,MNH0,DHNS,DX,GR,MAXRS)
C
C
        IF(MYL.LT.0)THEN
          WRITE(6,*)'*** FCF6 FAILURE...'
          WRITE(0,*)'*** FCF6 FAILURE...'
          GO TO 999
        ENDIF
C
      ELSE                                          !COULOMBIC
        TM=DZERO
C
        CALL FCF4(FR,DP0,DDY,DZA,MYL,MJH0,MNH0,DHNS,DX)
C
      ENDIF
C
      IF(.NOT.BREL2)THEN
        DO I=1,MAXRS0                                  !MAXRS WRONG
          GR(I)=(DL2(I)+DDY)*FR(I)
        ENDDO
      ENDIF
C
      IF(MYN.LT.0)WRITE(6,997)MYL,DDY,TM
      IF(.NOT.BORT)GO TO 120
      IF((MORT.EQ.-3             ).AND.IRLX.NE.2)GO TO 120
C                  .OR..NOT.BSTO
cccccccc      IF(BREL)GO TO 120
C
      DO K=1,N  !K2?
C
        IF(2*MYL.NE.QL(K))GO TO 121
        IF(DORIGZ(K).EQ.DZERO)GO TO 121
        IF(K.LT.K1.AND.K.GT.MB0)GO TO 121              !CASE IEQ(0).GT.0
        IF(K.GT.K2.AND.K.LT.N)GO TO 121                !CASE IEQ(0).GT.0
        IF(IRLX.EQ.2.AND.K.NE.N.AND.QN(K).EQ.QN(N))THEN
          KKK=((N-1)*(N-2))/2+K
          OVLPGR(KKK)=DONE
          GO TO 121
        ENDIF
        IF(QN(K).LT.0)GO TO 121                  !NO ORTHOG TO CONTINUUM
        IF(DAJNEW(K).LT.DZERO.and.RZERO.LE.DZERO)GO TO 121  !NOT TO CORR
        IF(BDR.AND.IVAL(K).GT.0)GO TO 121          !NO ORTHOG TO VALENCE
C
        IF(BREL2)THEN
          DO I=1,MAXRS
            DA(I)=DPNL(I,K)*FR(I)+DQNL(I,K)*GR(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DA(I)=DPNL(I,K)*FR(I)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD0,DA,DD,MNH,DHNS,MJH,MAXRS)
C
        DO I=1,MAXRS0
          FR(I)=FR(I)-DD*DPNL(I,K)
          GR(I)=GR(I)-DD*DQNL(I,K)
        ENDDO
        DP0=DP0-DD*DORIGZ(K)/DZ
C
  121 ENDDO
C
      DNORM=DONE
      IF(DP0.LT.DZERO)THEN
C        DNORM=-DNORM
C        WRITE(6,781)N,(FR(I),I=1,50)
C        WRITE(6,781)
C        TM=TM+DONE                                    !FOR ASSX
      ENDIF
C
      IF(RZERO.GT.DZERO)THEN                           !BOX STATE NORM=1
        IF(BREL2)THEN
          DO I=1,MAXRS0
            DA(I)=FR(I)*FR(I)+GR(I)*GR(I)
          ENDDO
        ELSE
          DO I=1,MAXRS0
            DA(I)=FR(I)*FR(I)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD0,DA,DD,MNH0,DHNS,MJH0,MAXRS0)   !BOX MAXRS=MAXRS0
C
        DD=SQRT(DD)
        IF(DNORM.LT.DZERO)DD=-DD
        DNORM=DONE/DD
      ENDIF
C
      IF(DNORM.NE.DONE)THEN
        DO I=1,MAXRS0
          FR(I)=DNORM*FR(I)
          GR(I)=DNORM*GR(I)
        ENDDO
        DP0=DNORM*DP0
      ENDIF
C
  120 DM=-MSHIFT*MINK
      DM=DM+DDY/DTWO-DSHIFT(N)
C
      IF(MYN.LT.0)WRITE(6,100)DDY,MCF,MP,MNN,MYL
C
C
      IF(MYN.LT.0)WRITE(6,300)N,QN(N),MYL,MION1,NZION,TM,MR5,DP0,
     X                        DX(MAXRS0),DD0,(FR(I),I=II,MAXRS0),DM
C
      IF(BDR)THEN
        WRITE(MRP)TM,MAXRS0
        WRITE(MRP)(FR(I),I=1,MAXRS0),(GR(I),I=1,MAXRS0),
     X            (DL2(I),I=1,MAXRS0)
      ENDIF
      GO TO 327
C
C-----------------------------------------------------------------------
C IDENTIFY AND RECOVER CONTINUUM INTERPOLATION ORBITALS DURING DR
C AND ZERO-OUT INTEGRAL ARRAYS FOR RECOMPUTATION.
C (SO ANY EXPLICIT DSHIFT(N)=DZERO HERE.)
C-----------------------------------------------------------------------
C
  133 IF(.NOT.BCONT)GO TO 138
C
      DO J=1,IRL                    !SLATER
        KP=NRLI(J)
        IF(KP.GT.0)THEN
          M=0
          DO I=1,4
            N=QRL(I,J)
            IF(N.GT.0)M=M+IVAL(N)
          ENDDO
          IF(M.NE.0)THEN
            DO I=1,MENG
              DRLI(I,KP)=DZERO
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
      DO J=1,NL000                 !FS
        KP=NLI(J)
        IF(KP.GT.0)THEN
          M=0
          DO I=1,4
            N=QSS(I,J)
            M=M+IVAL(N)
          ENDDO
          IF(M.NE.0)THEN
            DO I=1,MENG
              DNLI(I,KP)=DZERO
            ENDDO
          ENDIF
        ENDIF
      ENDDO
C
      IF(.NOT.BLAG)GO TO 138
      REWIND(MRP)
C
      K9=1
  135 IF(K9.GT.MXORB)GO TO 138
C
      DO K=K9,MXORB
        IF(DEY(K).EQ.DZERO)GO TO 134
        IF(IVAL(K).GT.0)GO TO 134
        IF(QN(K).GT.0)GO TO 134
        N=K
        GO TO 137
  134 ENDDO
      GO TO 138
C
  137 ICOUNT=0
      K9=N+1
C
  136 ICOUNT=ICOUNT+1                         !START RECOVERY LOOP
C
      IF(ICOUNT.EQ.NREL)THEN
        IF(BFOT.AND.BLAG)THEN
          DDY=DYY(NREL)*DTWO                  !A.U. TO RYD
          CALL RK4PI(NREL,N,M8)               !JUST GET GAUGE
        ENDIF
        ICOUNT=ICOUNT+1
      ENDIF
      IF(ICOUNT.GT.MENG)GO TO 135
C
      READ(MRP)TM,MXREAD
      READ(MRP)(FR(I),I=1,MXREAD),(GR(I),I=1,MXREAD),(DL2(I),I=1,MXREAD)
C
C---------------------------------------------------------
C *** EVALUATE BOUND-CONTINUUM INTERPOLATION INTEGRALS ***
C---------------------------------------------------------
C
  327 CONTINUE                                     !ENTRY FOR FIRST PASS
C
C *** PI DIPOLE INTEGRALS
C
      IF(BFOT.AND.BLAG)THEN
C
        CALL RK4PI(ICOUNT,N,M8)
C
        IF(M8.GT.IXD24.OR.M8.LT.0)THEN
          IF(M8.GT.IXD24)WRITE(6,605)IXD24,M8            !ALGEB2 CATCHES
          GO TO 999
        ENDIF
      ENDIF
C
C *** SLATER INTEGRALS AND (IF BKUTOO)
C     2-BODY NON-FINE STRUCTURE INTEGRALS.
C
      CALL SLATRI(ICOUNT,N,KK)
C
      IF(KK.GT.IXFSL.OR.KK.LT.0)THEN
        IF(KK.GT.IXFSL)WRITE(6,252)KK
        GO TO 999
      ENDIF
C
      IF(KK.GT.0)THEN
        CALL DIMUSE('MXFSL',KK)
        IF(BKUTOO)CALL DIMUSE('MXFOO',KK)
      ENDIF
C
C *** 2-BODY FINE-STRUCTURE INTEGRALS
C
      IF(NL000.GT.0)THEN
C
        CALL FSINTI(ICOUNT,N,KFS)
C
        IF(KFS.GT.IXFSS.OR.KFS.LT.0)THEN
          IF(KFS.GT.IXFSS)WRITE(6,253)KFS
          GO TO 999
        ENDIF
C
        CALL DIMUSE('MXFSS',KFS)
      ENDIF
C
C-----------------------------------------------------------------------
C
      IF(BJUMP)GO TO 136
      GO TO 46
C
C CHECK COMPLETENESS OF RADIAL FUNCTION SET
C COMPUTE RELATIVISTIC INTEGRALS (MASS AND DARWIN TERM, EJN-EQ.60)
C D2LL(K,L) IS USED BY SR.ALGEB4 WHICH EVALUATES THE BREIT-PAULI
C MODIFICATION OF THE M1 OPERATOR FOR USE BY SR.DIAGFS .
C
  138 MP=0
      ICM=100000
      IBM=0
      IF(BCONT)THEN
        DDY=DYY(NREL)                                   !ALWAYS A.U. NOW
COLD        IF(.NOT.BJUMP)DDY=DDY/DTWO    !RYD TO A.U. ELSE ALREADY A.U.
      ELSE
        DDY=DZERO                                       !NOT USED
      ENDIF
C
      DO K=1,MXORB
C
        IF(DEY(K).EQ.DZERO)GO TO 52
        MP=K
        IF(IYY(K).GT.0.AND.K.LT.ICM)ICM=K
        IF(IVAL(K).EQ.0.AND.QN(K).GT.0.AND.IBM.LT.K)IBM=K
C
        IF(SCREEN(K).GT.999)THEN
          WRITE(6,980)K
          DEY(K)=DZERO
          NF=-1
          GO TO 52
        ELSEIF(SCREEN(K).EQ.999)THEN
          WRITE(6,970)K
        ENDIF
C
        IF(NJO.LE.0.AND..NOT.BMVD.or.qn(k).gt.0)GO TO 52
C
        DORIGZ(K)=DORIG(K)*DZ
        IF((MAUTO.EQ.0.OR.BORT).AND..NOT.BREL)GO TO 75
C           SR.RADWIN ACCESSED
        DX1=DZERO
        IF(IYY(K).LT.0)DX1=DEY(K)-DUY(K,K)
        IF(IYY(K).GT.0)DX1=DDY+DSHIFT(K)               !A.U.
C
        tz=dzero
        IF(.NOT.BORT)THEN
          JPOT=QL(K)/2+1
          IF(JPOT.GT.MXPOT)JPOT=MXPOT
        ELSE
          JPOT=1                                     !RYD APPROX BY CONT
          if(igagr.gt.0)tz=nzion-mion1+1
        ENDIF
C
        DO L=1,K
C
          DD3=DZERO  !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
          DD2=DZERO
          DD1=DZERO
C
          IF(DEY(L).EQ.DZERO)GO TO 614                              !613
          IF(QL(K).NE.QL(L))GO TO 614                               !613
          M=IVAL(L)+IVAL(K)
          IF(BJUMP.AND.M.EQ.0)GO TO 613
          IF(BJUMPR.OR.BREL.AND.NL.LE.NL000)GO TO 614
C                                      .AND.L.EQ.K .OR.BREL2
          IMT=0
          IF(IYY(K).GT.0)IMT=IMT+1
          IF(IYY(L).GT.0)IMT=IMT+1
          IF(MODE.LE.2.AND.IMT.Ge.1)GO TO 614
C
          DX2=DZERO
          IF(IYY(L).LT.0)DX2=DEY(L)-DUY(L,L)
          IF(IYY(L).GT.0)DX2=DDY+DSHIFT(L)
C
          DO I=1,MAXRS
            DA(I)=DPNL(I,L)*(POT(I,JPOT)-tz/dx(i))*DPNL(I,K)
          ENDDO
          IF(BREL2)THEN
            DO I=1,MAXRS
              DA(I)=DA(I)+DQNL(I,K)*(POT(I,JPOT)-tz/dx(i))*DQNL(I,L)
            ENDDO
          ENDIF
C
          CALL WEDDLE(DD2,DA,DD3,MNH,DHNS,MJH,MAXRS)
C
          IF(.NOT.BREL)THEN        !EVALUATE INTEGRAND AT ORIGIN
            IF(QL(K).EQ.0)DD2=DORIGZ(K)*DORIGZ(L)
C
            DO I=1,MAXRS
              DERV2(I)=DA(I)*POT(I,JPOT)
            ENDDO
C
            CALL WEDDLE(DD2,DERV2,DD1,MNH,DHNS,MJH,MAXRS)
C
            DD1=DD1+(DX1+DX2)*DD3
            IF(L.EQ.K)DD1=DD1+DX1*DX2
            DD2=DD2*DFSC*DFSC/(DZ*DEIGHT)
          ENDIF
C
          DD1=-DD1*DFSC*DFSC/DTWO
          IF(L.EQ.K)DD3=DX1+DD3
C
  614     DMASS(K,L)=DD1                  !N.B. SWAPPED DMASS, DCD ORDER
          DCD(K,L)=DD2
          D2LL(K,L)=DD3+DD3
C
  613   ENDDO
C
        GO TO 52
C
C CASE NON-RELATIVISTIC RADIAL FUNCTIONS
C
  75    DX1=DZERO
        IF(MODE.GT.2.AND.IYY(K).GT.0)DX1=(DDY+DSHIFT(K))*DTWO       !RYD
C
        DO L=1,K
C
          DP0=DZERO  !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
          DD=DZERO
          DM=DZERO
C
          IF(DEY(L).EQ.DZERO)GO TO 54                                !53
          IF(QL(K).NE.QL(L))GO TO 54                                 !53
          M=IVAL(K)+IVAL(L)
          IF(BJUMP.AND.M.EQ.0)GO TO 53
          IF(BJUMPR           )GO TO 54                     !.OR.BREL
C                  .AND.L.EQ.K                              !.OR.BREL2
          IF(MORT.EQ.-3)GO TO 54                            !.AND.BREL
C
          IMT=0
          IF(IYY(K).GT.0)IMT=IMT+1
          IF(IYY(L).GT.0)IMT=IMT+1
          IF(MODE.LE.2.AND.IMT.Ge.1)GO TO 54
C
          DX2=DZERO
          IF(MODE.GT.2.AND.IYY(L).GT.0)DX2=(DDY+DSHIFT(L))*DTWO     !RYD
C
          DO I=1,MAXRS
            DD3=DTWO*DZ/DX(I)
            DD2=DPNL(I,L)*(DD3+DX2)+DQNL(I,L)
            DD1=DPNL(I,K)
            DA(I)=(DD1*(DD3+DX1)+DQNL(I,K))*DD2
            DERV2(I)=DD1*DD2
            IF(QN(K).LT.0.AND.QN(L).LT.0)THEN
              DD0=DX2*DPNL(I,L)*DPNL(I,K)
              DA(I)=DA(I)-DX1*DD0
              DERV2(I)=DERV2(I)-DD0
            ENDIF
          ENDDO
C
          CALL WEDDLE(DD,DERV2,DP0,MNH,DHNS,MJH,MAXRS)
C
          IF(K.EQ.L)DP0=DP0+DX2
          IF(QL(K).EQ.0.AND..NOT.BREL)DD=DORIGZ(K)*DORIGZ(L)
          DD3=DD*DFOUR
C
          CALL WEDDLE(DD3,DA,DM,MNH,DHNS,MJH,MAXRS)
C
          IF(L.EQ.K)DM=DM+DX1*DX2
          DM=-DM*DFSC*DFSC/DEIGHT
          DD=DD*DFSC*DFSC/(DZ*DEIGHT)
C
  54      DMASS(K,L)=DM                   !N.B. SWAPPED DMASS, DCD ORDER
          DCD(K,L)=DD
          D2LL(K,L)=DP0
C
  53    ENDDO
C
  52  ENDDO
C
C
      IF(BJUMP)GO TO 1000
      if(ieq(0).gt.0)go to 126
ctest      IF(MORT.EQ.-3)GO TO 126
      IF(ICM.GT.IBM)GO TO 21
      WRITE(6,601)IBM,ICM
      GO TO 999
C
  21  IF(IVP.LT.ICM)GO TO 125
      WRITE(6,602)IVP,ICM
      GO TO 999
C
 125  IF(IBM.LT.IVM)GO TO 126
      WRITE(6,603)IBM,IVM
      GO TO 999
C
 126  CONTINUE
C
      IF(NF.LE.0)GO TO 1000
C
      IF(.NOT.BPRNT0)GO TO 128
      IF(II.GT.1.AND.MYN.LT.0 )WRITE(6,400)(DX(I),I=II,MAXRS0)
C
      IF(MODE.LT.2)THEN
        WRITE(6,597)
        GO TO 132
      ENDIF
C
      IF(BLAG)THEN
        WRITE(6,594)MAUTO,MODE,ACE*2,IXFSL,KK
        WRITE(6,587)MENG,NREL
        F588='(11(I3,F9.3))'
        IF(2*DYY(MENG).GE.1.D5)F588='(10(I4,F10.2))'
        IF(2*DYY(MENG).GE.1.D6)F588='(10(I4,F11.1))'
        IF(2*DYY(MENG).GE.1.D7)F588='(10(I4,F12.0))'
        WRITE(6,F588)(I,2*DYY(I),I=1,MENG)                     !RYD
        IF(NLAGP.NE.NLAG)WRITE(6,584)NLAGP,KSHIFT,MKMAX,MXEP
        GO TO 128
      ENDIF
C
      WRITE(6,595)MAUTO,MODE,ACE*2,IXFSL,KK                 !
C
 128  CONTINUE
C
C PRINT SOME INFO
C
      IF(.NOT.BPRNT0)GO TO 1000                                  !RETURN
C
      IF(BXTRP)THEN
        IF(BDR)THEN
          IF(BLAG)WRITE(6,598)
          IF(.NOT.BLAG)WRITE(6,597)
        ELSE
          if(kstore.eq.0)stop'kstore=0...'
          DM=QN(KSTORE)*QN(KSTORE)
          DDY=DZA*DZA/DM
          WRITE(6,596)DDY
        ENDIF
      ENDIF
C
      DD=ECOR1+ECOR1
      DM=ECOR2+ECOR2
      DD=DD*DKCM
      DM=DM*DKCM
      IF(ECOR1.NE.DZERO.OR.ECOR2.NE.DZERO)WRITE(6,589)DD,DM
C
C MP IS NOW HIGHEST ORBITAL NUMBER WHICH HAS BEEN CALCULATED
C
  132 N=MIN(MYM,MP)
      IF(N.GT.0)THEN
C                       READ AT 70 READ 590  ALLOWS TO SPECIFY PRINTOUT
        IF(MYN.LT.0)MYN=-MYN
C
        IF(MYN.LE.N)THEN
          WRITE(6,990)(I,I=MYN,N)
          DO L=1,MAXRS
            WRITE(6,900)L,DX(L),(DPNL(L,I),I=MYN,N)
          ENDDO
        ENDIF
      ENDIF
C
C
 1000 IF(ALLOCATED(DORIGZ))DEALLOCATE (DORIGZ)
C
      RETURN
C
  999 NF=-1
      GO TO 1000
C
C
  100 FORMAT(29X,F13.5,30X,A4,I4,I3,I2)
  250 FORMAT(/  ' GAM ( N,  L,NION, Z, DEL/PI)    OLDEPS/RY OF RADIAL ',
     X'INPUT-FUNCTIONS',3X,'(ORIGIN    N L) FNORM, 3 LAST P, <NL!H1!NL>'
     X,';STPS/PTS=',I4,'/',I4)
  252 FORMAT(' *****STORAGE EXCEEDED IN SR.RADCON, INCREASE MXFSL TO ',
     XI5)
  253 FORMAT(' *****STORAGE EXCEEDED IN SR.RADCON, INCREASE MXFSS TO ',
     XI5)
  300 FORMAT('+',I3,I4,I4,I4,I4,F9.5,13X,I4,1X,F11.5,F10.3,17X,F8.3,
     X 1X,3(1PE9.2),0PF12.4)
  400 FORMAT(39X,"READ('')     PBAR0      RPEND",15X,"3 LAST R:",3F9.4,
     X 4X," (H1/2RY)"/)
  401 FORMAT(' ****ERROR IN SR.RADCON, CONTINUUM ORBITAL N=',I3
     X,' SKIPPED BECAUSE ENERGY DDY .LT. 0.0 ='  ,F10.4)
  584 FORMAT(/' NLAGP=',I3,2X,'KSHIFT=',I5,2X,'MKMAX=',I5,2X,'MXEP=',I3)
  587 FORMAT(' THE',I4,'  INPUT CONTINUUM ENERGIES (RYD) ARE AS FOLLOWS'
     X,' AND THE ENERGY IN POSITION',I4,'  WILL BE USED IN H(RC)'
     X,' PRINT.'/)
C  588 FORMAT(11(I3,F9.3))
  589 FORMAT(/' ECOR1*CM=',F10.1,5X,'ECOR2*CM=',F10.1)
C 591 FORMAT(7F10.4)
  594 FORMAT(/' MAUTO=',I3,2X,'MODE=',I2,2X,'ACE=',1PE9.2,' RYD.',2X,
     X'CONTINUUM FUNCTIONS IN USE; MODES 2 TO 6. INTERPOLATION IS ON,'
     X,4X,'MXFSL=',I7/100X,'**',6X,'USED=',I7)
  595 FORMAT(/' MAUTO=',I3,2X,'MODE=',I2,2X,'ACE=',1PE9.2,' RYD.',2X,
     X'CONTINUUM FUNCTIONS IN USE; MODES 2 TO 3. INTERPOLATION IS OFF,'
     X,3X,'MXFSL=',I7/100X,'***',6X,'USED=',I7)
  596 FORMAT(/' N.B. THE'
     X     ,   ' NL VALENCE ORBITALS HAVE BEEN APPROXIMATED BY A K=0  ',
     X 'CONTINUUM ORBITAL AND SO THE'/   ' INTERPOLATION ENERGIES HAVE '
     X,'BEEN',' SHIFTED BY (Z-NION+1)**2/N**2 =',F6.3,' RYD TO '
     X,'COMPENSATE.'/65X,'**********'/)                !EXPLICIT
  597 FORMAT(/' N.B. THE'
     X     ,  ' NL VALENCE ORBITALS HAVE BEEN APPROXIMATED BY A K=0 ',
     X'CONTINUUM ORBITAL.')
  598 FORMAT(/' N.B. THE'
     X     , ' NL VALENCE ORBITALS HAVE BEEN APPROXIMATED BY A K=0 ' ,
     X'CONTINUUM ORBITAL AND SO THE'/   ' INTERNAL AUTOIONIZATION '
     X,'ENERGIES WILL BE SHIFTED TO COMPENSATE.')      !IMPLICIT
  601 FORMAT(/' *****ERROR, THE LARGEST BOUND ORBITAL NUMBER USED=',I4
     X, ' IS GREATER THAN THE SMALLEST CONTINUUM ORBITAL NUMBER USED='
     X,I4)
  602 FORMAT(/' *****ERROR, THE LARGEST VALENCE ORBITAL NUMBER USED=',I4
     X, ' IS GREATER THAN THE SMALLEST CONTINUUM ORBITAL NUMBER USED='
     X,I4)
  603 FORMAT(/' *****ERROR, THE LARGEST CORE ORBITAL NUMBER USED=',I4
     X, ' IS GREATER THAN THE SMALLEST VALENCE ORBITAL NUMBER USED='
     X,I4)
  605 FORMAT(/' ***DIMENSION EXCEEDED IN SR.RADCON, INCREASE IXD24 FROM'
     X,I5,' TO:',I5)
  710 FORMAT('*** SR.RADCON POTENTIAL REQUIRES INITIAL STEP LENGTH ',
     X'DOUBLED, INCREASE MAXB1 OR INCREASE MSTEP  TO',I3,
     X' IN NAMELIST SMINIM')
  773 FORMAT(13X,'NL =',I3,I2,'    EXTERNAL POTENTIAL V(NL) FROM UNIT='
     X,I3,';  NON-COULOMB POT .LT. 1% OF COULOMBIC BEYOND R(IEND=',I5,
     X') =',F10.6)
  774 FORMAT(23X,'NL =',I3,I2,  '    S.M.-POTENTIAL V(NL) WITH SCALE '
     X,'FACTOR',F10.5,';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
 1774 FORMAT(45X,I1,'-POLE POLARIZED SCALE FACTOR'
     X,F10.5, ';  COULOMBIC DEVIATION AT R(IEND) =',F10.6)
 2774 FORMAT('GAM=',I3,' GRP=',I3,8X,'NL =',I3,I2,
     X'    S.M.-POTENTIAL V(NL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  775 FORMAT( 2X,'NL =',I3,I2, '    STO.-POTENTIAL CF=',I3,' WITH SCALE'
     X,' FACTOR',F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC BEYOND'
     X,' R(IEND=',I5,') =',F10.6)
  776 FORMAT(23X,'NL =',I3,I2,  ' PARMET.-POTENTIAL V(NL) WITH SCALE '
     X,'FACTOR',F10.5,';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  777 FORMAT(/'*** ATTENTION: RYDBERG AND CONTINUUM ORBITALS '
     X                 ,'ARE NOT ORTHOGONAL -',2(I5,F10.5)/)
C 781  FORMAT(' ORTHOGONALIZATION CHANGES SIGN OF ORBITAL K= ',I2,
C     X' VALUES NEAR ORIGIN ARE: '/10(1PE13.4))
C  781 FORMAT('+',57X,'*')
  900 FORMAT(I5,(7F18.6))
  960 FORMAT('       OVERLAP INTEGRAL',4X,I3,I2,' WITH',2I2,' ='
     X,1PE12.4)
  961 FORMAT('    RENORMLZTN INTEGRAL',4X,I3,I2,11X,1PE12.4)
  970 FORMAT(61X,"P/Q-INPUT FOR ORBITAL K=",I2," MISSING, S.M. USED - ",
     X"ORBITALS MAY"/89X,"NOT BE ORTHOGONAL TO INPUT-PNL'S WITH SAME L")
  980 FORMAT(61X,'P/Q-INPUT FOR ORBITAL K=',I2, ' MISSING (OR MAXB2 TOO'
     X,' SMALL), CASE FAILS')
  990 FORMAT(/' OPTIONAL PRINTOUT OF  I, R(I), AND P(I):'//(20X,6I18)/)
  997 FORMAT(' L=',I2,3X,'E=',F10.5,'RYD',3X,'DEL/PI=',1PD14.6/)
  998 FORMAT(I5,3E16.7)
C
      END SUBROUTINE RADCON
C
C                             *******************
C
      SUBROUTINE RADCX0
C
C-----------------------------------------------------------------------
C
C  SR.RADCX0 READS USER INPUT FOR CONTINUUM ORBITAL GENERATION AND
C            SETS-UP AN ENERGY MESH ACCORDINGLY.
C  IT ALSO CALCULATES THE UNIQUE CONTINUUM DISTORTED-WAVE POTENTIAL
C  USED BY THE CONTINUUM BASIS, TF OR STO, SPECIFIED AS WITH BOUND.
C  USER INPUT (SCALING PARAMETER ETC) IS VIA ORBITAL NO. MXORB+1,
C  I.E. THE NEXT POSITION AFTER THE USER DEFINED BOUND ORBITALS.
C  IF NONE READ FOR SUCH AN ORBITAL, THEN USES DATA ASSOCIATED WITH
C  THE LAST ORBITAL POSITION FOR WHICH INFO WAS READ.
C  IT COMBINES ELEMENTS OF SR.RADCN0 AND SR.RADIAL.
C
C  IT CALLS:
C    SR.DIMUSE
C    SR.TFDAPO
C    SR.STOPOT
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MULT=5)
      PARAMETER (MXD04=MULT*MXENG)                   !READ/SET-UP BUFFER
      PARAMETER (MXD06=MXENG*MXENG)
      PARAMETER (MXNDE=MULT*MXENG)       !BUFFER/CHARACTERISTIC ENERGIES
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      PARAMETER (D1PT2=1.2D0)
      PARAMETER (DEL=1.D-4)                              !FOR CONT. INTS
      PARAMETER (DTOL=0.01D0)
      PARAMETER (TOLDE0=0.1D0)
COLD      PARAMETER (DLAM0=1.3D0)                   !DEFAULT CONT LAMBDA
      PARAMETER (DEPS=1.D-10)
C
      DIMENSION DELTAE(0:MXNDE)
      DIMENSION IXX(MXD04),IXX0(MXD04),DXX(MXD04),DXX0(MXD04)
c
      dimension btmp(mxeng,mxeng)
c      common /nrbuse/buse(mxeng),busi(mxeng,mxeng),btmp(mxeng,mxeng)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
C      COMMON /COM3/DDY,DZ,TM
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW7/MNDEX(MXD06,2),MRNDX(MXD06),MTRAN,mlim(mxeng,2)
      COMMON /NRBDW8/DYY0(MXENG),IYY0(MXENG),MENG0
      COMMON /NRBDW9/DSPECJ(MAXLV),INDXJ(MAXLV),JNDXJ(MAXLV),NSPECJ
     X              ,NENERJ
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
C THE FULL NAMELIST-ING FROM SR.RADCN0 IS USED, FOR COMPATIBILITY
C BUT THE ONLY VARIABLES USED/SPECIFIABLE ARE:
C
C            MENG, EMIN, EMAX - SCATTERED ENERGY DEFINITION, AS "USUAL"
C            NDE, DEMIN, DEMAX - EXCITATION ENERGY DEFINITION,
C                                FORMAT SPEC. AS FOR SCATTERED ENERGY
C            MENGI, EMINI, EMAXI - INTERPOLATION ENERGY DEFINITION
C                     MENGI.GT.0 FORMAT SPEC. AS FOR SCATTERED ENERGY
C                     MENGI.LT.0 INSERT -MENGI POINTS BETWEEN SCATTERED
C            DELTAX - MAX EXCITATION ENERGY RESTRICTION
C                    (DEFAULT USES HIGHEST TARGET)
C            NIDX - NO. OF "INCIDENT" ENERGIES BEYOND FINAL SCATTERED.
C                   NEW DEFAULT: AT LEAST 2 (BECAUSE OF DIPOLE)
C                   OLD "DEFAULT" (NO NIDX) JUST DELTAX, I.E. 1.
C            NLAG - POINT FORMULA, DEFAULT 2 UNLESS MENGI.LT.0 THEN
C                   2-MENGI.
C                     N.B. LARGE NOT GOOD IF POINTS WIDELY SPACED
C            TOLDE RELATIVE DIFFERENCE FOR PRUNING OF CLOSELY SPACED
C                  INTERPOLATION ENERGIES. DEFAULT 0.1
C            TEAPOT - IONIZATION POTENTIAL. IF MENG=0 THEN SCATTERING
C                     ENERGIES ARE A FUNCTION OF (INTERNAL) I.P. GIVEN
C                     BY BINDING ENERGY OF OUTER ELECTRON OF GROUND CF,
C                     UNLESS OVERRIDEN BY USER: RYD.GT.0.
C
C user should not normally change/set these test variables:
c
c            bnointerp - sets deltax=0, nidx=0, nlag=1, over-riding any
c                        user specification. Then uses nearest incident
c                        energy k-matrix. User should set interpolation
c                        energies with mengi to be the meng scattered
c                        energies *plus* all the relevant excitation
c                        energies. Obviously, this is for precise tests.
c                        Note, if comparing coupling schemes, then need
c                        to switch-off the hard-wired 2x2 approx unitary
c                        in sr.cadwx, dwxls, dwxbp  set by bunit at top.
c            ilog - gt 0 for log energy spacing
c                 - eq 0 for linear energy spacing
c                 - lt 0 code chooses appropriately (default)
c            nskp - gt 0 read and skip energy integral pairs
c                 - le 0 default, keep all.
c            nbund- gt 0 bundle characteristic energies for n .ge. nbund
c                 - le 0 default, no bundling.
c            tolp - ge 0 prune energies closer than tolp.
c                   lt 0 code chooses appropriately (default)
C
      NAMELIST/SRADCON/
     X ACE,
     X ECOR1,ECOR2,ECORCA,ECORIC,ECORLS,EMIN,EMAX,
     X MDECP,MENG,MENGP,MP,MYN,MYM,
     X NLAG,NREL,
     X PIG,PMIN,
     X DELTAX,DEMIN,DEMAX,NDE,NIDX,
     X EMINI,EMAXI,MENGI,
     X TEAPOT,TOLDE
     X,ilog,nbund,nskpi,tolp,bnointerp
c     x                     ,DLAMX,toldc
C NOT ALL VARIABLES USED BY RADCX0, BUT PRESENT FOR RADCN0 COMPATIBILITY
C
C SOME INITIALIZATIONS
C
      PI=ACOS(-DONE)
      TOL=DONE/10**ITOL
      DHNSX=DHNS(MJH)
      BORT=MORT.LT.0
      IORT=ABS(MORT)
      DZ=NZION
      NZA=NZION-MION
      NZAP=NZA+1                   !FOR TARGET ELECTRON
      DZAP=NZAP
C      DZAP2=NZAP*NZAP
      TOLR=DEL/DZAP
      DLAMX=-DONE
C
C ********** ALL INPUT ENERGIES SHOULD BE IN RYDBERGS ***********
C
      BTHRSH=LVMAX.GE.0
      NLAG=-1
      ilog=-999
      tolp=-done
c
      TOLDE=-DONE
      DXX(1)=DZERO
      if(abs(modd).gt.1)then                      !back compatible
        DELTAX=DSPECE(NSPECE)
      else                                         !but strictly
        DELTAX=DSPECJ(NSPECJ)
      endif
      DELTAX=DELTAX+DELTAX*DEPS  !SO AS NOT TO FLAG ZERO*USE OF INTERP E
      NIDX=-1
C SCATTERED
      EMIN=0
      EMAX=-3*DELTAX
      MENG=0
      TEAPOT=-DONE
C CHARACTERISTIC
      DELTAE(0)=DZERO
      NDE=-999
      DEMIN=-1
      DEMAX=-2
      nbund=6            !lump all-n.ge.nbund, case use orbital epsilons
      toldc=tolde0/2                            !set zero for no pruning
C INTERPOLATION
      EMINI=-1
      EMAXI=-2
      MENGI=-999
      nskpi=0
      bnointerp=.false.
C
      IF(BNAME)THEN
C
C
        READ(5,SRADCON,END=998,ERR=998)     ! <---------------- NAMELIST
C
C
      ELSE                                        !HISTORIC FIXED FORMAT
C
        READ(5,590)E1,E2,MENG,MENGI,NDE
C
        IF(MENG.NE.0)THEN
          EMIN=E1
          EMAX=E2
        ELSEIF(MENGI.NE.0)THEN
          EMINI=E1
          EMAXI=E2
        ELSEIF(NDE.GT.0)THEN
          DEMIN=E1
          DEMAX=E2
        ENDIF
C
      ENDIF
c
      if(bnointerp)then
        nidx=0
        nlag=1
        deltax=0
      endif
C
      IF(BTHRSH)THEN
        IF(MENG.LT.0.OR.MENG.GT.1)THEN
          WRITE(6,600)
          NF=-1
          GO TO 999
        ENDIF
C                                                           !DR DEFAULTS
        ISGN=1-2*mod(abs(NLAG),ITWO)             !(-1)**NLAG
        IF(NLAG.LT.4.OR.NLAG.GT.10.OR.ISGN.LT.0)NLAG=6
        IF(NDE.EQ.-999.AND.MENGI.EQ.-999)MENGI=-2*NLAG+2     !AS INSERTS
        IF(NIDX.LE.0)NIDX=1
      ENDIF
C
      IF(NDE.EQ.-999.AND.MENGI.EQ.-999)NDE=-2
      IF(NDE.EQ.-999)NDE=0
      IF(MENGI.EQ.-999)MENGI=0
C
      if(ilog.eq.-999)then                  !set default log/lin spacing
        if(nde.lt.0)then
          ilog=1                                      !log (for char de)
        else
          ilog=0                                     !linear (for mengi)
        endif
      endif
c
      if(nde.eq.0)tolp=d1p10
      if(mengi.ge.0)tolp=dzero
      if(tolp.lt.dzero)tolp=d1pt2
c
      IF(NLAG.LT.1)THEN                       !=1 NO INTERP, USE NEAREST
        NLAG=2
        NLAG=MAX(NLAG,NLAG-MENGI)
        nlag=min(nlag,6_SP)                   !case large negative mengi
      ELSEIF(NLAG.GT.4.AND..NOT.BTHRSH)THEN
        WRITE(6,*)'USE OF NLAG=',NLAG
        WRITE(6,*)
     X          'IS NOT RECOMMENDED UNLESS ENERGIES ARE CLOSELY SPACED'
      ENDIF
C
C SAME SCATTERED ENERGIES ARE USED IN DWXLS AND DWXBP.
C
      MENG0=MENG
      IF(MENG0.LT.0)MENG=-MIN(-NLAG,MENG0,-IFOUR)
C
      IF(MENG.GT.MXD04)THEN                             !.or.mxeng.lt.5
        MM=MENG/MULT
        WRITE(6,250)MM+1
        WRITE(0,*)' *** NUMBER OF SCATTERING ENERGIES HAS BEEN REDUCED'
        WRITE(0,*)' *** INCREASE MXENG TO RETAIN ALL'
        MENG=MXD04
      ENDIF
C
      IF(MENG0.LT.0)THEN
C
        IF(EMAX.LT.EMIN)THEN                   !WAS NOT READ IN NAMELIST
          READ(5,*,END=22,ERR=22)EMIN0,EMAX0
          EMIN=EMIN0
          EMAX=EMAX0
        ENDIF
        IF(EMAX.GT.EMIN.AND.EMIN.LT.DZERO)EMIN=DZERO
C
  22    IF(NF.LE.0)GO TO 999
C
C
C-----------------------------------------------------------------------
C
C SET-UP SCATTERED ENERGIES INTERNALY.
C
        IF((EMAX-EMIN).LT.D1M5)THEN
          WRITE(6,604)EMIN,EMAX
          WRITE(0,*)'****ERROR IN SR.RADCX0, UNSUITABLE ENERGY RANGE'
          NF=-1
          GO TO 999
        ENDIF
C
        IF(MENG.LE.1)THEN                     !CASE MXENG=1
          WRITE(6,605)-MENG,MXENG
          WRITE(0,*)'****ERROR IN SR.RADCON, REQUIRE AT LEAST TWO ',
     X              'SCATTERED ENERGIES TO DEFINE RANGE, CASE MENG.LT.0'
          NF=-1
          GO TO 999
        ENDIF
C
        DD=MENG-1
        EMAX=EMAX+DONE
        EMIN=EMIN+DONE
        T0=EMAX/EMIN
        DO M=1,MENG
          DM=M-1
          T=T0**(DM/DD)
          DXX0(M)=EMIN*T-DONE
        ENDDO
C
        MENG0=MENG
C
      ELSEIF(MENG0.GT.0)THEN
C
        MENG0=MENG
C
C READ USER SUPPLIED SCATTERED ENERGIES (RYD)
C
        READ(5,*)(DXX0(I),I=1,MENG0)
C
        IF(NF.LE.0)GO TO 999
C
        IF(BTHRSH)THEN                           !ONLY HERE IF MENG0=1
          IF(DXX0(1).NE.DZERO)THEN               !ALLOW USER TO SET ZERO
            WRITE(0,*)'***RE-SETTING INPUT SCATTERING ENERGY TO ZERO...'
            DXX0(1)=DZERO
          ENDIF
        ENDIF
C
C RE-ORDER INTO ASCENDING ENERGIES (NOW NECESSARY)
C
        DO I=2,MENG0
          IM=I-1
          IF(DXX0(I).GT.DXX0(IM))GO TO 200
          T=DXX0(I)
          DXX0(I)=DXX0(IM)
          DXX0(IM)=T
C
          DO J=2,IM
            JM=I-J
            JJ=JM+1
            IF(DXX0(JJ).GT.DXX0(JM))GO TO 200
            T=DXX0(JJ)
            DXX0(JJ)=DXX0(JM)
            DXX0(JM)=T
          ENDDO
C
  200   ENDDO
C
C REMOVE DEGENERATE SCATTERING ENERGIES
C
        I=2
        DO I0=2,MENG0
          IF(DXX0(I)-DXX0(I-1).LT.DEPS)THEN
            DO J=I,MENG
              DXX0(J-1)=DXX0(J)
            ENDDO
            MENG=MENG-1
            I=I-1
          ENDIF
          I=I+1
          IF(I.GT.MENG)GO TO 26
        ENDDO
C
   26   MENG0=MENG
C
      ELSEIF(BTHRSH)THEN                                     !MENG=0
        MENG=1
        DXX0(1)=DZERO
        MENG0=MENG
      ELSE
C
C SET DEFAULT SCATTERED ENERGIES AS A FUNCTION OF I.P.
C
        IF(TEAPOT.LE.DZERO)THEN
          IC=INDEX(1)
          IF(NSL0.GT.0)IC=NFK(IC)                            !NOT CA
          DO IB=MXORB,1,-1
            IF(NEL(IB,IC).GT.0)GO TO 27
          ENDDO
C          STOP 'SR.RADCX0: SHOULD NEVER GET HERE'
  27      TEAPOT=DUY(IB,IB)-DEY(IB)
          TEAPOT=TEAPOT+TEAPOT
        ENDIF
        DEX=MAX(TEAPOT,DELTAX)
        MENG=4
        DXX0(1)=DZERO
        DXX0(2)=DEX/3
        DXX0(3)=DEX
        DXX0(4)=DEX*3
        IF(MAXLT.GT.35)THEN
          MENG=MENG+1
          DXX0(5)=DEX*8
        ENDIF
        MENG0=MENG
C
      ENDIF
C
C FIX FOR NEUTRALS
C
      IF(NZA.EQ.0.AND.DXX0(1).LT.D1M2)THEN
        WRITE(6,555)
        DO M=1,MENG0
          IF(DXX0(M).LT.D1M2)THEN
            DXX0(M)=D1M2
          ELSE
            GO TO 28
          ENDIF
        ENDDO
        NF=-1
      ENDIF
C
C WRITE SCATTERED ENERGIES
C
  28  WRITE(6,587)MENG0
      WRITE(6,588)(I,DXX0(I),I=1,MENG0)
      IF(NF.LT.0)THEN
        WRITE(0,*)
     X  '*** ERROR: ALL SCATTERING ENERGIES TOO SMALL FOR A NEUTRAL...'
        GO TO 999
      ENDIF
C
C ADD ENERGIES ABOVE LAST SCATTERED ENERGY, REQUIRED UP TO +DELTAX.
C
      IF(NIDX.Lt.0)THEN               !1=OLD DEFAULT, POOR FOR DIPOLES
        IF(MENG0.GT.1)THEN
          T=DELTAX/(DXX0(MENG0)-DXX0(MENG0-1))
          NIDX=T
          NIDX=MAX(ITWO,NIDX)
        ELSE
          NIDX=2                                               !SIMPLE
        ENDIF
        NIDX=MAX(NIDX,NLAG)
      ENDIF
C
      MENG00=MENG0
      IF(MENG0+NIDX.LE.MXD04.and.nde.le.0)THEN
        if(ilog.gt.0)then
          e0=DXX0(MENG0)+done
          e1=e0+DELTAX
          t0=e1/e0
          dd=nidx
          DO M=1,NIDX
            de=m
            t=t0**(de/dd)
            DXX0(MENG0+M)=e0*t-done
c            write(0,*)meng0+m,dxx0(meng0+m)
          ENDDO
        else
          if(nidx.gt.0)DE=DELTAX/NIDX
          DO M=1,NIDX
            DXX0(MENG0+M)=DXX0(MENG0)+DE*M
          ENDDO
        endif
        MENG00=MENG0+NIDX
      ENDIF
C
C-----------------------------------------------------------------------
C
C SET-UP CHARACTERISTIC EXCITATION ENERGIES DELTAE(I), I=0,NDE
C (COULD ALSO ATTEMPT TO SET FROM ACTUAL DSPECE VALUES...)
C
C ***CURRENTLY, NO INTERPOLATION OF SCATTERED ENERGIES AND SO *MUST*
C    HAVE DELTAE(0)=0 TO ENSURE INPUT SCATTERED ENERGIES ARE USED
C    AS INTERPOLATION ENERGIES AS WELL.***
C
      IF(ABS(NDE).GT.MXNDE)THEN
        WRITE(6,*)'***SR.RADCX0: INCREASE INTERNAL DIMENSION MXNDE TO'
     X            ,NDE
        WRITE(0,*)'***SR.RADCX0: INCREASE INTERNAL DIMENSION MXNDE'
        NF=-1
        GO TO 999
      ENDIF
C
      IF(NDE.LT.0)THEN                          !USE A RANGE OF DELTAE
C
        IF(DEMAX.LT.DEMIN)THEN               !WAS NOT READ IN NAMELIST
          DEMIN=DZERO
          DEMAX=DELTAX
C          READ(5,*,END=23,ERR=23)DEMIN0,DEMAX0   !ALLOW ONLY NAMELIST
C          IF(DEMIN0.GE.DZERO)DEMIN=DEMIN0         !TO AVOID CONFUSION
C          IF(DEMAX0.GT.DEMIN)DEMAX=DEMAX0
        ELSE
          IF(DEMIN.LT.DZERO)DEMIN=DZERO
        ENDIF
C
C 23     CONTINUE
        NDE0=-NDE
        NDE=0
C        IF(DEMIN.GT.DZERO)NDE=-1 !DROP ORIGINAL POINTS, NOT ALLOWED YET
C
        if(ilog.gt.0)then
          dd=nde0
          e2=done
          e0=done
          e1=DELTAX+e2
          t0=e1/e0
          DO I=1,NDE0
            di=i
            t=t0**(di/dd)
            t=e0*t-e2
            IF(T.GE.DEMIN)THEN
              NDE=NDE+1
              DELTAE(NDE)=T
              IF(T.GT.DEMAX)GO TO 23
            ENDIF
          ENDDO
 23       DELTAX=DELTAE(NDE)
        elseif(ilog.eq.0)then
          DE=DELTAX/NDE0
          DO I=1,NDE0
            T=DELTAE(I-1)+DE
            IF(T.GE.DEMIN)THEN
              NDE=NDE+1
              DELTAE(NDE)=T
              IF(T.GT.DEMAX)GO TO 24
            ENDIF
          ENDDO
 24       DELTAX=DELTAE(NDE)
        else                                      !use orbital energies
          do i=1,nbund
            deltae(i)=0                           !max delta-e (n.eq.n')
          enddo
          np=nbund
          nq=np+1
          do j=2,mxnde
            do i=1,j-1
              np=np+1
              nq=nq+1
              deltae(np)=0                        !max delta-e (n.ne.n')
              deltae(nq)=d1p30                    !min delta-e (n.ne.n')
            enddo
            np=nq
            nq=np+j
            if(nq+j.gt.mxnde)go to 25
          enddo
 25       nde=0
          do i=mb0+1,mxorb
            if(dey(i).ne.dzero)then
              nl=qn(i)
c              ll=ql(i)/2
              dei=duy(i,i)-dey(i)
              do j=i+1,mxorb
                if(dey(j).ne.dzero)then
                  nu=qn(j)
c                  lu=ql(j)/2
                  dej=duy(j,j)-dey(j)
                  de=2*abs(dei-dej)
                  nm=min(nl,nu)
                  nx=max(nl,nu)
                  if(nl.ne.nu)then
                    np=(nx-1)*(nx-2)+nm+nbund
                    nq=(nx-1)*(nx-1)+nm+nbund
                  else
                    np=min(nu,nbund)
                    nq=0
                  endif
c                  write(0,*)nl,nu,np,nq,de,deltae(np),deltae(nq)
                  deltae(np)=max(deltae(np),de)
                  deltae(nq)=min(deltae(nq),de)
                  nde=max(nde,np,nq)
                endif
              enddo
            endif
          enddo
          if(nde.gt.mxnde)then
            mm=nde/mult
            write(6,254)mm+1
            nf=-1
            go to 999
          endif
c          do i=1,nde
c            write(0,*)i,deltae(i)
c          enddo
          dpx=0
          dq=d1p30
          do i=1,nbund
            dpx=max(dpx,deltae(i))                !max delta-e (n.eq.n')
            if(deltae(i).gt.deps)dq=min(dq,deltae(i)) !min  "   "    "
            deltae(i)=0
          enddo
          deltae(1)=dpx
          deltae(2)=dq
          i=1
          nq=nde
          if(demin.eq.dzero)demin=deps               !just remove zeroes
          do i0=1,nq
            if(deltae(i).lt.demin.or.deltae(i).gt.demax
     x         .or.abs(deltae(i)-deltae(i-1)).lt.toldc*deltae(i)
     x                                                          )then
              do j=i+1,nde
                deltae(j-1)=deltae(j)
              enddo
              nde=nde-1
              i=i-1
            endif
            i=i+1
            if(i.gt.nde)go to 29
          enddo
   29     deltae(0)=dzero                            !just in case
        endif
C
      ELSEIF(NDE.GT.0)THEN
C
        READ(5,*)(DELTAE(I),I=1,NDE)
        DELTAX=DZERO
        DO I=1,NDE                                 !CASE OUT OF ORDER
          DELTAX=MAX(DELTAX,DELTAE(I))
        ENDDO
C
      ENDIF
C
C WRITE CHARACTERISTIC EXCITATION ENERGIES
C
      IF(NDE.NE.0)THEN
C
C FIRST RE-ORDER TO ASCENDING (NOT NECESSARY, BUT LESS CONFUSING)
C
        DO I=2,NDE
          IM=I-1
          IF(DELTAE(I).GT.DELTAE(IM))GO TO 30
          T=DELTAE(I)
          DELTAE(I)=DELTAE(IM)
          DELTAE(IM)=T
C
          DO J=2,IM
            JM=I-J
            JJ=JM+1
            IF(DELTAE(JJ).GT.DELTAE(JM))GO TO 30
            T=DELTAE(JJ)
            DELTAE(JJ)=DELTAE(JM)
            DELTAE(JM)=T
          ENDDO
 30     ENDDO
C
        WRITE(6,585)NDE+1
        WRITE(6,588)(I,DELTAE(I),I=0,NDE)
C
      ENDIF
C
C-----------------------------------------------------------------------
C
C READ ANY USER SUPPLIED INTERPOLATION ENERGY SET-UP
C (MENGI,EMINI,EMAXI,DXXI->DXX)
C
C
C SAME INTERPOLATION ENERGIES ARE USED IN DWXLS AND DWXBP.
C
      MENGI0=MENGI
      IF(MENGI0.LT.0)MENGI=-MENGI0
C
      IF(MENGI+MENG.GT.MXD04)THEN
        MM=(MENGI+MENG)/MULT
        WRITE(6,251)MM+1
        WRITE(0,*)'*** TOO MANY INTERPOLATION ENERGIES, INCREASE MXENG'
        NF=-1
        GO TO 999
      ENDIF
C
C SET-UP INTERPOLATION ENERGIES INTERNALY BY INSERTING -MENGI POINTS
C BETWEEN EXISTING SCATTERING ENERGY POINTS BETWEEN EMINI AND EMAXI,
C LIN OR LOG SPACED.
C
      IF(MENGI0.LT.0)THEN
C
        IF(EMAXI.LT.EMINI)THEN                 !WAS NOT READ IN NAMELIST
          EMINI=DZERO
          EMAXI=DXX0(MENG0)+DELTAX
C          READ(5,*,END=21,ERR=21)EMIN0,EMAX0       !ALLOW ONLY NAMELIST
C          IF(EMIN0.GE.DZERO)EMINI=EMIN0             !TO AVOID CONFUSION
C          IF(EMAXI.GT.EMINI)EMAXI=EMAX0
        ENDIF
        IF(EMAXI.GT.EMINI.AND.EMINI.LT.DZERO)EMINI=DZERO
C
C  21    CONTINUE
        IF(NF.LE.0)GO TO 999
C
        IF(EMAXI.LT.EMINI)THEN
          T=EMAXI
          EMAXI=EMINI
          EMINI=T
        ENDIF
c      write(0,*)'emini, emaxi=', emini,emaxi
c
        IF((EMAXI-EMINI).LT.D1M5)THEN
          WRITE(6,606)EMINI,EMAXI
          WRITE(0,*)'****ERROR IN SR.RADCX0, UNSUITABLE ENERGY RANGE'
          NF=-1
          GO TO 999
        ENDIF
C
C NOW INSERT -MENGI ENERGIES
C
        DD=MENGI+1
        IM=0
        MP=1
        if(nde.le.0)MP=MP-NIDX
C
        if(ilog.gt.0)then                !log spacing of inserted points
          DO M=1,MENG0-MP
            IF(DXX0(M).GE.EMINI.AND.DXX0(M+1).LE.EMAXI .AND.
     X         DXX0(M+1)-DXX0(M).LT.TOLP*DELTAX)THEN
              e0=DXX0(M)+done
              e1=DXX0(M+1)+done
              t0=e1/e0
              DO I=1,MENGI
                IM=IM+1
                IF(IM.LE.MXD04)THEN
                  di=i
                  t=t0**(di/dd)
                  DXX(IM)=e0*t-done
C                  write(0,*)im,dxx(im),dxx0(m),dxx(im)-dxx0(m)
                ENDIF
              ENDDO
            ENDIF
          ENDDO
        else                          !linear spacing of inserted points
          DO M=1,MENG0-MP
            IF(DXX0(M).GE.EMINI.AND.DXX0(M+1).LE.EMAXI .AND.
     X         DXX0(M+1)-DXX0(M).LT.TOLP*DELTAX)THEN
              DE=(DXX0(M+1)-DXX0(M))/DD
              DO I=1,MENGI
                IM=IM+1
                IF(IM.LE.MXD04)DXX(IM)=DXX0(M)+I*DE
c                  write(0,*)im,dxx(im),m,dxx0(m)      !,dxx(im)-dxx0(m)
              ENDDO
            ENDIF
          ENDDO
        endif
C
        IF(MP.LE.0)THEN                                          !EQ->LE
          IM=IM+1
          IF(IM.LE.MXD04)DXX(IM)=DXX0(MENG00)                    !0->00
        ENDIF
C
        IF(IM.GT.MXD04)THEN
          MM=IM/MULT
          WRITE(6,251)MM+1
          WRITE(0,*)'***TOO MANY INTERPOLATION ENERGIES, INCREASE MXENG'
          NF=-1
          GO TO 999
        ENDIF
C
        MENGI=IM
C
      ELSEIF(MENGI.GT.0)THEN
C
C READ USER SUPPLIED INTERPOLATION ENERGIES (RYD)
C
        READ(5,*)(DXX(I),I=1,MENGI)
C
        IF(NF.LE.0)GO TO 999
        IF(MENGI.EQ.1)GO TO 203
C
C RE-ORDER INTO ASCENDING ENERGIES (NOT NECESSARY, BUT LESS CONFUSING)
C
        DO I=2,MENGI
          IM=I-1
          IF(DXX(I).GT.DXX(IM))GO TO 202
          T=DXX(I)
          DXX(I)=DXX(IM)
          DXX(IM)=T
C
          DO J=2,IM
            JM=I-J
            JJ=JM+1
            IF(DXX(JJ).GT.DXX(JM))GO TO 202
            T=DXX(JJ)
            DXX(JJ)=DXX(JM)
            DXX(JM)=T
          ENDDO
  202   ENDDO
C
      ELSEIF(NDE.EQ.0)THEN
C
        DXX(1)=DXX0(MENG0)+DELTAX
        MENGI=1
C
      ENDIF
C
      IF(MENGI0.GT.0.and.nde.eq.0)THEN
        IF(DXX(MENGI).LT.(0.9D0*DXX0(MENG0)+DELTAX))THEN
          WRITE(6,500)DXX(MENGI),DXX0(MENG0)+DELTAX
          WRITE(0,*)
     X'*** MAX INTERPOLATION ENERGY TOO SMALL FOR MAX SCATTERED ENERGY'
        ENDIF
      ENDIF
C
  203 IF(NZA.EQ.0.AND.DXX(1).LT.D1M2)THEN
        WRITE(6,556)
        DO M=1,MENG0
          IF(DXX(M).LT.D1M2)THEN
            DXX(M)=D1M2
          ELSE
            GO TO 204
          ENDIF
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C NOW SET-UP COMPLETE BASIS OF INTERPOLATION ENERGIES
C (ADD-IN ORIGINAL MENG0 POINTS PLUS ANY DUE TO NDE.)
C
C-----------------------------------------------------------------------
C
  204 MENG=(NDE+1)*MENG00+MENGI                   !MAX POSSIBLE
C
      MX=MIN(MENG,MXD04)
      DO M=1,MX
        IXX(M)=0
        IXX0(M)=0
      ENDDO
c
      t0=dxx0(meng0)+deltax+d1m5
C
      MENG=MENGI
      DO M=1,MENG00
C
        IF(DELTAE(0).EQ.DZERO)THEN
          MENG=MENG+1
          IF(MENG.LE.MXD04)THEN
            IF(M.LE.MENG0)THEN
              IXX(MENG)=M                      !FLAG SCATTERING ENERGIES
            ELSE
              IXX(MENG)=-999                     !FLAG THE NIDX ENERGIES
            ENDIF
            DXX(MENG)=DXX0(M)
          ENDIF
        ENDIF
C
        IF(NDE.GT.0               )THEN
c                  .and.m.le.meng0
          IF(M.LT.MENG00)THEN
            T1=DXX0(M+1)
          ELSE
            T1=DXX0(M)+TOLP*DELTAX+D1M5
          ENDIF
          IF(T1-DXX0(M).GE.TOLP*DELTAX)THEN
            DO N=1,NDE
              T=DXX0(M)+DELTAE(N)
             if(t.lt.t0)then
              MENG=MENG+1
              IF(MENG.LE.MXD04)DXX(MENG)=T
c            else
c              do not bailout as deltae may not be energy ordered
             endif
            ENDDO
          ENDIF
        ENDIF
C
      ENDDO
C
      IF(MENG.GT.MXD04)THEN
        MM=MENG/MULT
        WRITE(6,253)MM+1
        NF=-1
        GO TO 999
      ENDIF
C
C RE-ORDER INTO ASCENDING ENERGIES
C
      DO I=2,MENG
        IM=I-1
        IF(DXX(I).GT.DXX(IM))GO TO 205
        T=DXX(I)
        DXX(I)=DXX(IM)
        DXX(IM)=T
        M=IXX(I)
        IXX(I)=IXX(IM)
        IXX(IM)=M
C
        DO J=2,IM
          JM=I-J
          JJ=JM+1
          IF(DXX(JJ).GT.DXX(JM))GO TO 205
          T=DXX(JJ)
          DXX(JJ)=DXX(JM)
          DXX(JM)=T
          M=IXX(JJ)
          IXX(JJ)=IXX(JM)
          IXX(JM)=M
        ENDDO
C
  205 ENDDO
C
C PRUNE CLOSELY ADJACENT ENERGIES (BUT DO NOT DROP ANY ORIGINAL POINTS,
C NOR THE LAST, UNLESS ACCIDENTLY DEGENERATE, AND RETAIN ENOUGH FOR
C INTERPOLATION AT HIGH-E - SEE TDE)
C
      IF(TOLDE.LT.DZERO)THEN
        TOLDE=TOLDE0
        IF(NDE.NE.0.OR.MENGI0.LT.0)TOLDE=TOLDE/2
      ENDIF
      TDE=0.95D0*DELTAX
C
      MX=MENG
COLD      IF(IXX(MX).EQ.0)IXX(MX)=-999             !NOW FLAGGED ALL NIDX
C
      I=2
      DO IX=2,MX
        T=ABS(DXX(I)-DXX(I-1))
        IF(T.LE.TOLDE*DXX(I).AND.T.LT.TDE)THEN
          IP=0
          IF(IXX(I).EQ.0)THEN
            IP=I+1
          ELSEIF(IXX(I-1).EQ.0)THEN
            IP=I
          ELSEIF(T.LE.D1M5*DXX(I))THEN
            IP=I
            if(ixx(i).lt.0)ixx(i)=ixx(i-1)
          ENDIF
          IF(IP.GT.0)THEN
            DO J=IP,MENG
              DXX(J-1)=DXX(J)
              IXX(J-1)=IXX(J)
            ENDDO
            MENG=MENG-1
            I=I-1
          ENDIF
        ENDIF
        I=I+1
        if(i.gt.meng)go to 17                     !we are done, bail out
      ENDDO
C
  17  CONTINUE                         !IF(IXX(MENG).EQ.-999)IXX(MENG)=0
C
      DO M=1,MENG
        IF(IXX(M).EQ.-999)THEN
          IXX(M)=0
        ELSE
          M0=IXX(M)
          IF(M0.GT.0.AND.M0.LE.MENG0)IXX0(M0)=M
        ENDIF
      ENDDO
C
C TRANSFER (REDUCED SET) TO COMMON VARIABLES
C
      CALL DIMUSE('MXENG',MENG)
C
      IF(MENG.GT.MXENG)THEN
        WRITE(6,252)MENG
        NF=-1
        GO TO 999
      ENDIF
C
      DO M=1,MENG
        IYY0(M)=IXX0(M)
        DYY0(M)=DXX0(M)
        DYY(M)=DXX(M)
      ENDDO
C
C WRITE INTERPOLATION ENERGIES (RYD)
C
      WRITE(6,586)MENG
      WRITE(6,588)(I,DYY(I),I=1,MENG)
C
C WRITE MAPPING OF SCATTERED TO INTERPOLATION
C
      WRITE(6,584)(M0,IYY0(M0),M0=1,MENG0)
C
C WRITE LAGRANGE INTERPOLATION INFO
C
      WRITE(6,589)NLAG
C
C-----------------------------------------------------------------------
C
C SET-UP A MAPPING OF MTRAN INTERACTING ENERGY PAIRS:
C MNDEX(M,MT) GIVES ENERGY PAIRS (M=1,2) FOR MT=1,MTRAN.
C FORMALLY, |E1-E2|.GT.DELTAE DO NOT CONTRIBUTE.
C FOR INTERPOLATION, WE GO NLAG/2 POINTS FURTHER.
C (WILL NOT CATCH USER DELTAX << NEEDED.)
C WE MUST ALSO CATCH THE REVERSE CASE BECAUSE OF USE
C OF FALLING ORDER ON TWO-BODY INTEGRALS.
C
      IF(DELTAX.LT.0.9D0*DSPECE(NSPECE))THEN
        WRITE(6,580)DELTAX,DSPECE(NSPECE)
        WRITE(0,*)
     X'***LARGEST FLAGGED EXCITATION ENERGY LESS THAN MAX TARGET ENERGY'
        WRITE(0,*)'***COLLISION INTEGRALS ARE BEING EXTRAPOLATED!'
      ENDIF
C
      do m2=1,meng
        do m1=1,meng
          btmp(m1,m2)=.false.
        enddo
      enddo
C
C FIRST PASS SETS PAIRS, BUT MAY NOT CATCH REVERSE ENERGY MATCH
C
c      write(0,*)deltax
      TE=DELTAX+DEPS
      NLAG2=(NLAG+1)/2
C
      DO M0=1,MENG0
        M2=IYY0(M0)
        DO M1=M2,MENG
          IF(DYY(M1)-DYY(M2).GT.TE)THEN
            LP=M1
            GO TO 210
          ENDIF
        ENDDO
        LP=MENG
  210   CONTINUE
        LM0=MAX(IONE,M2-NLAG2+1)
        LP0=MIN(MENG,LP+NLAG2)   !NLAG2-1 -> NLAG2 for dipole (see xint)
        DO M1=LM0,LP0
          btmp(m1,m2)=.true.
        ENDDO
      ENDDO
c
c so, if one pair is required, flag the reverse pair as well
c
      do m0=1,meng0
        m2=iyy0(m0)
        do m1=1,meng
          btmp(m2,m1)=btmp(m1,m2)
        enddo
      enddo
c
c Allow user to flag removal, e.g. from a test-run - see sr.dwx, fn.xint
c to uncomment such log info. Be wary if reverse not flagged, maybe need
c by falling order reverse integral.
c
      do n=1,nskpi
        read(5,*)m1,m2
        btmp(m1,m2)=.false.
      enddo
c
c now we can index
c
      MTRAN=0
      do m2=1,meng
        ml=0
        mu=0
        do m1=1,meng
          if(btmp(m1,m2))then
            MTRAN=MTRAN+1
            MNDEX(MTRAN,1)=M1
            MNDEX(MTRAN,2)=M2
c            write(6,*)mtran,m1,m2,dyy(m1),dyy(m2)
            mu=m1
          else
            if(mu.eq.0)ml=m1
          endif
        enddo
        if(ixx(m2).gt.0)then                        !a scattering energy
          mlim(m2,1)=ml+1
          mlim(m2,2)=mu
          if(mu-ml.lt.nlag)then
            write(0,*)'Not enough interpolation integral energies'
            if(nlag.gt.2)then
              write(0,*)'Try decreasing NLAG to',nlag-1
              write(6,596)nlag-1
            else
              write(0,*)'Check deltax not set too small?'
c              write(0,*)m2,ml+1,mu,dyy(m2),deltax
              write(6,597)deltax
            endif
            nf=-1
            go to 999
          endif
        else                                     !shouldn't be necessary
          mlim(m2,1)=0
          mlim(m2,2)=-1
        endif
      enddo
C
      WRITE(6,582)MTRAN
C
C SET-UP REVERSE MAPPING INDEX (COULD DO BETTER)
C
      DO M=1,MTRAN
        M1=MNDEX(M,1)
        M2=MNDEX(M,2)
        IF(M1.NE.M2)THEN
          DO MM=1,MTRAN
            IF(M1.EQ.MNDEX(MM,2).AND.M2.EQ.MNDEX(MM,1))THEN
              MRNDX(M)=MM
              GO TO 33
            ENDIF
          ENDDO
          write(6,*)'***',m,m1,m2
          stop 'mtran index error 2'                  !should not happen
        ELSE
          MRNDX(M)=M
        ENDIF
  33  ENDDO
C
C-----------------------------------------------------------------------
C
C GENERATE A UNIQUE CONTINUUM DW POTENTIAL FOR THE BASIS
C
C-----------------------------------------------------------------------
C
      T=SQRT(DYY(MENG))                         !FIRST CHECK RADIAL MESH
      IF(T.NE.DZERO)THEN
        T=PI/T
        T=T/DHNSX
C        IF(T.LT.DTWELV)THEN
          IF(T.LT.DSIX)THEN
            M0=MSTEP+1
            WRITE(6,1222)DYY(MENG),M0
            WRITE(0,*)'RADIAL MESH TOO COARSE'
            NF=-1
            GO TO 999
          ENDIF
C        ENDIF
      ENDIF
C
      IF(DLAMX.LE.DZERO)THEN                    !SET DEFAULT CONT LAMBDA
        IF(NZA.GT.2)THEN
          DLAMX=1.3D0
        ELSE
          DLAMX=DONE+0.1D0*NZA
        ENDIF
      ENDIF
C
      IF(BORT)THEN                               !FIND SCALING PARAMETER
        IC=MXORB+1
        IF(NPARAM.GT.MXORB)THEN
          DJ=DADJUS(IC)
        ELSE
          DJ=DLAMX              !SINCE LAST BOUND MAY NOT BE APPROPRIATE
          DADJUS(IC)=DJ         !RADCNX JUST NEEDS SIGN - FCF6 OR FCF4
          NPARAM=IC             !INDEX IT
        ENDIF
      ELSE
        IC=NPARAM
        DJ=DADJUS(IC)
      ENDIF
      if(dj.eq.dzero)dj=dlamx
C
      IF(DJ.GT.0)THEN
        IF(.NOT.BSTO)MRED=-1                            !ADD AN ELECTRON
        IF(BSTO)MRED=0                                  !DONE IN STOPOT
        MYN=MION-MRED                                   !N+1
        DS=DZ
        DJ0=DJ
      ELSE
        IF(IORT.LT.0)DS=-DJ*DZ     !I.E. NOT USED. USE ASYMPTOTIC CHARGE
        DS=NZION-MION
        MYN=1
        DJ0=DONE
      ENDIF
C
      DHNS0=DHNS(1)
      MK=MXORB+1
      QN(MK)=-90
      QL(MK)=0
      SCREEN(MK)=9999
      IVAL(MK)=0
      IF(BSTO.AND.MCFMX.GT.0)THEN
        IF(MCFSTO(MK).EQ.0)MCFSTO(MK)=1  !ASSUME USER LISTS GROUND FIRST
        MCFMX=MK
      ENDIF
      MPP=1                             !PLASMA POTENTIAL
      IF(MDEN.LT.0)MPP=2
C
      IF(.NOT.BSTO)CALL TFDAPO(DS,MYN,MK,DJ0,DONE,DONE,DHNS0,MAXRS,MJH
     X                        ,MNH,DHNS,DX,DPOT,TOL,MEND,DZERO,DZERO)
C
      IF(BSTO)CALL STOPOT(DS,MYN,MK,DJ0,DHNS0,MAXRS,MJH,MNH,DHNS,DX
     X                   ,DPOT,DTOL,MEND,MPP)
C
      IF(NF.LE.0)GO TO 999                              !RETURN
C
      IF(DHNS(1).NE.DHNS0)THEN
        WRITE(6,*)'SR.RADCX0: PROBLEM GENERATING N+1 POTENTIAL'
        WRITE(0,*)'SR.RADCX0: PROBLEM GENERATING N+1 POTENTIAL'
        NF=-1
        GO TO 999
      ENDIF
C                                                 V(X>X(MEND)) COULOMBIC
      IF(.NOT.BSTO)WRITE(6,774)DJ,MEND,DX(MEND)
      IF(BSTO)WRITE(6,775)DJ,MEND,DX(MEND)
      JEND(MK)=MEND
C
C NOW LOOK TO REDUCE RADIAL MESH EXTENT FOR SCATTERING INTEGRALS.
C THIS IS A BALANCE BETWEEN MEMORY USAGE FOR THE BASIS AND TIME
C SPENT RE-GENERATING IT ASYMPTOTICALY.
C
      IF(RZERO.GT.DZERO)THEN
        DO M=1,MAXRS
          IF(DX(M).GT.RZERO)GO TO 43
        ENDDO
        M=MAXRS
  43    MAXPS=M
      ELSE
        MAXPS=0
        DO K=1,MXORB
          IF(DEY(K).NE.DZERO)THEN
            DO M=1,MAXRS
              IF(ABS(DPNL(M,K)).GT.TOLR)MAXPS=MAX(MAXPS,M)
            ENDDO
          ENDIF
        ENDDO
      ENDIF
C
      MAXRS0=MAXRS
      MAXRS=0
      MJH0=MJH
      DO I=1,MJH0
        MAXRS=MNH(I)+MAXRS
        MJH=I
        IF(MAXRS.EQ.MAXPS)GO TO 609
        IF(MAXRS.GT.MAXPS)THEN
          MAXRS=MAXRS-MNH(I)
          MNH(I)=MAX(MAXPS-MAXRS,ININE)
          MAXRS=MAXRS+MNH(I)
          GO TO 609
        ENDIF
      ENDDO
C
  609 WRITE(6,700)MAXRS0,DX(MAXRS0),MAXRS,DX(MAXRS)
C
C V -> 2(V-Z/R)
C
      DO I=1,MAXRS
        DPOT(I)=DPOT(I)-DZ/DX(I)
        DPOT(I)=DPOT(I)+DPOT(I)
      ENDDO
C
C RE-ALIGN FINITE NUCLEUS FOR FCF6
C (FINITE NUCLEUS INITIALIZED IN SR.RADIAL)
C
      DO I=1,INUK
        DNUK(I)=DTWO*(DNUK0(I)-DZ/DX(I))
      ENDDO
C
      ZS(0)=DTWO*ZS0(0)
C
C INITIALIZE CONTINUUM DW POTENTIAL FOR KAPPA-AVERAGED ORBITALS
C
      IF(BREL)THEN
C
        DO I=1,MAXRS
          GR(I)=DPOT(I)
          GR(I)=GR(I)+DTWO*VSC(I)                        !+PLASMA POT
        ENDDO
C
C SET-UP POTENTIAL DERIVATIVES FOR DARWIN
C
        CALL DIFF(GR,DERV1,MNH,DHNS,MJH)
        CALL DIFF(DERV1,DERV2,MNH,DHNS,MJH)
C
        INUKP=INUK+1
C
        DO I=INUKP,MAXRS
          T=DX(I)**2
          DERV1(I)=DHALF*DERV1(I)-DZ/T
          DERV2(I)=DHALF*DERV2(I)+DTWO*DZ/(T*DX(I))
        ENDDO
C
C ADD-IN FINITE NUCLEUS
C
        DO I=1,INUK
          DERV1(I)=DHALF*DERV1(I)+DNUK1(I)
          DERV2(I)=DHALF*DERV2(I)+DNUK2(I)
c          write(6,*)i,dx(i),dnuk(i),derv1(i),derv2(i)
        ENDDO
C
        DO J=1,JZNM
          ZS(J)=DTWO*ZS0(J)
        ENDDO
C
      ELSE                                !JUST POWER SERIES NEAR ORIGIN
C
        M1=0
        DD=DZERO
C
        CALL FIT(DD,M1,DHNS(1),DPOT,ZS(1))
C
        IF(RNUK.GT.DZERO)THEN                 !ADD-IN FINITE NUCLEUS
          DO J=1,JZNM
            ZS(J)=ZS(J)+DTWO*ZS0(J)
          ENDDO
        ENDIF
C
      ENDIF
C
  999 RETURN
C
  998 WRITE(6,1997)
      WRITE(0,*)'*** SR.RADCX0: ERROR READING NAMELIST SRADCON!'  !FATAL
      NF=-1
      GO TO 999
C
C
  250 FORMAT(/' THE NUMBER OF SCATTERED ENERGIES HAS BEEN REDUCED'/
     X' INCREASE MXENG TO',I4,' TO RETAIN ALL, CONTINUING...'/)
  251 FORMAT(/' TOO MANY INTERPOLATION ENERGIES INCREASE MXENG TO',I4)
  252 FORMAT(/' INCREASE MXENG TO',I4,' OR REDUCE NUMBER OF SCATTERING'
     X,' AND/OR CHARACTERISTIC ENERGIES')
  253 FORMAT(/'NOT ENOUGH BUFFER SPACE (MXD04), INCREASE MXENG TO',I4
     X,' OR REDUCE NUMBER OF SCATTERING'
     X,' AND/OR CHARACTERISTIC ENERGIES')
  254 FORMAT(/'NOT ENOUGH BUFFER SPACE (MXNDE), INCREASE MXENG TO',I4)
  500 FORMAT(/'*** WARNING: LARGEST USER SUPPLIED INTERPOLATION ENERGY'
     X,F10.3/'IS LESS THAN LARGEST SCATTERED ENERGY PLUS TARGET ENERGY'
     X,F10.3/3X,
     X'TRANSITIONS WITH LARGER EXCITATION ENERGIES WILL BE INACCURATE!')
  555 FORMAT(/'*** RE-SETTING SCATTERED ENERGY E=0 TO 0.01 FOR NEUTRALS'
     X)
  556 FORMAT(/'*** RE-SETTING INTERPOLATION ENERGY E=0 TO 0.01 FOR '
     X,'NEUTRALS')
  580 FORMAT(//'*** WARNING: YOUR LARGEST CHARACTERISTIC EXCITATION '
     X,'ENERGY',F10.3,' IS LESS THAN THE MAX TARGET ENERGY',F10.3/4X,
     X'TRANSITIONS WITH LARGER EXCITATION ENERGIES WILL BE INACCURATE!')
  582 FORMAT(/' RESULTANT TOTAL NUMBER OF ENERGY INTEGRAL PAIRS:',I4)
  584 FORMAT(//' THE SCATTERED ENERGIES ARE MAPPED TO THE INTERPOLATION'
     X,' ENERGIES AS FOLLOWS:'/(/15(I5,I3)))
  585 FORMAT(//' THE',I4,'  CHARACTERISTIC EXCITATION ENERGIES (RYD)'
     X,' ARE AS FOLLOWS:'/)
  586 FORMAT(//' THE',I4,'  CONTINUUM INTERPOLATION ENERGIES (RYD)'
     X,' ARE AS FOLLOWS:'/)
  587 FORMAT(//' THE',I4,'  INPUT SCATTERED CONTINUUM ENERGIES (RYD)'
     X,' ARE AS FOLLOWS:'/)
  588 FORMAT(11(I3,F9.3))
  589 FORMAT(//' WHERE AN NLAG=',I2
     X,'-POINT LAGRANGE INTERPOLATION IS TO BE USED.')
  590 FORMAT(2F10.1,3I5)
  596 format(//'Not enough interpolation integral energies'
     x             ,' - try decreasing NLAG to',i3)
  597 format(//'Not enough interpolation integral energies'
     x             ,' - check DELTAX=',f10.3,' not set too small?')
  600 FORMAT(/' ****ERROR IN SR.RADCON, CANNOT READ/USE ADDITIONAL'
     X,' SCATTERING ENERGIES WITH THRESHOLD PARTIAL COLLISION STRENGTHS'
     X,' (LVMAX.GE.0)'/
     X,' ****RE-SET MENG=0 (DEFAULT) AND ADJUST INPUT ACCORDINGLY')
  604 FORMAT(/' ****ERROR IN SR.RADCON, UNSUITABLE ENERGY RANGE FOR ',
     X'SCATTERING ENERGIES, EMIN=',F10.4,3X,'EMAX=',F10.4/)
  605 FORMAT(/'****ERROR IN SR.RADCON, REQUIRE AT LEAST TWO '
     X,'SCATTERED ENERGIES TO DEFINE RANGE, CASE MENG.LT.0'
     X/' BUT MENG=',I3,' AND MXENG=',I3)
  606 FORMAT(/' ****ERROR IN SR.RADCON, UNSUITABLE ENERGY RANGE FOR ',
     X'INTERPOLATION, EMINI=',F10.4,3X,'EMAXI=',F10.4/)
  700 FORMAT(/' REDUCING RADIAL EXTENT FROM  X(',I5,')=',F8.3,'  TO  X('
     X,I5,')=',F8.3,'  FOR',' SCATTERING INTEGRALS'//)
  774 FORMAT(///' CONTINUUM S.M.-POTENTIAL WITH SCALE FACTOR'
     X,F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  775 FORMAT(///' CONTINUUM STO.-POTENTIAL WITH SCALE FACTOR'
     X,F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC BEYOND R(IEND='
     X,I5,') =',F10.6)
 1222 FORMAT(/' SR.RADCX0: EMAX=',1PD9.2,' MESH TOO COARSE, CONTINUUM-',
     X'CONTINUUM INTEGRALS IN ERROR.'/'*** REDUCE EMAX IN NAMELIST ',
     X'SRADCON OR INCREASE MSTEP TO',I3,' IN NAMELIST SMINIM')
 1997 FORMAT('*** SR.RADCX0: ERROR READING NAMELIST SRADCON!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
C
      END SUBROUTINE RADCX0
C
C                             *******************
C
      SUBROUTINE RADIAL(DAJNEW)
C
C-----------------------------------------------------------------------
C
C  SR.RADIAL CALCULATES THOSE RADIAL FUNCTIONS FOR WHICH THE POTENTIAL
C  V(L) IS TO BE CHANGED SINCE PREVIOUS CALLS, DAJNEW(J).NE.DADJUS(J)
C  J=L+1; FOR FUNCTIONS NOT NEEDED DEY(K) HAS BEEN INITIALIZED AS 0.;
C  NK,LK=QN(K),QL(K)/2, NORMALLY (ALGEB1) K=1,2,3.. FOR NL=1S,2S,2P..
C  ALTERNATE STO POTENTIAL AND/OR V(NL).
C
C  IT CALLS:
C    SR.BDCF3
C    SR.BXSCHN
C    SR.DIFF
C    SR.DIMUSE
C    SR.MESH
C    SR.RADCON
C    SR.RADWAV
C    SR.RADWIN
C    SR.STOPOT
C    SR.TFDAPO
C    SR.MVDINT
C    SR.VMPOT
C    SR.VNUKE
C    SR.VPNL
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: IRL
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL,MXQIN
      USE COMMON_NRBFSI, ONLY: BNRBFSI,DNLI,NLI
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
c      PARAMETER (MXD01=14)
      PARAMETER (MXD12=100)
      PARAMETER (MXD14=100)
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      PARAMETER (DEL=1.D-6)                 !SEE ALSO MINIM
      PARAMETER (DTOL=0.01D0)
      PARAMETER (DKEY=999.D0)
      PARAMETER (D1PT05=1.05D0)
      PARAMETER (D99=99.0D0)
      PARAMETER (D999=999.0D0)
      PARAMETER (D5999=5999.0D0)
      PARAMETER (DLAM0=1.D-10)              !DAJNEW=DADJUS
      PARAMETER (TOLPP=1.D-5)
C
      CHARACTER(LEN=3) LAB1,LAB2
      CHARACTER(LEN=4) TLBL
      CHARACTER(LEN=12) LABB
C
      DIMENSION DAJNEW(MXVAR),DEOLD(MAXGR)
C
      COMMON /BASIC/NF,KV,MGAP(10)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
      COMMON /COM6/DA(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /COMIKE/DP0,DQ0,pnorm
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBBOX/TINORB,RZERO,MXBOX
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
C      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBEXT/BHFF
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBPOT/POT(MAXB1,MXPOT),JPOT1
      COMMON /NRBQED/VPINT(MAXGR),SLFINT(MAXGR),QED
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBRAD/IRAD(MAXGR)
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBSPL/DP(MAXB1),DERV1(MAXB1),DERV2(MAXB1),DQ(MAXB1)
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
c      common /nrbinf/rinf2(maxgr)
C
      SAVE INUKP,MAXPS
      save maxrs0                      !not necess. but useful for debug
C
      DATA MRWR/13/,BHFF0/.FALSE./
C
C   THE RADIAL FUNCTIONS WILL BE CALCULATED UNTIL THE RELATIVE CHANGE
C     IN THE EIGENVALUE IS SMALLER THAN TOL
C
      TOL=DONE/10**ITOL
C
      MDEN10=MOD(MDEN,ITEN)
      IF(MDEN.NE.0)THEN
C
C MIGHT BE FASTER TO USE OLD DENSITY FUNCTIONS?
C  SO COMMENT-OUT MP0 BELOW.....
        MP0=0
C
C MAX NO OF ITERATIONS OF RADIAL FUNCTIONS FOR SELF-CONSISTENT SOLUTION
C  SUBJECT TO ALL EPSILONS CONVERGING TO TOLPP (THEN BMPP=.FALSE.)
C
        MPP5=ABS(NPITER)
        IF(MDEN.LT.-1)MPP5=MAX(-MDEN,MPP5)
        MPP=1
        IF(BJUMP)MPP=2
        BMPP=.FALSE.
        do i=1,mxorb
          DEOLD(i)=DZERO
c          rinf2(i)=d1p10
        enddo
      ELSE
        MPP=0
      ENDIF
C
      IF(MAXB2.LT.MAXB1)THEN
        WRITE(6,*)'***SR.RADIAL ERROR: INCREASE MAXB2 TO MAXB1',MAXB2
     X            ,MAXB1
        WRITE(0,*)'***SR.RADIAL ERROR: INCREASE MAXB2 TO MAXB1'
        GO TO 999                                             !RETURN
      ENDIF
C
      IF(MORT.LE.-4.AND.IUNIT(16).EQ.0)THEN       !BOX/LPS
        IUNIT(16)=1
        OPEN(16,FILE='OVRLAP',STATUS='REPLACE')   !ORBITAL OVERLAP LIST
      ENDIF
C
      BDR=IDR.NE.0
      BCONT=MODE.EQ.2.OR.MODE.EQ.3
C
      DZ=NZION
      BREL2=ABS(IREL).EQ.2
C
      JPOT=-1
      LOLD=-1
      EOLD=DZERO
      DDE=DONE                                   !FOR NO NEW DQNL
      NZA=MAX(IONE,NZION-MION+1)
      TOLR=DEL/NZA
C
      BORT=MORT.LT.0                             !.T.= NL-DEP ELSE L-DEP
      IORT=ABS(MORT)
      IF(IORT.EQ.5)TOLR=TINORB                   !RZERO
      BHF=MHF.GT.0
      IF(BHFF)BHFF0=.TRUE.
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
      BPRNT3=JPRINT.NE.-3
C
      MB0=MB
      IF(IEQ(0).LT.0)MXBORB=-IEQ(0)              !FOR NON-UNIQUE BASIS
      IF(IEQ(0).GT.0)THEN                        !UNPACK
        IF(IRLX.LT.0)MB0=0
        ID=IEQ(0)-MXORB
        NGRP=ID/100000
        ID=ID-100000*NGRP
        MXFORB=ID/10000
        ID=ID-10000*MXFORB
        MXVORB=ID/1000
        ID=ID-1000*MXVORB
        MXBORB=ID
C       write(0,*)ngrp,mxborb,mxvorb,mxforb
      ENDIF
C
C PRINT DETAILS OF RELATIVISTIC RADIAL OPERATORS
C
      INUK=-1
      IF(BREL.AND.BPRNT0)THEN
        LAB1='OFF'
        IF(ABS(IREL).EQ.2)LAB1=' ON'
        LAB2='OFF'
        IF(IRTARD.NE.0)LAB2=' ON'
        WRITE(6,880)LAB1,IREL,LAB2,IRTARD
        LABB='            '
        IF(IBREIT.LT.0)LABB='GENERALIZED+'
        IF(IBREIT.GT.0)LABB='GENERALIZED '
        WRITE(6,879)-KUTSO,KUTSS,KUTOO,LABB,IBREIT,QED
      ENDIF
C
C SOME INITIALIZATIONS
C
      IF(.NOT.BJUMP)THEN
        MSHIFT=10000
        TSHFT=4*MSHIFT
        BLAG=.FALSE.
        IVLSUM=0
        DO I=1,MXORB                                     !MAXGR
          IVLSUM=IVLSUM+IVAL(I)
          IRAD(I)=0
          DSHIFT(I)=DZERO
          MI=QN(I)
          QN(I)=ABS(MI)
          IYY(I)=-1
C         DORIG(I)=DONE
        ENDDO
        IF(IRLX.EQ.2)THEN
          II=(MXORB*(MXORB-1))/2
          DO I=1,II
            OVLPGR(I)=DZERO
          ENDDO
          II=(KMAX*(KMAX-1))/2
          DO I=1,II
            OVLPCF(I)=DZERO
          ENDDO
        ENDIF
      ENDIF
C
C CALCULATE DPNL(I,K)=<NL(K)!X(I)> FOR NK,LK=QN(K),QL(K)/2 AT X(I)
C   ACCORDING TO INTERVAL SET-UP OF STATISTICAL MODEL(=S.M.) POTENTIAL
C   EVALUATE DUY(J,K)=<NL(J)! V(L)-Z/X !NL(K)> FOR LJ=LK=L, E&N 2.8,
C   AND FOR N'=N DEY(K)=DUY(K,K)+EIGENENERGY/2RY(=2EPSILON,E+N2.1)
C
C SR. TFDAPO CALCULATES STATISTICAL MODEL POTENTIAL FOR MION ELECTRONS
C   AND ELECTRIC NUCLEAR CHARGE DZ; SR. STOPOT CALCULATES SLATER-TYPE-
C   ORBITAL UNIVERSAL POTENTIAL FOR MION-1 ELECTRON ION WITH CHARGE DZ
C   OUTPUT: POTENTIAL IN /COM1/, DX(I)=X(I) FROM INTERVAL SET-UP MJH..
C   DHNS(M)=DHNS(1)*2**(M-1); DX(IEND)=RANGE OF NON-COULOMB POTENTIAL
C
C SR. RADWAV CALCULATES RADIAL FUNCTIONS RHO IN POTENTIAL FROM TFDAPO
C   IF BSTO .FALSE. (NZION .GT. 0 READ-IN SR.MINIM) OR FROM STOPOT
C   IF BSTO .TRUE.  (NZION .LT. 0 READ-IN SR.MINIM).
C   FOR SCREEN(K)=SCREENING PARAMETERS SEE NOTE IN SR MINIM
C
C FIRST, SET-UP THE MAXIMAL RADIAL MESH, MAXRS POINTS.
C
C THIS WILL EVENTUALLY BE TRUNCATED TO MAXPS, WHICH CONVERGES INTEGRALS.
C
C NOTE: DO NOT NEED TO DEFINE A SEPARATE MAXPS MESH FOR INTEGRALS IN
C SR.RADIAL SINCE ONLY ONE-BODY EXIST AND SR.WEDDLE CAN HANDLE MAXPS
C NON-ALIGNED WITH THE MNH(I),I=1,MJH WHICH DEFINES MAXRS.
C
      IF(MAXRS.EQ.0)MAXPS=0          !INITIALIZE
C
 615  IFLAGR=1
C
      CALL MESH(NZION,MION,TOLR,DHNS0,DX,IFLAGR)
C
      IF(NF.LE.0)GO TO 500
C
      MAXRS0=MAXRS                   !MAXRS WILL BE TRUNCATED EVENTUALLY
C
C NOW SET-UP FINITE NUCLEUS
C
      IF(INUK.LT.0)THEN
C
        CALL VNUKE(DZ,MSTEP,DHNS0,MAXRS,DX,IFLG1,IFLG2)
C
        IF(DHNS0.GT.DHNS(1)*D1PT05)THEN       !CURRENTLY, ONLY DECREASED
          DHNS(1)=DHNS0
          INUK=-1
          GO TO 615
        ELSEIF(DHNS0.LT.DHNS(1)/D1PT05)THEN
          GO TO 999                    !AS DX ETC NOT RE-ALLOCATABLE YET
        ENDIF
C
        INUKP=INUK+1
C
      ENDIF
C
C WRITE SOME MESH INFO
C
      JI=1
      IF(BORT.AND.MXQIN.LT.50)WRITE(6,778)MXQIN
      IF(BPRNT3.AND..NOT.BJUMP)THEN
        WRITE(6,975)TOL,MAXRS,MSTEP,NZION,MION
        IF(.NOT.BORT.AND.BHFF.AND.MAUTO.GE.0)WRITE(6,976)MXPOT
      ENDIF
C
C PRE-LOAD EXTERNAL ORBITALS, CASE SELF-CONSISTENT CONFIG. AVERAGE POT
C
      IF(BHFF.AND.MDEN.LT.0)THEN
        DO K=1,MXORB
          IF(SCREEN(K).GE.D999.AND.SCREEN(K).LT.D5999)
     X    DADJUS(K)=DAJNEW(K)                             !FLAG COMPUTED
          IF(SCREEN(K).LT.D999)DEY(K)=DZERO       !AS NOT YET CALCULATED
        ENDDO
C
        CALL RADWIN(MAXPS)
C
        BHFF=.FALSE.
        DO K=1,MXORB
          IF(DADJUS(K).EQ.DAJNEW(K))SCREEN(K)=-3999    !RE-FLAG EXTERNAL
          IF(SCREEN(K).GT.DZERO)DEY(K)=DONE            !RE-FLAG FOR CALC
        ENDDO
      ENDIF
C
C-----------------------------------------------------------------------
C
C BEGIN OUTER LOOP OVER L/NL-DEPENDENT LAMBDAS/ORBITALS
C
      NP0=0
      IF(IPOLFN.LT.0)NP0=-IPOLFN
      NPARM3=(NP0+1)*NPARAM
C
  616 DJ=DZERO
C
      DO 603 J=1,NPARAM           !<------------------------------------
C
C
      IF(IORT.LT.4)THEN
        DO N=0,NP0
          N0=N*NPARAM+J
          IF(ABS(DAJNEW(N0)-DADJUS(N0)).GT.DLAM0)GO TO 617
        ENDDO
        GO TO 603
      ENDIF
C
  617 CONTINUE
C
      IF(BORT)THEN
        JEND(J)=MEND
        IF(SCREEN(J).GT.D5999.AND.IVAL(J).EQ.0)GO TO 603
        IF(SCREEN(J).GT.DKEY.AND.IVAL(J).EQ.0)GO TO 631
        JI=J
      ELSE
        IPOTJ=J
      ENDIF
C
C BEGIN INNER LOOP OVER ORBITALS
C
      DO 632 K=JI,MXORB      !MAXGR<------------------------------------
C
C
      IF(DEY(K).EQ.DZERO)GO TO 602
      IF(BJUMP.AND.IVAL(K).EQ.0)GO TO 602
C
      MYL=QL(K)/2
      IF(DEY(K).EQ.DONE)DUY(K,K)=DZERO
      MRED=0
C
C SET-UP POTENTIAL, EITHER USE EXISTING ONE OR GENERATE A NEW ONE
C
      IF(BORT)THEN
        IF(.NOT.BSTO)THEN                         !TRY AND "OPTIMIZE" TF
          IF(MORT.GT.-4)then
            if(ieq(0).lt.0)then                           !RELAXED BASIS
              kf=igrcf(k)
              if(kf.gt.0)then
                ii=qcg(nf,kf)           !CHECK OUTER ORBITAL FOR CF TYPE
                if(abs(qn(ii)).lt.90.and.ival(ii).eq.0)then  !N+1 BOUND
                  mred=0
                else                           !RYD/CONT, SO REDUCE CORE
                  mred=1
                endif
              else
                if(idr.gt.0)mred=1                          !CLOSED CORE
              endif
            elseif(ieq(0).gt.0)then       !FIND OUTER ORB GROUP BOUNDARY
              if(ieq(k).gt.mb0)then
                if(ival(k).eq.0)then
                  lf=mxborb*ngrp+mb0
                  do l=lf+1,mxorb
                    if(dey(l).ne.dzero.and.igrcf(l).eq.igrcf(k))then
                      if(abs(qn(l)).ge.90.or.ival(l).ne.0)then !Ryd/cont
                        mred=1
                        go to 18
                      endif
                    endif
                  enddo
   18             continue
                endif
              else
                if(idr.gt.0)mred=1
              endif
c        mred=0   !test
c          write(0,*)'mred:',k,mred
            else                                           !UNIQUE BASIS
              if(idr.gt.0)mred=1                              !DR "CORE"
            endif
CTEST                                                    !PS CLOSED CORE
CTEST     elseIF(MORT.EQ.-4.AND.IEQ(K).GE.MA.AND.IEQ(K).LE.MB)then
CTEST       MRED=1
          ENDIF
        ENDIF
C
        LI=1                                 !LOWER ORB BOUND FOR ORTHOG
        LF=K                                 !UPPER ORB BOUND FOR ORTHOG
c
        if(ieq(0).ne.0.and.irlx.ne.2)then       !FIND ORB GROUP BOUNDARY
          ng=igrcf(k)
          li=mxborb*(ng-1)+mb0+1
          if(ival(k).ne.0)lf=li+mxborb-1
c         write(0,*)'orthog',ng,':',li,lf,k
        endif
c
c        write(6,*)k,ival(k),mred
        IF(IVAL(K).EQ.0)GO TO 646                           !NON-VALENCE
        MRED=MION-NF-NW                          !0 UNLESS MRED USER-SET
        if(ieq(0).ne.0)go to 624
C
        IF(JPOT.GT.0)GO TO 601
c        IF(.NOT.BSTO.OR.BSTO.AND.IVLSUM.EQ.1)THEN   !POT NOT DEFINED IN
        JPOT=1                       !RADCON FOR RYD ORB APPROXED BY K=0
        IF(BJUMP)GO TO 11
        JPOT=0
c        ENDIF
        GO TO 624
C
      ELSE                                    !HISTORIC L-DEPENDENT POTS
C
        JPOT=MYL+1
        IF(JPOT .NE.J)GO TO 632                            !IPOTJ=J HERE
        IF(DAJNEW(J).EQ.DJ.AND.IORT.LT.4)GO TO 601
        IF(.NOT.BJUMP)GO TO 624
        IF(JPOT.GT.MXPOT)JPOT=MXPOT
C
      ENDIF
C
  11  IF(SCREEN(K).GT.DKEY)GO TO 602
C
C LOAD OLD POTENTIAL
C
      DO I=1,MAXRS
        DPOT(I)=POT(I,JPOT)
      ENDDO
      MEND=JEND(J)
      DJ=DAJNEW(J)
      GO TO 300
C
  646 CONTINUE
C
C POTENTIAL UNCHANGED FROM LAST CALL
C
      IF((.NOT.BSTO.OR.MHF.EQ.1.OR.MHF.EQ.2).AND.DAJNEW(J).EQ.DJ
     X         .AND.IORT.LT.4.and.ieq(0).eq.0.AND.IPOLFN.eq.0)GO TO 601
C
C GENERATE NEW POTENTIAL
C
  624 DJ=DAJNEW(J)
      DJ0=DJ
      IF(.NOT.BSTO)THEN
        DJ1=DONE
        DJ2=DONE
        IF(NP0.GT.0)DJ1=DAJNEW(NPARAM+J)
        IF(NP0.EQ.2)DJ2=DAJNEW(2*NPARAM+J)
      ENDIF
C
      MK=K
      MYN=max(MION-MRED,IONE)
      DS=DZ
C
      IF(DJ.GT.DZERO)GO TO 611
      IF(IORT.EQ.2)GO TO 611                        !CUSP CONDITION
      IF(BREL)GO TO 611                             !MUST SET POT RADWAV
C
      IF(IORT.LT.4)DS=-DJ*DZ                        !HYDROGENIC ORBITALS
      IF(IORT.EQ.4)DS=-QN(K)*(NZION-MYN+1)*DJ/DTWO  !PSEUDO-STATE BASIS
      IF(IORT.EQ.5)DS=-(NZION-MYN+1)*DJ             !BOX-STATE BASIS
C
      MYN=1
      DJ0=DONE
C
C THOMAS-FERMI DIRAC AMALDI POTENTIAL
C
  611 IF(.NOT.BSTO)CALL TFDAPO(DS,MYN,MK,DJ0,DJ1,DJ2,DHNS0,MAXRS,MJH,MNH
     X                        ,DHNS,DX,DPOT,TOL,MEND,CRRCT1,CRRCT2)
C
C SLATER-TYPE ORBITAL POTENTIAL
C
      IF(BSTO)CALL STOPOT(DS,MYN,MK,DJ0,DHNS0,MAXRS,MJH,MNH,DHNS,DX
     X                   ,DPOT,DTOL,MEND,MPP)
C
      IF(NF.LE.0)GO TO 500                              !RETURN
C
      IF(DHNS0.GT.DHNS(1)*D1PT05)THEN !TFDAPO FAILURE, TRY DOUBLING MESH
        DO I=1,NPARM3
          DADJUS(I)=DZERO
        ENDDO
        IF(BHFF0)THEN
          REWIND(12)
C          REWIND(5)                       !????????????
          BHFF=.TRUE.
        ENDIF
        MAXPS=0
        JPOT=-1
        DHNS(1)=DHNS0
        GO TO 615
      ELSEIF(DHNS0.LT.DHNS(1)/D1PT05)THEN    !CURRENTLY, NOT POSSIBLE...
        GO TO 999                         !DX ETC NOT RE-ALLOCATABLE YET
      ENDIF
C
      IF(.NOT.BPRNT3.OR.MPP.GT.1)GO TO 300
      IF(.NOT.BORT)THEN
        IF(.NOT.BSTO.AND..NOT.BHF)WRITE(6,776)MYL,DJ,MEND,DX(MEND)
        IF(BSTO.AND..NOT.BHF)WRITE(6,777)MYL,DJ,MEND,DX(MEND)
        IF(BHF)WRITE(6,772)MYL,MHF,MEND,DX(MEND)
        GO TO 300
      ENDIF
C
      IF(BORT.AND..NOT.BSTO.AND..NOT.BHF)THEN
        IF(IEQ(0).EQ.0)THEN
          WRITE(6,774)QN(K),MYL,DJ,MEND,DX(MEND)
          IF(NP0.GT.0)WRITE(6,1774)1,DJ1-DONE,CRRCT1                !DJ1
          IF(NP0.EQ.2)WRITE(6,1774)2,DJ2-DONE,CRRCT2                !DJ2
        ELSE
          WRITE(6,2774)K,IGRCF(K),QN(K),MYL,DJ,MEND,DX(MEND)
        ENDIF
      ENDIF
      IF(BSTO.AND..NOT.BHF)WRITE(6,775)QN(K),MYL,MCFSTO(K),DJ,MEND
     X,DX(MEND)
      IF(BHF)WRITE(6,773)QN(K),MYL,MHF,MEND,DX(MEND)
C
C EVALUATE MODEL PTOL, E.G. POLARIZATION PTOL, OR PLASMA SCREENING PTOL,
C APPLIED TO ALL ORBITALS. TO SWITCH-OFF FOR CORE REQUIRES UNCOMMENTING
C 'CORE' BELOW AND IN SR.RADCON
C
  300 ZNP=DX(MAXRS)*DPOT(MAXRS)
      MML=MYL
CORE  IF(BORT.AND.IEQ(MK).GE.MA.AND.IEQ(MK).LE.MB)MML=-MML
      IF(MCFMX.GT.0)ZNP0=-D99
C
      CALL VMPOT(ZNP,MML,MAXRS,DX,DZ,MAXPS,MPP,MK,MXORB)
C
      IF(NF.LE.0)GO TO 500                                      !FAILURE
C
C EVALUATE DIFFERENTIALS OF POTENTIAL FOR MASS-VELOCITY AND DARWIN
C FOR USE BY PMVDAR (HANDLE POINT NUCLEAR ANALYTICALLY).
C COULD ADD-IN PLASMA POT - SEE ALSO FN.PMVDAR
C
      IF(BREL)THEN
C
C NOTE DIFFERENCE OF /COM1/DPOT POTENTIAL TO SR.RADCON/FCF6 USE
        IF(MDEN.EQ.0)THEN
          DO I=1,MAXRS
            DA(I)=DPOT(I)-DZ/DX(I)                       !SUBTRACT POINT
          ENDDO
        ELSE                                             !ADD PLASMA POT
          DO I=1,MAXRS
            DA(I)=DPOT(I)-DZ/DX(I)+VSC(I)             !-POINT+PLASMA POT
          ENDDO
        ENDIF
C
        CALL DIFF(DA,DERV1,MNH,DHNS,MJH)
        CALL DIFF(DERV1,DERV2,MNH,DHNS,MJH)
C
        DO I=INUKP,MAXRS                                 !ADD POINT BACK
          DD1=DX(I)**2
          DERV1(I)=DERV1(I)-DZ/DD1
          DERV2(I)=DERV2(I)+DTWO*DZ/(DX(I)*DD1)
c          if(i.lt.150)write(6,*)i,dx(i),dpot(i),derv1(i),derv2(i)
        ENDDO
C
C ADD-IN FINITE NUCLEUS
C
        DO I=1,INUK
          DERV1(I)=DERV1(I)+DNUK1(I)
          DERV2(I)=DERV2(I)+DNUK2(I)
c          write(6,*)i,dx(i),dpot(i),derv1(i),derv2(i)
        ENDDO
C                             MAY SMOOTH EDGE, CASE UNIFORM
        IF(IFLG2.GT.IFLG1)THEN
c    write(0,*)iflg1,iflg2,dx(iflg1),dx(iflg2),dnuk2(iflg1),dnuk2(iflg2)
          DXX=DX(IFLG1)-DX(IFLG2)
          DO I=IFLG1,IFLG2
            DERV2(I)=DERV2(IFLG1)*(DX(I)-DX(IFLG2))/DXX
     X              -DERV2(IFLG2)*(DX(I)-DX(IFLG1))/DXX
c            write(0,*)i,dx(i),dnuk2(i)
          ENDDO
        ENDIF
C
      ENDIF
C
C NOW ENTER SECTION TO GENRATE RADIAL ORBITAL, NUMERICALLY IN
C RADWAV OR ANALYTICALLY (NON-REL COULOMB, INC. LAGUERRES) IN BDCF3
C
 601  KAPPA=0         !PMVDAR IGNORES KAPPA AND USES ITS OWN, DEFAULT -1
c
c      if(myl.gt.0)kappa=-myl-1                   !myl or -myl-1
c
      MYN=QN(K)
      JEND(J)=MEND
      SC=SCREEN(K)
      IF(SC.GT.DKEY)GO TO 602
      BJUMPR=.FALSE.
      IF(SC.LE.-DKEY)THEN
        QN(K)=-QN(K)
        SC=(QL(K)+1)*MYN
        IF(SC.GE.MION)SC=MION-1
        MODE=4
      ENDIF
C
      IF(DJ.GT.DZERO)GO TO 60                     !DW OR REL COULOMB
C
      DS=DJ*DZ                                    !COULOMBIC, LAGUERRES
      SC=DZ+DS
C
      IF(IORT.EQ.2)GO TO 60                       !USE RADWAV
      IF(BREL)GO TO 60                            !REL COULOMB
      IF(DENE.NE.DZERO)GO TO 60                   !PLASMA SCREENING
C
      IF(IORT.EQ.4)DS=MYN*(NZION-MION+MRED+1)*DJ/DTWO !NON-REL LAGUERRES
C
      IF(IORT.EQ.5)DS=-(NZION-MION+MRED+1)*DJ     !BOX STATES
C
      IF(MODE.EQ.4)IYY(K)=1
      DD2=MYN
      DE=DS/DD2
      DE=-DE*DE
      M=1
C
      IF(IORT.NE.5)THEN                             !HYDROGENIC/PS
C
        CALL BDCF3(DP,DE,MYN,MYL,DS,M,MAXRS,DX)
C
        IF(MYL.LT.0)GO TO 999                                   !FAILURE
      ELSE                                          !BOX
        IF(MYL.EQ.LOLD)THEN
          IF(EOLD.GT.DZERO)DE=EOLD*D1PT05
          IF(EOLD.LE.DZERO)DE=EOLD/D1PT05
        ENDIF
C
        CALL BXSCHN(MJH,MNH,DHNS,DS,MYN,MYL,DE,DP,DX,MXBOX,MSTEP)
C
        IF(MYL.LT.0)THEN
          WRITE(6,*)'*** BXSCHN FAILURE...'
          WRITE(0,*)'*** BXSCHN FAILURE...'
          GO TO 999
        ENDIF
C
        LOLD=MYL
        EOLD=DE
      ENDIF
C
      DP0=DP(1)/DX(1)**(MYL+1)
      GO TO 61
C
CT  TEST CODE RE-ENTRY POINT FOR GO TO AT STATEMENT 642
CT  55  BJUMPR=.TRUE.
CT      BREL=.FALSE.
C
C
  60  CALL RADWAV(MYN,MYL,DZ,MAXRS,MJH,MNH,DHNS,DX,SC,DP,DQ,DE,rtwo)
C
C
      IF(.NOT.BJUMP.AND.BPRNT3.AND.(MDEN10.GT.2.OR.MDEN.LT.0))
     X   WRITE(6,765)MYN,MYL,DE,MPP
C
      IF(MYN.LE.0.OR.MYL.LT.0)THEN
        WRITE(6,*)'*** SR.RADWAV FAILURE...'
        WRITE(0,*)'*** SR.RADWAV FAILURE...'
        GO TO 999
      ENDIF
C
      if(bort.and.mend.ne.jend(k))stop 'mend.ne.jend'   !should not
      if(mend.eq.0)stop 'sr.radial: mend=0'             !happen...
c
c      rinf2(k)=rtwo              !hydrogenic estimate seems good enough
      rnorm(k)=pnorm
c      write(0,*)k,rtwo  !pnorm
C
  61  IF(MGRP.LT.0)THEN
        T0=MION-1
        T1=MYN
        T0=T1*(T0-SC)
        SC=T0/(DZ-SC)
      ENDIF
      IF(SCREEN(K).LT.DKEY)SCREEN(K)=SC
C
      DDE=DE
      IF(BREL2)DDE=DZERO       !IF BREL THEN OMITS DDE FROM DQ IF ORTHOG
C
      DO M=1,MAXRS
        IF(ABS(DP(M)).GT.TOLR)MAXPS=MAX(M,MAXPS)
        DPNL(M,K)=DP(M)
      ENDDO
      IF(BREL2)THEN
        DO M=1,MAXRS
          DQNL(M,K)=DQ(M)
        ENDDO
      ELSE
c        write(6,*)'k=',k,dz,dde
        DO M=1,MAXRS
          DQNL(M,K)=((DPOT(M)-DZ/DX(M)+VSC(M))*DTWO+DDE)*DP(M)
c          if(m.le.maxps)write(6,*)m,dx(m),DQNL(M,K),dpot(m)*dx(m)-dz
        ENDDO
      ENDIF
C
      IF(BJUMPR)GO TO 642
C
      if(mden.ne.0)then
        IF(IEQ(K).GT.MB.AND.ABS(DE-DEOLD(k)).GT.-TOLPP*DE)BMPP=.TRUE.
        DEOLD(k)=de
      endif
      DE=DE/DTWO
      DDE=DDE/DTWO
      DEY(K)=DE                              !FLAG EXISTS, or for radwin
      IRAD(K)=1
      DORIG(K)=DP0
      K0=K
      IF(BJUMP)K0=MXORB                                           !MAXGR
C
      IF(.NOT.BORT)GO TO 634                   !AS HAVE UNMODIFED "DQNL"
      DD1=DZERO
      IF(MORT.EQ.-3.AND.IRLX.NE.2)THEN
        IF(BREL)GO TO 634
        GO TO 62
      ENDIF
C
C ORTHONORMALIZE
C
      DS=DZERO
C
      DO L=1,K
C
        IF(DEY(L).EQ.DZERO)GO TO 635                     !DOES NOT EXIST
        IF(QL(K).NE.QL(L))GO TO 635                      !WRONG ORB A.M.
        IF(MORT.LT.0.AND.QN(K).EQ.QN(L).AND.L.NE.K)GO TO 635 !FOR SAFETY
C        IF(MORT.LE.-4.AND.QN(K).EQ.QN(L).AND.L.NE.K)GO TO 635  !BOX/LPS
        IF(L.LT.LI.AND.L.GT.MB0)GO TO 635              !CASE IEQ(0).GT.0
        if(l.gt.lf.and.l.lt.k)go to 635                !case ieq(0).gt.0
        IF(IVAL(K)+IVAL(L).EQ.2.AND.IRLX.NE.2
     X    .AND.QN(K).EQ.QN(L).AND.L.NE.K)GO TO 635         !SKIP RYDBERG
C        IF(IVAL(K)+IVAL(L).EQ.1.AND..NOT.BSTO.AND.IRLX.NE.2)GO TO 635
        IF(SCREEN(L).GE.DKEY)GO TO 602                 !NOT YET COMPUTED
        IF(L.EQ.K.AND.(DS.EQ.DZERO.OR.IRLX.EQ.2))GO TO 63  !SKIP UNMODFD
C
        IF(BREL2)THEN
          DO M=1,MAXPS
            DA(M)=DPNL(M,L)*DPNL(M,K)+DQNL(M,L)*DQNL(M,K)
          ENDDO
        ELSE
          DO M=1,MAXPS
            DA(M)=DPNL(M,L)*DPNL(M,K)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD1,DA,DS,MNH,DHNS,MJH,MAXPS)
C
        IF(L.EQ.K)GO TO 635
        IF(BPRNT0)WRITE(6,780)QN(K),MYL,QN(L),MYL,DS
C
        IF(MORT.LE.-4)THEN
          IF(IVAL(K).EQ.1)THEN
            NN=QN(L)
            IF(DAJNEW(L).LT.DZERO)NN=-NN
            WRITE(16,795)QL(K)/2,QN(K),NN,DS
            IF(QN(K).LE.NN)THEN
              WRITE(6,764)K,QN(K),NN,L
C              GO TO 999                   !ERROR: VALENCE N .LE. CORE N
              GO TO 635
            ENDIF
            IF(DAJNEW(L).LT.DZERO)GO TO 635
C         ELSE
C           IF(DAJNEW(K)*DAJNEW(L).LT.DZERO)THEN
C             NN=QN(K)
C             IF(DAJNEW(K).LT.DZERO)NN=-NN
C             WRITE(16,795)QL(L)/2,QN(L),NN,DS
C           ENDIF
          ENDIF
        ENDIF
C
        IF(IRLX.EQ.2)THEN
          KK=((K-1)*(K-2))/2+L
          OVLPGR(KK)=DS
          GO TO 635
        ENDIF
C
        DO M=1,MAXRS
          DPNL(M,K)=DPNL(M,K)-DS*DPNL(M,L)
          DQNL(M,K)=DQNL(M,K)-DS*DQNL(M,L)
        ENDDO
        DP0=DP0-DS*DORIG(L)
C
  635 ENDDO
C
C END ORTHOGONALIZATION
C
      IF(DS.LT.DEL)THEN
        WRITE(6,779) K
        NF=-1
        DEY(K)=DZERO
        GO TO 602
      ENDIF
C
      DS=DONE/SQRT(DS)
      IF(DP0.LT.DZERO)THEN
C       DS=-DS
C       WRITE(6,781)K,(DPNL(M,K),M=1,50)
C        WRITE(6,781)
      ENDIF
C
      DO M=1,MAXRS
        DPNL(M,K)=DS*DPNL(M,K)
        IF(ABS(DPNL(M,K)).GT.TOLR)MAXPS=MAX(MAXPS,M)
        DQNL(M,K)=DS*DQNL(M,K)
      ENDDO
      DP0=DS*DP0
      DORIG(K)=DP0
C
C NEED TO RECALCULATE ORBITALS L .GT. K  WITH QL(L) .EQ. QL(K)
C DURING MINIMIZATION SO CAN RE-ORTHOGONALIZE TO NEW K.
C
  63  IF(.NOT.BDR)THEN
        DO L=K,MXORB               !MAXGR
          IF(QL(L).EQ.QL(K).AND.DEY(L).NE.DZERO)THEN
            DO N=0,NP0
              N0=N*NPARAM
              DADJUS(N0+L)=DZERO
            ENDDO
          ENDIF
        ENDDO
      ENDIF
C
C END ORTHONORM
C
  62  IF(DDE.EQ.DZERO)GO TO 634                                   !BREL2
C
C FORM NON-NUCLEAR ELECTROSTATIC ONE-BODY ENERGY INTEGRALS:
C                              NON-RELATIVISTIC ORBITALS, IF BREL ABOVE,
C                              RELATIVISTIC LARGE CPT ONLY IF BREL2,
C                              THEN ENERGY FACTOR MAYBE OMITTED
C                              FROM DQNL DURING ORTHOG - SEE DDE.
C
      DO L=1,K0
C
        DD2=DZERO    !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
C
        IF(QL(K).NE.QL(L))GO TO 641                                 !639
        IF(SCREEN(L).GE.DKEY)GO TO 641                              !639
        IF(DEY(L).EQ.DZERO)GO TO 641
        IF(K.LE.ABS(MPSEUD))GO TO 641
        IF(L.GT.K.AND.IVAL(L).GT.0)GO TO 639
c
ctest        call diff(DPNL(1,l),derv1,MNH,DHNS,MJH)
ctest        call diff(derv1,DA,MNH,DHNS,MJH)
ctest        tlll=(ql(l)*(ql(l)+2))/4
ctest        t=1
C
        DO M=1,MAXPS
ctestc          if(dene.gt.dzero)t=exp(-dx(m)/debye)
ctest          da(m)=-da(m)+(tlll/dx(m)**2-2*dz*t/dx(m))*dpnl(m,l)
ctest          da(m)=da(m)*dpnl(m,k)
          DA(M)=DQNL(M,K)*DPNL(M,L)
CTEST          DA(M)=DQNL(M,L)*DPNL(M,K)
        ENDDO
        IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN!PERT DH1
          DO M=1,MAXPS
            T=EXP(-DX(M)/DEBYE)
            DA(M)=DA(M)+DTWO*DPNL(M,L)*DPNL(M,K)*(DONE-T)*DZ/DX(M)
          ENDDO
        ELSE
          DO M=1,MAXPS
            DA(M)=DA(M)-DTWO*DPNL(M,L)*DPNL(M,K)*VSC(M)
          ENDDO
        ENDIF
        IF(MPSEUD.NE.0)THEN
          DO M=1,MAXPS
            DA(M)=DA(M)+DTWO*DPNL(M,L)*DPNL(M,K)*(DZ/DX(M)-POTHAM(M))
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD1,DA,DS,MNH,DHNS,MJH,MAXPS)
C
        DD2=DS/DTWO
        DD2=DD2*SCALER                   !C.F. COWAN SLATER SCALE FACTOR
C
  641   DUY(K,L)=DD2
        DUY(L,K)=DD2
C
  639 ENDDO
C
      DUY(K,K)=DUY(K,K)-DDE*SCALER
      DEY(K)=DUY(K,K)+DE
      IF(QN(K).LT.0)DEY(K)=DEY(K)-TSHFT
C
      IF(.NOT.BREL)THEN
        DE=DE-DDE            !SO NOT DOUBLE COUNTED IN D2LL WHEN IN DQNL
        DEC=DZERO
      ENDIF
C
      GO TO 636
C
C FORM NON-NUCLEAR ELECTROSTATIC ONE-BODY ENERGY INTEGRALS:
C                                DOES NOT USE DQNL.
C                                REALLY REQUIRES OVERLAPS BE SMALL AS
C                                USES UNMODIFIED POTENTIAL.
C                                IF ONLY SMALL CPT THEN CAN GO THRU
C                                NON-REL BRANCH ABOVE.
C
  634 DD1=DZERO
      BFIRST=.TRUE.
C
      DO L=1,K0
C
        DS=DZERO     !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
C
        IF(QL(K).NE.QL(L))  GO TO 605                               !604
        IF(SCREEN(L).GE.DKEY)GO TO 605                              !604
C       IF(BREL.AND.L.NE.K)GO TO 605
        IF(DEY(L).EQ.DZERO)GO TO 605
        IF(K.LE.ABS(MPSEUD))GO TO 605
        IF(L.GT.K.AND.IVAL(L).GT.0)GO TO 604
C
        IF(BFIRST)THEN
          IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN      !DH
            DO I=1,MAXPS
              T=EXP(-DX(I)/DEBYE)
              DP(I)=DPOT(I)-T*DZ/DX(I)+VSC(I)
c         write(78,*)i,dx(i),dpot(i)*dx(i),t*dz,vsc(i)*dx(i),dp(i)*dx(i)
            ENDDO
C          ELSEIF(MDEN10.EQ.2.AND.DENE.GT.DZERO)THEN       !IS NO 2-BODY
          ELSE
            DO I=1,MAXPS
              DP(I)=DPOT(I)-DZ/DX(I)
            ENDDO
          ENDIF
          IF(MPSEUD.NE.0)THEN
            DO I=1,MAXPS
              DP(I)=DP(I)+DZ/DX(I)-POTHAM(I)
            ENDDO
          ENDIF
          BFIRST=.FALSE.
        ENDIF
C
        IF(BREL2)THEN
          DO I=1,MAXPS
            DA(I)=DP(I)*(DPNL(I,L)*DPNL(I,K)+DQNL(I,L)*DQNL(I,K))
          ENDDO
        ELSE
          DO I=1,MAXPS
            DA(I)=DP(I)*DPNL(I,L)*DPNL(I,K)
          ENDDO
        ENDIF
C
        CALL WEDDLE(DD1,DA,DS,MNH,DHNS,MJH,MAXPS)
C
        DS=DS*SCALER                     !C.F. COWAN SLATER SCALE FACTOR
C
  605   DUY(K,L)=DS
        DUY(L,K)=DS
        DCD(K,L)=DZERO
        DCD(L,K)=DZERO
C
  604 ENDDO
C
      DEY(K)=DE+DUY(K,K)                             !AS DE OMIITED HERE
      IF(QN(K).LT.0)DEY(K)=DEY(K)-TSHFT
C
C END ONE-BODY ENERGY DETERMINATION
C
C ADD-IN EIGEN-ENERGY
C
      IF(.NOT.BREL2.AND.DDE.EQ.DZERO)THEN
        DDE=DE+DE
        DO I=1,MAXRS
          DQNL(I,K)=DQNL(I,K)+DDE*DPNL(I,K)
        ENDDO
        DDE=DE
      ENDIF
C
C DETERMINE CORRECTION TO KAPPA AVERAGE ENERGIES
C
C CAN ALSO TEST HERE EVALUATION OF SPIN-ORBIT: WITH FULL POTENTIAL IN
C SMALL R CORRECTION FOR WHEN SMALL CPT IN USE, SINCE WE ONLY RETAIN
C DIAGONAL IN NL CORRECTION DEPENDS ON E-V, AND/OR POTENTIAL DERIVATIVE.
C DO NOT USE CLOSED SHELLS THEN! STORED TEMPORARILY IN DARWIN ARRAY DCD.
C **NO GOOD FOR RADWIN!** SEE ALSO SOCC TO SWITCH-OFF CALCULATION THERE.
C
  636 IF(.NOT.BREL.OR.K.LE.ABS(MPSEUD).OR.QL(K).EQ.0)GO TO 642
C
      IF(BREL2)THEN
        DO I=1,MAXPS
          DP(I)=DPNL(I,K)*DPNL(I,K)
C     X                    +DQNL(I,K)*DQNL(I,K) !for test (B&W) s-o only
          DA(I)=DONE+DALF*(DE+DPOT(I))/DTWO
        ENDDO
      ELSE
        DO I=1,MAXPS
          DP(I)=DPNL(I,K)*DPNL(I,K)
          DA(I)=DONE+DALF*(DQNL(I,K)/DPNL(I,K)+DTWO*(DE-DDE+DZ/DX(I)))
     X         /DFOUR
        ENDDO
      ENDIF
C
      DO I=1,MAXPS
        DQ(I)=DP(I)*DERV1(I)/DX(I)                !POTENTIAL DERIV
        DP(I)=DP(I)/(DX(I)*DX(I)*DX(I))           !NUCLEAR
        DP(I)=DP(I)/DA(I)
        DQ(I)=DQ(I)/DA(I)
      ENDDO
      DD1=DZERO
      DD3=DZERO
C                                          !BREL2 TEST ONLY & .not.b1mbp
CT      CALL WEDDLE(DD1,DP,DD3,MNH,DHNS,MJH,MAXPS)
C
      DD3=DALF*DD3/DFOUR
C
C TEST KAPPA-AVERAGED (NUCLEAR) SPIN-ORBIT CONTRIBUTION.
C NEED TO UNCOMMENT KAPPA=QL(K)/2 AT STATEMENT NUMBER 601 ABOVE
C
c      write(0,*)'kappa=',kappa
c      write(0,*)dd3,dd3*2*dz,dey(k),duy(k,k),de
c
      IF(KAPPA.GT.0)THEN
        DSOOLD=DD3
      ELSEIF(KAPPA.LT.0)THEN
        I0=(QL(K)/2)
        I1=I0+1
        I2=I0+I1
        DD3=(DSOOLD*I0+DD3*I1)/I2
        write(0,*)'kappa-averaged spin-orbit=',dd3,dd3*2*dz
        DSOOLD=DD3
      ENDIF
C
      DCD(K,K)=DD3                                !DSOOLD
C
      CALL WEDDLE(DD1,DQ,DD3,MNH,DHNS,MJH,MAXPS)
C
      DD3=DALF*DD3/DFOUR
      IF(IREL.LT.0)DCD(K,K)=-DD3/DZ               !USE POTENTIAL DERIV
C
C TEST KAPPA-AVERAGED ONE-BODY ENERGY CONTRIBUTION.
C NEED TO UNCOMMENT KAPPA=QL(K)/2 AT STATEMENT NUMBER 601 ABOVE
C
      IF(KAPPA.NE.0)THEN
        DDD=-(KAPPA+1)*DD3              !KAPPA DEPENDENT ONE-BODY ENERGY
      ELSE
        DDD=-DZERO*DD3               !KAPPA=-1 .EQ. (2J+1) KAPPA-AVERAGE
      ENDIF
C
      DUY(K,K)=DUY(K,K)+ddd
      DEY(K)=DEY(K)+ddd
c
c      write(0,*)ddd,dey(k),duy(k,k),de
C
C TEST KAPPA-AVERAGED BINDING ENERGY (EPSILON) CONTRIBUTION.
C NEED TO UNCOMMENT KAPPA=QL(K)/2 AT STATEMENT NUMBER 601 ABOVE.
C
      IF(KAPPA.GT.0)THEN
        DEHOLD=DE
      ELSEIF(KAPPA.LT.0)THEN
        I0=(QL(K)/2)
        I1=I0+1
        I2=I0+I1
        DE=(DEHOLD*I0+DE*I1)/I2
c        write(0,*)'kappa-averaged epsilon=',de
c        dehold=de
      ENDIF
C
      IF(KAPPA.GT.0)THEN
        KAPPA=-KAPPA-1
        GO TO 60
      ELSEIF(KAPPA.LT.0)THEN
        KAPPA=0
        GO TO 60
      ENDIF
C
C DETERMINE CORRECTION TO KAPPA-AVERAGED BINDING ENERGY
C
      CALL DIFF(DPNL(1,K),DA,MNH,DHNS,MJH)
C
      DO I=1,MAXPS
        DA(I)=DQ(I)*DX(I)*DA(I)/DPNL(I,K)
      ENDDO
C
      CALL WEDDLE(DD1,DA,DD4,MNH,DHNS,MJH,MAXPS)
C
      DD4=DALF*DD4/DFOUR
      DEC=(QL(K)+1)*(DD3-DD4)
c      if(brel2)dec=dec/rnorm(k)**2
c
c      if(ql(k).eq.0)go to 642       !test
c      write(0,*)'correction to kappa-averaged binding energy='
c     x          ,dd3,dd4,dec,de,de+dec
c      dec=0.0
      DE=DE+DEC
c      de=dehold        !test use explicitly calculated deviation, above
C
      DEY(K)=DE+DUY(K,K)
C
      IF(.NOT.BREL2.and.dde.ne.dzero)THEN
        DDE=DE-DDE
        DDE=DDE+DDE
        DO I=1,MAXRS
          DQNL(I,K)=DQNL(I,K)+DDE*DPNL(I,K)
        ENDDO
        dde=de
      ENDIF
C
C UNCOMMENT TWO LINES 'IF..' BELOW TO LOOP AROUND RADIAL EQUATION TWICE
C (BOUND AND CONTINUUM AUTOMATICALLY TAKEN CARE OF) FIRST TO EVALUATE
C RELATIVISTIC RADIAL FUNCTION FOR ONE-BODY AND ELECTROSTATIC MATRIX
C ELEMENTS THEN TO EVALUATE NON-RELATIVISTIC RADIAL FUNCTION FOR
C TWO-BODY FINE-STRUCTURE AND (IF INSERTED IN RADCON AND DIAGON)
C TWO-BODY NON-FINE-STRUCTURE. SHOULD NOT BE NEEDED AS USE OF
C RELATIVISTIC RADIAL FUNCTIONS FINE FOR ALL OPERATORS - HISTORIC.
C N.B. REMOVE SECOND APPEARENCE OF STATEMENT NO 642, UNCOMMENT 55, NEXT
C
CT642 IF(BREL.AND..NOT.BJUMPR)GO TO 55
CT    IF(BJUMPR)BREL=.TRUE.
C
C  ******************DATA TO RELATIVISTIC CONTRIBUTIONS*****************
C
C     IF BHFF .TRUE. THEN THERE EXIST ORBITALS TO BE CALCULATED IN
C     SR.RADWIN, LEAVE CALC OF REL CONTRIB TIL THEN.
C
  642 IF((.NOT.BMVD.AND.NJO.EQ.0).OR.BHFF)GO TO 602
C
C MASS-VELOCITY AND DARWIN (+M1+BP RAD)
C
      CALL MVDINT(K,DE,MRED,MAXPS)
C
C
  602 IF(K.LE.ABS(MPSEUD))THEN
        DUY(K,K)=DZERO
        DEY(K)=DZERO
      ENDIF
      IF(K.EQ.ABS(MPSEUD).AND..NOT.BHFF)THEN
        CALL VPNL(DZ,-IONE,IZERO,WK,DJ0,MAXRS,MJH,MNH,DHNS
     X                                     ,POTHAM,DTOL,MEND)
        IF(NF.LE.0)GO TO 500                                     !RETURN
      ENDIF
C
      IF(.NOT.BORT)GO TO 632
      IF(JPOT.NE.0)GO TO 631
      JPOT1=K                           !CASE RYD LAMBDA NL.NE.CONTINUUM
      JPOT=1
      IPOTJ=1
      GO TO 12
C
C END INNER LOOP OVER ORBITALS
C
  632 CONTINUE                   !<-------------------------------------
C
C
C ADJUST POTENTIAL STORAGE
C
      IF(J.GT.MXPOT)GO TO 631
      IF(BJUMP)GO TO 631
C
  12  DO I=1,MAXRS
        POT(I,IPOTJ)=DPOT(I)
      ENDDO
      CALL DIMUSE('MXPOT',IPOTJ)
C
  631 DO N=0,NP0
        N0=N*NPARAM
        DADJUS(N0+J)=DAJNEW(N0+J)
      ENDDO
C
C END OUTER LOOP OVER SCALING PARAMETERS
C
  603 CONTINUE                    !<------------------------------------
C
C-----------------------------------------------------------------------
C
C UPDATE DQNL (IF NOT ALREADY DONE SO)
C
      IF(.NOT.BREL2.AND.DDE.EQ.DZERO)THEN
        DO K=1,MXORB               !MAXGR
          IF(DEY(K).EQ.DZERO)GO TO 619
          IF(SCREEN(K).GT.DKEY)GO TO 619
          DE=DEY(K)-DUY(K,K)
          DE=DE+DE
          DO M=1,MAXRS
            DQNL(M,K)=DQNL(M,K)+DE*DPNL(M,K)
          ENDDO
  619   ENDDO
      ENDIF
C
C UPDATE PLASMA POTENTIAL ITERATION
C
      IF(MDEN10.GT.2.OR.MDEN.LT.0.AND..NOT.BJUMP)THEN
        IF(MPP.LT.MPP5.AND.BMPP)THEN
          MPP=MPP+1
          I0=0
          DO I=1,NPARAM
c            i0=0                                 !limit core iterations
c            if(mpp.gt.qn(i)+1)i0=mb              !if troublesome
c            if(ieq(i).ge.i0)then
            if(screen(i).gt.-d999.AND..NOT.BFIX(I))then
              do n=0,np0
                n0=n*nparam+i
                DADJUS(n0)=DZERO
              enddo
            endif
c            endif
          ENDDO
          ZNP0=-D99
          BMPP=.FALSE.
          JPOT=-1
          GO TO 616
        else
c          do i=1,maxrs
c            write(66,566)i,dx(i),dx(i)*dpot(i),-dpot(i)
c  566 format(i5,3(1pe16.7))
c          enddo
        ENDIF
      ENDIF
c
      if(abs(includ).ge.1000000)then
        do k=1,mxorb
          if(screen(k).lt.-d999)then
            de=dey(k)-duy(k,k)                           !epsilon a.u.
            de=-2*de
            screen(k)=dz-sqrt(qn(k)*de)
          endif
        enddo
      endif
C
C DETERMINE QED CONTRIBUTIONS (ALL ORBITALS)
C
      IF(QED.NE.0)CALL QEDINT(MAXPS)
C
C LOOK FOR ANY EXTERNAL ORBITALS
C
      IF(.NOT.BHFF.and..not.bdr)GO TO 612
C
      IF(.NOT.BJUMP)GO TO 4
C
      DO K=1,MXORB               !MAXGR
        IF(DEY(K).EQ.DZERO)GO TO 5
        IF(SCREEN(K).LT.DKEY)GO TO 5
        GO TO 9
   5  ENDDO
      IF(.NOT.BLAG)BHFF=.FALSE.
      GO TO 612
C
   9  MAXPS=0
C
      DO K=1,MXORB               !MAXGR
        IF(DEY(K).EQ.DZERO)GO TO 7
        IF(QN(K).LT.0)GO TO 7
        IF(SCREEN(K).GT.DKEY)GO TO 7
        DO M=1,MAXRS
         IF(ABS(DPNL(M,K)).GT.TOLR.or.dx(m).lt.rzero)MAXPS=MAX(MAXPS,M)
        ENDDO
   7  ENDDO
C
   4  IF(MAUTO.GT.0)GO TO 622
C
C
C TO READ RADIAL BOUND FUNCTIONS AS INPUT AND PROCESS THEM.
C
      IF(BHFF)THEN
C
        CALL RADWIN(MAXPS)
C
        IF(NF.LE.0)GO TO 500                                     !RETURN
C
        BHFF=.FALSE.
C
        IF(MAUTO.EQ.0)GO TO 622
C
      ENDIF
C
C PREPARE FOR DROPPING ALL POINTS I BEYOND WHICH ALL /<NL!X>/.LT.TOLR
C                                               - AS DEFINED BY MAXPS
C
  612 CONTINUE
C
      IF(RZERO.GT.DZERO)THEN
        DO M=1,MAXRS
          IF(DX(M).GT.RZERO)GO TO 43
        ENDDO
        M=MAXRS
  43    MAXPS=M
      ENDIF
c
      if(mauto.gt.0.and.mden.gt.0.and.xmax.gt.dzero)go to 622 !for cont.
C
      MAXRS=0
      MJH0=MJH
      DO I=1,MJH0
        MAXRS=MNH(I)+MAXRS
        MJH=I
        IF(MAXRS.EQ.MAXPS)GO TO 609
        IF(MAXRS.GT.MAXPS)THEN
          MAXRS=MAXRS-MNH(I)
          nxtra=9
c          if(.not.bsto.and.mauto.gt.0)nxtra=max(nxtra,2*mnh(i-1))!test
          MNH(I)=MAX(MAXPS-MAXRS,nxtra)
          MAXRS=MAXRS+MNH(I)
          GO TO 609
        ENDIF
      ENDDO
C
  609 IF(MAUTO.Le.0)THEN
        MAXPS=MAXRS                         !TWEAk C.F. OLD MAXQS
        GO TO 630                           !.NOT.BHFF.OR.
      ENDIF
C
C*****************************************************************
C EVALUATE CONTINUUM FUNCTIONS FOR AUTO/PHOTOIONIZATION RATE
C DETERMINATION IN SR.DIAGON AND SR.DIAGFS
C*****************************************************************
C
  622 CALL RADCON(MAXPS)
C
C
      IF(NF.LE.0)GO TO 500                                       !RETURN
C
C WRITE RADIAL MESH AND EFFECTIVE CHARGE DUE TO NUCLEUS PLUS CLOSED
C SHELL CORE, AND THEN ORBITALS  TO FILE 'radout' IN SS/IMPACT FORMAT.
C
  630 IF(MRAD.GE.0)GO TO 500
C
C FIRST DETERMINE EFFECTIVE CHARGE
C
      IF(MPSEUD.EQ.0.AND..NOT.BHFF)THEN
        CALL VPNL(DZ,-IONE,IZERO,WK,DONE,MAXRS,MJH,MNH,DHNS
     X                                     ,POTHAM,DTOL,MEND)
        IF(NF.LE.0)GO TO 500                                     !RETURN
      ENDIF
C
      IF(IUNIT(MRWR).LT.0)THEN
        WRITE(6,*)"TRYING TO RE-OPEN FILE='radout'..."
        WRITE(0,*)'TRYING TO RE-OPEN UNIT=13'
        GO TO 999                                                !RETURN
      ENDIF
      IUNIT(MRWR)=1
      OPEN(MRWR,FILE='radout',STATUS='REPLACE')
C
      MMRAD=MOD(MRAD,I100)
C
      MAXW2=(MAXRS-1)/2
      MAXW=MAXW2*2-1
      MAXW2=MAXW2+1
      MAXX=2*MAXW2
      ZERO=DZERO
      NORB=0
      TLBL='TFDA'
      IF(BSTO)TLBL='STO '
      IF(BREL)TLBL='REL '
      IF(IORT.EQ.4)TLBL='LPS '
      IF(IORT.EQ.5)TLBL='BOX '
C
      IF(MMRAD.NE.0)THEN
        DO J=1,MXORB               !MAXGR
          IF(DEY(J).EQ.DZERO.AND.J.GT.ABS(MPSEUD))GO TO 501
          NORB=NORB+1
  501   ENDDO
      ENDIF
C
      KEY=-9
      WRITE(MRWR,702)KEY,NORB,MB,MAXX,MION,DZ,(DADJUS(I),I=1,5),TLBL
C
      KEY=-8
      I1=1
      I2=2
      WRITE(MRWR,704)KEY,I1,ZERO,DZ,I2,DX(1),DX(1)*POTHAM(1)
C
      DO I=1,MAXW,2
        I1=I+1
        I2=I+2
        I3=I+3
        WRITE(MRWR,704)KEY,I2,DX(I1),DX(I1)*POTHAM(I1),I3,DX(I2),DX(I2)
     X  *POTHAM(I2)
      ENDDO
C
      IF(MMRAD.EQ.0)GO TO 502
C
C WRITE ORBITAL FUNCTIONS P AND Q IN "IMPACT" FORMAT
C
      DO J=1,MXORB               !MAXGR
        IF(DEY(J).EQ.DZERO.AND.J.GT.ABS(MPSEUD))GO TO 506
        KEY=-7
        MYN=QN(J)
        MYL=QL(J)/2
        DE=DEY(J)-DUY(J,J)
        DE=DE+DE
        T=ZERO
        IF(IEQ(J).GE.MA.AND.IEQ(J).LE.MB)T=2*(QL(J)+1)
        WRITE(MRWR,705)KEY,J,MYN,MYL,T,DE,MAXW2,TLBL
C
        KEY=-6
        I1=1
        I2=2
        WRITE(MRWR,704)KEY,I1,DORIG(J),ZERO,I2,DPNL(1,J),DQNL(1,J)
C
        DO I=1,MAXW,2
          I1=I+1
          I2=I+2
          I3=I+3
          WRITE(MRWR,704)KEY,I2,DPNL(I1,J),DQNL(I1,J),I3,DPNL(I2,J)
     X                ,DQNL(I2,J)
        ENDDO
  506 ENDDO
C
C FULL ATOMIC STO POTENTIAL FOR E.G. D.W.
C
C***CURRENTLY, SAME FILE AS ORBITALS,
C   BUT -100 NO WRITE OF ORBITALS, ONLY POTENTIAL
C
  502 IF(MRAD.GT.-100.OR..NOT.BSTO.OR..NOT.BORT)GO TO 508
      MNP=MION+1
      DJ0=DAJNEW(MCFMX)
C
      CALL STOPOT(DZ,MNP,MCFMX,DJ0,DHNS0,MAXRS,MJH,MNH,DHNS,DX,DPOT,DTOL
     X           ,MEND,MPP)
      IF(NF.LE.0)GO TO 500                              !RETURN
C
      KEY=-14
      J=-1
      DJ0=DZERO
      T=ZERO
      WRITE(MRWR,705)KEY,J,MEND,J,T,DJ0,MAXW2,TLBL
C
      KEY=-4
      I1=1
      I2=2
      POT0=DTHREE*DPOT(1)
      WRITE(MRWR,704)KEY,I1,POT0,POT0,I2,DPOT(1),DPOT(1)
C
      DO I=1,MAXW,2
        I1=I+1
        I2=I+2
        I3=I+3
        WRITE(MRWR,704)KEY,I2,DPOT(I1),DPOT(I1),I3,DPOT(I2),DPOT(I2)
      ENDDO
C
  508 WRITE(MRWR,702)
C
      CLOSE(MRWR,STATUS='KEEP')
      IUNIT(MRWR)=-1
C
  500 CONTINUE
c
c check radial overlaps
c
c      do 450 k=1,mxorb
c        if(dey(k).eq.dzero)go to 450
c        do 451 j=k,mxorb
c          if(dey(j).eq.dzero)go to 451
c          if(ql(j).ne.ql(k))go to 451
c          dd2=dzero
c          do i=1,maxps
c            da(i)=dpnl(i,k)*dpnl(i,j)
c            if(brel)da(i)=da(i)+dqnl(i,k)*dqnl(i,j)
c          enddo
c          call weddle(dd2,da,dd1,mnh,dhns,mjh,maxps)
c          write(6,453) k,j,dd1
c 453      format(2i5,1pe15.5)
c 451    enddo
c 450  enddo
C
C CHECK RADIAL MESH SUFFICIENT (N.B. MAXRS HAS BEEN TRUNACTED BY NOW)
C
      IF(MAXPS.EQ.MAXRS0.AND.IORT.LT.4.and.mden.le.0)THEN
        IF(MAXRS0.EQ.MAXB1)THEN                   !END OF PHYSICAL ARRAY
          WRITE(6,771)MSTEP
          WRITE(0,*)'SR.RADIAL: RADIAL ARRAY FULL'
          GO TO 999                                              !RETURN
        ELSE
          WRITE(6,*)' WARNING: INTERNAL RADIAL ARRAY MAYBE TOO SHORT...'
          WRITE(0,*)' WARNING: INTERNAL RADIAL ARRAY MAYBE TOO SHORT...'
c          write(0,*)'xmax=',xmax
        ENDIF
      ENDIF
C
      RETURN
C
  999 NF=-1
      RETURN
C
  702 FORMAT(3I5,9X,2I4,F5.1,5F7.3,A4)
  704 FORMAT(I5,2(I4,2(1PE14.7)))
  705 FORMAT(3I5,I3,F5.1,2X,F12.6,I6,29X,A4)
  764 FORMAT(' WARNING: ORBITAL',I3,' HAS VALENCE N=',I3,' .LE. CORE N='
     X,I3,' OF ORBITAL',I3)
  765 FORMAT(' N=',I3,5X,'L=',I3,5X,'EPSILON=',F12.5,10X,'MPP=',I3)
  771 FORMAT(' SR.RADIAL: RADIAL ARRAY FULL -- TRY BIGGER INTEGRATION ',
     X'RANGE - MORE POINTS (INCREASE MAXB1 2) OR LONGER STEPS (DECREASE'
     X,' MSTEP IN NAMELIST SMINIM)'/' CURRENTLY, MSTEP=',I3)
  772 FORMAT(16X,'LL =',I2, '    EXTERNAL POTENTIAL V(LL) FROM UNIT=',I2
     X,';  NON-COULOMB POT .LT. 1% OF COULOMBIC BEYOND R(IEND=',I5,') ='
     X,F10.6)
  773 FORMAT(13X,'NL =',I3,I2,'    EXTERNAL POTENTIAL V(NL) FROM UNIT='
     X,I2,';  NON-COULOMB POT .LT. 1% OF COULOMBIC BEYOND R(IEND=',I5, '
     X) =',F10.6)
  774 FORMAT(23X,'NL =',I3,I2,  '    S.M.-POTENTIAL V(NL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
 1774 FORMAT(45X,I1,'-POLE PERTURBED SCALE FACTOR'
     X,F10.5, ';  COULOMBIC DEVIATION AT R(IEND) =',F10.6)
 2774 FORMAT('GAM=',I3,' GRP=',I3,8X,'NL =',I3,I2,
     X'    S.M.-POTENTIAL V(NL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  775 FORMAT( 2X,'NL =',I3,I2,'    STO.-POTENTIAL CF=',I3,' WITH SCALE'
     X,' FACTOR',F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC'
     X,' BEYOND R(IEND=',I5,') =',F10.6)
  776 FORMAT(24X,'LL =',I2,',..   S.M.-POTENTIAL V(LL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  777 FORMAT( 3X,'LL =',I2,',..   STO.-POTENTIAL V(LL) WITH SCALE'
     X,' FACTOR',F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC'
     X,' BEYOND R(IEND=',I5,') =',F10.6)
  778 FORMAT( ' NON-ORTHOGONAL ORBITALS IN USE; BUT MAXB2=',I5,
     X' INSUFFICIENT FOR DQNL, ERRORS MAY ARISE IN ONE-BODY INTEGRALS')
  779 FORMAT( '  NEAR IDENTICAL FUNCTION FOR ORBITAL K=',I2,
     X' CASE SKIPPED  ')
  780 FORMAT( '       OVERLAP INTEGRAL',4X,I3,I2,' WITH',2I2,' ='
     X,1PE12.4)
C 781  FORMAT( ' ORTHOGONALIZATION CHANGES SIGN OF ORBITAL K=' ,I2,
C     X' VALUES NEAR ORIGIN ARE: '/10(1PE13.4))
C 781 FORMAT('+',57X,'*')
  795 FORMAT(3I5,1PE13.4)
  879 FORMAT(/5X,'BREIT INTERACTIONS: ',1X,'KUTSO=',I2,3X,'KUTSS=',I2
     X       ,3X,'KUTOO=',I2,4X,A12,1X,'(IBREIT=',I2,')',12X,'QED=',I2)
  880 FORMAT(//' *** KAPPA-AVERAGED RELATIVISTIC WAVEFUNCTIONS '
     X,'IN USE: ',' SMALL COMPONENT IS ',A3,' (IREL=',I2,')',3X
     X,'RETARDATION IS ',A3,' (IRTARD=',I2,')'/ 75X,'***',28X,'***')
  975 FORMAT(/// ' RADIAL FUNCTIONS:   PRECISION OF EIGENVALUE IS',
     X1PE9.2,4X,I6, ' POINTS (MSTEP=',I2,');  ATOMIC NUMBER',I3,
     X',   NUMBER OF ELECTRONS',I3)
  976 FORMAT('+',122X,'MXPOT=',I2)
C
      END SUBROUTINE RADIAL
C
C                             *******************
C
      SUBROUTINE RADWAV(N,L,Z,NPOINT,NI,NTI,DXI,X,SCREEN,DP,DQ,EA,rinf2)
C
C-----------------------------------------------------------------------
C
C  SR.RADWAV CALCULATES ELECTRON BOUND WAVE FUNCTIONS IN A POTENTIAL POT
C  -IF SR.TFDAPO/STOPOT IS RUN BEFORE RADWAV THEN COMMON /COM1/ WILL
C  CONTAIN THE POTENTIAL POT(I) AT RADIAL MESH POINTS X(I),I=1,NPOINT
C  QUANTITIES REQUIRED     -APART FROM POT(I) AND X(I) -
C  N=PRINCIPAL QUANTUM NUMBER, L=ANGULAR MOMENTUM,
C  Z=NUCLEAR CHARGE, ASYMPTOTIC CHARGE =POT(NPOINT)*X(NPOINT) ASSUMED
C  NI=NUMBER OF INTERVALS INTO WHICH THE WHOLE RANGE IS DIVIDED,
C  NTI(J)=NUMBER OF STEPS (.GE.8) IN EACH INTERVAL J=1,NI,
C  DXI(J)=STEP LENGTH IN INTERVAL J, NPOINT=TOTAL NUMBER OF STEPS
C  SCREEN IS AN ESTIMATE OF THE SCREENING VALUE IN A RYDBERG FORMULA;
C  AFTER EXCECUTING RADWAV THE INITIAL VALUE OF SCREEN IS REPLACED BY
C  THECALCULATED SIGMA. OTHER INPUT ARE IEND, DTOL(=10**(-ITOL))
C  RESULTS
C  DP(I) I=1,NPOINT VALUES OF THE NORMALIZED WAVE FUNCTION
C  E=ENERGY EIGENVALUE IN RYDBERGS (INACCURACY ABS(DE/E).LT.DTOL);
C  SCREEN=SCREENING PARAMETER IN A RYDBERG FORMULA (FOR  E=EA).
C  IF BREL THEN DQ(I) CONTAINS THE SMALL COMPONENT, AND DP(I) THE LARGE.
C
C  IT CALLS:
C    SR.DIFF
C    SR.NUMERO
C    FN.PMVDAR
C    SR.WEDDLE
C    FN.WHITEX
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      DIMENSION DP(*),X(*),DXI(*),NTI(*),DQ(*)
      DIMENSION A(12),U(3),IND(3),PKOEF(4),Y(:)              !Y(6)
C
      PARAMETER (C3=2.094D0)
      PARAMETER (D99=99.0D0)
      PARAMETER (D180=180.0D0)
      PARAMETER (D840=840.0D0)
      PARAMETER (DPT9=0.9D0)
      PARAMETER (D2PT5=2.5D0)
      PARAMETER (D2PT42=2.42D0)
      PARAMETER (D1PT5=1.5D0)
      PARAMETER (D1PT3=1.3D0)
      PARAMETER (D1PT1=1.1D0)
      PARAMETER (D1PT05=1.05D0)
ct      PARAMETER (D0PT7=0.7D0)
C
      COMMON /COM1/POT(MAXB1),DTOL,IEND
      COMMON /COM3/EE,ZN0,TLL
      COMMON /COM6/PQ(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /COMIKE/DP0,DQ0,pnorm
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      POINTER :: Y
      TARGET :: A
C
      Y=>A(7:12)                                 !FOR PASS TO SR.NUMERO
C
c      EQUIVALENCE (Y(1),A(7))                   !FOR PASS TO NUMERO
C
C INITIALIZE
C
      MAXIT=25
      IF(N.EQ.1)MAXIT=30
cw      IF(BREL.AND.N.EQ.1)MAXIT=40
      IF(DENE.GT.DZERO)MAXIT=45
C
CT      DE0=D1P20
      BREL2=ABS(IREL).EQ.2
      EMINIM=D1M70
      NPRES=NPOINT
      ITERA=MAXIT
      BSHORT=.TRUE.              !.not.brel     !DARWIN NOT IN FN.WHITEX
      IJPGT=0
      NCORR=0
      TLL=L*(L+1)
      NODES=N-L
C
C ZN=ASYMPTOTIC SCREENING CHARGE=POT(.GT.IEND)*X(.GT.IEND)
C
      ZN=POT(NPOINT)*X(NPOINT)
      ZNS=VSC(NPOINT)*X(NPOINT)
      ZN0=ZN+ZNS      !FOR /COM3/ BUT NOT USED BY SR.NUMERO OR FN.PMVDAR
C                     !                        AS IND(1).NE.0 & EE.LT.0
C CORRECT THE SCREENING CHARGE IF TOO LARGE
C
      IF(Z-ZN.LT.SCREEN)SCREEN=Z-ZN
C
      IF(.NOT.BREL)THEN
C
C NK=NUMBER OF TERMS IN THE WAVE EXPANSION AT THE ORIGIN:
C        DP(X)=A(1)*X**(L+1) +..+A(NK)*X**(L+NK)
C
        NK=5
C
C EXPAND POT(X)=PKOEF(1)/X+PKOEF(2) +..+PKOEF(NC+1)*X**(NC-1)
C
        NC=NK-2
        PKOEF(1)=DSIXTH
C
        DO I=1,NC
          A(I)=(POT(I)+VSC(I))*X(I)-Z
          PKOEF(I+1)=PKOEF(I)/X(1)
        ENDDO
C
        PKOEF(1)=Z
        PKOEF(2)=((A(1)*2-A(2))*9+A(3)*2)*PKOEF(2)
        PKOEF(3)=(-A(1)*5+A(2)*4-A(3))*3*PKOEF(3)
        PKOEF(4)=((A(1)-A(2))*3+A(3))*PKOEF(4)
C
        IF(RNUK.GT.DZERO)THEN                 !ADD-IN FINITE NUCLEUS
          PKOEF(1)=ZS0(0)
          DO J=1,JZNM
            I=J+1
            PKOEF(I)=PKOEF(I)+ZS0(J)
          ENDDO
        ENDIF
C
      ENDIF
C
C REPLACE POINT WITH FINITE NUCLEUS (IN POT)
C
      DO I=1,INUK
        T=POT(I)-Z/X(I)
        POT(I)=DNUK0(I)+T
        DNUK0(I)=T
      ENDDO
C
C CALCULATE A FIRST APPROXIMATION TO THE EIGENVALUE
C
      BNORM=.FALSE.
      ZSC=Z-SCREEN
      E=-(ZSC/N)**2
      T=ZN/X(NPRES-5)
      IF(.NOT.BREL.AND.-E.LT.T)E=-T
C
C ADD-IN ANY CORRECTION TO E DUE TO PLASMA POTENTIAL
C
      TE=DZERO
      IF(DENE*ABS(VSC(1)).GT.DZERO)THEN
        MDEN10=MOD(MDEN,ITEN)
  26    IF(MDEN10.EQ.1)THEN
          T=N
          T1=ZN*DEBYE
          T1=T*T/T1
          TE=(ZN/T)**2*(DONE-(DONE-T1)*EXP(-T1))
          GO TO 28
        ENDIF
  19    IF(MDEN10.EQ.2)THEN
          T1=D2PT42*ZN**D2THRD*DENE**D1THRD
          T2=N*N*(5*N*N+1-3*L*(L+1))
          T2=DHALF*T2/(ZN*ZN)
          T2=C3*DENE*T2
C 1.5 TO ALLOW FOR DENSITY DEPENDENT <R**2>
          T2=D1PT5*T2
          TE=T1-T2
          TE=TE+TE
          GO TO 28
        ENDIF
        IF(GAMQ.LT.D2PT5)THEN
          MDEN10=1
          GO TO 26
        ELSE
          MDEN10=2
          GO TO 19
        ENDIF
  28    E=E+TE
        IF(E.GE.DZERO)THEN
          E=E-TE
          TE=TE*DPT9
          GO TO 28
        ENDIF
      ENDIF
C
      EH=-(Z/N)**2+TE
      IF(EH.GT.DZERO)EH=E+E
      IF(Z.EQ.ZN)EH=D1PT1*EH
      EL=-(ZN/N)**2+TE
      IF(EL.GT.DZERO)EL=DZERO
      IF(Z.EQ.ZN)EL=DPT9*EL
C
C ADD-IN ANY CORRECTION TO E DUE TO MASS-VELOCITY PLUS DARWIN OPERATORS
C
      Z0=Z
      ZW=ZN
      TLB=TLL
      TLW=TLL
      IF(BREL)THEN
        TL=L
        T=(DFOUR*N/(TL+DHALF)-DTHREE)
        EH=EH-DQUART*DALF*(Z/N)**4*T
        EL=EL-DQUART*DALF*(ZN/N)**4*T
        E=E-DQUART*DALF*(ZSC/N)**4*T
        IF(L.LE.0)THEN
          EH=EH+DALF*(Z/N)**4*N
          EL=EL+DALF*(ZN/N)**4*N
          E=E+DALF*(ZSC/N)**4*N
        ENDIF
      ENDIF
C
C PASS TO NUMERO VIA /COM3/ (SIGH)
C
      EE=E
C
C CALCULATE JOINING DISTANCE FOR INWARD AND OUTWARD INTEGRATION. WE
C CHOOSE IT AS THE OUTER ONE OF THE TWO POINTS FOR WHICH THE SECOND
C DERIVATIVE OF THE WAVE FUNCTION IS DZERO
C
   30 IF(E.GE.EL)THEN
        E=(E+EE)/DTWO
        EL=EL/D1PT05
        IF(E.GT.EL)E=EL
      ENDIF
   22 IF(E.LE.EH)THEN
        E=(E+EE)/DTWO
        EH=EH*D1PT05
        IF(E.LT.EH)E=EH
      ENDIF
      EW=E
      EE=E
C
C ASYMPTOTIC MODS DUE TO MASS-VELOCITY OPERATOR
C
      IF(BREL)THEN
        EW=E+DQUART*DALF*E*E
        Z0=Z+DHALF*DALF*Z*E
        ZW=ZN+DHALF*DALF*ZN*E
        TLB=TLL-DALF*Z*Z
        TLW=TLL-DALF*ZN*ZN
      ENDIF
C
C THE SEARCH FOR RJ IS DONE STEP BY STEP FROM X(NPOINT) INWARDS
C
      JJ=NPOINT
C      ZW0=ZW
C
  31  ZW0=ZW+X(JJ)*VSC(JJ)
      RJ=DZERO
      IF(EW.LT.DZERO)RJ=-ZW0/EW
      IF(X(JJ).LE.RJ)GO TO 41
      T=DTWO*(POT(JJ)+VSC(JJ))-TLL/X(JJ)**2+E
      IF(BREL)T=T+PMVDAR(JJ,X(JJ))
      IF(T.LT.DZERO)THEN
        JJ=JJ-1
        IF(JJ.GT.0)GO TO 31
        GO TO 70
      ENDIF
      rinf2=x(jj)
c                                                     write(0,*)rinf2,e
c
   32 RJ=X(JJ)
C
C FIND  THE JOINING POINT.  WE TAKE AS JOINING POINT THE FIRST X
C WHICH IS LARGER THAN THE JOINING DISTANCE.
C
   41 NOUTW=0
C     WRITE(6,1001)JJ,X(JJ),RJ,ZN,E,TLL,POT(JJ),T
C 1001 FORMAT(I5,7F12.6)
C
C RUN THROUGH THE BIG (INDEX I) AND THE SMALL (INDEX J) INTERVALS
C
      DO I=1,NI
        NHI=I
        NC=NTI(I)
        DO J=1,NC
          NOUTW=NOUTW+1
          IF(RJ.LE.X(NOUTW).AND.J.GE.4)THEN
            NTINHI=J
            II=NTI(I)-NTINHI
            IF(I.GT.1)GO TO 80
            IJPGT=IJPGT-1
            WRITE(6,996)
            JJ=NTI(1)+7
            IF(IJPGT.GT.-10)GO TO 32
            N=0
            GO TO 999
          ENDIF
        ENDDO
      ENDDO
C
   70 JJ=NPOINT-5
      IJPGT=IJPGT+1
      WRITE(6,997)
      IF(IJPGT.LE.4)GO TO 32
   75 N=-N
      GO TO 999
C
C SHIFT JOINING POINT IF TOO NEAR TO END OF INTERVAL
C AS WE CALCULATE THE DERIVATIVE WITH 7 POINTS.
C
   80 IF(II.LT.4)THEN
        NOUTW=NOUTW-(4-II)
        NTINHI=NTINHI+II-4
      ENDIF
C
C DETERMINE THE COEFFICIENTS FOR A SERIES EXPANSION OF
C THE WAVE FUNCTION ABOUT THE ORIGIN
C
      TL=L
      A(1)=DONE
      IF(BREL)THEN
        IF(RNUK.LT.DZERO)THEN                  !POINT
          NK=2
          TQ=DONE+(E+DFOUR/DALF)*X(1)/Z
          TQ=DONE/TQ
          TQ=TQ*TQ
          T=L*(L+1)-DALF*Z*Z+D3QRT*TQ
          TLAM=DQUART+T
          TLAM=SQRT(TLAM)-DHALF
          A(2)=(TLAM+DONE)*(TLAM+DTWO)-T
          A(2)=-A(1)*DTWO*Z*(DONE+E*DALF/DTWO)/A(2) !Z=ZS0(0)
          A(3)=A(1)*TLAM/DTWO                       !FOR Q NORM
        ELSE                                   !FINITE
          NK=3
          A(2)=DZERO
          T=(L+2)*(L+3)-L*(L+1)
          TZE=2*ZS0(1)+E
          TT=DONE+DQUART*DALF*TZE
          TT=-2*ZS0(3)*D3QRT*DALF/TT
          TT=TT-TZE*(DONE+DQUART*DALF)
          A(3)=A(1)*TT/T
        ENDIF
      ELSE
        A(2)=-A(1)*PKOEF(1)/(L+1)
        DO I=3,NK
          II=I-1
          A(I)=DZERO
          DO J=1,II
            A(I)=A(I)+A(J)*PKOEF(I-J)
          ENDDO
          A(I)=-(DTWO*A(I)+A(I-2)*E)/(II*(2*L+I))
        ENDDO
      ENDIF
C
C CALCULATE FIRST (TWO) POINTS FROM SERIES
C (IF FINITE NUCLEUS THEN THE EXPANSION COEFFICIENTS ARE ONLY VALID
C  INSIDE THE NUCLEUS. CODE TESTS THAT THERE ARE TWO MESH POINTS THERE.)
C
      I2=2
C
      TLAM=TL                        !AND FOR FN.WHITEX NORM
      DO I=1,I2
        PQ(I)=DZERO                  !CONTAINS THE VALUE OF THE FUNCTION
        DO J=1,NK
          T=J
          T=T+TLAM
          PQ(I)=PQ(I)+A(J)*X(I)**T
        ENDDO
      ENDDO
C
C NOW TRANSFER LAST TWO POINTS FOR NUMEROV INTEGRATION
C
      DO II=2,3
        I=I2+II-3
        U(II)=PQ(I)
        IND(II)=I
      ENDDO
C
C CHECK THAT THE FUNCTION DOES NOT CHANGE SIGN BETWEEN THE FIRST TWO
C POINTS. IF IT DOES, THEN PRINT ERROR MESSAGE AND STOP.
C THIS MAY BREAK DOWN AT VERY HIGH-L, C.F. CONTINUUM, SO ONLY TEST AT
C THE INNER TURNING POINT - SEE BELOW.
C  (N.B. DO NOT TEST PRODUCT->UNDER/OVERFLOW)
C
      if(l.lt.30)then
      IF(PQ(1).GT.DZERO.AND.PQ(I2).LT.DZERO.OR.
     X   PQ(1).LT.DZERO.AND.PQ(I2).GT.DZERO)THEN
        WRITE(6,991)
        N=0
        GO TO 999
      ENDIF
      endif
C
C OUTWARD INTEGRATION
C NC=NUMBER OF POINTS EXCLUDING THE ORIGIN FOR INTEGRATION.
C XA=START, XB=END OF INTEGRATION
C
      I2M=I2-1
      NC=NTI(1)-I2M
      XA=X(I2M)
      XB=X(NC+I2M)
C
C NODE AT THE ORIGIN DOES NOT COUNT
C
      NODS=1
C
C FIRST 2 POINTS
C
      J=I2
      IX0=J
C
C ESTIMATE INNER TURNING POINT(DON'T START COUNTING NODES UNTIL REACHED)
C
      X0=Z0*Z0+TLB*EW
C
      if(x0.lt.dzero)then
        WRITE(6,*)
     X     '*** SR.RADWAV ERROR: NO RADIAL SOLUTION FOR THIS POTENTIAL!'
        WRITE(0,*)
     X     '*** SR.RADWAV ERROR: NO RADIAL SOLUTION FOR THIS POTENTIAL!'
        l=-999
        go to 999
      endif
c
      X0=SQRT(X0)+Z0
      X0=TLB/X0
C
C ARRAY INDEX IN NUMEROV MUST INCREASE   (STEPS +1 OF INDEX TO XB)
C
      IND(1)=1
      DO I=1,NHI
C
        CALL NUMERO(XA,XB,U,IND,NC,DP)
C
        DO II=2,NC
          J=J+1
          PQ(J)=DP(II)
c
c                 if(n.eq.1.and.itera.eq.maxit)write(6,1111)j,x(j),pq(j)
c 1111            format(i5,1pd12.5,d17.8)
C
C MAKE SURE THE SIGN OF PQ IS ALWAYS WELL DEFINED.
C
          IF(PQ(J).EQ.DZERO)PQ(J)=EMINIM
C
C START COUNTING NODES WHEN FIRST TURNING POINT IS REACHED
C
          IF(X(J).GE.X0)THEN
C
C A NODE IMPLIES A CHANGE OF SIGN IN PQ
C  (N.B. DO NOT TEST PRODUCT->UNDER/OVERFLOW)
C
            IF(PQ(J).GT.DZERO.AND.PQ(J-1).LT.DZERO.OR.
     X         PQ(J).LT.DZERO.AND.PQ(J-1).GT.DZERO)NODS=NODS+1
C
C NOT YET TOO MANY NODES, OUTWARD INTEGRATION MAY GO ON
C
            IF(NODS.GT.NODES)THEN
C
C TOO MANY NODES.  THE PRESENT ABSOLUTE OF E THEREFORE REPRESENTS
C A LOWER LIMIT EL
C
              EL=E
C
C INCREASE THE ABSOLUTE OF E, BUT NOT BY TOO MUCH
C
              E=E*D1PT5
              IF(L.LT.5)GO TO 22
              X1=-ZN*ZN/TLW
              T=E
              IF(BREL)T=T-D3QRT*DALF*T*T
              IF(T.LT.X1)THEN
                E=DTWO*(T/DTHREE+X1)/DTHREE
                IF(BREL)E=E+D3QRT*DALF*E*E
              ENDIF
              GO TO 22
            ENDIF
          ELSE
            IX0=J
          ENDIF
C
        ENDDO
C
C CALCULATE THE STARTING VALUES FOR NUMEROV FOR THE NEXT INTERVAL
C
        IF(I.LT.NHI)THEN
          U(2)=DP(NC-2)
          U(3)=DP(NC)
          XA=X(J-2)
          IND(2)=J-2
          IND(3)=J
C
C IND(3) GIVES THROUGH X(IND(3)) THE INITIAL POINT OF THE PARTICULAR
C NUMEROV INTEGRATION
C
          NC=NTI(I+1)+1
          IF(I.EQ.NHI-1)NC=NTINHI+5
          XB=X(J+NC-1)
        ENDIF
      ENDDO
C
C     ELSE CHECK NODES
C
      IF(NODS.NE.NODES)THEN
C
C CHECK WHETHER NUMBER OF NODES IS CORRECT
C IF NOT ENOUGH NODES IN THE WAVE FUNCTION REDUCE THE ENERGY AND
C START THE PROCESS AGAIN
C THE PRESENT ABSOLUTE OF E THEN REPRESENTS AN UPPER LIMIT EH
C
        EH=E
        E=E/D1PT3
C
C START INTEGRATION AGAIN WITH NEW E
C
        GO TO 30
C
      ENDIF
C
C FIND STARTING POINT X(NP) FOR INWARD INTEGRATION
C
      I=NPRES+5
      IF(I.GT.NPOINT)I=NPOINT
      SQRE=SQRT(-E)
      SQRW=SQRT(-EW)
      IF(.NOT.BNORM)PNORM=DONE
  151 NC=I
  157 NP=I
      XA=X(NP)
      I=I-4
      IF(I.LE.NOUTW)THEN
        WRITE(6,993)MSTEP
        GO TO 75
      ENDIF
C
C THE STARTING VALUES WILL BE CALCULATED WITH A WHITTAKER FUNCTION
C EXP(-SQRT(-E)*XA) MUST NOT BECOME DZERO-REDUCE IF MACHINE ALLOWS
C
      IF(XA*SQRW.GE.D180)GO TO 151
C
      ZW0=ZW+X(NP)*VSC(NP)
C
      PO=WHITEX(XA,TLAM,TLW,EW,ZW0,BNORM)
C
      IF(.NOT.BNORM)PNORM=DONE
      PO=ABS(PO)*PNORM
      IF(PO.GE.D1M30)GO TO 152
      IF(I.GT.IEND)GO TO 157
      IF(PO.LT.EMINIM)GO TO 151
C
C THE FUNCTION WILL BE CALCULATED FOR ALL X.LE.X(NP)
C
  152 NPRES=NP
      IF(BSHORT)THEN
        NP=IEND+5
        IF(NOUTW.GT.IEND)NP=NOUTW+5
        NP=NP+NCORR
        IF(NP.GT.NPRES)NP=NPRES
      ENDIF
C
C CHECK WHETHER NEW STARTING POINT FALLS NOT TOO NEAR TO END OF
C INTERVAL;  PP WILL BE USED FOR DERIVATIVES, NTI(NHI) FOR WEDDLE
C
      II=0
      PP=DXI(NHI)*D840
      DO J=1,NI
        IF(NTI(J).LT.8)GO TO 156
        NHI=J
        JJ=II+NTI(J)
        IF(JJ.LT.NP)GO TO 155
        IF(JJ.EQ.NP)GO TO 140
        IF(NP-II.GE.8)GO TO 140
        NP=II+8
        IF(NP.LE.NC)GO TO 140
        NHI=J-1
        NP=II
        II=II-NTI(J-1)
        IF(NOUTW+4.GT.NP)GO TO 156
        GO TO 140
  155   II=JJ
      ENDDO
C
  156 WRITE(6,994)
      N=0
      GO TO 999
C
  140 NTINHI=NTI(NHI)
      NTI(NHI)=NP-II
C
C INWARD INTEGRATION;
C   ARRAY INDEX IN NUMEROV MUST DECREASE   (IND(1) NEGATIVE)
C
C   GIVE THE STARTING VALUES FOR THE NUMEROV INTEGRATION
C   CALCULATE THE TWO OUTERMOST POINTS WITH THE WHITTAKER FUNCTION
C
      XA=X(NP)
      ZW0=ZW+X(NP)*VSC(NP)
C
      DP(NP)=WHITEX(XA,TLAM,TLW,EW,ZW0,BNORM)*PNORM
C
      I=NP-1
      XB=X(I)
      ZW0=ZW+X(I)*VSC(I)
C
      U(3)=WHITEX(XB,TLAM,TLW,EW,ZW0,BNORM)*PNORM
C
      IF(BNORM)GO TO 159
      U(3)=(U(3)/DP(NP))*D1M30
      DP(NP)=D1M30
      GO TO 159
C
C   A NEW INTERVAL WITH A SMALLER SET UP HAS BEEN ENTERED.
C   THE SECOND STARTING POINT HAS TO BE CALCULATED BY AN INTERPOLATION,
C   AT 6 EQUIDISTANT POINTS X(J): J=I+3,I+2,I+1,I-1,I-3,I-5.
C   INTEGRATE OVER ANOTHER 3 INTERVALS OF THE OLD LENGTH
C
  170 IND(1)=-2
      I=I-1
      DO J=1,4
        Y(J)=X(I+3-2*J)
      ENDDO
      XB=Y(4)
C
      CALL NUMERO(XA,XB,U,IND,IFOUR,A)
C
      Y(5)=X(I+3)
      Y(6)=X(I+2)
      A(5)=DP(I+3)
      A(6)=DP(I+2)
C
C INTERPOLATE TO GET A FUNCTION VALUE DP(I) AT X(I), THEN PROCEED
C TO USE NUMERO
C
      U(3)=DZERO
      DO II=1,6
        XA=DONE
        XB=DONE
        DO JJ=1,6
          IF(JJ.NE.II)THEN
            XA=XA*(X(I)-Y(JJ))
            XB=XB*(Y(II)-Y(JJ))
          ENDIF
        ENDDO
        U(3)=A(II)*XA/XB+U(3)
      ENDDO
C
  159 DP(I)=U(3)
C
C ASSIGN STARTING VALUES FOR THE CONTINUATION OF THE NUMEROV
C INTEGRATION
C
      U(2)=DP(I+1)
C
C INTEGRATE INWARDS TO THE MATCHING POINT
C
  160 IND(2)=I+1
      IND(3)=I
C N.B. THE  U(2),U(3)  ALREADY CONTAIN THEIR PROPER VALUES.
      XA=X(I+1)
C
C DETERMINE NEW I AND INTERVAL
C INDEX I SHALL GIVE THE ARRAY INDEX OF XB
C
      DO J=2,12
C     IF THE END HAS NOT BEEN REACHED YET, CONTINUE WITH THE INTEGRATION
        IF(I.LE.NOUTW-4)THEN
          IF(J.EQ.2)GO TO 190
          GO TO 180
        ENDIF
C     CHECK WHETHER THE NEW STEP HAS THE SAME LENGTH AS THE PREVIOUS ONE
        IF(X(I+1)-X(I).GT.(X(I)-X(I-1))*D1PT05 )THEN
          IF(J.EQ.2)GO TO 170
          GO TO 180
        ENDIF
        I=I-1
        NC=J
      ENDDO
C
  180 IND(1)=-1
      XB=X(I)
C
      CALL NUMERO(XA,XB,U,IND,NC,A)
C
C STORE RESULT IN P
C
      DO J=2,NC
        II=I+NC-J
        DP(II)=A(J)
      ENDDO
      GO TO 160
C
C IF INWARD AND OUTWARD FUNCTIONS HAVE DIFFERENT SIGNS, CHANGE
C THE SIGN OF THE INWARD FUNCTION.
C SCALE OUTWARD AND INWARD FUNCTION TO PQ(NOUTW)=DP(NOUTW)=1.*SIGN(P)
C
  190 RJ=DONE/ABS(DP(NOUTW))
C     WRITE(6,1003)PQ(NOUTW),DP(NOUTW)
      IF(PQ(NOUTW)*DP(NOUTW).LT.DZERO)RJ=-RJ
      II=NOUTW-4
      DO I=II,NP
        DP(I)=DP(I)*RJ
      ENDDO
      DQUOT=ABS(DONE/PQ(NOUTW))
      JJ=NOUTW+4
      DO I=1,JJ
        PQ(I)=PQ(I)*DQUOT
      ENDDO
C
C CALCULATE DERIVATIVES XB AND XA OF INWARD AND OUTWARD FUNCTIONS
C
      I=NOUTW
      XB=( 672*(DP(I+1)-DP(I-1))-168*(DP(I+2)-DP(I-2))
     X     +32*(DP(I+3)-DP(I-3))-3*(DP(I+4)-DP(I-4)) )/PP
      XA=( 672*(PQ(I+1)-PQ(I-1))-168*(PQ(I+2)-PQ(I-2))
     X     +32*(PQ(I+3)-PQ(I-3))-3*(PQ(I+4)-PQ(I-4)) )/PP
C
C CALCULATE DP(X)*DP(X), INTEGRATE THAT FUNCTION AND CALCULATE
C                      THE ENERGY CORRECTION ACCORDING TO HARTREE
      PO=DZERO
      DO I=1,NOUTW
        DP(I)=PQ(I)
        IF(ABS(DP(I)).GT.PO)PO=ABS(DP(I))
        PQ(I)=PQ(I)*PQ(I)
      ENDDO
C
      DPMIN=PO*EMINIM
      IF(DP(NOUTW).LT.DZERO)DPMIN=-DPMIN
      POO=PO*D1M30
      DO I=NOUTW,NP
        IF(ABS(DP(I)).LT.POO)DP(I)=DPMIN
        PQ(I)=DP(I)*DP(I)
      ENDDO
C
C INTEGRATE DP(X)*DP(X) AND CORRECT ASYMPTOTICALLY; RESTORE NTI(NHI)
C
      CALL WEDDLE(DZERO,PQ,PP,NTI,DXI,NHI,NP)
C
      NTI(NHI)=NTINHI
      PO=PQ(NP)/(DTWO*SQRW)
      PP=PP+PO
c                             write(6,*)pp-po,po,pp,noutw,p(noutw),xa,xb
C
C ENERGY CORRECTION:
C
      DE=DP(NOUTW)*(XB-XA)/PP
C
C ENERGY CORRECTION;  E MUST NOT BECOME POSITIVE
C
      IF(E.GE.DE)DE=E/D1PT5                                 !AS E<0
C
C MORE GENERALLY, E SHOULD NOT EXCEED EL BY A LARGE AMOUNT IN LATER
C STAGES OF ITERATION, IF SO, THEN FAILING SO TRY AND KICK-START
C (E.G. LANTHANIDE 4F-ORBITAL COLLAPSE.)
C
      IF(N.GT.1.AND.ITERA*2.LT.MAXIT.AND.E-DE.GT.EL)DE=E-EL*D1PT1
C
C      WRITE(6,1001)NOUTW,XA,XB,DE,PP
C
C ENERGY CORRECTION;  E MUST NOT BECOME SO NEGATIVE THAT THERE CAN
C NO OUTWARD TURNING POINT.
C
      IF(L.GE.5)THEN
        XB=-ZN*ZN/TLW
        T=E-DE
        IF(.NOT.BREL)THEN
          IF(T.LT.XB)DE=DTWO*(E-XB)/DTHREE
        ELSE
          T=T-D3QRT*DALF*T*T
          IF(T.LE.XB)THEN
            TT=E-D3QRT*DALF*E*E
            T=(TT+DTWO*XB)/DTHREE
            DE=E-(T+D3QRT*DALF*T*T)
          ENDIF
        ENDIF
      ENDIF
C
C THE APPROXIMATION IS TERMINATED WHEN THE RELATIVE CORRECTION TO
C THE EIGENVALUE IS SMALLER THAN DTOL, AND .NOT. BSHORT.
C
      XB=ABS(DE/E)
c                      write(6,*)itera,nods,n,l,e,de,xb,bshort,x(np)
      IF(.NOT.BSHORT)THEN
ct        t=log10(-e-1)-.7 !D0PT7
ct        it=nint(t/2)
c        write(6,*)it
        IF(XB.LT.DTOL)GO TO 225                          !/10**it
      ENDIF
C
      ITERA=ITERA-1
      IF(XB.LT.D99*DTOL.OR.ITERA*2.LT.MAXIT)BSHORT=.FALSE.
CTEST
CT      IF(ABS(DE).GT.5*ABS(DE0)+D1M3)THEN !CORRECTN GROWING, NOT CONVRG
CT        E=E0
CT        DE=DE0/DTWO
CTc        ITERA=ITERA+1
CT      ELSE
CT        E0=E
CT      ENDIF
CT      DE0=DE
c                                                     write(6,*)n,l,e,de
C
C FORM NEW EPSILON
C
      E=E-DE
C
      IF(PO.GT.D1M3*PP)NCORR=NCORR+10
      PNORM=ABS(RJ)*PNORM
      IF(ITERA.GE.0)GO TO 30
C
      WRITE(6,990)E,DE,MAXIT,N,L
      IF(XB.GT.D99*DTOL)THEN
        WRITE(6,*)'*** SR.RADWAV ERROR: RADIAL FUNCTION TOO INACCURATE'
        WRITE(0,*)'*** SR.RADWAV ERROR: RADIAL FUNCTION TOO INACCURATE'
        L=-999
        GO TO 999
      ENDIF
C
C WE ARE DONE
C
  225 CONTINUE
C
C NORMALIZE THE FUNCTION
C SET ALL FUNCTION VALUES FOR X.GE.X(NP) TO DZERO
C
      PNORM=DONE/SQRT(PP)
      IF(DP(IX0).LT.DZERO)PNORM=-PNORM
      DPMIN=DPMIN*PNORM
      DO I=1,NPOINT
        IF(I.GT.NP)DP(I)=DPMIN
        DP(I)=DP(I)*PNORM
      ENDDO
      PO=POT(NP)*X(NP)
C
c Suppress pesky 1s since mesh is large enough, rather 1s is too
c compact in heavy atoms to get outside the charge cloud. Nothing
c to be done and 1s is deep closed-shell core.
c
      IF(NP.LE.IEND.and.N.NE.1)WRITE(6,992)NP,X(NP),PO,ZN,N,L
C
C /COMIKE/ CONTAINS THE CORRECT ANORM FOR THE STARTING EXPANSION
C
      IF(PNORM.LT.DZERO)PNORM=-PNORM
      DP0=PNORM*DQUOT
      PKOEF(2)=POT(1)-Z/X(1)                     !ELECTROSTATIC POT ONLY
      DQ0=(DTWO*PKOEF(2)+E)*DP0                      !NOT USED BY AS
C
C CALCULATE THE CORRECT SCREENING VALUE
C
      EA=E
      SCREEN=Z-N*SQRE
C
      pnorm=done
C
C NORMALIZE TRANSFORMED RELATIVISTIC SOLUTION
C
      IF(BREL)THEN
C
      DO I=1,NP
        DQ(I)=POT(I)+VSC(I)
        PQ(I)=DP(I)*DP(I)*DQ(I)
      ENDDO
C
      CALL WEDDLE(DZERO,PQ,PP,NTI,DXI,NHI,NP)
C
      PNORM=DONE+DQUART*DALF*(E+DTWO*PP)
      PNORM=DONE/SQRT(PNORM)
c      w=done                !standard Darwin
c      if(kappa.ne.0)w=-2.   !see also pmvdar
      DO I=1,NP
        PP=DONE+DQUART*DALF*(E+DTWO*DQ(I))
        pp=abs(pp)
        DQ(I)=PP
        PP=SQRT(PP)
c        pp=pp**(w/dtwo)
        DP(I)=DP(I)*PNORM*PP
c        pq(i)=p(i)*p(i)
      ENDDO
c
c      call weddle(dzero,pq,pp,nti,dxi,nhi,np)!further renorm for w.ne.1
c      pp=done/sqrt(pp)
c      pnorm=pnorm*pp
c      do i=1,np
c        p(i)=p(i)*pp
c      enddo
c      write(0,*)l,pp
c
      PP=DONE
      IF(RNUK.GT.DZERO)PP=PP+DQUART*DALF*(E+DTHREE*Z/RNUK)
      PP=SQRT(PP)
      DP0=DP0*PNORM*PP
C
c2      DQ0=DQ0*PNORM*PP
C
c      IF(BREL2)THEN
        DQ0=DHALF*DFSC*DP0
        IF(L.EQ.0)DQ0=DQ0*DTWO*A(3)
        IF(L.GT.0)DQ0=DQ0*TLAM
c
c note. kappa is set in radial
        tkap=-1
        if(kappa.ne.0)tkap=kappa
C
        CALL DIFF(DP,PQ,NTI,DXI,NI)
C
        DO I=1,NP
          DQ(I)=DHALF*DFSC*(PQ(I)+tkap*DP(I)/X(I))/DQ(I)
ct          q(i)=dzero
          PQ(I)=DQ(I)*DQ(I)
        ENDDO
C
        CALL WEDDLE(DZERO,PQ,PP,NTI,DXI,NHI,NP)
C
        PNORM=DONE+PP
        PNORM=DONE/SQRT(PNORM)
      if(brel2)then
        DO I=1,NP
          DQ(I)=DQ(I)*PNORM
          DP(I)=DP(I)*PNORM
        ENDDO
        DP0=DP0*PNORM
        DQ0=DQ0*PNORM
C
        IF(NPOINT.GT.NP)THEN
          DQMIN=PNORM*DPMIN*DQ(IX0)/DP(IX0)
          DO I=NP,NPOINT
            DQ(I)=DQMIN
          ENDDO
        ENDIF
      ENDIF
C
C ESTIMATE SCREENING COMARED TO (RELATIVISTIC) HYDROGENIC FORM
C
      TL=L
      T=-DQUART*DALF*(DFOUR*N/(TL+DHALF)-DTHREE)
      IF(L.EQ.0)T=T+DALF*N
      TL=DONE+DFOUR*T*E
      TL=SQRT(TL)
      TL=(DONE-TL)/(DTWO*T)
      SQRE=SQRT(TL)
      SCREEN=Z-N*SQRE
C
      ENDIF
C
C PUT BACK POINT NUCLEUS
C
      DO I=1,INUK
        T=POT(I)
        POT(I)=DNUK0(I)+Z/X(I)
        DNUK0(I)=T-DNUK0(I)
      ENDDO
C
C
  999 RETURN
C
C
  997 FORMAT(' SR.RADWAV: JOINING DISTANCE GT LIMIT')
  996 FORMAT(' SR.RADWAV: JOINING POINT LIES IN FIRST INTERVAL ---'
     X,' HAS CHARGE Z GONE OUT OF HAND?')
C                            (Z WRONG, OR SIGMA0 POORLY SPECIFIED)
  994 FORMAT(' SR.RADWAV: MIXUP IN JOINING AREA, CHECK NTI-INPUT FIRST')
  993 FORMAT(' SR.RADWAV: WHITEX ALWAYS ZERO --- TRY BIGGER INTEGRATION'
     X,' RANGE - MORE POINTS (INCREASE MAXB1 2) OR LONGER STEPS '
     X,'(DECREASE MSTEP IN NAMELIST SMINIM)'/' CURRENTLY, MSTEP=',I3)
  992 FORMAT( ' RADWAV-WARNING:  INWARD-INTEGRATION STARTED AT X(',I5,
     X') =',F7.3, ': Z(X)-ZN =',F10.6,'  -',F3.0,5X, 'FOR  (N L) =',2I3)
  991 FORMAT(' SR.RADWAV: CHANGE OF SIGN AT BEGINNING')
  990 FORMAT(' SR.RADWAV GIVES UP WITH (E,DE)=',2F13.7,' AFTER',I3,
     X'ITERATIONS OF (N,L)=',2I2,' CHECK WHETHER PRECISION GOOD ENOUGH')
C
      END SUBROUTINE RADWAV
C
C                             *******************
C
      SUBROUTINE RADWIN(MAXPS)
C
C-----------------------------------------------------------------------
C
C  SR.RADWIN READS RADIAL FUNCTION INPUT AND PROCESSES IT FOR
C  ORBITALS K MARKED BY SIGMA(K).GE.999 & .LT. 5999. IT EXPECTS INPUT
C  IN COLLALG/IMPACT FORMAT -- UNLESS KEY.NE.-9 IN (T1,I5) OF FIRST C
C  AFTER A HEADING CARD WITH KEY.GE.0, THIS VERSION OF SR.RADWIN
C  READS HARTREE-FOCK-FROESE FUNCTIONS P(N,L) AND Q(N,L) AS PROVIDED
C  BY H.SARAPH OR D.C.GRIFFIN FROM CHARLOTTE FROESE'S PROGRAM AT
C  THE USUAL RADII. PROGRAM ASSUMES THESE ARE BOUND FUNCTIONS.
C  USE KEY .EQ. -20 TO READ IN CONTINUUM FUNCTIONS (FORMAT SAME AS
C  OUTPUT RADIAL FUNCTIONS PRODUCED BY AUTOSTRUCTURE).
C  NOTE KEY CAN BE REDEFINED BETWEEN ORBITALS SO A MIXTURE OF BOUND AND
C  CONTINUUM FUNCTIONS CAN BE READ IN. ALTERNATIVE BRANCHES MAY BE
C  INSERTED USING KEY.
C  EXTENDED SO AS TO READ AND PROCESS STO INPUT IF KEY=-10.
C
C  IT CALLS:
C     SR.STOPOT
C     SR.TFDAPO
C     SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG,MXPIN
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_NRBDQE, ONLY: DQNL,MXQIN
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD14=100)
C
      PARAMETER (IREAD=5)
      PARAMETER (OVRLP=2.D-6)
      PARAMETER (D999=999.0D0)
      PARAMETER (D3999=3999.0D0)
      PARAMETER (D5999=5999.0D0)
      PARAMETER (ID=4)
      PARAMETER (CON1=85.196D0)
C
      CHARACTER(LEN=4) MBLNK,MHEAD
C
      ALLOCATABLE  :: DH(:),DY(:),DP(:),DQ(:),KHLP(:)
      ALLOCATABLE  :: DWRK1(:),DWRK2(:)
      ALLOCATABLE  :: DOVLP(:),DORIGZ(:)
C
      DIMENSION JRAD(0:22),ZE(0:22),CJ(0:22)
C
      COMMON /BASIC/NF,KVV,MGAP(10)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /JSPOR/NJO,NRR(MAXLV),NT(MAXJG),JN(MAXLV),NGR(MAXLV)
      COMMON /NXRNL/NL000,NL
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBNAM/NF0,BNAME
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBRAD/IRAD(MAXGR)
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
      NAMELIST/SRADWIN/ACE,KEY,MR5                                !,MDUM
C
      DATA MBLNK/'    '/                                  !,MXPIN/MAXB1/
C
      IF(IEQ(0).GT.0)THEN                     !NOT A GOOD IDEA ANYWAY...
        WRITE(0,*)'*** SR.RADWIN NOT CODED TO READ RELAXED ORBITALS!'
        WRITE(6,*)'*** SR.RADWIN NOT CODED TO READ RELAXED ORBITALS!'
        NF=-1
        RETURN
      ENDIF
C
C HISTORICALLY, MXPIN AND MXQIN COULD BE USED TO SWITCH-OFF MEMORY USE
C ASSOCIATED WITH RADWIN. NOW UNNECESSARY. CURRENTLY THEY ARE SET
C EQUAL TO MAXRS IN SR.MINIM, WHICH IS THE DPNL, DQNL ALLOCATION.
C
c      MXQIN=SIZE(DQNL,IONE)           !PASSED VIA MODULE
c      MXPIN=SIZE(DPNL,IONE)           !PASSED VIA MODULE
      MXBUF=2*MXPIN
C
      ALLOCATE (DH(MXBUF),DY(0:MXBUF),DP(MXBUF),DQ(MXBUF),KHLP(MAXRS))
      ALLOCATE (DWRK1(MXPIN),DWRK2(MXPIN))
      ALLOCATE (DOVLP(MXORB),DORIGZ(MXORB))
C
      IPMX=0
      DY(0)=DZERO
      MR5=IREAD
      MWR=10
      MHLP=0
      BLAG=.FALSE.
      BPRNT=JPRINT.NE.-3
      MINK=0
      MSHIFT=10000
      KEY=0
      IORB=0
      SKREEN=DONE
      DZ=NZION
      BORT=MORT.LT.0
      IF(.NOT.BORT)WRITE(6,101)
      K00=1000
      KST=1
C
      IF(NF.GT.0)THEN
        DO K=1,MXORB
          DORIGZ(K)=DZERO
          IF(DEY(K).EQ.DZERO)GO TO 66
          IF(SCREEN(K).GE.D999.AND.SCREEN(K).LT.D5999)GO TO 66
          DORIGZ(K)=DORIG(K)*DZ
  66    ENDDO
        II=1
      ENDIF
C
  70  MXP=MXBUF                                    !MXPIN
C
      IF(BNAME)THEN
        MRR=MR5
        MR5=0
C        MDUM=0
        ACE=DZERO
        KEY0=KEY
        KEY=-9
        IF(KEY0.NE.-9)THEN
C
          READ(MRR,SRADWIN,END=1000,ERR=1000)  ! <------------- NAMELIST
C
          KEY0=KEY
          IF(KEY.EQ.-15)KEY=-9
        ENDIF
        IF(KEY.EQ.-10.AND.MR5.EQ.0)MR5=MRR
        MORE=MR5
      ELSE
        IF(KEY.NE.-9)READ(MR5,590)KEY,MORE     ,ACE
C                                        ,MDUM
      ENDIF
C
      IF(KEY.GE.0.AND.KEY.LT.10)BPRNT=.FALSE.
      IF(MORE.GT.0)MR5=MORE
      IF(MORE.LE.0)MR5=MWR+2
      IF(MR5.NE.IREAD)THEN
        IF(IUNIT(MR5).EQ.0)THEN
          WRITE(6,*)"MISSING INPUT FILE='radwin'..."
          WRITE(0,*)'MISSING FILE ON UNIT=12'
          GO TO 99
        ENDIF
        REWIND(MR5)
      ENDIF
C
      MXORBI=0
      MPS=0
C
      IF(KEY.EQ.-9)READ(MR5,589,END=1001,ERR=1001)KEY,MXORBI,MPS,MPMX
C
      IF(MXORBI.LE.0)MXORBI=MXORB
      IF(ABS(MPSEUD).GT.0.AND.MPS.NE.ABS(MPSEUD))THEN
        WRITE(6,*)'CLOSED-SHELL POTENTIAL INPUT TO RADWIN NOT'
     X  ,' CONSISTENT WITH CLOSED-SHELL DEFINITION IN ALGEB',MPS,MPSEUD
        WRITE(0,*)'CLOSED-SHELL POTENTIAL INPUT TO RADWIN NOT'
     X  ,' CONSISTENT WITH CLOSED-SHELL DEFINITION IN ALGEB'
        GO TO 99
      ENDIF
C
      J=KEY
      IF(KEY.NE.-20)GO TO 11
      IF(MODE.EQ.1)MODE=2
C     IF(MDUM.GT.0)MODE=MDUM
      IF(MODE.GT.0.AND.MODE.LT.4)GO TO 1
      WRITE(6,593)MODE
      GO TO 99
C
   1  IF(MHLP.NE.0)GO TO 72
      IF(ACE.LT.D1M4)ACE=D1P10
      IF(BPRNT)WRITE(6,592)KEY,MODE,ACE
C
C
C FOR CONTINUUM WAVEFUNCTION WE DROP ALL POINTS PAST INPUT MAXPS
C SINCE ALL INTEGRALS P*F, P*P SHOULD HAVE CONVERGED BY THEN,
C UNLESS GOING INTO SR.RADCON NEXT.
C
      MAXRS0=MAXRS
      IF(MAUTO.NE.0)THEN                     !IF(MAUTO.EQ.0)MAXTS=MAXRS0
        MAXTS=MAXPS
        if(maxps.eq.0)maxts=maxrs
        MJH0=MJH
        MAXRS=0
        DO I=1,MJH0
          MAXRS=MNH(I)+MAXRS
          MJH=I
          IF(MAXRS.EQ.MAXTS)GO TO 18
          IF(MAXRS.GT.MAXTS)THEN
            MAXRS=MAXRS-MNH(I)
            MNH(I)=MAX(MAXTS-MAXRS,ININE)
            MAXRS=MAXRS+MNH(I)
            GO TO 18
          ENDIF
        ENDDO
      ENDIF
C
  18  IF(BPRNT)WRITE(6,250)MAXRS,MAXRS0
C
C RE-ENTRY POINT TO READ ORBITALS
C
  72  IF(KEY.NE.-20)GO TO 12
C
      READ(MR5,591)MYN,MYL,DDY,MPMX,MHEAD,MP
C
C PROGRAM ASSUMES SAME ENERGY FOR EACH CONTINUUM ORBITAL, WILL PUT DDY
C IN DYY(NREL) FOR NOW WHERE NREL=1 IS DEFAULT SET IN SR.RADIAL,
C NO DSHIFT AND NO INTERPOLATION POSSIBLE.
C
C   MP .GT. 0 PRINTS OUT INPUT FUNCTION AS INTERPOLATED ONTO
C   SUPERSTRUCTURE GRID. MP .GT. 5 PRINTS OUT CONTIUUM FUNCTION ON
C   ORIGINAL GRID
C
      IF(MYL.LT.0)GO TO 79
      IF(MPMX.GT.0)GO TO 13
      IF(MPMX.EQ.0)GO TO 79
      MHLP=1
      GO TO 70
  13  IF(DDY.LT.DZERO)WRITE(6,997)DDY
C
      DO I=1,MXP                          !MPMX
C        IF(I.LE.MXP)THEN
          READ(MR5,998)L,DY(I),DP(I),DQ(I)
          IF(MP.GT.5)WRITE(6,998)L,DY(I),DP(I),DQ(I)
C        ENDIF
      ENDDO
C
      DP0=DZERO
      IF(DY(1).GT.DZERO)DP0=DP(1)/DY(1)**(MYL+1)
      IF(MHLP.GE.0)GO TO 40
      GO TO 14
C
  11  IF(BPRNT)WRITE(6,250)MAXRS,MAXRS
      DP0=DZERO
      DDY=DZERO
      IF(KEY.EQ.-9)GO TO 43
      IF(KEY.EQ.-10)GO TO 12
C
C ASSUME MXP.LE.MXPIN POINTS DY FOR (HARTREE-FOCK-FROESE) CARD INPUT
C (ADDITIONAL CARDS WILL BE SKIPPED-DO49; 2 POINTS PER CARD)
C
      DM=DONE/(DFOUR*DFOUR)
      DD=-DFOUR
C
      DO I=1,MXP
        DY(I)=EXP(DD)/DZ
        DD=DD+DM
      ENDDO
      GO TO 40
C
C ADDRESS ARRAY KHLP WILL HELP TO INTERP. DY ONTO DX
C
  41  MXP=IPMX
  40  II=1
      MHLP=-1
      DO K=1,MAXRS
        KHLP(K)=0
        GO TO 82
  81    II=II+1
  82    IF(II.GT.MXP)GO TO 85
        IF(II.EQ.MXP)GO TO 84
        IF(DY(II+1)+DY(II).LT.DX(K)*DTWO)GO TO 81
  84    IF(DX(K).GT.DY(MXP))GO TO 81
        KHLP(K)=II
  85  ENDDO
C
      IF(KEY.EQ.-20)GO TO 14
  12  MYN=0
      N=0
      NSTO=0
      DP0=DZERO
      IORB=IORB+1
      IF(IORB.GT.MXORBI)GO TO 79
      IF(KEY.GE.0)  GO TO 42
C
      READ(MR5,570,END=79)J,N,MYN,MYL,DDY,MPMX,MHEAD,MP
C
      IF(J.EQ.0)GO TO 79
      IF(J.EQ.-5)GO TO 79
      SKREEN=DZERO
      MPMX=MPMX*2
      DDY=-ABS(DDY)                   !COMPENSATE FOR MCHF
      IF(KEY.GE.-9)GO TO 43
      IF(J.LE.0)GO TO 43
C
C-----------------------------------------------------------------------
C
C COMPUTE SLATER TYPE ORBITALS FROM INPUT IN RMATRX/STG1 FORMAT,
C              I.E. READ  ISTO(K),ZESTO(K),CSTO(K), WHEN KEY=-10.
C
      MPMX=0
      MP=0
      MHEAD=MBLNK
      DY(1)=DZERO
      INORM=N
      N=J
      READ(MR5,*)(JRAD(K),K=1,N)
      READ(MR5,*)(ZE(K),K=1,N)
      READ(MR5,*)(CJ(K),K=1,N)
      NSTO=N
C
C COMPUTE P AND Q BAR0, AND SATISFY CUSP CONDITION IF SO TOLD BY MYN
C
  88  K=1
  32  L=JRAD(K)
      DM=DZERO
      DD1=DZERO
      DP0=DZERO
      DD2=DZERO
      DQ0=DZERO
      DO K=1,N
        IF(JRAD(K).LT.L)GO TO 32
        IF(JRAD(K).EQ.L)THEN
          IF(ZE(K).GT.DM)DM=ZE(K)
          DP0=CJ(K)+DP0
          DD=ZE(K)*CJ(K)
          DD1=DD+DD1
          DQ0=(DZ*2-(2*L+1)*ZE(K))*DD+DQ0
        ELSEIF(JRAD(K).EQ.L+1)THEN
          DD2=CJ(K)+DD2
          DQ0=((L*2+1)*ZE(K)-DZ)*2*CJ(K)+DQ0
        ENDIF
      ENDDO
C
      JRAD(0)=L
      if(myn.le.0)MYL=L-1
      MYN=-1                                                !**** NRB
      CJ(0)=DZERO
      ZE(0)=DZ
C
C TRY  IF(ZE(0).LE.DM*1.1)MYN=-2
C   MODIFY  Z(0) FOR CUSP CORRECTION IF REQUIRED.
C
      DDY=DZERO
      IF(MYN+1.NE.0)THEN
        IF(MYN+1.LT.0)ZE(0)=-MYN*DM
        DD=(DD2-DD1)*L+DZ*DP0
        IF(ABS(DD).LT.D1M5)GO TO 35
        IF(L*ZE(0).LE.DZ)ZE(0)=(DZ+DONE)/L
        CJ(0)=DD/(L*ZE(0)-DZ)
        DP0=CJ(0)+DP0
        DDY=(DZ*2-(2*L+1)*ZE(0))*ZE(0)*CJ(0)+DQ0
      ENDIF
      DQ0=DDY
C
  35  SKREEN=CJ(0)
C      ######   POSSIBLY TEMPORARY, FOR PRINTING C(0) CUSP CORRECTION.
c      DDY=-ZE(0)
      DDY=DZERO
C
      DO K=1,MXORB
        IF(2*MYL.NE.QL(K))GO TO 36
        IF(DEY(K).EQ.DZERO)GO TO 36
        IF(DORIGZ(K).NE.DZERO)GO TO 36
        MYN=MOD(INT(QN(K),SP),I70)
        GO TO 28
  36  ENDDO
C
      WRITE(6,800)
      GO TO 72
C
C COMPUTE SLATER TYPE ORBITAL AT THE INTERNAL GRID POINTS (I=1,MAXRS)
C
  28  MYLLP=MYL*(MYL+1)                       !CASE PSEUDO, NOT X**(L+1)
      DO I=1,MAXRS
        DD1=DX(I)
        J=L
        DD2=DD1**J
        DM=(MYLLP/DD1-2*DZ)/DD1
        DP(I)=DZERO
        DQ(I)=DZERO
        DO K=0,N
          IF(ZE(K)*DD1.LT.CON1)THEN
            IF(JRAD(K).NE.J)DD2=DD1**JRAD(K)
            J=JRAD(K)
            DD=CJ(K)*DD2*EXP(-ZE(K)*DD1)
            DP(I)=DD+DP(I)
            DQ(I)=(((1-J)/DD1+ZE(K)*2)*J/DD1-ZE(K)*ZE(K)+DM)*DD+DQ(I)
          ENDIF
        ENDDO
      ENDDO
C
      J=KEY
      GO TO 34
C
C END OF STO EXTENSION
C-----------------------------------------------------------------------
C
  42  READ(MR5,600,END=79)MYN,MYL,J,N,DDY,SKREEN,MPMX,DP0,DM,MHEAD,MP
C
C A BLANK (P/Q) HEADING CARD SERVES AS A DATA INPUT TERMINATOR.
C
  43  IF(MPMX.LT.0)GO TO 70
      IF(MPMX.EQ.0)GO TO 79
C
C DO 49 PROCESSES A RANDOM ORDERED SET THAT MAY EXCEED BUFFER SIZES.
C
      DO 49 I=1,MPMX,2
C
        READ(MR5,600)L,L,L,I1,DD1,DD,I2,DD2,DM
C
        I2=I1+1
        IF(J.NE.-9)GO TO 46
        IF(I1.GT.MXP)GO TO 49
        IF(I1.EQ.MXP)GO TO 45
        DY(I2)=DD2
        DH(I2)=DM
  45    DY(I1)=DD1
        DH(I1)=DD
        GO TO 49
  46    IF(I1.GT.MXP)GO TO 49
        IF(I1.EQ.MXP)GO TO 48
        DP(I2)=DD2
        DQ(I2)=DM
  48    DP(I1)=DD1
        DQ(I1)=DD
  49  CONTINUE
C
      IF(DP0.EQ.DZERO.AND.DY(1).GT.DZERO)DP0=DP(1)/DY(1)**(MYL+1)
      IF(DDY.GT.DZERO)WRITE(6,996)DDY
C
  14  IF(NF.LE.0)GO TO 72
      IF(MXQIN.EQ.1)GO TO 72
      IPMX=MIN(MPMX,MXP)
      IF(J.EQ.-9)GO TO 41
C     IF(N.LE.-MPSEUD)GO TO 72 ! POTENTIAL DERIVATIVE
      IF(MPSEUD.LT.0.AND.N.LE.ABS(MPSEUD))GO TO 72 !CASE N=0 & MPSEUD=0
C REQUIRES A CONSISTENT ORBITAL NUMBER BE READ-IN.
      IF(KEY.NE.-20)THEN
        L=MPMX-IPMX
        IF(MPMX.GT.MXP+1)WRITE(6,580)L,MPMX,MXPIN,MXP,DY(IPMX),DP(IPMX)
      ENDIF
C
  34  II=MAXRS-2
      IF(BPRNT)WRITE(6,100)DDY,MHEAD,MP, MYN,MYL
      IF(KEY.NE.-20.AND.DDY.EQ.DZERO)DDY=-D1M10
      IF(MPSEUD.GT.0.AND.N.LE.MPSEUD)GO TO 69 ! DITTO N=0
C
      DO K=1,MXORB
        IF(2*MYL.NE.QL(K))GO TO 68
        IF(DORIGZ(K).NE.DZERO)GO TO 68
        IF(DEY(K).EQ.DZERO)GO TO 68
C       IF(K.LE.ABS(MPSEUD))GO TO 68
        N=K
        IF(N.LT.K00)K00=N
        MQN=MOD(INT(QN(K),SP),I70)
        IF(MQN.NE.ABS(MYN))THEN
c          if(mqn.gt.myl)go to 68 !trust n-label, but dangerous for KCOR
          WRITE(6,940)K,MYN
          WRITE(0,941)MYL,K,MQN,MYN
C          GO TO 99
        ENDIF
        IF(QN(K).LT.80.AND.QN(K).GT.69)QN(K)=ABS(MYN)
        IF(KEY.GE.0.AND.JPRINT.NE.-3)WRITE(6,995)QN(N),MYL
        IF(DDY.LT. DZERO)GO TO 69
        QN(N)=-QN(N)
        IYY(N)=1
        IYY(IEQ(N))=1                       !CASE NOT IN GROUP 1
        DYY(NREL)=DDY
C N.B.DYY CONTAINS INTERPOLATION ENERGIES. PROGRAM ASSUMES SAME
C     INTERPOLATION ENERGY FOR EACH CONTINUUM ORBITAL.
        GO TO 69
  68  ENDDO
C
      WRITE(6,800)
      WRITE(0,801)MYN,MYL
      GO TO 72
C
  69  IF(DP0.NE.DZERO)GO TO 60
      DP0=DP(1)
      DP(1)=DZERO
      DQ(1)=DZERO
C
C ALLOW FOR CONTINUUM ELECTRON WITH ZERO ENERGY
C NEW IF(DP(IPMX).EQ.DZERO)  IPMX=IPMX-1
C LAGRANGE INTERPOLATION (ID+1 POINTS) FROM ARGUMENTS DY TO DX(L)
C FOR E>=0 FUNCTION VALUES BEYOND THE SUPPLIED AND HELD RANGE ARE SET =0
C FOR E<0  THE FUNCTION VALUES ARE EXTENDED USING ASYMPTOTIC FORMS
C
  60  LM=MAXRS
      DO L=1,MAXRS
        DD1=DP(L)
        DD2=DQ(L)
        DD3=DZERO
        IF(NSTO.NE.0)GO TO 74
        DD1=DZERO
        DD2=DZERO
        IF(DX(L).GT.DY(IPMX))THEN                       !BEYOND SUPPLIED
          IF(DDY.GE.DZERO)GO TO 74
          LM=L-1
          TE=SQRT(-DDY)
          TXM=DX(LM)
          DPNORM=DPNL(LM,N)
          IF(L.LE.MXQIN)THEN
            IF(DPNORM.EQ.DZERO)THEN
              DQNORM=DZERO
            ELSE
              DQNORM=DQNL(LM,N)/DPNORM-DDY
              DQNORM=DQNORM*TXM                         !=-2*MION
            ENDIF
          ENDIF
          DD3=POTHAM(LM)*TXM
          GO TO 75
        ENDIF
C
        M=KHLP(L)-ID/2
        I1=MAX(M,IONE)
        I2=I1+ID
        IF(I2.GT.IPMX)I2=IPMX
        DO I=I1,I2
          DD=DONE
          DM=DONE
          DO J=I1,I2
            IF(J.NE.I)THEN
              DM=(DX(L)-DY(J))*DM
              DD=(DY(I)-DY(J))*DD
            ENDIF
          ENDDO
          DD1=DP(I)*DM/DD+DD1
          DD2=DQ(I)*DM/DD+DD2
          DD3=DH(I)*DM/DD+DD3
        ENDDO
        J=KHLP(L)
        IF(MP.GT.0)WRITE(6,999)L,DX(L),J,I1,I2,DY(J),DD1
C
   74   IF(ABS(DD1).LT.D1M70)THEN
          IF(DD1.NE.DZERO)DD2=DD2/DD1
          DD1=SIGN(D1M70,DD1)
          DD2=DD2*DD1
        ENDIF
        DPNL(L,N)=DD1
        IF(L.LE.MXQIN)DQNL(L,N)=DD2
        POTHAM(L)=DD3/DX(L)
        IF(ABS(DD1).GT.D1M6)MAXPS=MAX(MAXPS,L)
      ENDDO
C
C EXTEND BOUND FUNCTIONS
C
  75  DO L=LM+1,MAXRS
        TXL=DX(L)
        T=TXL-TXM
        DD1=DPNORM*EXP(-TE*T)
        IF(ABS(DD1).LT.D1M70)DD1=SIGN(D1M70,DD1)
        DPNL(L,N)=DD1
        IF(L.LE.MXQIN)THEN
          DD2=DQNORM/TXL+DDY
          DQNL(L,N)=DD2*DD1
        ENDIF
        POTHAM(L)=DD3/TXL
        IF(ABS(DD1).GT.D1M6)MAXPS=MAX(MAXPS,L)
      ENDDO
C
      DD3=DZERO
      DORIG(N)=DP0
      DORIGZ(N)=DP0*DZ
      IF(N.LE.MPSEUD)GO TO 72                 ! BLUME  & WATSON
C     IF(MPSEUD.GT.0.AND.N.LE.MPSEUD)GO TO 72  ! BLUME & WATSON
C
C GENERATE A Q-FUNCTION INTERNALLY IF NONE SUPPLIED (KEY=-15)
C E.G. IF INPUT FROM GRASP.
C
      IF(KEY0.EQ.-15)THEN
        DTOL=D1M2
        TOL=D1M7
        MPP=1
        IORT=ABS(MORT)
        DHNS0=DHNS(1)
        DJ=DADJUS(N)
        DJ0=DJ
        MK=N
        NELC=MION                 !-MRED
        DS=DZ
        IF(DJ.GT.DZERO)  GO TO 611
        IF(IORT.EQ.2)GO TO 611
        IF(BREL)GO TO 611
C
        IF(IORT.LT.4)DS=-DJ*DZ                !HYDROGENIC WAVE FUNCTIONS
        IF(IORT.EQ.4)DS=-QN(MK)*(NZION-NELC+1)*DJ/DTWO    !PSEUDO-STATES
        IF(IORT.EQ.5)DS=-(NZION-NELC+1)*DJ              !BOX-STATE BASIS
C
        NELC=1
        DJ0=DONE
C
 611    IF(.NOT.BSTO)CALL TFDAPO(DS,NELC,MK,DJ0,DONE,DONE,DHNS0,MAXRS
     X                    ,MJH,MNH,DHNS,DX,DWRK1,TOL,MEND,CRRCT1,CRRCT2)
        IF(BSTO)CALL STOPOT(DS,NELC,MK,DJ0,DHNS0,MAXRS,MJH,MNH,DHNS,DX
     X                     ,DWRK1,DTOL,MEND,MPP)
C
        IF(DHNS(1).NE.DHNS0)THEN
          WRITE(6,*)'***ERROR SR.RADWIN: UNABLE TO DETERMINE POTENTIAL',
     X              ' INTERNALLY...'
          WRITE(0,*)'***ERROR SR.RADWIN: UNABLE TO DETERMINE POTENTIAL',
     X              ' INTERNALLY...'
          GO TO 99
        ENDIF
C
        IF(MPP.EQ.1)THEN
          IF(BORT)THEN
            IF(.NOT.BSTO)WRITE(6,774)QN(MK),MYL,DJ,MEND,DX(MEND)
            IF(BSTO)WRITE(6,775)QN(K),MYL,MCFSTO(MK),DJ,MEND,DX(MEND)
          ELSE
            IF(.NOT.BSTO)WRITE(6,776)MYL,DJ,MEND,DX(MEND)
            IF(BSTO)WRITE(6,777)MYL,DJ,MEND,DX(MEND)
          ENDIF
        ENDIF
        DO I=1,MAXRS
          DQNL(I,N)=DPNL(I,N)*((DWRK1(I)-DZ/DX(I))*DTWO+DDY)   !DDY(RYD)
        ENDDO
      ENDIF
C
C ORTHONORMALIZE (SCHMIDT PROCEDURE DO63, NORMALIZATION DO64-65)
C ONLY ATTEMPT TO ORTHOG TO FUNCTIONS K .LT. N IF BORT TRUE
C
      K0=MXORB
 153  IF(BORT)THEN
        K0=N
        IF(MORT.EQ.-3.AND.IRLX.NE.2)KST=N+1
      ENDIF
c      DD=DZERO
C
      DO K=KST,K0
C
        DD=DZERO     !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
C
        IF(QL(N).NE.QL(K))  GO TO 63
        IF(SCREEN(K).GE.D999)GO TO 63
        IF(DEY(K).EQ.DZERO)GO TO 63
C       IF(K.LE.ABS(MPSEUD))GO TO 63
        IF(QN(K).LT.0)GO TO 63      !AVOID TRYING TO ORTHOG TO CONTINUUM
        IF(MORT.LT.0.AND.N.NE.K.AND.QN(N).EQ.QN(K))GO TO 63  !FOR SAFETY
C        IF(MORT.LE.-4.AND.N.NE.K.AND.QN(N).EQ.QN(K))GO TO 63   !BOX/LPS
C
        DO I=1,MAXPS
          DWRK1(I)=DPNL(I,K)*DPNL(I,N)
        ENDDO
C
        CALL WEDDLE(DZERO,DWRK1,DD,MNH,DHNS,MJH,MAXPS)
C
        IF(K.LT.N)THEN
          L1=N
          L2=K
        ELSE
          L1=K
          L2=N
        ENDIF
C
        IF(JPRINT.NE.-3)WRITE(6,960)QN(L1),MYL,QN(L2),MYL,DD
C
        IF(MORT.LE.-4)THEN                 !BOX/LPS
          IF(IVAL(L1).EQ.1)THEN
            NN=QN(L2)
            IF(DADJUS(L2).LT.DZERO)NN=-NN
            WRITE(16,795)QL(L1)/2,QN(L1),NN,DD
            IF(QN(L1).LE.NN)THEN
              WRITE(6,764)L1,QN(L1),NN,L2
C              GO TO 99                    !ERROR: VALENCE N .LE. CORE N
              DD=DZERO
              GO TO 63
            ENDIF
            IF(DADJUS(L2).LT.DZERO)GO TO 63
C         ELSE
C           IF(DADJUS(L1)*DADJUS(L2).LT.DZERO)THEN
C             NN=QN(L1)
C             IF(DADJUS(L1).LT.DZERO)NN=-NN
C             WRITE(16,795)QL(L2)/2,QN(L2),NN,DD
C           ENDIF
          ENDIF
        ENDIF
C
        IF(IRLX.EQ.2)THEN
          KK=((L1-1)*(L1-2))/2+L2
          OVLPGR(KK)=DD
          GO TO 63
        ENDIF
C
        DO I=1,MAXRS
          IF(I.LE.MXQIN)DQNL(I,L1)=DQNL(I,L1)-DD*DQNL(I,L2)
          DPNL(I,L1)=DPNL(I,L1)-DD*DPNL(I,L2)
        ENDDO
C
        DORIG(L1)=DORIG(L1)-DD*DORIG(L2)
C
  63    DOVLP(K)=DD
C
C       DD3=DZERO FOR MODES 1&2,=SUM OVERLAP**2 FOR MODE GT 3(CONTINUUM)
        IF(K.LT.N.AND.QN(N).LT.0.AND.MODE.GT.2)DD3=DD3+DD*DD
C
      ENDDO                                                          !63
C
C
CTEST WRITE(6,100) DDY,M,MP, MYN,MYL
C
C AVOID  RE-NORMALISATION OF CONTINUUM FUNCTION
C
      if(nf.gt.1.and.skreen.eq.dzero.and.ddy.lt.dzero)then
        skreen=dz-sqrt(-qn(n)*ddy)
      endif
c
      SCREEN(N)=SKREEN
C
      DO K=N,K0
C
        IF(QL(N).NE.QL(K))GO TO 86
        IF(SCREEN(K).GE.D999)GO TO 86
        IF(DEY(K).EQ.DZERO)GO TO 86
C       IF(K.LE.ABS(MPSEUD))GO TO 86
        IF(QN(K).LT.0)GO TO 86
        IF(MORT.LT.0.AND.N.NE.K.AND.QN(N).EQ.QN(K))GO TO 86  !FOR SAFETY
C        IF(MORT.LE.-4.AND.N.NE.K.AND.QN(N).EQ.QN(K))GO TO 86   !BOX/LPS
C
C        DM=DONE
C        IF(K.EQ.N.AND.DD.EQ.DZERO)GO TO 15    !ONLY IF INPUT NORMALIZED
C
        DO I=1,MAXPS
          DWRK1(I)=DPNL(I,K)*DPNL(I,K)
        ENDDO
C
        CALL WEDDLE(DZERO,DWRK1,DD,MNH,DHNS,MJH,MAXPS)
C
        IF(DD.LT.OVRLP.AND.NSTO.LE.0)THEN  !IGNORE NEAR-IDENTICAL FUNCTN
          WRITE(6,700)OVRLP
          GO TO 72
        ENDIF
C
        DM=DONE/SQRT(DD)
C
C THIS TEST IS ALSO SUPRESSED IN THE ORIGINAL VERSION OF SS.
C IF(DORIG(K).LT.DZERO)DM=-DM   !EVENTUALLY POSITIVE SLOPE AT ORIGIN R=0
C
C  15    CONTINUE
C
        DO M=1,MAXRS
          DD1=DM*DPNL(M,K)
          IF(ABS(DD1).GT.D1M6)MAXPS=MAX(M,MAXPS)
C                        =DEL
          IF(I.LE.MXQIN)DQNL(M,K)=DM*DQNL(M,K)
          DPNL(M,K)=DD1
        ENDDO
        DORIG(K)=DORIG(K)*DM
C
  86  ENDDO
C
C NOW DETERMINE ONE-BODY ENERGY INTEGRALS
C
      DO K=1,K0
C
        DD2=DZERO    !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
C
        IF(QL(K).NE.QL(N))  GO TO 93                                 !94
        IF(SCREEN(K).GE.D999)GO TO 93                                !94
        IF(DEY(K).EQ.DZERO)GO TO 93                                  !94
C       IF(K.LE.ABS(MPSEUD))GO TO 93                                !94
        IF(QN(K).LT.0.AND.QN(N).LT.0.AND.MODE.LE.2)GO TO 93
C
        DO I=1,MAXPS
          DWRK1(I)=DZERO
          IF(I.LE.MXQIN)THEN
            DWRK1(I)=DQNL(I,N)*DPNL(I,K)
CTEST                         DWRK1(I) =(DPNL(I,K)*DQNL(I,N)+DWRK1(I))/2
            IF(MPSEUD.NE.0)DWRK1(I)=DWRK1(I)+DTWO*DPNL(I,N)*DPNL(I,K)
     X                         *(DZ/DX(I)-POTHAM(I))
          ENDIF
        ENDDO
C
        CALL WEDDLE(DZERO,DWRK1,DD,MNH,DHNS,MJH,MAXPS)
C
        DD2=DD/DTWO
        DD2=DD2*SCALER                   !C.F. COWAN SLATER SCALE FACTOR
C
  93    DUY(N,K)=DD2
        DUY(K,N)=DD2
C
        IF(K.GT.N)THEN
          DE=DEY(K)-DUY(K,K)
          DUY(K,K)=DUY(K,K)-DOVLP(K)*DUY(K,N)*DTWO+DUY(N,N)*DOVLP(K)**2
          DEY(K)=DUY(K,K)+DE
        ENDIF
C
      ENDDO                                                          !94
C
      IF(QN(N).GT.0)THEN
        DUY(N,N)=DUY(N,N)-DDY*SCALER/DTWO
        DEY(N)=DUY(N,N)+DDY/DTWO
C        DM=DONE                           !ONLY IF INPUT NORMALIZED
        IF(IRAD(N).GT.0)GO TO 79
        GO TO 20
      ENDIF
C
      MINK=0
      DD1=-MSHIFT*MINK
      DM=DZERO
      DEY(N)=DUY(N,N)+DD1+DDY*(DONE+DD3)/DTWO
      IF(DEY(N).EQ.DZERO)DEY(N)=D1M10
      DUY(N,N)=DUY(N,N)+DDY*DD3/DTWO
C
  20  IF(BPRNT)WRITE(6,300)N,QN(N),MYL,MION,NZION,SKREEN,MR5,DORIG(N),
     X                     DY(IPMX),DM,(DPNL(I,N),I=II,MAXRS),DEY(N)
      IF(KEY.NE.-10)GO TO 72
C STO
      IF(ABS(DM-DONE).LT.D1M1.OR.INORM.NE.0)GO TO 12
      WRITE(6,950)
      DORIGZ(N)=DZERO
      SCREEN(N)=D3999
      IF(NSTO.LE.0)THEN
        WRITE(6,*)'CONFUSION OVER NORMALIZATION FOR ORBITAL:',N
        WRITE(0,*)'CONFUSION OVER STO/CLEMENTI NORMALIZATION'
        GO TO 99
      ENDIF
      DO J=1,NSTO
        DD=ZE(J)*DTWO
        DO K=1,2*JRAD(J)
          DD=ZE(J)*DD*DTWO/K
        ENDDO
        CJ(J)=SQRT(DD)*CJ(J)
      ENDDO
      N=NSTO
      NSTO=-N
      GO TO 88
C
  79  IF(BORT.and.(MORT.ne.-3.or.IRLX.NE.2))THEN
        KST=K00
        IF(N.GT.0)IRAD(N)=0
C
        DO K57=K00,MXORB
          IF(IRAD(K57).NE.0)THEN
            N=K57
            MYL=QL(N)/2
            DDY=(DEY(N)-DUY(N,N))*DTWO          !EPS(RYD)
            SKREEN=SCREEN(N)
            SCREEN(N)=3999
            GO TO 153                           !RE-ORTHONORMALIZE
          ENDIF
        ENDDO
      ENDIF
C
      IF(NF.LE.0)GO TO 90
C
C CHECK COMPLETENESS OF RADIAL FUNCTION SET
C COMPUTE RELATIVISTIC INTEGRALS (MASS AND DARWIN TERM, EJN-EQ.60)
C
C      MP=MYN
C      IF(MAUTO.EQ.0)GO TO 56       !ALL DONE IN RADCON
C
      MP=0
      DO K=1,MXORB
C
        IF(DEY(K).EQ.DZERO)GO TO 52
C       IF(K.LE.ABS(MPSEUD))GO TO 52
C
        MP=K
        IF(SCREEN(K).LT.D999.or.screen(k).gt.D5999)GO TO 96  !FOR RADCON
        IF(SCREEN(K).NE.D999)THEN
          WRITE(6,980) K
          DEY(K)=DZERO
          NF=-1
          GO TO 52
        ENDIF
        WRITE(6,970) K
  96    IF(NJO.LE.0.AND..NOT.BMVD.or.qn(k).lt.0)GO TO 52
C
        DORIGZ(K)=DORIG(K)*DZ
        DX1=DZERO
        IF(MODE.GT.2.AND.IYY(K).GT.0)DX1=DYY(NREL)
C
        DO L=1,K
C
          DP0=DZERO  !INITIALIZE ALL FOR SAFETY AS NANs CAN BE ALLOCATED
          DD=DZERO
          DM=DZERO
C
          IF(DEY(L).EQ.DZERO)GO TO 54                                !53
C         IF(L.LE.ABS(MPSEUD))GO TO 54                              !53
          IF(QL(K).NE.QL(L))GO TO 54                                 !53
          IF(BREL.AND.NL.LE.NL000)GO TO 54
          IF(MODE.LE.2.AND.(QN(K).LT.0.OR.QN(L).LT.0))GO TO 54
C
          DX2=DZERO
          IF(MODE.GT.2.AND.IYY(L).GT.0)DX2=DYY(NREL)
C
          DO I=1,MAXPS
            DWRK1(I)=DZERO
            DWRK2(I)=DZERO
            IF(I.LE.MXQIN)THEN
              DD3=2*DZ/DX(I)
              DD2=DPNL(I,L)*(DD3+DX2)+DQNL(I,L)
              DD1=DPNL(I,K)
              DWRK1(I)=(DD1*(DD3+DX1)+DQNL(I,K))*DD2
              DWRK2(I)=DD1*DD2
              IF(QN(K).LT.0.AND.QN(L).LT.0)THEN
                DD0=DX2*DPNL(I,L)*DPNL(I,K)
                DWRK1(I)=DWRK1(I)-DX1*DD0
                DWRK2(I)=DWRK2(I)-DD0
              ENDIF
            ENDIF
          ENDDO
C
          CALL WEDDLE(DD,DWRK2,DP0,MNH,DHNS,MJH,MAXPS)
C
          IF(K.EQ.L)DP0=DP0+DX2
          IF(BREL)GO TO 54                                           !53
          IF(QL(K).EQ.0)DD=DORIGZ(K)*DORIGZ(L)
          DD3=DD*DFOUR
C
          CALL WEDDLE(DD3,DWRK1,DM,MNH,DHNS,MJH,MAXPS)
C
          IF(L.EQ.K)DM=DM+DX1*DX2
          DM=-DM*DALF/DEIGHT
          DD=DD*DALF/(DZ*DEIGHT)
C
  54      DMASS(K,L)=DM
          DCD(K,L)=DD
          D2LL(K,L)=DP0                                              !53
C
        ENDDO
C
  52  ENDDO
C
      IF(BREL)THEN
        IF(ABS(IREL).EQ.2)THEN
          DO K=1,MXORB
            IF(DEY(K).NE.DZERO)THEN
              DO I=1,MAXRS
                DQNL(I,K)=DZERO                     !LARGE CPT ONLY READ
              ENDDO
            ENDIF
          ENDDO
C                COULD CONTINUE ZEROED OUT, TBD: ESTIMATE FROM LARGE CPT
          WRITE(6,*)'***SR.RADWIN ERROR: SMALL COMPONENT NOT AVAILABLE!'
          WRITE(0,*)'***SR.RADWIN ERROR: SMALL COMPONENT NOT AVAILABLE!'
          GO TO 99
        ENDIF
      ENDIF
C
C  56  CONTINUE
      IF(BPRNT .AND.II.GT.1)WRITE(6,400)(DX(I),I=II,MAXRS)
      IF(MAXPS.GT.MXQIN)WRITE(6,500)MXQIN,MAXPS,DX(MXQIN)
C
C TERMINATOR CARD (READ AT 72 READ 570/600) ALLOWS TO SPECIFY PRINTOUT
C
      N=MIN(MYN,MP)
      IF(N.GT.0)THEN
        WRITE(6,990)
        M=MIN(MAXPS,MXQIN)
        DO  L=1,M
          WRITE(6,900)L,DX(L),(DPNL(L,I),DQNL(L,I),I=1,N)
        ENDDO
      ENDIF
C
  90  DEALLOCATE (DH,DY,DP,DQ,KHLP)
      DEALLOCATE (DWRK1,DWRK2)
      DEALLOCATE (DOVLP,DORIGZ)
C
      RETURN
C
 1000 WRITE(6,1997)
      WRITE(0,*)'*** SR.RADWIN: ERROR READING NAMELIST SRADWIN!'  !FATAL
      GO TO 99
 1001 WRITE(6,1998)
      WRITE(0,*)'*** SR.RADWIN: ERROR READING radwin FILE!'  !FATAL
C
  99  NF=-1
      GO TO 90
C
C
  100 FORMAT(27X,F13.5,30X,A4,I4,I3,I2)
  101 FORMAT(//' ****WARNING IN SR.RADWIN, YOU ARE ASSUMING ORTHOGONAL'
     X,' ORBITALS, ERRORS MAY ARISE')
  250 FORMAT(/ 'GAM ( N,  L,NION, Z, DEL/PI)    OLDEPS/RY OF RADIAL ',
     X'INPUT-FUNCTIONS',4X, '(ORIGIN  N L)  FNORM, 3 LAST P, <NL!H1!NL>'
     X,';STPS/PTS=',I5,'/',I5)
  300 FORMAT(I3,I4,I4,I4,I4,F9.5,13X,I4,1X,F11.5,F10.3,17X,F8.3,
     X 1X,3E9.2,F12.4)
  400 FORMAT(38X, 'READ("")     PBAR0      RPEND',15X,'3 LAST R:',3F9.4,
     X 4X, ' (H1/2RY)'/)
  500 FORMAT(' SR.RADWIN: P/Q DATA READ WHILE  MAXB2=',I3,' -- SHOULD '
     X,'BE .GE.MAXPS=',I5/12X, 'RESULTS INVOLVING Q(N,L) MAY BE POOR - '
     X,'R(MAXB2)/A0 =',F9.3)
  570 FORMAT(3I5,I3,7X,F12.6,2X,I4,29X,A4,I4)
  580 FORMAT(66X, '**WARNING**   FOR THE FOLLOWING FUNCTION P'/68X,I3,
     X  ' OF THE IPMX=',I4, ' INPUT VALUES P/Q HAVE BEEN IGNORED',/68X,
     X'EITHER BECAUSE BUFFER(MXPIN=',I5, ') CANNOT HOLD THEM'/68X,'OR ',
     X'BECAUSE ARGUMENTS R HAVE BEEN READ IN FOR ONLY MXP=',I4,' POINTS'
     X/68X, '-- CUT-OFF RADIUS ',F6.2, '*A0,  P(RCUT) =',E10.2)
  589 FORMAT(3I5,8X,I5)
  590 FORMAT(2I5,5X,F8.4)
  591 FORMAT(2I2,F10.4,I4,A4,I4)
  592 FORMAT(/'   KEY=',I3,2X,'MODE=',I2,2X,'ACCURACY OF ENERGY'
     X,' CONSERVATION=',F8.4,' A.U.',4X, 'CONTINUUM FUNCTIONS IN USE;'
     X,' MODES 2 TO 3'/)
  593 FORMAT('  YOUR VALUE OF',I3,' FOR MODE IN SR.RADWIN IS NOT'
     X,' WITHIN THE CURRENT VALID RANGE')
  600 FORMAT(I2,I1,I2,2(I4,2E14.7),3X,A4,I4)
  700 FORMAT(84X, 'WILL BE SKIPPED,  OVERLAP .LT.',1PE8.1)
  764 FORMAT(' WARNING: ORBITAL',I3,' HAS VALENCE N=',I3,' .LE. CORE N='
     X,I3,' OF ORBITAL',I3)
  774 FORMAT(23X,'NL =',I3,I2,'    S.M.-POTENTIAL V(NL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  775 FORMAT( 2X,'NL =',I3,I2,'    STO.-POTENTIAL CF=',I3,' WITH SCALE'
     X,' FACTOR',F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC'
     X,' BEYOND R(IEND=',I5,') =',F10.6)
  776 FORMAT(24X,'LL =',I2,',..   S.M.-POTENTIAL V(LL) WITH SCALE'
     X,' FACTOR',F10.5, ';  COULOMBIC BEYOND R(IEND=',I5,') =',F10.6)
  777 FORMAT( 3X,'LL =',I2,',..   STO.-POTENTIAL V(LL) WITH SCALE'
     X,' FACTOR',F10.5,';  NON-COULOMB POT .LT. 1% OF COULOMBIC'
     X,' BEYOND R(IEND=',I5,') =',F10.6)
  795 FORMAT(3I5,1PE13.4)
  800 FORMAT(84X, 'WILL BE SKIPPED,  BECAUSE NO MORE FUNCTIONS ARE'/
     X77X, 'SPECIFIED BY SIGMA.GE.999 & .LT. 5999 FOR THIS ORBITAL L')
  801 FORMAT(' SR.RADWIN: EXTERNAL ORBITAL BEING SKIPPED FOR N L=',2I2)
  900 FORMAT(I5,(7F18.6))
  940 FORMAT(' SR.RADWIN: MIS-MATCH FOR ORBITAL',I3,' FILE N=',I3)
  941 FORMAT(' SR.RADWIN: MIS-MATCH OF L=',I2,' ORBITALS?'/' FOR ORB K='
     X       ,I3,2X,'INTERNAL N=',I2,' WHILE EXTERNAL N=',I2)
  950 FORMAT(' REPEAT SINCE NORM INDICATES CLEMENTI TYPE INPUT FORMAT:')
  960 FORMAT( '       OVERLAP INTEGRAL',4X,I3,I2,' WITH',2I2,' ='
     X,1PE12.4)
  970 FORMAT(61X,"P/Q-INPUT FOR ORBITAL K=",I2," MISSING, S.M. USED - ",
     X"ORBITALS MAY"/89X,"NOT BE ORTHOGONAL TO INPUT-PNL'S WITH SAME L")
  980 FORMAT(61X,'P/Q-INPUT FOR ORBITAL K=',I2,' MISSING (OR MAXB2 TOO'
     X,' SMALL), CASE FAILS')
  990 FORMAT(/  " OPTIONAL PRINTOUT OF  I, R(I), N P(I) AND Q(I)'S:"/)
  995 FORMAT(10X,'NL =',I3,I2,4X,'HARTREE-FOCK FROZEN-CORE P-Q INPUT')
  996 FORMAT(' *****WARNING IN SR.RADWIN, YOU HAVE SPECIFIED A BOUND'
     X,' ORBITAL WITH POSITIVE ENERGY=' ,1PE14.7)
  997 FORMAT(  ' *****WARNING IN SR.RADWIN, YOU HAVE SPECIFIED A'
     X,' CONTINUUM ORBITAL WITH NEGATIVE ENERGY=' ,F10.4)
  998 FORMAT(I5,3F18.6)
  999 FORMAT(5X,I4,E14.7,14X,3I4,2E14.7)
 1997 FORMAT('*** SR.RADWIN: ERROR READING NAMELIST SRADWIN!'/4X,
     X'IF PRESENT, CHECK FOR ILLEGAL OR MISTYPED VARIABLE NAMES')
 1998 FORMAT('*** SR.RADWIN: ERROR/END-OF-FILE READING FILE radwin...')
      END SUBROUTINE RADWIN
C
C                             *******************
C
      SUBROUTINE REDSS(MAM,NAM,QLMC,QBML,QBMS,JYI,JYF,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.REDSS REDUCES THE TARGET SLATER SLATE EXPANSION TO THE MINIMUM
C  REQUIRED BY THE COLLISION PROBLEM (IDW.NE.0).
C  CURRENT OPTIONS:
C     ALL M_S.LT.0, AS USED BY AN IC TARGET, ARE RESTRICTED
C     TO  M_S.GE.-NF+2*(NF/2), FOR A BP COLLISION PROBLEM
C     WITH SOME/ALL TARGET CONFIGS OMITTING 2-BODY FINE STRUCTURE.
C     (NOTE: THE LS PROBLEM HAS ALREADY BEEN RESTRICTED BY SR.VCG.)
C
C  IT CALLS:
C    SR.DISKDC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC,IDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (ID32=32)                               !DISKDC UNIT NOS
      PARAMETER (ID33=33)
C
      INTEGER(EP) MDCF8,MDCFT8
C
      DIMENSION MAM(*),NAM(*),JYI(*),JYF(*)
      DIMENSION QLMC(MAXEL,*),QBML(*),QBMS(*)
C
      COMMON /BASIC/NF,MBASE(11)
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
C
      IF(ABS(MODD).GT.1)RETURN          !SINCE LS COUPLING, DONE IN VCG
C
      IEND=MTGD
      MTGD1=MTGD+1
C
      IF(KUTSSX.NE.-9)THEN               !SET COLLISION 2FS CFGS
        MKT=KUTSSX
        IF(MKT.EQ.-999)MKT=-1
        IF((MKT+3)/2.EQ.1)MKT=1+MKT      !ALIGNS DEFAULT KUTSSX=0 AND -1
        MKT=ABS(MKT)
      ELSE
        RETURN                           !SINCE 2FS ON ALL TARGET CFGS
      ENDIF
C
C INITIALIZE (OPEN) WRITE REDUCED DC ARRAY TO DUMP DSKDMP (UNIT33).
C WILL THEN MOVE BACK TO PERMANENT DISKDC (UNIT32)
C
      BDISK=KUTDSK.LT.KMAX               !USE DISKDC
C
      IF(BDISK)THEN
        MOLD=MDCBUF                      !HOLD OLD BUFFER FOR READS
        MNEW=0                           !DETERMINE REDUCED BUFFER
        CALL DISKDC(ID33,IZERO,IZERO,IZERO,IZERO,IZERO,IZERO)
        IUD=33                                   !POINT TO DSKDMP
        MDCF8=0
        MDCFT8=0
      ENDIF
C
C STRIKE OUT SLATER STATES WITH M_S .LT. MSMIN
C
      MSMIN0=-NF+2*(NF/2)
C
      JM0=0
      LB=JYI(1)-1
      M=0
      K1=0                               !FOR BFAST
C
      DO KF=1,KMAX
C
        BDISK=KF.GT.KUTDSK               !USE DISKDC
C
        IF(KF.GT.MKT)THEN                !CAN RESTRICT
          MSMIN=MSMIN0
        ELSE                             !CANNOT AS 2-FS PRESENT
          MSMIN=-999
        ENDIF
C
        JA=JYI(KF)
        JYI(KF)=LB+1
        JB=JYF(KF)
C
        JM=0
        L=JA-1
C
c                               write(6,*)'kf=',kf
        DO J=JA,JB
C
          I=L+1
          ML=QBML(J)
          MS=QBMS(J)
C
          IF(MS.GE.MSMIN)THEN
C
            L=I
            LB=L-JM0
C
            QBML(LB)=ML
            QBMS(LB)=MS
c                               write(6,*)lb,ms,ml
C
            MAM(J)=LB
C
            DO I=1,NF
              QLMC(I,LB)=QLMC(I,J)
            ENDDO
C
          ELSE
C
            MAM(J)=-1
            JM=JM+1
C
          ENDIF
C
        ENDDO
C
c          write(0,*)' ss reduction for configuration',kf,':',jyf(kf),lb
        JYF(KF)=LB
        JM0=JM0+JM
C
C NOW STRIKE-OUT CORRESPONDING VCC'S
C
        M1=M+1
        N=NTG(KF-1)
        KSL0=KGCF(KF)-KGCF(KF-1)
C
        DO K0=1,KSL0
C
          IF(BDISK)THEN                                        !READ OLD
            MDCBUF=MOLD
            ISTRT=MTGD1
            CALL DISKDC(ID32,ISTRT,IEND,KF,K0,IONE,IZERO)
            IF(IEND.LT.0)GO TO 999
          ENDIF
C
          KTT=NKSL(K0,KF)
C
          IF(BFAST)THEN    !ORIGINAL FAST ACCESS, WITHOUT MEMORY POINTER
C
            DO KT=1,KTT
              N=N+1
              I=JTGD(N)
              JTGD(N)=M-JYI(KF)+1
c                               write(6,*)'n,jd=',n,jtgd(n)
C
              DO J=JA,JB
                IF(MAM(J).GT.0)THEN
                  M=M+1
                  DC(M)=DC(J+I)
c                               write(6,*)j-ja+jyi(kf),j+jd,dc(j+jd)
                ENDIF
              ENDDO
            ENDDO
C
          ELSE                           !MEMORY EFFICIENT OPTION IN USE
C
            DO KT=1,KTT
C
              N=N+1
C
              K2=JTGD(N)                     !absolute end flagged
              IF(K2.LT.0)THEN                !bdisk first so KT=1...
                K2=-K2
                K1=MTGD
              ENDIF
              K1=K1+1
C
c                               write(6,*)'n,jd=',n,m+1
              DO K12=K1,K2
                J=IDC(K12)
                IF(MAM(J).GT.0)THEN
                  M=M+1
                  DC(M)=DC(K12)
                  IDC(M)=MAM(J)
c                               write(6,*)mam(j),m,dc(m)
                ENDIF
              ENDDO
C
              K1=K2
              JTGD(N)=SIGN(M,JTGD(N))
C
            ENDDO
C
          ENDIF
C
          IF(BDISK)THEN                                       !WRITE NEW
            MDCBUF=MNEW
            ISTRT=M1
            IFIN=M
            CALL DISKDC(ID33,ISTRT,IFIN,KF,K0,-IONE,IZERO)
            MNEW=MDCBUF
            M=M1-1
          ENDIF
C
        ENDDO
C
      ENDDO
c                               write(0,*)'total ss reduction:',jbf,lb
c                               write(0,*)'total vcc reduction:',mtgd,m
      MTGD=M
      MTGD1=MTGD+1                      !shouldn't be necess.
C
c                               write(6,*)'lb,mtgd=',lb,mtgd
C
C JUGGLE FILES...
C
      IF(BDISK)THEN
        MDCFT8=MDCFT8+MDCF8               !pick-up final config
        WRITE(6,22)MDCFT8
        IF(KUTDSK.LT.KFBUFF)THEN                      !TBD
          write(0,*)'kutdsk.ge.1000 not yet coded for idw.ne.0'
          write(6,*)'kutdsk.ge.1000 not yet coded for idw.ne.0'
          nf=-1
c note:old mdcbuf2,3 no help since likely will store multiple target slp
c       per total LSP. Ditto, 2FS. So,
c          MDCBUF=MAXDC                    !SINCE UNKNOWN AHEAD OF TIME
c          IF(MDCFT8.LE.MAXDC)THEN
c            M=INT(MDCFT8)
c            MDCBUF=MIN(MDCBUF,MTGD+M)     !FOR SUBSEQUENT ALLOCATE
c          ENDIF
        ELSE
          MDCBUF=MNEW
          MDCBUF=MDCBUF+MDCBUF+MTGD       !SINCE NEED TO HOLD TWO SLICES
c          IF(MDCBUF.GT.MAXDC)THEN        !not poss. since mnew.lt.mold
c            WRITE(6,140)MDCBUF
c            NF=-1
c          ENDIF
        ENDIF
C CLOSE/DELETE DISKDC
        CALL DISKDC(ID32,IZERO,IZERO,IZERO,IZERO,IZERO,IZERO)
c        write(0,*)mold,mdcbuf
      ENDIF
C
 999  IF(IEND.LT.0)NF=-1
C
      RETURN
C
   22 FORMAT(/47X,"TOTAL NUMBER OF VCC'S STORED ON DISK:",I12/)
C
      END SUBROUTINE REDSS
C
C                             *******************
C
      SUBROUTINE RES1(QLMC,MAXEL,DFS,MAM,NAM,IZX)
C
C-----------------------------------------------------------------------
C
C  SR.RES1 CALCULATES THE ALGEBRA OF THE MATRIX ELEMENTS OF THE
C  SPIN-SPIN MUTUAL SPIN-ORBIT AND SPIN-OTHER ORBIT INTERACTION
C  BETWEEN A PAIR OF STATES OF THE TYPE !CBSLJ MJ), WHERE C =
C  CONFIGURATION, B=DEGENERACY PARAMETER OF TERM S,L AND J, MJ =
C  TOTAL ANGULAR MOMENTUM AND ITS AZIMUTHAL COMPONENT.
C  ORIGINAL ROUTINE WRITTEN BY MICHAEL JONES,
C  REFERENCES: JONES,M., J.PHYS.B.:ATOM.  MOLEC.PHYS. VOL. 4(1971).
C  ***THIS VERSION EVALUATES THE SLATERSTATE INTERACTIONS ONLY - NRB
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C    FN.VCC
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-6)
      PARAMETER (TTYNY=10*TYNY)
      PARAMETER (FSTYNY=10*TTYNY)
C
      DIMENSION QLMC(MAXEL,*),DFS(*),MAM(*),NAM(*)
      DIMENSION Q1(2,2),Q2(2,2),Q3(2,2),Q4(2,2),VC(2),VK(2,3)
     X         ,JSS(4),IGAM(5),NEN(2,2),NES(2)
C
      COMMON /BASIC/NF,NEK(2),JA,JB,JAP,JBP,MGAP(5)
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /COMRES/DVC12,ICLRS,ICLRR,BLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      COMMON /OUTP1/MPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      ALLOCATABLE :: IGRGR(:)
C
c      MVC(MLX,MLY)=((MLX+2)*MLX/2+MLY)/2+1 !SEE INTRNL FN ABVE END RES1
C
      BPLANT2=MXORB.LT.37
      BSKP=MXLL.EQ.-1
C
      NLS01=NLS00+1
      IF(ICLRR.LT.0)GO TO 400
C
      MXLAM=ABS(MAXLAM)                             !MAX MULTIPOLE VALUE
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      ALLOCATE (IGRGR(MXORB))
C
      DO I=1,MB                                                     !MB0
        IGRGR(I)=I
      ENDDO
C
      KF=NEK(1)
      KG=NEK(2)
C
C      GO TO (101,102,103,104,105,106,107,108),QQCUT
C
      IF(QQCUT.EQ.1)THEN
        BSS=.TRUE.          !101
        BSO=.TRUE.
        BSOO=.TRUE.
      ELSEIF(QQCUT.EQ.2)THEN
        BSS=.FALSE.         !102
        BSO=.TRUE.
        BSOO=.FALSE.
      ELSEIF(QQCUT.EQ.3)THEN
        BSS=.FALSE.         !103
        BSO=.FALSE.
        BSOO=.TRUE.
      ELSEIF(QQCUT.EQ.4)THEN
        BSS=.TRUE.          !104
        BSO=.FALSE.
        BSOO=.FALSE.
      ELSEIF(QQCUT.EQ.5)THEN
        BSS=.FALSE.         !105
        BSO=.FALSE.
        BSOO=.FALSE.
      ELSEIF(QQCUT.EQ.6)THEN
        BSS=.TRUE.          !106
        BSO=.FALSE.
        BSOO=.TRUE.
      ELSEIF(QQCUT.EQ.7)THEN
        BSS=.TRUE.          !107
        BSO=.TRUE.
        BSOO=.FALSE.
      ELSEIF(QQCUT.EQ.8)THEN
        BSS=.FALSE.         !108
        BSO=.TRUE.
        BSOO=.TRUE.
      ENDIF
C
C     IN LOOPS 110,120 SCAN THROUGH SLATER STATES IN INITIAL AND
C     FINAL STATES RESP., AND CALCULATE CONTRIBUTIONS DUE TO EACH PAIR.
C
      DO 110 J1=JA,JB
C
        JC=MAM(J1)
        NES(1)=JC
C
        DO 120 J2=JAP,JBP
C
          JD=NAM(J2)
C
CTHIS NEXT STATEMENT RESOLVES INTERACTIONS BY SLATER STATE
COLD      IRSS00=IRSS+1
C
          DO I=NLS01,NLS
            IORIG2(I)=0
          ENDDO
C
          NES(2)=JD
          NK=0
C
C     NOW COMPARE INITIAL AND FINAL SLATER STATES AND SELECT ONLY THE
C     ONES WHICH DIFFER IN NK=TWO, ONE, OR NO SETS OF QUANTUM NUMBERS
C
          MEN=0
          IF(JD.EQ.JC)GO TO 75
C
C     FIND THE POSITIONS OF THE ELECTRONS WITH DIFFERING QUANTUM NUMBERS
C     STORE THESE IN THE ARRAY NEN
C
          IF(MXORB.GT.MXS2I)THEN                        !MAXGR !UNLIKELY
            WRITE(6,*)'***RES1: INCREASE MXS2I'
            WRITE(0,*)'***RES1: INCREASE MXS2I'
            GO TO 1
          ENDIF
C
          DO I=1,NF
            KB=QLMC(I,JC)
            KA=QCG(I,KF)
            KAC=IEQ(KA)
            DO L=1,NF
              IF(QLMC(L,JD).NE.KB)GO TO 23
              IF(IEQ(QCG(L,KG)).NE.KAC)GO TO 23
              LP=L
              IGRGR(KA)=QCG(L,KG)
              GO TO 22
  23        ENDDO
            NK=NK+1
            IF(NK.GT.2)GO TO 120
            NEN(1,NK)=I
            MEN=I+MEN
            LP=0
  22        QLMC(I,1)=LP
          ENDDO
C
          K=0
          DO L=1,NF
            DO I=1,NF
              IF(QLMC(I,1).EQ.L)GO TO 20
            ENDDO
            K=K+1
            NEN(2,K)=L
            MEN=L+MEN
            IF(K.EQ.NK)GO TO 75
  20      ENDDO
C
  75      II=0
 240      II=II+1
          IF(II.GT.NF)GO TO 13
          IF(NK.EQ.1.AND.II.EQ.NEN(1,1))GO TO 240
          KK=0
 250      KK=KK+1
          IF(KK.GE.II.AND.NK.EQ.0)GO TO 240
C
C     THE ELECTRON LABELLED BY (K1,K2) BELONGS TO THE CONFIGURATION KX
C     AND TO THE SLATER STATE KY. K1=NO. OF ELECTRON WITHIN A PAIR AND
C     K2=NO. OF PAIR.
C
          IMT=0
          DO K2=1,2
            KP=II
            IF(NK.EQ.0.AND.K2.EQ.2) KP=KK
            DO K1=1,2
C
              NI=K1
              IF(NK-1.LT.0)GO TO 752
              IF(NK-1.GT.0)GO TO 754
              IF(K2.EQ.1)GO TO 754
              NI=1
              GO TO 752
C
 754          KP=NEN(K1,K2)
 752          KX=NEK(NI)
              KY=NES(NI)
C              WRITE(0,*)KP
C              IF(KP.LE.0)THEN
C                WRITE(0,*)'KP.LE.0'
C                NF=-1
C                GO TO 999
C              ENDIF
              IH=QCG(KP,KX)
              IF(QN(IH).GE.90)IMT=IMT+1
              IF(IMT.GT.1)GO TO 14
              MU=QLMC(KP,KY)
              ML=((100+MU)/2)*2-100
              Q1(K1,K2)=QL(IH)
              Q2(K1,K2)=IH
              Q3(K1,K2)=ML
              Q4(K1,K2)=(MU-ML)*2-1
C
            ENDDO
          ENDDO
C
          IF(NK.EQ.1)Q2(2,2)=IGRGR(Q2(2,2))
C
C INITIALIZE DATA FOR LAMBDA-LOOP
C
          VK(1,2)=DZERO
          VK(1,3)=DZERO
          VK(2,2)=DZERO
          VK(2,3)=DZERO
          DV2=DZERO
          DV3=DZERO
          NI=0
          KC=0
  78      KB=0
C
 265      L1=Q1(1,1+KC)
          L2=Q1(1,2-KC)
          IF(L1+L2.EQ.0)GO TO 14
          L3=Q1(2,1+KB)
          L4=Q1(2,2-KB)
          IF(L3+L4.EQ.0)GO TO 14
C
          MU=MIN(L1+L3,L2+L4,ITWO*MXLAM)          !MAX LAM
          MLAM2=MAX(ABS(L1-L3),ABS(L2-L4))        !MIN LAM
          MU=MIN(MU,MLAM2+IFOUR*NMULT)            !LIMIT NUMBER
          MLAM0=MLAM2-4
          IF(MLAM2.GT.0)MLAM2=MLAM0
          MLAM0=MLAM0-4              !FIX SPIN-SPIN NRB FROM PETE FEB 90
          IF(MLAM2.GT.MU)GO TO 76
C
          JSS(1+KC)=Q2(1,1)
          JSS(2-KC)=Q2(1,2)
          JSS(3+KB)=Q2(2,1)
          JSS(4-KB)=Q2(2,2)
          ML1=Q3(1,1+KC)
          ML2=Q3(1,2-KC)
          ML3=Q3(2,1+KB)
          ML4=Q3(2,2-KB)
C
COLD      BLOGJ=JSS(2).LE.JSS(1).OR.JSS(3).NE.JSS(2).OR.JSS(4).NE.JSS(1)
COLD         =FALSE  FOR EXPLOITING  N(B,A;A,B)=N(A,B;B,A) WHEN B.LT.A.
C
          DSJ=SQRT(REAL((L1+1)*(L2+1)*(L3+1)*(L4+1),WP))
     X    *REAL(MOD(ABS((KB+KC+MEN)*2+MLAM2-ML1-ML2),IFOUR)-1,WP)*DVC12
C
          BSPN=.FALSE.
          IF(BSKP)GO TO 267
C
          MDIFF1=ML1-ML3
          MDIFF2=ML2-ML4
          NI=MIN(ABS(MDIFF1),ABS(MDIFF2))
C
          M1=Q4(1,1+KC)
          M2=Q4(1,2-KC)
          M3=Q4(2,1+KB)
          M4=Q4(2,2-KB)
          MD1=M1-M3
          MD2=M2-M4
          MST=MD1+MD2
C
          DV1=VCC(IONE,ITWO,IONE,M3,MD1,M1,DFS)
          DV2=VCC(IONE,ITWO,IONE,M4,MD2,M2,DFS)
C
C SPIN-SPIN
C
          DD1=DZERO
          IF(BSS)DD1=-VCC(ITWO,ITWO,IFOUR,MD1,MD2,MST,DFS)
     X               *DV1*DV2*DTHREE/(DTWO*SQRT(DFIVE))
C
          M1=MVC(L1,-ML1)
          M2=MVC(L2,-ML2)
          M3=MVC(L3,ML3)
          M4=MVC(L4,ML4)
C
          DDR1=DZERO
          DDR2=DZERO
          IF(MD1*MD2.NE.0)BSPN=.TRUE.
          IF(MD2.EQ.0)THEN
            IF(BSO)DDR1=DV1
            IF(BSOO)DDR2=DV1+DV1
          ENDIF
          IF(MD1.EQ.0)THEN
            IF(BSOO)DDR1=DV2+DV2+DDR1
            IF(BSO)DDR2=DV2+DDR2
          ENDIF
C
C      ----- BEGIN OF LAMBDA-LOOP (INNER LOOP)
C
 267      MLAM=MLAM2
          IF(MLAM.GT.MU)GO TO 76
C
          DSJ=-DSJ
  40      MLAM2=MLAM0+2
          MLAM1=MLAM2+2
C
          VK(1,1)=VK(1,2)
          VK(1,2)=VK(1,3)
          VK(2,1)=VK(2,2)
          VK(2,2)=VK(2,3)
          VK(1,3)=DZERO
          VK(2,3)=DZERO
          DV1=DV2
          DV2=DV3
          DV3=DZERO
C
          IF(MLAM1.LT.NI)GO TO 59
          BLMM=MOD(MU-MLAM0,IFOUR).NE.0
          IF(BLMM)GO TO 59
C
          BLH=L1+L3.LT.MLAM1
          BLN=L2+L4.LT.MLAM1
          BLK=MLAM0.LT.0 .OR. MLAM0.NE.MLAM
          DD=DONE
C
          IF(BSKP)GO TO 59
C
C THE N-CASE MLAM=-2 (AND ALSO MLAM0.LT.MLAM)
C
          KP=MLAM1/4
          K1=KP+1
          IF(.NOT.BVC)THEN
            IF(L1.GT.MXLL)GO TO 42
            IF(L3.GT.MXLL)GO TO 42
          ENDIF
          IF(.NOT.BLK)THEN
            VC(1)=VCB(M1,M3,KP)
            IF(BLH)GO TO 53
          ENDIF
          VK(1,3)=VCA(M1,M3,K1)
          GO TO 53
C
  42      IF(.NOT.BLK)THEN
            VC(1)=VCC(L1,L3,MLAM0,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L1,L3,MLAM2,-ML1,ML3,-MDIFF1,DFS)
            IF(BLH)GO TO 53
          ENDIF
          VK(1,3)=VCC(L1,L3,MLAM1,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L1,L3,MLAM1,-ML1,ML3,-MDIFF1,DFS)
     X           /REAL(MLAM1+1,WP)
C
  53      IF(.NOT.BVC)THEN
            IF(L2.GT.MXLL)GO TO 45
            IF(L4.GT.MXLL)GO TO 45
          ENDIF
          IF(.NOT.BLK)THEN
            VC(2)=VCB(M2,M4,KP)
            IF(BLN)GO TO 59
          ENDIF
          VK(2,3)=VCA(M2,M4,K1)
          GO TO 46
C
  45      IF(.NOT.BLK)THEN
            VC(2)=VCC(L2,L4,MLAM0,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L2,L4,MLAM2,-ML2,ML4,-MDIFF2,DFS)
            IF(BLN)GO TO 59
          ENDIF
          VK(2,3)=VCC(L2,L4,MLAM1,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L2,L4,MLAM1,-ML2,ML4,-MDIFF2,DFS)
     X           /REAL(MLAM1+1,WP)
C
  46      IF(.NOT.BLH)DV3=VK(1,3)*VK(2,3)
     X               *VCC(MLAM1,MLAM1,ITWO,MDIFF1,MDIFF2,-MST,DFS)
C
  59      MLAM0=MLAM2
          IF(MLAM0.LE.MLAM)GO TO 40
          IF(MLAM1.LT.NI)GO TO 267                          !NEXT LAMBDA
C
C NOW MLAM2=MLAM+2
C AND MLAM1=MLAM+4
C
          IF(BLMM)GO TO 60
          DDR=DZERO
          ML=MLAM+200
          IF(BLK)GO TO 66
          IF(ABS(L4-L2).GT.MLAM)GO TO 64
          IF(BLH)GO TO 62
          IF(BSKP)GO TO 70
C
C     FOLLOWING STATEMENT: SPIN-SPIN; THEREAFTER: MUTUAL SPIN-ORBIT.
C
          DDR=SQRT(REAL((MLAM+5)*MLAM1*(MLAM+3)*MLAM2*(MLAM+1),WP))*DD1
     X       *VCC(MLAM1,MLAM,IFOUR,MDIFF1,MDIFF2,-MST,DFS)
     X       *VK(1,3)*VK(2,1)
C
          IF(BSPN)  GO TO 68
C
          MD2=(MLAM2-L4+L2)*(MLAM2-L2+L4)*(L2-MLAM+L4)
          IF(MD2.EQ.0)  GO TO 62
CORWE IF(MLAM2.LT.ABS(L2-L4))GO TO 4503-*4502
C
C 2ND V2
C
          DDR=DDR-VCC(MLAM1,MLAM2,ITWO,MDIFF1,MDIFF2,-MST,DFS)
     X       *SQRT(REAL((MLAM1+L2+L4)*(MLAM+5)*MD2,WP)
     X       /REAL((MLAM+1)*MLAM1*32,WP))*DDR2*VC(2)*VK(1,3)
C
  62      IF(BSPN)GO TO 267
          IF(ABS(L3-L1).GT.MLAM)GO TO 64
          MD1=(MLAM2-L3+L1)*(MLAM2-L1+L3)*(L3-MLAM+L1)
          IF(MD1.EQ.0)GO TO 63
          IF(BSKP)GO TO 70
C
C 1ST V2
C
          DDR=SQRT(REAL((MLAM1+L1+L3)*MD1,WP)/(32*MLAM2))*VC(1)*VK(2,1)
     X       *DDR1*VCC(MLAM2,MLAM,ITWO,MDIFF1,MDIFF2,-MST,DFS)+DDR
C
  63      IF(MLAM.EQ.0)GO TO 64
          IF(BSKP)GO TO 70
C
C**********************************************************************
C 1ST V3  , POS SIGN IN 1ST AND 2ND V3 GIVE M.JONES TABLE 2 -WERNER
C          , HOWEVER THEY DO NOT GIVE SAME RESULTS FOR CLOSED SHELL
C          , WHEN TREATED AS OPEN (2-BODY F.S.) AS CLOSED (BLUME-WATSON)
C          , SO STAY WITH MINUS FOR NOW. - NRB
C**********************************************************************
C
          DDR=DDR-SQRT(REAL((MLAM+1)*MLAM,WP)/REAL(64*MLAM2,WP))
     X       *REAL((L1*(L1+2)-L3*(L3+2)-MLAM*MLAM2),WP)*DDR1*DV1
C
  64      IF(BLH)GO TO 68
          IF(BLN)GO TO 68
  66      IF(BSPN)GO TO 267
          IF(BSKP)GO TO 70
C
C**********************************************************************
C 2ND V3  , POS SIGN IN 1ST AND 2ND V3 GIVE M.JONES TABLE 2 -WERNER
C          , HOWEVER THEY DO NOT GIVE SAME RESULTS FOR CLOSED SHELL
C          , WHEN TREATED AS OPEN (2-BODY F.S.) AS CLOSED (BLUME-WATSON)
C          , SO STAY WITH MINUS FOR NOW. - NRB
C**********************************************************************
C
          DDR=DDR-DDR2*DV3
     X       *SQRT(REAL((MLAM+5)*(MLAM+6),WP)/REAL(64*MLAM1,WP))
     X       *REAL((L2*(L2+2)-L4*(L4+2)-(MLAM+6)*MLAM1),WP)
C
  68      DD=DDR*DSJ
          GO TO 69
C
  60      IF(BSPN)GO TO 267                                 !NEXT LAMBDA
          ML=MLAM+100
          IF(BSKP)GO TO 70
C
          DD=SQRT(REAL(((MLAM+3)*MLAM2*MLAM1)/4,WP))*DV2*DDR1*DSJ
  69      IF(ABS(DD).LT.TTYNY)GO TO 267                     !NEXT LAMBDA
C
  70      IGAM(5)=ML
C
C IMPOSE V(AB;CD)=V(AD;CB)
C IMPOSE N(AB;CD)=N(AD;CB)=N(CD;AB)=N(CB;AD)
C BY WAY OF FALLING ORDER - NRB
C
          IF(BLMM)THEN
            DO K1=1,3,2
              IGAM(K1)=JSS(K1)
            ENDDO
            K11=2
          ELSE
            K11=1
          ENDIF
          DO K1=K11,2
            IF(JSS(K1).LT.JSS(K1+2))THEN
              KP=2
              JP=0
            ELSE
              KP=0
              JP=2
            ENDIF
            IGAM(K1)=JSS(K1+KP)
            IGAM(K1+KP+JP)=JSS(K1+JP)
          ENDDO
c
c test suppress falling-order
c          do j=1,4
c            igam(j)=jss(j)
c          enddo
COLD
C          DO K1=1,4
C            KP=K1
C            IF(.NOT.BLMM.AND..NOT.BLOGJ)THEN
C              KP=K1-2
C              IF(KP.LE.0)KP=K1+2
C            ENDIF
C            IGAM(K1)=JSS(KP)
C          ENDDO
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
          IF(BPLANT2)IPLANT=IGAM(5)+
     X    ((((IGAM(4)*MXORB+IGAM(3))*MXORB+IGAM(2))*MXORB)+IGAM(1))*1000
c
c test - exclude "core"
c          imt=0
c          do i=1,4
c            if(qn(igam(i)).lt.80)imt=imt+1
c          enddo
c          if(imt.gt.2)go to 267
C
          DO J=NLS01,NLS
            IF(.NOT.BPLANT2)THEN
              DO I=5,1,-1                                    !1,5 SLOWER
                IF(QSSS(I,J).NE.IGAM(I))GO TO 272
              ENDDO
            ELSE
              IF(IPLANT.NE.JORIG2(J))GO TO 272
            ENDIF
            L=J
            I=IORIG2(L)
            IF(I.GT.0)THEN
              DSSS(I)=DSSS(I)+DD
              GO TO 267                                     !NEXT LAMBDA
            ENDIF
            GO TO 301
 272      ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
          L=NLS+1
          IF(L.GT.IXS2I)THEN                                    !GO TO 1
C
            IXXX=7*(IXS2I/5+1)
C
            WRITE(6,*)'*** RES1: increasing MXS2I from ',IXS2I,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RES1: increasing MXS2I from ',IXS2I,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QSSS,IONE,IFIVE,IONE,IXS2I,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES1: REALLOCATION FAILS FOR QSSS'
              NF=0
              GO TO 1
            ENDIF
C
            IXXX0=MAX(IXS2I,IAXMI)
            IXXX2=MAX(IXXX,IAXMI)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
            CALL RE_ALLOC(JORIG2,IONE,IXS2I,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES1: REALLOCATION FAILS FOR IORIG2,JORIG2'
              NF=0
              GO TO 1
            ENDIF
C
            IXS2I=IXXX
C
          ENDIF
C
          NLS=L
          DO I=1,5
            QSSS(I,L)=IGAM(I)
          ENDDO
          IF(BPLANT2)JORIG2(L)=IPLANT
C
 301      IRSS=IRSS+1
          IF(IRSS.GT.IXS2C)THEN                                 !GO TO 1
C
            IXXX=7*(IXS2C/5+1)
C
            WRITE(6,*)'*** RES1: increasing MXS2C from ',IXS2C,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RES1: increasing MXS2C from ',IXS2C,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DSSS,IONE,IXS2C,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES1: REALLOCATION FAILS FOR DSSS'
              NF=0
              GO TO 1
            ENDIF
C
            CALL RE_ALLOC(MSSS,IONE,IXS2C,IXXX,IERR)
            CALL RE_ALLOC(NSTJ2,IONE,IXS2C,IXXX,IERR)
            CALL RE_ALLOC(NSTJ2D,IONE,IXS2C,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES1: REALLOCATION FAILS FOR MSSS,NSTJ2'
              NF=0
              GO TO 1
            ENDIF
C
            IXS2C=IXXX
C
          ENDIF
C
          IORIG2(L)=IRSS
          MSSS(IRSS)=L
          DSSS(IRSS)=DD
          NSTJ2(IRSS)=JC
          NSTJ2D(IRSS)=JD
C
          GO TO 267                  !NEXT LAMBDA
C
C       ----- END OF LAMBDA-LOOP
C
  76      IF(KB.NE.0)THEN
            IF(KC.NE.0)GO TO 78
            KC=1
            GO TO 265
          ENDIF
          KB=1
          IF(KC.EQ.0)GO TO 265
  14      IF(NK-1.LT.0)GO TO 250
          IF(NK-1.EQ.0)GO TO 240
  13      CONTINUE
C
 120    ENDDO                 !END SCAN OF INITIAL SLATER STATES
C
 110  ENDDO                 !END SCAN OF FINAL SLATER STATES
C
C
      IF(BLX)GO TO 999                                  !RETURN
C
C     ELIMINATE COEFFICIENTS /DSSS/.LT.TYNY AND ARGUMENTS QSSS THAT HAVE
C     BEEN LISTED BEFORE IN THE REFERENCE LIST
C
 400  ICLRR=0
      IF(IRSS.LT.IRSS0)GO TO 999                        !RETURN, AS NONE
C
      K=IRSS0-1
      KP=0
      DO I=NLS01,NLS
        IORIG2(I)=0
      ENDDO
C
      DO I=IRSS0,IRSS
        JD0=MSSS(I)
        JD=ABS(JD0)
        IF(ABS(DSSS(I)).LT.FSTYNY)THEN
          IF(IORIG2(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QSSS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
        K=K+1
        DSSS(K)=DSSS(I)
        NSTJ2(K)=NSTJ2(I)
        NSTJ2D(K)=NSTJ2D(I)
C
  94    IF(JD.LE.NLS00)THEN
          WRITE(6,*)'RES1: INFORM NRB OF STOP HERE'
          WRITE(0,*)'RES1: INFORM NRB OF STOP HERE'
          NF=-1
          GO TO 999
C        LP=JD
C        GO TO 92
        ENDIF
C
        IF(IORIG2(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,NLS00
            DO J=1,5
              IF(QSSS(J,JD).NE.QSSS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG2(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG2(JD)
          GO TO 92
        ENDIF
C
        IORIG2(JD)=LP
        DO J=1,5
          QSSS(J,LP)=QSSS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          MSSS(K)=LP
C          IF(JD0.LT.0)MSSS(K)=-MSSS(K)
        ENDIF
C
  91  ENDDO
C
      NLS=NLS-KP
      IRSS=K
C
 999  IF(ALLOCATED(IGRGR))DEALLOCATE (IGRGR)
C
      RETURN
C
 1    IZX=1
      GO TO 999
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(MLX,MLY)
C
      MVC=((MLX+2)*MLX/2+MLY)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE RES1
C
C                             *******************
C
      SUBROUTINE RES2(mam,nam,KK,IZX)
C
C-----------------------------------------------------------------------
C
C  SR.RES2 EVALUATES ALGEBRAIC CONTRIBUTIONS TO THE SPIN-ORBIT MATRIX
C  ELEMENTS BY LOOPING OVER ALL SLATER-STATE INTERACTIONS - NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_DMQSS3, ONLY: DSS,MSS,QSS,IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-7)
      PARAMETER (TTYNY=10*TYNY)
      PARAMETER (FSTYNY=10*TTYNY)
C
      DIMENSION mam(*),nam(*)
C
      COMMON /BASIC/NF,KF,KG,JGAP(5),NJ2,NJP2,MGAP(2)
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL,NL000
C
      NL00=NL
C      NL1=NL00+1
C
      DO J=1,NLS
        JORIG2(J)=0
      ENDDO
C
C
C     BEGIN MAIN LOOP 65 OVER SLATER STATE INTERACTIONS
C
      K0=NADS2(KK-1)+1
C
      DO 65 KS=K0,NADS2(KK)
C
        L1=NSTJ2(KS)
        L2=NSTJ2D(KS)
C
        IF(BFAST)THEN
          DDH=DC(L1+NJ2)*DC(L2+NJP2)*DSSS(KS)
        ELSE
          m1=mam(l1)
          if(m1.eq.0)go to 65
          m2=nam(l2)
          if(m2.eq.0)go to 65
          DDH=DC(m1)*DC(m2)*DSSS(KS)
        ENDIF
C
        IF(ABS(DDH).LT.TYNY)GO TO 65
C
        M=MSSS(KS)
        L=JORIG2(M)
        IF(L.GT.0)THEN
          K=IORIG2(L)
          DSS(K)=DSS(K)+DDH
        ELSE
C
C     CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C     MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          L=NL+1
          IF(L.GT.IAXMI)THEN                                    !GO TO 1
C
            IXXX=7*(IAXMI/5+1)
C
            WRITE(6,*)'*** RES2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RES2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES2: REALLOCATION FAILS FOR QSS'
              NF=0
              GO TO 1
            ENDIF
C
            IXXX0=MAX(IXS2I,IAXMI)
            IXXX2=MAX(IXS2I,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES2: REALLOCATION FAILS FOR IORIG2'
              NF=0
              GO TO 1
            ENDIF
C
            IAXMI=IXXX
C
          ENDIF
C
          IRS=IRS+1
          IF(IRS.GT.IXRSS)THEN                                  !GO TO 1
C
            IXXX=7*(IXRSS/5+1)
C
            WRITE(6,*)'*** RES2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RES2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES2: REALLOCATION FAILS FOR DSS'
              NF=0
              GO TO 1
            ENDIF
C
            CALL RE_ALLOC(MSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RES2: REALLOCATION FAILS FOR MSS'
              NF=0
              GO TO 1
            ENDIF
C
            IXRSS=IXXX
C
          ENDIF
C
          NL=L
          DO K=1,5
            QSS(K,L)=QSSS(K,M)
          ENDDO
          JORIG2(M)=L
          IORIG2(L)=IRS
          MSS(IRS)=L
          DSS(IRS)=DDH
C
        ENDIF
C
  65  ENDDO
C
C     CLEAR THE ARRAY OF ZEROS AND ADJUST MSS(K) ACCORDINGLY
C
      IF(IRS.LT.IRS0) RETURN
C
      K=IRS0-1
      KP=0
      DO I=IRS0,IRS
        IF(ABS(DSS(I)).LT.FSTYNY)GO TO 90
        K=K+1
        DSS(K)=DSS(I)
        JD=INT(MSS(I))
        LP=JD-KP
        DO L=1,NL00
          DO J=1,5
            IF(QSS(J,JD).NE.QSS(J,L))GO TO 94
          ENDDO
          LP=L
          GO TO 91
  94    ENDDO
        KP=KP-1
        DO J=1,5
          QSS(J,LP)=QSS(J,JD)
        ENDDO
  91    MSS(K)=LP
  90    KP=KP+1
      ENDDO
C
      NL=NL-KP
      IRS=K
      RETURN
C
  1   IZX=1
      RETURN
C
      END SUBROUTINE RES2
C
C                             *******************
C
      SUBROUTINE RESX1(QLMC,NAM,qnf1,DFS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.RESX1 CALCULATES THE SLATER-STATE SPIN-SPIN, MUTUAL SPIN-ORBIT
C  AND SPIN-OTHER ORBIT INTERACTION BETWEEN PAIRS OF ELECTRONS, ONE
C  PAIR BEING CONTINUUM.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C    FN.VCC
C
C  IT CONTAINS:
C    FN.MVC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DMQSS3, ONLY: IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C
      PARAMETER (MXD31=MAXLL+1)
      PARAMETER (MXD32=MXD31*MXD31)
C
      PARAMETER (TYNY=1.0D-6)
      PARAMETER (TTYNY=10*TYNY)
      PARAMETER (FSTYNY=10*TTYNY)
C
      DIMENSION QLMC(MAXEL,*),DFS(*),NAM(*),qnf1(*)
     X         ,NEN(2,2),NES(2),Q1(2,2),Q2(2,2),Q3(2,2),Q4(2,2)
     X         ,JSS(4),IGAM(5),VC(2),VK(2,3)
C
      COMMON /BASIC/NF,NEK(2),JA,JB,MGAP(4),LLCH(2),MAXLX
      COMMON /CFCT/VCA(MXD32,MXD32,MXD31),VCB(MXD32,MXD32,MXD31)
     X            ,MXLL,BVC,BDLBD
      COMMON /CMDVC/DVC12O,ICLRR,BLX,BEQUALM
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
C
      SAVE BSS,BSO,BSOO
      DATA IFIRST/0/
C
C
c      MVC(MLX,MLY)=((MLX+2)*MLX/2+MLY)/2+1!SEE INTRNL FN ABVE END RESX1
C***
      QQCUTX=1                          !TBD (OR COULD USE TARGET QQCUT)
C***
      MXORBC=MXORB+LCONDWJ
      BPLANT2=MXORBC.LT.37
      MPOSC=MXORB+(LCONDWJ+1)/2
C
      BSKP=IDW.LT.0            !MXLL.EQ.-1
C
      NLS01=NLS00+1
      IF(ICLRR.LT.0)GO TO 400
C
      MXLAM=ABS(MXLAMX)                             !MAX MULTIPOLE VALUE
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      KF=NEK(1)
      KG=NEK(2)
      brev=kf.lt.kg
      NF1=NF+1
C
      IF(IFIRST.NE.0)GO TO 109
C
C      GO TO (101,102,103,104,105,106,107,108),QQCUTX
C
      IF(QQCUTX.EQ.1)THEN
        BSS=.TRUE.          !101
        BSO=.TRUE.
        BSOO=.TRUE.
      ELSEIF(QQCUTX.EQ.2)THEN
        BSS=.FALSE.         !102
        BSO=.TRUE.
        BSOO=.FALSE.
      ELSEIF(QQCUTX.EQ.3)THEN
        BSS=.FALSE.         !103
        BSO=.FALSE.
        BSOO=.TRUE.
      ELSEIF(QQCUTX.EQ.4)THEN
        BSS=.TRUE.          !104
        BSO=.FALSE.
        BSOO=.FALSE.
      ELSEIF(QQCUTX.EQ.5)THEN
        BSS=.FALSE.         !105
        BSO=.FALSE.
        BSOO=.FALSE.
      ELSEIF(QQCUTX.EQ.6)THEN
        BSS=.TRUE.          !106
        BSO=.FALSE.
        BSOO=.TRUE.
      ELSEIF(QQCUTX.EQ.7)THEN
        BSS=.TRUE.          !107
        BSO=.TRUE.
        BSOO=.FALSE.
      ELSEIF(QQCUTX.EQ.8)THEN
        BSS=.FALSE.         !108
        BSO=.TRUE.
        BSOO=.TRUE.
      ENDIF
C
 109  CONTINUE
      IFIRST=1
C
C BEGIN MAIN SLATER-STATE INTERACTION LOOP (110)
C
      DVC12=DVC12O
C
      DO 110 J1=JA,JB
C
        kk=nam(j1)
        if(brev.or.kk.lt.0)then
          kk=abs(kk)
          i1=2
          i2=1
        else
          i1=1
          i2=2
        endif
        nes(i1)=kinti(kk)
        nes(i2)=kintf(kk)
        jc=nes(1)
        jd=nes(2)
c
c        write(6,*)kf,jc,'      ',kg,jd
c
        IF(BEQUALM)THEN
          IF(JD.GT.JC)GO TO 110
          IF(JD.LT.JC)THEN
            DVC12=2*DVC12O
          ELSE
            DVC12=DVC12O
          ENDIF
        ENDIF
C
        DO I=NLS01,NLS
          IORIG2(I)=0
        ENDDO
C
        NK=1                                !0->1 SINCE CONT-CONT IS ONE
        DO K=1,2                            !INITIALIZE NK=1 CONT-CONT
          NEN(K,1)=NF1
        ENDDO
C
        DDH=DONE                  !PHASE FACTOR FOR REMAINING NF-NK SETS
C
        NU=0
        IF(JD.EQ.JC)GO TO 240                  !SO EQCFS=.TRUE
C
C  NK.EQ.2 HERE
C
        nk=2
        nen2=ken2(kk)
        if(nen2.lt.0)then
          ddh=-ddh
          nen2=-nen2
        endif
        nen(i1,2)=nen2/nf1
        nen(i2,2)=nen2-nen(i1,2)*nf1
c
C test
c        do k=1,2
c          nen(k,1)=nen(k,2)
c          nen(k,2)=nf1
c        enddo
c
        go to 72
C
C NOW NK=1 (CASE JC.EQ.JD ONLY NOW)
C
 240    NU=NU+1
        IF(NU.GT.NF)GO TO 110
        NEN(1,2)=NU
C
C     THE ELECTRON LABELLED BY (K1,K2) BELONGS TO THE CONFIGURATION KX
C     AND TO THE SLATER STATE KY. K1=NO. OF ELECTRON WITHIN A PAIR AND
C     K2=NO. OF PAIR.
C
  72    DO l=1,2 !=1 FOR SLATER STATES JC (OF KF),=2 FOR JD (OF KG)
          I=L
          DO K=1,2 !=1 FOR FOR FIRST PAIR OF ELECTRON STATES,=2 FOR 2'ND
            IF(NK.LT.K)I=1
            KP=NEN(I,K)
            LP=NES(I)
            MU=QLMC(KP,LP)
            LP=NEK(I)
            LP=QCG(KP,LP)
            IF(LP.GT.MXORB)THEN            !CONTINUUM
              Q1(L,K)=LLCH(L)
              Q2(L,K)=(LLCH(L)-MTJ+1)/2+MPOSC
              if(jc.eq.jd.and.l.eq.2)mu=qnf1(jd)
            ELSE
              Q1(L,K)=QL(LP)
              Q2(L,K)=LP
            ENDIF
c            ML=((100+MU)/2)*2-100       ! 100 -> Q1=QL
            ML=Q1(L,K)
            ML=((ml+MU)/2)*2-ml
            Q3(l,k)=ML
            Q4(l,k)=(MU-ML)*2-1
          ENDDO
        ENDDO
C
C INITIALIZE DATA FOR LAMBDA-LOOP
C
        VK(1,2)=DZERO
        VK(1,3)=DZERO
        VK(2,2)=DZERO
        VK(2,3)=DZERO
        DV2=DZERO
        DV3=DZERO
        NI=0
        KC=0
  78    KB=0
C
 265    L1=Q1(1,1+KC)
        L2=Q1(1,2-KC)
        IF(L1+L2.EQ.0)GO TO 14
        L3=Q1(2,1+KB)
        L4=Q1(2,2-KB)
        IF(L3+L4.EQ.0)GO TO 14
C
        MU=MIN(L1+L3,L2+L4,ITWO*MXLAM)          !MAX LAM
        MLAM2=MAX(ABS(L1-L3),ABS(L2-L4))        !MIN LAM
        MU=MIN(MU,MLAM2+IFOUR*NMULT)            !LIMIT NUMBER
        MLAM0=MLAM2-4
        IF(MLAM2.GT.0)MLAM2=MLAM0
        MLAM0=MLAM0-4
        IF(MLAM2.GT.MU)GO TO 76
C
        JSS(1+KC)=Q2(1,1)
        JSS(2-KC)=Q2(1,2)
        JSS(3+KB)=Q2(2,1)
        JSS(4-KB)=Q2(2,2)
        ML1=Q3(1,1+KC)
        ML2=Q3(1,2-KC)
        ML3=Q3(2,1+KB)
        ML4=Q3(2,2-KB)
C
        DSJ=SQRT(REAL((L1+1)*(L2+1)*(L3+1)*(L4+1),WP))
     X   *REAL(MOD(ABS((KB+KC)*2+MLAM2-ML1-ML2),IFOUR)-1,WP)*DDH*DVC12
C
        BSPN=.FALSE.
        IF(BSKP)GO TO 267
C
        MDIFF1=ML1-ML3
        MDIFF2=ML2-ML4
        NI=MIN(ABS(MDIFF1),ABS(MDIFF2))
        M1=Q4(1,1+KC)
        M2=Q4(1,2-KC)
        M3=Q4(2,1+KB)
        M4=Q4(2,2-KB)
        MD1=M1-M3
        MD2=M2-M4
        MST=MD1+MD2
C
        DV1=VCC(IONE,ITWO,IONE,M3,MD1,M1,DFS)
        DV2=VCC(IONE,ITWO,IONE,M4,MD2,M2,DFS)
C
C SPIN-SPIN
C
        DD1=DZERO
        IF(BSS)DD1=-VCC(ITWO,ITWO,IFOUR,MD1,MD2,MST,DFS)
     X             *DV1*DV2*DTHREE/(DTWO*SQRT(DFIVE))
C
        M1=MVC(L1,-ML1)
        M2=MVC(L2,-ML2)
        M3=MVC(L3,ML3)
        M4=MVC(L4,ML4)
C
        DDR1=DZERO
        DDR2=DZERO
        IF(MD1*MD2.NE.0)BSPN=.TRUE.
        IF(MD2.EQ.0)THEN
          IF(BSO)DDR1=DV1
          IF(BSOO)DDR2=DV1+DV1
        ENDIF
        IF(MD1.EQ.0)THEN
          IF(BSOO)DDR1=DV2+DV2+DDR1
          IF(BSO)DDR2=DV2+DDR2
        ENDIF
C
C      ----- BEGIN OF LAMBDA-LOOP (INNER LOOP)
C
 267    MLAM=MLAM2
        IF(MLAM.GT.MU)GO TO 76
C
        DSJ=-DSJ
  40    MLAM2=MLAM0+2
        MLAM1=MLAM2+2
C
        VK(1,1)=VK(1,2)
        VK(1,2)=VK(1,3)
        VK(2,1)=VK(2,2)
        VK(2,2)=VK(2,3)
        VK(1,3)=DZERO
        VK(2,3)=DZERO
        DV1=DV2
        DV2=DV3
        DV3=DZERO
C
        IF(MLAM1.LT.NI)GO TO 59
        BLMM=MOD(MU-MLAM0,IFOUR).NE.0
        IF(BLMM)GO TO 59
C
        BLH=L1+L3.LT.MLAM1
        BLN=L2+L4.LT.MLAM1
        BLK=MLAM0.LT.0 .OR. MLAM0.NE.MLAM
        DD=DONE
C
        IF(.NOT.BSKP)THEN
C
C THE N-CASE MLAM=-2 (AND ALSO MLAM0.LT.MLAM)
C
          KP=MLAM1/4
          K1=KP+1
          IF(.NOT.BVC)THEN
            IF(L1.GT.MXLL)GO TO 42
            IF(L3.GT.MXLL)GO TO 42
          ENDIF
          IF(.NOT.BLK)THEN
            VC(1)=VCB(M1,M3,KP)
            IF(BLH)GO TO 53
          ENDIF
          VK(1,3)=VCA(M1,M3,K1)
          GO TO 53
C
  42      IF(.NOT.BLK)THEN
            VC(1)=VCC(L1,L3,MLAM0,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L1,L3,MLAM2,-ML1,ML3,-MDIFF1,DFS)
            IF(BLH)GO TO 53
          ENDIF
          VK(1,3)=VCC(L1,L3,MLAM1,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L1,L3,MLAM1,-ML1,ML3,-MDIFF1,DFS)
     X           /REAL(MLAM1+1,WP)
C
  53      IF(.NOT.BVC)THEN
            IF(L2.GT.MXLL)GO TO 45
            IF(L4.GT.MXLL)GO TO 45
          ENDIF
          IF(.NOT.BLK)THEN
            VC(2)=VCB(M2,M4,KP)
            IF(BLN)GO TO 59
          ENDIF
          VK(2,3)=VCA(M2,M4,K1)
          GO TO 46
C
  45      IF(.NOT.BLK)THEN
            VC(2)=VCC(L2,L4,MLAM0,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L2,L4,MLAM2,-ML2,ML4,-MDIFF2,DFS)
            IF(BLN)GO TO 59
          ENDIF
          VK(2,3)=VCC(L2,L4,MLAM1,IZERO,IZERO,IZERO,DFS)
     X           *VCC(L2,L4,MLAM1,-ML2,ML4,-MDIFF2,DFS)
     X           /REAL(MLAM1+1,WP)
C
  46      IF(.NOT.BLH)DV3=VK(1,3)*VK(2,3)
     X               *VCC(MLAM1,MLAM1,ITWO,MDIFF1,MDIFF2,-MST,DFS)
        ENDIF
C
  59    MLAM0=MLAM2
        IF(MLAM0.LE.MLAM)GO TO 40
        IF(MLAM1.LT.NI)GO TO 267                          !NEXT LAMBDA
C
C NOW MLAM2=MLAM+2
C AND MLAM1=MLAM+4
C
        IF(BLMM)GO TO 60
        DDR=DZERO
        ML=MLAM+200
        IF(BLK)GO TO 66
        IF(ABS(L4-L2).GT.MLAM)GO TO 64
        IF(BLH)GO TO 62
        IF(BSKP)GO TO 70
C
C     FOLLOWING STATEMENT: SPIN-SPIN; THEREAFTER: MUTUAL SPIN-ORBIT.
C
        DDR=SQRT(REAL((MLAM+5)*MLAM1*(MLAM+3)*MLAM2*(MLAM+1),WP))*DD1
     X     *VCC(MLAM1,MLAM,IFOUR,MDIFF1,MDIFF2,-MST,DFS)
     X     *VK(1,3)*VK(2,1)
C
        IF(BSPN)  GO TO 68
C
        MD2=(MLAM2-L4+L2)*(MLAM2-L2+L4)*(L2-MLAM+L4)
        IF(MD2.EQ.0)  GO TO 62
C
C 2ND V2
C
        DDR=DDR-VCC(MLAM1,MLAM2,ITWO,MDIFF1,MDIFF2,-MST,DFS)
     X     *SQRT(REAL((MLAM1+L2+L4)*(MLAM+5)*MD2,WP)
     X     /REAL((MLAM+1)*MLAM1*32,WP))*DDR2*VC(2)*VK(1,3)
C
  62    IF(BSPN)GO TO 267
        IF(ABS(L3-L1).GT.MLAM)GO TO 64
        MD1=(MLAM2-L3+L1)*(MLAM2-L1+L3)*(L3-MLAM+L1)
        IF(MD1.EQ.0)GO TO 63
        IF(BSKP)GO TO 70
C
C 1ST V2
C
        DDR=SQRT(REAL((MLAM1+L1+L3)*MD1,WP)/(32*MLAM2))*VC(1)*VK(2,1)
     X     *DDR1*VCC(MLAM2,MLAM,ITWO,MDIFF1,MDIFF2,-MST,DFS)+DDR
C
  63    IF(MLAM.EQ.0)GO TO 64
        IF(BSKP)GO TO 70
C
C**********************************************************************
C 1ST V3  , POS SIGN IN 1ST AND 2ND V3 GIVE M.JONES TABLE 2 -WERNER
C          , HOWEVER THEY DO NOT GIVE SAME RESULTS FOR CLOSED SHELL
C          , WHEN TREATED AS OPEN (2-BODY F.S.) AS CLOSED (BLUME-WATSON)
C          , SO STAY WITH MINUS FOR NOW. - NRB
C**********************************************************************
C
        DDR=DDR-SQRT(REAL((MLAM+1)*MLAM,WP)/REAL(64*MLAM2,WP))
     X     *REAL((L1*(L1+2)-L3*(L3+2)-MLAM*MLAM2),WP)*DDR1*DV1
C
  64    IF(BLH)GO TO 68
        IF(BLN)GO TO 68
  66    IF(BSPN)GO TO 267
        IF(BSKP)GO TO 70
C
C**********************************************************************
C 2ND V3  , POS SIGN IN 1ST AND 2ND V3 GIVE M.JONES TABLE 2 -WERNER
C          , HOWEVER THEY DO NOT GIVE SAME RESULTS FOR CLOSED SHELL
C          , WHEN TREATED AS OPEN (2-BODY F.S.) AS CLOSED (BLUME-WATSON)
C          , SO STAY WITH MINUS FOR NOW. - NRB
C**********************************************************************
C
        DDR=DDR-DDR2*DV3
     X     *SQRT(REAL((MLAM+5)*(MLAM+6),WP)/REAL(64*MLAM1,WP))
     X     *REAL((L2*(L2+2)-L4*(L4+2)-(MLAM+6)*MLAM1),WP)
C
  68    DD=DDR*DSJ
        GO TO 69
C
  60    IF(BSPN)GO TO 267                                  !NEXT LAMBDA
        ML=MLAM+100
        IF(BSKP)GO TO 70
C
C V1
C
        DD=SQRT(REAL(((MLAM+3)*MLAM2*MLAM1)/4,WP))*DV2*DDR1*DSJ
  69    IF(ABS(DD).LT.TTYNY)GO TO 267                     !NEXT LAMBDA
C
  70    IGAM(5)=ML
C-----------------------------------------------------------------------
c
c There is little to be gained here due to the lesser symmetry compared
c to Slater integrals and the fact that we have a continuum pair. Also,
c for l=l' the case of N(C'C;BB)=N(BC;C'B) for Bound and Continuum needs
c a further flag so as to distinguish it from N(C'C;BB)=N(C'B;BC),
c since in the former we need C'=M2 while in the latter C'=M1 for
c distinct energies. The latter case needs its energy indexes to be
c swapped when forming H. If want to implement then see also sr.fsintx
c and sr.dwxbp.
C
C IMPOSE V(AB;CD)=V(AD;CB)
C IMPOSE N(AB;CD)=N(AD;CB)=N(CD;AB)=N(CB;AD)
C BY WAY OF FALLING ORDER - NRB
C
c        IF(BLMM)THEN                     !V
c          DO K1=1,3,2
c            IGAM(K1)=JSS(K1)
c          ENDDO
c          K11=2
c        ELSE                            !N
c          K11=1
c        ENDIF
c        DO K1=K11,2
c          IF(JSS(K1).LT.JSS(K1+2))THEN
c            KP=2
c            JP=0
c          ELSE
c            KP=0
c            JP=2
c          ENDIF
c          IGAM(K1)=JSS(K1+KP)
c          IGAM(K1+KP+JP)=JSS(K1+JP)
c        ENDDO
c so
        do j=1,4
          igam(j)=jss(j)
        enddo
c
C-----------------------------------------------------------------------
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
        IF(BPLANT2)IPLANT=IGAM(5)+
     X  ((((IGAM(4)*MXORBC+IGAM(3))*MXORBC+IGAM(2))*MXORBC)+IGAM(1))*
     X  1000
C
        DO J=NLS01,NLS
          IF(.NOT.BPLANT2)THEN
            DO I=5,1,-1                                    !1,5 SLOWER
              IF(QSSS(I,J).NE.IGAM(I))GO TO 272
            ENDDO
          ELSE
            IF(IPLANT.NE.JORIG2(J))GO TO 272
          ENDIF
          L=J
          I=IORIG2(L)
          IF(I.GT.0)THEN
            DSSS(I)=DSSS(I)+DD
            GO TO 267                                     !NEXT LAMBDA
          ENDIF
          GO TO 301
 272    ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
        L=NLS+1
        IF(L.GT.IXS2I)THEN                                    !GO TO 999
C
          IXXX=7*(IXS2I/5+1)
C
          WRITE(6,*)'*** RESX1: increasing MXS2I from ',IXS2I,' to: '
     X              ,IXXX
          WRITE(0,*)'*** RESX1: increasing MXS2I from ',IXS2I,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC2(QSSS,IONE,IFIVE,IONE,IXS2I,IFIVE,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'RESX1: REALLOCATION FAILS FOR QSSS'
            NF=0
            GO TO 999
          ENDIF
C
          IXXX0=MAX(IXS2I,IAXMI)
          IXXX2=MAX(IXXX,IAXMI)
          IF(IXXX2.GT.IXXX0)
     X    CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
          CALL RE_ALLOC(JORIG2,IONE,IXS2I,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'RESX1: REALLOCATION FAILS FOR IORIG2,JORIG2'
            NF=0
            GO TO 999
          ENDIF
C
          IXS2I=IXXX
C
        ENDIF
C
        NLS=L
        DO I=1,5
          QSSS(I,L)=IGAM(I)
        ENDDO
        IF(BPLANT2)JORIG2(L)=IPLANT
C
 301    IRSS=IRSS+1
        IF(IRSS.GT.IXS2C)THEN                                 !GO TO 999
C
          IXXX=7*(IXS2C/5+1)
C
          WRITE(6,*)'*** RESX1: increasing MXS2C from ',IXS2C,' to: '
     X              ,IXXX
          WRITE(0,*)'*** RESX1: increasing MXS2C from ',IXS2C,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC(DSSS,IONE,IXS2C,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'RESX1: REALLOCATION FAILS FOR DSSS'
            NF=0
            GO TO 999
          ENDIF
C
          CALL RE_ALLOC(MSSS,IONE,IXS2C,IXXX,IERR)
          CALL RE_ALLOC(NSTJ2,IONE,IXS2C,IXXX,IERR)
          CALL RE_ALLOC(NSTJ2D,IONE,IXS2C,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'RESX1: REALLOCATION FAILS FOR MSSS,NSTJ2'
            NF=0
            GO TO 999
          ENDIF
C
          IXS2C=IXXX
C
        ENDIF
C
        IORIG2(L)=IRSS
        MSSS(IRSS)=L
        DSSS(IRSS)=DD
        NSTJ2(IRSS)=JC
        NSTJ2D(IRSS)=JD
C
        GO TO 267                  !NEXT LAMBDA
C
C       --- END OF LAMBDA-LOOP
C
  76    IF(KB.NE.0)THEN
          IF(KC.NE.0)GO TO 78
          KC=1
          GO TO 265
        ENDIF
        KB=1
        IF(KC.EQ.0)GO TO 265
  14    IF(NK-1.EQ.0)GO TO 240
C
 110  ENDDO            !END SLATER-STATE LOOP
C
C
      IF(BLX) RETURN
C
C     ELIMINATE COEFFICIENTS /DSSS/.LT.TYNY AND ARGUMENTS QSSS THAT HAVE
C     BEEN LISTED BEFORE IN THE REFERENCE LIST
C
 400  ICLRR=0
      IF(IRSS.LT.IRSS0)RETURN                       !AS NONE
C
      K=IRSS0-1
      KP=0
      DO I=NLS01,NLS
        IORIG2(I)=0
      ENDDO
C
      DO I=IRSS0,IRSS
        JD0=MSSS(I)
        JD=ABS(JD0)
        IF(ABS(DSSS(I)).LT.FSTYNY)THEN
          IF(IORIG2(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QSSS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
        K=K+1
        DSSS(K)=DSSS(I)
        NSTJ2(K)=NSTJ2(I)
        NSTJ2D(K)=NSTJ2D(I)
C
  94    IF(JD.LE.NLS00)THEN
          WRITE(6,*)'RESX1: INFORM NRB OF STOP HERE'
          WRITE(0,*)'RESX1: INFORM NRB OF STOP HERE'
          NF=-1
          GO TO 999
        ENDIF
C
        IF(IORIG2(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,NLS00
            DO J=1,5
              IF(QSSS(J,JD).NE.QSSS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG2(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG2(JD)
          GO TO 92
        ENDIF
C
        IORIG2(JD)=LP
        DO J=1,5
          QSSS(J,LP)=QSSS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)MSSS(K)=LP
C
  91  ENDDO
C
      NLS=NLS-KP
      IRSS=K
C
 999  RETURN
C
C-----------------------------------------------------------------------
      CONTAINS
C-----------------------------------------------------------------------
      FUNCTION MVC(MLX,MLY)
C
      MVC=((MLX+2)*MLX/2+MLY)/2+1
C
      END FUNCTION MVC
C-----------------------------------------------------------------------
C
      END SUBROUTINE RESX1
C
C                             *******************
C
      SUBROUTINE RESX2(iam,ibm,KK)
C
C-----------------------------------------------------------------------
C
C  SR.RESX2 CALCULATES THE LEVEL-RESOLVED SPIN-SPIN, MUTUAL SPIN-ORBIT
C  AND SPIN-OTHER ORBIT INTERACTION BETWEEN PAIRS OF ELECTRONS, ONE
C  PAIR BEING CONTINUUM.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_DMQSS3, ONLY: DSS,MSS,QSS,IXRSS,IAXMI
      USE COMMON_DMQSSS, ONLY: DSSS,MSSS,QSSS,IXS2C,IXS2I
      USE COMMON_NSTS2,  ONLY: NADS2,NSTJ2,NSTJ2D,IORIG2,JORIG2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-6)
      PARAMETER (TTYNY=10*TYNY)
      PARAMETER (FSTYNY=10*TTYNY)
C
      DIMENSION iam(*),ibm(*)
C
      COMMON /BASIC/NF,KF,KG,NJ1,NJ2,NJP1,NJP2,MGAP(5)
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
      COMMON /NXRLS/IRS,IRS0
      COMMON /NXRNL/NL,NL000
      COMMON /NRBDW1/MXORB,MR,ma0,mb0
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
C
      NL00=NL
C      NL1=NL00+1
C
      DO J=1,NLS
        JORIG2(J)=0
      ENDDO
C
      IRS0=IRS+1
c
      mtj2=(mtj/2)*2
C
C     BEGIN MAIN LOOP 65 OVER SLATER STATE INTERACTIONS
C
      K0=NADS2(KK-1)+1
C
      DO 65 KS=K0,NADS2(KK)
C
        L1=NSTJ2(KS)
        m1=iam(l1)
        if(m1.eq.0)go to 65
c
        L2=NSTJ2D(KS)
C
        IF(BFAST)THEN
          DDH=DC(m1)*DC(L2+NJP2)*DSSS(KS)               !DC(L1+NJ2)
        ELSE
          m2=ibm(l2)
          if(m2.eq.0)go to 65
          DDH=DC(m1)*DC(m2)*DSSS(KS)
        ENDIF
C
        IF(ABS(DDH).LT.TYNY)GO TO 65
C
        M=MSSS(KS)
        L=JORIG2(M)
        IF(L.GT.0)THEN
          K=IORIG2(L)
          DSS(K)=DSS(K)+DDH
        ELSE
C
C     CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C     MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          L=NL+1
          IF(L.GT.IAXMI)THEN                                    !GO TO 1
C
            IXXX=7*(IAXMI/5+1)
C
            WRITE(6,*)'*** RESX2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RESX2: increasing MAXMI from ',IAXMI,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QSS,IONE,IFIVE,IONE,IAXMI,IFIVE,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RESX2: REALLOCATION FAILS FOR QSS'
              NF=0
              GO TO 1
            ENDIF
C
            IXXX0=MAX(IXS2I,IAXMI)
            IXXX2=MAX(IXS2I,IXXX)
            IF(IXXX2.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG2,IONE,IXXX0,IXXX2,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RESX2: REALLOCATION FAILS FOR IORIG2'
              NF=0
              GO TO 1
            ENDIF
C
            IAXMI=IXXX
C
          ENDIF
C
          IRS=IRS+1
          IF(IRS.GT.IXRSS)THEN                                  !GO TO 1
C
            IXXX=7*(IXRSS/5+1)
C
            WRITE(6,*)'*** RESX2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
            WRITE(0,*)'*** RESX2: increasing MXRSS from ',IXRSS,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RESX2: REALLOCATION FAILS FOR DSS'
              NF=0
              GO TO 1
            ENDIF
C
            CALL RE_ALLOC(MSS,IONE,IXRSS,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'RESX2: REALLOCATION FAILS FOR MSS'
              NF=0
              GO TO 1
            ENDIF
C
            IXRSS=IXXX
C
          ENDIF
C
          NL=L
          DO K=1,5
            QSS(K,L)=QSSS(K,M)
          ENDDO
c
          if(qss(1,l).gt.mxorb.and.qss(3,l).gt.mxorb
     x   .or.qss(2,l).gt.mxorb.and.qss(4,l).gt.mxorb)then
          else
            qss(5,l)=qss(5,l)-mtj2                    !exchange
          endif
C
          JORIG2(M)=L
          IORIG2(L)=IRS
          MSS(IRS)=L
          DSS(IRS)=DDH
C
        ENDIF
C
  65  ENDDO
C
C     CLEAR THE ARRAY OF ZEROS AND ADJUST MSS(K) ACCORDINGLY
C
      IF(IRS.LT.IRS0) RETURN
C
      K=IRS0-1
      KP=0
      DO I=IRS0,IRS
        IF(ABS(DSS(I)).LT.FSTYNY)GO TO 90
        K=K+1
        DSS(K)=DSS(I)
        JD=INT(MSS(I))
        LP=JD-KP
        DO L=1,NL00
          DO J=1,5
            IF(QSS(J,JD).NE.QSS(J,L))GO TO 94
          ENDDO
          LP=L
          GO TO 91
  94    ENDDO
        KP=KP-1
        DO J=1,5
          QSS(J,LP)=QSS(J,JD)
        ENDDO
  91    MSS(K)=LP
  90    KP=KP+1
      ENDDO
C
      NL=NL-KP
      IRS=K
C
  1   RETURN
C
      END SUBROUTINE RESX2
C
C                             *******************
C
      SUBROUTINE RK1ST(X0,Y0,H,N,X1,Y1)
C
C-----------------------------------------------------------------------
C
C  SR.RK1ST INTEGRATES 1 RUNGE-KUTTA STEP WITH INITIAL VALUES X0,Y0(N).
C  RESULT X1=X+H (H=LENGTH OF STEP), Y1(N)=SOLUTION AT X1.
C  FKT(X,Y,N,Z) REPRESENTS THE SYSTEM TO BE INTEGRATED, Z(N)=
C  DERIVATIVES.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION Y0(*),Y1(*),Y(2),A(5),Z(2)
C
      X1=X0
      HH=H*DHALF
      A(1)=HH
      A(2)=HH
      A(5)=HH
      A(4)=H
      A(3)=H
      DO K=1,N
        Y(K)=Y0(K)
        Y1(K)=Y0(K)
      ENDDO
C
      DO I=1,4
        Z(1)=Y(2)
        Z(2)=DFOUR*X1*SQRT(Y(1)**3)+Y(2)/X1
        X1=X0+A(I)
        DO K=1,N
          Y(K)=Y0(K)+A(I)*Z(K)
          Y1(K)=Y1(K)+A(I+1)*Z(K)/DTHREE
        ENDDO
      ENDDO
C
      RETURN
C
      END SUBROUTINE RK1ST
C
C                             *******************
C
      SUBROUTINE RK4PI(ICOUNT,N,M80)
C
C-----------------------------------------------------------------------
C
C  SR.RK4PI CALCULATES MULTIPOLE PHOTOIONIZATION INTEGRALS INVOLVING
C  CONTINUUM FUNCTIONS (ORBITAL N) AT THE ICOUNT'TH INTERPOLATION ENERGY
C  INDEXED BY M8.
C
C  IT IS CALLED BY:
C    SR.RADCON
C
C  IT CALLS:
C    FN.SBESS
C    FN.SBESSP
C    SR.DIFF
C    SR.DIPOL
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBRN2, ONLY: BINDB
      USE COMMON_NRBTS1, ONLY: DFOT,DFOSS,PMIN,NFOSS,IPIG,IGAG,IXD24
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD12=100)
C
      PARAMETER (D1PT05=1.05D0)
      PARAMETER (D8M4=8.0D-4)
      PARAMETER (D4M5=4.0D-5)
C
      CHARACTER(LEN=4) CODE
C
      DIMENSION CP(100),CM(100),JDUM(100)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM3/DDUM,DZDUM,TM       !TM IS STILL USED BELOW
      COMMON /COM6/DA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBFR/DP(MAXB1)
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
c      common /nrbnfg/fnorm,gnorm
C
      DATA BWARN/.TRUE./
C
C-----------------------------------------------------------------------
      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
      DPOL1(X)=(DONE-EXP(-(X/RCAV)**3))/X**3
      DPOL2(X)=DONE/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
      PI=ACOS(-DONE)
      PIH=PI/DTWO
C
C SET RETARDATION
C
      JSWTCH=1
c      brtard=irtard.ne.0                          !only for brel=.true.
      BREL2=ABS(IREL).EQ.2
c
      if(brel2.and.irtard.ne.0)then
c       iswtch=1   !use Grant (1974) integrals - need to set kappa below
       iswtch=0             !use continuity form, e.g. for kappa average
c       iswtch=-1             !ditto, but test use of filon, length only
      else
        iswtch=0                                               !not used
      endif
C
C INITIALIZE
C
      IPOLF2=IPOLFN/10
      MXRM=MAXRS-1
C
      DRY=DYY(ICOUNT)*DTWO
C
      DM=DZERO
      DD=DZERO
      DZA=MION-NZION-1
C
      P100=DONE
      IF(NNEW.GE.NSW)P100=D100
C
      IF(PMIN.GT.DZERO)THEN                         !DETERMINE SAFE IPIG
        L=LNEW
        IF(L.LT.0)L=NNEW-1
        LP=L+1
        DE=DZA/NNEW
        DE=DE*DE+DRY
        E2=DRY/(DZA*DZA)
C
        CALL DIPOL(IONE,NNEW,IZERO,E2,LP,CP,CM,JDUM)
C
        TL=L+L
        TLP=LP+LP
        T=TLP*CP(LP)*D1P10**JDUM(LP)
        IF(L.GT.0)T=T+TL*CM(L)*D1P10**JDUM(L)
        T=T*DE/DZA**4
        IPIG=1
        IF(T.LT.PMIN*P100)THEN                      !LENGTH FAILURE
          IPIG=0
c          write(6,*)'switch to velocity, icount=',icount
          IF(T.LT.PMIN*P100/D1P6)THEN               !VELOCITY FAILURE
            IF(BREL)THEN
              IF(BWARN.and.irtard.eq.0)THEN
                WRITE(6,100)DYY(ICOUNT-1)/D1PT05
                WRITE(0,101)DYY(ICOUNT-1)/D1PT05
                BWARN=.FALSE.
              ENDIF
CABORT        WRITE(0,*)'ERROR: CANNOT USE ACC GAUGE FOR PI IN ICR MODE'
CABORT        GO TO 999                             !RETURN
            ELSE
              IPIG=-1
c              write(6,*)'switch to acceleration, icount=',icount
              IF(T.LT.PMIN*P100/(D1P6*D1P6))THEN    !ACC. FAILURE (WARN)
                IF(NNEW.GE.NSW)
     X             WRITE(6,*)'PI ACCELERATION MAYBE INACCURATE'
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        IGAG(ICOUNT)=IPIG
c        write(*,*)icount,ipig,t,pmin
      ENDIF
C
      IF(ICOUNT.EQ.NREL)RETURN                    !WAS JUST TO GET GAUGE
C
      DA(MAXRS)=DZERO
      IF(IPIG.EQ.0)CALL DIFF(FR,DA,MNH,DHNS,MJH)    !VELOCITY
C
      IF(IPIG.LT.0)DAX=DZERO                        !ACCELERATION
      IF(IPIG.EQ.0)DAX=D8M4*(DONE-DZA)**2           !VELOCITY
      IF(IPIG.GT.0)DAX=D4M5*(DONE-DZA)**2           !LENGTH
C
C BEGIN INNER ORBITAL LOOP
C
      DO J=1,N
C
        IF(DEY(J).EQ.DZERO)GO TO 332
        IF(BJUMP.AND.IVAL(J).EQ.0)GO TO 332
        IF(IYY(J).GT.0.AND.MODE.LE.2)GO TO 332
        IF(J.GE.MA.AND.J.LE.MB)GO TO 332                        !MA0,MB0
COLD        IF((QL(J)-QL(N))**2.NE.4)GO TO 332      !DIPOLE ONLY
C
          IN=ICOL(J,N,IZERO)
          LM=ABS(QL(N)-QL(J))/2
          m=max(lm,mpol00/2)
          if(mod(m,itwo).ne.mod(lm,itwo))m=m+1
          mm=m-2
          if(mpol00.gt.0.and.mm.le.mpole/2)then
            if(bindb(in,mm/2))m=mm                         !allow for mk
            if(m.lt.0)m=m+2
          endif
          IF(M.GT.MPOLE/2)GO TO 332
          MM=M
C          M0=M
          LL=(QL(N)+QL(J))/2
          LP=MIN(LL,MPOLE/2)
cp          if(brel)lp=lp+2                         !for retardation
cp          if(lp.eq.0.and.igagr.gt.0)lp=2
          if(lp.eq.0)go to 332                      !none (no Born here)
          if(mm.gt.lp)go to 332
c
        brtard=irtard.ne.0.and.qn(j).gt.0         !off for ryd/cont-cont
  840   IF(.NOT.BINDB(IN,mm/2))then
c          write(0,*)'No algebra for PI?',j,n,mm
c            m=m+2
            mm=mm+2
            if(mm.le.lp)go to 840
          GO TO 332
        ENDIF
        if(qn(j).lt.0.and.(mm.gt.mkmax.or.icount.gt.mxep))
     x                                      go to 332 !rest upscaled
C
        DE=DEY(J)-DUY(J,J)-DRY*DHALF                  !A.U.
        IF(BREL)THEN
          mp=mm+1
          TE=ABS(DE*DFSC)
          TJ=DONE/TE**mm
          do i=1,mm
            tj=tj*(2*i+1)
          enddo
        ENDIF
        if(mm.eq.0)then                             !skip e0, go to m1
          dd=0
          rem=0
          go to 339
        endif
C
        MN=0
        IF(IPIG.GT.0)MN=mm                            !LENGTH
        IF(IPIG.LT.0)MN=-2                            !ACCELERATION
        IF(QN(J).LT.0.AND.DRY.LE.DAX)MN=-2            !DITTO
        if(mn.eq.-2.and.mm.ne.1)then                  !no acc non-dipole
          mn=0                                        !velocity fallback
          ipig0=0
          if(da(maxrs).eq.dzero)call diff(fr,da,mnh,dhns,mjh)
c          if(qn(j).gt.0)then                         !or zero-out...
c            ist=1
c          else
c            ist=2
c          endif
c          rem=dzero
c          dd=d1m75
c          go to 339
        else
          ipig0=ipig
        endif
C
        IF(MN.EQ.0)THEN                               !VELOCITY
C
          if(ipig0.ne.0)stop 'rk4pi: velocity?'   !not really needed now
          IAP=1
          MN=-1
          dll=((ql(n)/2+1)*ql(n)-(ql(j)/2+1)*ql(j))/2
          mmm=mm-1
          IF(BREL.and.brtard)THEN
            IF(BREL2)THEN
              T=-2*DE*TJ/(2*mm+1)
C ORIGINAL GRANT (1974) WITH KAPPA DEPENDENCE - sync with fcf6/radial
c do *not* use with kappa average.
       if(iswtch.gt.0)then
              tk1=-1 !ql(n)/2                  !continuum kappa
              tk2=-1                           !bound s-orbital
              DO I=1,MAXRS
                TFQ=FR(I)*DQNL(I,J)
                TGP=GR(I)*DPNL(I,J)
                TZ=DX(I)*TE
                TB0=SBESS(mmm,TZ,JSWTCH)
                TB2=SBESS(mp,TZ,JSWTCH)
                DP(I)=               -(TFQ-TGP)*(TB0+TB2)*mm
                DP(I)=DP(I)+(tk1-tk2)*(TFQ+TGP)*(TB0-TB2*mm/mp)
                DP(I)=DP(I)*T
              ENDDO
       elseif(iswtch.eq.0)then
C FOR KAPPA-AVERAGE: USES CONTINUITY TO REMOVE EXPLICIT KAPPA-DEPENDENCE
C AS SUCH IT DIFFERS ONLY TRIVIALLY (A BESSEL RECURRENCE) FROM LENGTH
c kappa dependent gives same answer as above (if continuity satisfied)
              DO I=1,MAXRS
                TZ=DX(I)*TE
                TB0=SBESS(mmm,TZ,JSWTCH)
                TB2=SBESS(mp,TZ,JSWTCH)
                DP(I)=(DPNL(I,J)*FR(I)+DQNL(I,J)*GR(I))*TZ
     X               *(TB0-TB2*mm/mp)
                tb1=sbess(mm,tz,jswtch)
                DP(I)=DP(I)-(FR(I)*DQNL(I,J)-GR(I)*DPNL(I,J))
     X               *tz*tb1*(mm+mp)/mp
                DP(I)=DP(I)*T
              ENDDO
       else
         write(0,*)"Filon's method not coded for Velocity gauge"
         go to 999
       endif
            ELSE
              CALL DIFF(DPNL(1,J),DP,MNH,DHNS,MJH)
              DO I=1,MAXRS
                TZ=DX(I)*TE
                DP(I)=FR(I)*DPNL(I,J)*DLL*SBESS(mm,TZ,JSWTCH)/DX(I)**2
     X            +(DA(I)*DPNL(I,J)-FR(I)*DP(I))*SBESSP(mm,TZ,JSWTCH)*te
                dp(i)=dp(i)*tj
              ENDDO
            ENDIF
          ELSE
            mmm=mm-1
            IF(BREL2.and.qn(j).gt.0)THEN
              T=mm*2/DFSC
              DO I=1,MAXRS
                DP(I)=((FR(I)*DPNL(I,J)+GR(I)*DQNL(I,J))*DLL/DX(I)
     X               -(FR(I)*DQNL(I,J)-GR(I)*DPNL(I,J))*T)
     x                                                       *dx(i)**mmm
              ENDDO
            ELSE
              ddll=dll+mmm*mm
              DO I=1,MAXRS
                DP(I)=(FR(I)*dDLL/DX(I)+DA(I)*mm*2)*DPNL(I,J)
     x                                                       *dx(i)**mmm
              ENDDO
            ENDIF
          ENDIF
C
        ELSE                                        !LENGTH/ACCELERATION
C
          mmm=0
          IAP=0
          DO I=1,MAXRS
            DP(I)=DPNL(I,J)*FR(I)
          ENDDO
          IF(BREL2)THEN
            DO I=1,MAXRS
              DP(I)=DP(I)+DQNL(I,J)*GR(I)
            ENDDO
          ENDIF
          IF(MN.EQ.-2)THEN                                 !ACCELERATION
            DO I=1,MAXRS
              DP(I)=-DP(I)*DERV(I)
            ENDDO
          ELSE                                                   !LENGTH
            if(mn.ne.mm)stop 'rk4pi: length?'
            IF(BREL.and.brtard)THEN
              IF(BREL2)THEN
C ORIGINAL GRANT (1974) WITH KAPPA DEPENDENCE - sync with fcf6/radial
c do *not* use with kappa average.
       if(iswtch.gt.0)then
                tk1=-1 !ql(n)/2                !continuum kappa
                tk2=-1                         !bound s-orbital
                DO I=1,MAXRS
                  TFQ=FR(I)*DQNL(I,J)
                  TGP=GR(I)*DPNL(I,J)
                  TZ=DX(I)*TE
                  tb1=sbess(mm,tz,jswtch)
                  DP(I)=DP(I)*tb1
                  TB2=SBESS(mp,TZ,JSWTCH)
                  DP(I)=DP(I)-(TFQ-TGP)*TB2
                  DP(I)=DP(I)-(tk1-tk2)*(TFQ+TGP)*TB2/mp
                  dp(i)=dp(i)*tj
                ENDDO
       elseif(iswtch.eq.0)then
C FOR KAPPA-AVERAGE: USES CONTINUITY TO REMOVE EXPLICIT KAPPA-DEPENDENCE
c kappa dependent gives same answer as above (if continuity satisfied)
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  TB2=SBESS(mp,TZ,JSWTCH)
                  tb1=sbess(mm,tz,jswtch)
                  DP(I)=DP(I)*(tb1-TZ*TB2/mp)
                  DP(I)=DP(I)-(FR(I)*DQNL(I,J)-GR(I)*DPNL(I,J))
     X                 *tz*tb1/mp
                  dp(i)=dp(i)*tj
                ENDDO
       else
c test use of filon's method, not really an issue here since we have a
c grid set-up to describe continuum, unlike bound-bound case, only when
c te.gt.k-momentum does j_l oscillate more rapidly viz 75,000 Ryd.
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  TB2=1 !SBESS(mp,TZ,JSWTCH)
                  DP(I)=DP(I)*(-TZ*TB2/mp) !*tj
                ENDDO
c                call weddle(dm,dp,fb2,mnh,dhns,mjh,maxrs)
                call filonw(mp,te,dx,mnh,dhns,mjh,maxrs,dp,fb2,dum)
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  tb1=1 !sbess(mm,tz,jswtch)
                  DP(I)=DPNL(I,J)*FR(I)+DQNL(I,J)*GR(I)
                  DP(I)=DP(I)*tb1-(FR(I)*DQNL(I,J)-GR(I)*DPNL(I,J))
     X                 *tz*tb1/mp
c                  dp(i)=dp(i)*tj
                ENDDO
c                call weddle(dm,dp,fb1,mnh,dhns,mjh,maxrs)
                call filonw(mm,te,dx,mnh,dhns,mjh,maxrs,dp,fb1,dum)
              fb1=fb1*tj
              fb2=fb2*tj
              dd=fb1+fb2
c              write(6,*)fb1,fb2,dd,te
              go to 3333
       endif
              ELSE
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  DP(I)=DP(I)*TJ*SBESS(mm,TZ,JSWTCH)
                ENDDO
              ENDIF
            ELSE
              DO I=1,MAXRS
                DP(I)=DP(I)*DX(I)**mm
              ENDDO
            ENDIF
C ADD-IN 2-BODY POL
            IF(IPOLF2.GT.0.AND.mm.eq.1)THEN       !ipolf2.ge.0 gives v24
              IF(IPOLF2.le.1)THEN               !.le.1 allows v24 result
                DO I=1,MAXRS
                  DP(I)=DP(I)*(DONE-ALAV*DPOL1(DX(I)))
                ENDDO
              ELSEIF(IPOLF2.EQ.2)THEN
                DO I=1,MAXRS
                  DP(I)=DP(I)*(DONE-ALAV*DPOL2(DX(I)))
                ENDDO
              ELSE
                STOP 'SR.RK4PI: HERE BE MONSTERS'
              ENDIF
            ENDIF
          ENDIF
C
        ENDIF
C
C
        CALL WEDDLE(DM,DP,DD,MNH,DHNS,MJH,MAXRS)
c
 3333  continue
C
C LONG-RANGE INTEGRAL F*G*X**MN (VEL ALSO FP*G) CASE RYD APPROX BY CONT
C
        REM=DZERO
        IST=1
        IF(QN(J).GT.0)GO TO 339
        IST=2
C
        DX1=DX(MAXRS)
        DT=DX(MAXRS)-DX(MXRM)
        ML1=QL(N)/2
        DS=ML1*(ML1+1)
        ML2=QL(J)/2
        DC=ML2*(ML2+1)
        DNORM=-QN(J)
        DNORM=DNORM-SCREEN(J)
        TN=DZA/DNORM
        TN=TN*TN
        DNORM=TN/(PIH*DNORM)
        DNORM=SQRT(DNORM)
        TN=SCREEN(J)
C
        DO IAA=0,IAP
          MN=MN+IAA
          nm=mn+mmm
          F0=FR(MXRM)
          F1=FR(MAXRS)
          G0=DPNL(MXRM,J)
          G1=DPNL(MAXRS,J)
          IF(IAA.EQ.0)THEN
            CALL ASS2X(DX1,DT,DX2,F0,F1,G0,G1,DRY,DM,DS,DC,DM,DM,DM,DM,
     X                 DZA,nm,REM2)
            TMP=TM
ctest            rem00=0.                                         !ctest
          ELSE             !VEL: F=A*SIN(B), SO FP=A*BP*COS(B)+ap*sin(b)
            P0=DA(MXRM)
            P1=DA(MAXRS)
            CALL ASS2PX(DX1,DT,DX2,F0,F1,P0,P1,G0,G1,DRY,DM,DS,DC,DM,
     X                  DM,DM,DM,DZA,nm,REM2)
c
ctest contribution from ap*sin(b)
ctest            rem00=0.
ctest            call assx(dx2,nm-2,tm,tn,dry,dm,dza,ml1,ml2,ds,dc
ctest     x                ,dm,dm,dm,dm,rem00)
ctest            rem00=-rem00*dnorm*dza/(dtwo*dry)
c
ctest contribution from a*(z/k)*cos(b)/r
ctest            rem00=0.
ctest            call assx(dx2,nm-1,tm+dhalf,tn,dry,dm,dza,ml1,ml2,ds,dc
ctest     x               ,dm,dm,dm,dm,rem00)
ctest            rem00=-rem00*dnorm*dza/sqrt(dry)
c
            TE=DRY
            TZ=DZA
            IF(BREL)THEN
              TZ=TZ+DHALF*DALF*TZ*TE
              TE=TE+DQUART*DALF*TE*TE
            ENDIF
            PNORM=SQRT(TE)*(done-tz/(te*dx2))       !approx z/r contrib.
            DNORM=DNORM*PNORM                       !NORM*DP
            TMP=TM+DHALF                            !AS ASSX EXPECTS SIN
          ENDIF
C
          REM0=DZERO
C
          CALL ASSX(DX2,nm,TMP,TN,DRY,DM,DZA,ML1,ML2,DS,DC,DM,DM,DM,DM,
     X              REM0)
C
          REM0=REM0*DNORM                           !+rem00       !ctest
c
c          if(iaa.gt.0)then
c            f1=p1
c            f1=f1/pnorm                            !as dry.ne.0 here
c            g1=g1*pnorm
c          endif
c          if(fnorm.ne.dzero)f1=f1/fnorm
c          if(gnorm.ne.dzero)g1=g1/(gnorm*dnorm)
cc
c          write(6,*)'*** ',mn,rem2,rem0,f1,g1,dx1,dx2
c
          REM0=REM2+REM0
          IF(MN.EQ.-1)REM0=REM0*dDDL
          IF(MN.EQ.0)REM0=REM0*2*mm
          REM=REM+REM0
        ENDDO
C
        IF(MN.EQ.-2)THEN
          REM=-REM*DZA                            !BFOT=.TRUE. HERE
          DE=DONE
        ELSE
          DE=-DHALF*DRY
CWORSE DE=-0.5*(DRY+DSHIFT(J))
        ENDIF
C
C FIND STORE POINTER
C
  339   M8=NFOSS(mm/2,N,J)
        IF(M8.LE.0)THEN
          M80=M80+1
          IF(M80.GT.IXD24)GO TO 332               !MXD24
          M8=M80
          NFOSS(mm/2,N,J)=M8
        ENDIF
C
c        write(6,*)m8,j,n,mm,icount,ist,mn,dd,rem,dd+rem,tm,tn
c
        DD=DD+REM
        IF(MN.EQ.-2)DD=DD/DE**2                   !ACC
        IF(MN.EQ.-1.OR.MN.EQ.0)DD=-DD/(2*DE)      !VEL
C
        IF(IST.EQ.1)DFOSS(M8,ICOUNT,1)=DD
        DD=DD*DE**2                               !FOR INTERP
        DFOSS(M8,ICOUNT,2)=DD                     !& for kshift=0 mxep
C
C MAGNETIC
C
        IF(MPOLE.GT.2.and.qn(j).gt.0)THEN         !explicit mk upscaled
          IF(BREL2)THEN
            M8=NFOSS(mm/2,J,N)
            IF(M8.LE.0)THEN
              M80=M80+1
              IF(M80.GT.IXD24)GO TO 332           !MXD24
              M8=M80
              NFOSS(mm/2,J,N)=M8
            ENDIF
c            mp=mm+1
            T=-2/(DFSC*(mp+2))
            IF(brtard)THEN
              T=T*TJ*(2*mp+1)/TE
              DO I=1,MAXRS
                TZ=DX(I)*TE
                TB2=SBESS(mp,TZ,JSWTCH)
                DP(I)=(FR(I)*DQNL(I,J)+GR(I)*DPNL(I,J))*TB2
              ENDDO
            ELSE
              DO I=1,MAXRS
                DP(I)=(FR(I)*DQNL(I,J)+GR(I)*DPNL(I,J))*DX(I)**mp
              ENDDO
            ENDIF
C
            CALL WEDDLE(DM,DP,DD,MNH,DHNS,MJH,MAXRS)
C
            DD=DD*T
c            DD=DD+REM
            IF(IST.EQ.1)DFOSS(M8,ICOUNT,1)=DD
            DD=DD*DE**2                           !FOR INTERP
            DFOSS(M8,ICOUNT,2)=DD                 !& for kshift=0 mxep
          ELSE                                    !USE ELECTRIC
            NFOSS(mm/2,J,N)=M8
          ENDIF
        ENDIF
c
c        m=m+2
        mm=mm+2
        if(mm.le.lp)go to 840                    !to next multipole
C
  332 ENDDO                                      !END INNER ORBITAL LOOP
C
      RETURN
C
  999 CONTINUE
      M80=-1                                     !FLAG ABORT
      RETURN
C
  100 FORMAT(//'*** SR.RK4PI: ERROR, CANNOT USE ACC GAUGE FOR PI IN'
     X       ,' ICR MODE, REDUCE EMAX (RYD) TO:',F6.0/4X
     X       ,'CONTINUING WITH VELOCITY GAUGE, AT YOUR OWN RISK -'
     X       ,' NO MORE WARNINGS!'/)
  101 FORMAT(/'*** STRONG WARNING: VEL GAUGE LIKELY INACCURATE ***'/
     X       ,'   (NO ACC GAUGE FOR ICR MODE) YOU ARE ADVISED TO REDUCE'
     X       ,' EMAX(RYD) TO:',F6.0/4X,'PROCEED AT YOUR OWN RISK -'
     X       ,' NO MORE WARNINGS!'/)
C
      END SUBROUTINE RK4PI
C
C                             *******************
C
      SUBROUTINE RKINT(BPRNT0)
C
C-----------------------------------------------------------------------
C
C  SR.RKINT CALCULATES R^K RADIATIVE MULTIPOLE INTEGRALS FOR BOUND-BOUND
C  AND BOUND-FREE TRANSITIONS.
C  OPTIONALLY, CALCULATES FINITE AND/OR INFINITE ENERGY BORN INTEGRALS.
C
C  LENGTH IN LOWER TRIANGLE OF DOSC, VELOCITY IN UPPER.
C  ACCELERATION STORED IN ACC (USES NZION/R FOR THE POTENTIAL).
C
C  IT IS CALLED BY:
C    SR.CARATE
C    SR.DIAGON
C
C  IT CALLS:
C    SR.ASSX
C    SR.ASS2X
C    SR.BORN
C    SR.DIFF
C    FN.SBESS
C    FN.SBESSP
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_CACC,   ONLY: ACC
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_INTS,   ONLY: DOSC
      USE COMMON_MQVC,   ONLY: NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBORN, ONLY: BNRBORN,BL,OBO,TM2,IXBLM
      USE COMMON_NRBRN1, ONLY: BNRBRN1,SBL,DBL
     X                        ,MB3,MB4,INDX,INDL,INDK,IXD33
      USE COMMON_NRBRN2, ONLY: BINDB,MENGB
      USE COMMON_NRBRN3, ONLY: V0,V1,MV0,MV1,MINFB,MXNXV,MXD21
     X                        ,NLAGB,NPDEC,IVV0
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
      USE COMMON_NRBTS1, ONLY: DFOT,DFOSS,PMIN,NFOSS,IPIG,IGAG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C      PARAMETER (MXD09=MXBLM+2)                           !+2 CASE BREL
      PARAMETER (MXD12=100)
C
      PARAMETER (D1PT1=1.1D0)
      PARAMETER (D0PT35=0.35D0)
      PARAMETER (PIH=1.5707963D0)
      PARAMETER (DBIG=100.0D0)
      PARAMETER (D8M4=8.0D-4)
      PARAMETER (D4M5=4.0D-5)
C
      CHARACTER(LEN=3) PIG
      CHARACTER(LEN=4) CODE
C
      DIMENSION LIMR(MAXGR),IHAR(MAXGR),DDY(MXENG),VV(MXNXV)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBAL2/MDEL,MXORBR,MPOL00,MPOL0,MPOLE,MPOLX,CODE
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBFOT/DERV(MAXB1),BFOT
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      common /nrbtim/iw,iwp,btime,btimex
C
C-----------------------------------------------------------------------
      ICOL(ILI,ILF,IONE1)=((ILF-1)*(ILF-2*IONE1))/2+ILI
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
      DPOL1(X)=(DONE-EXP(-(X/RCAV)**3))/X**3
      DPOL2(X)=DONE/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
C INITIALIZE LOGICALS
C
c      brtard=irtard.ne.0                          !only for brel=.true.
      BREL2=ABS(IREL).EQ.2
      BBORN=MENGB.GE.0
      BFOTJ=.NOT.BFOT.OR..NOT.BLAG
      IF(.NOT.BFOTJ.AND.PMIN.GT.DZERO)IPIG=1
      BORT=MORT.LT.0
C
C SET MAX BORN/RADIATION MULTIPOLE
C
      IXD09=IXBLM
      IF(BREL)IXD09=IXD09+2                                !+2 CASE BREL
C
C SET RETARDATION
C
      JSWTCH=1
C
C SET CHARGES ETC.
C
      NZA=NZION-MION+1
      DZA=-NZA
      DZM=-NZION
      DDY(1)=DONE
      MXRM=MAXRS-1
      mxmm=0
C
C INITIALIZE FOR PI
C
C (WE HAVE NO TEST FOR GAUGE HERE.
C  DEFAULT NREL=1 AND LENGTH.
C  IF USER SETS NREL TOO LARGE THEN SHOULD USE VEL/ACC.
C  ATTEMPT TO IMPROVE-ON DEFAULT BY CHECKING IGAGR FROM RK4PI.)
C
      PIG='   '
      IF(BFOT)THEN
c        write(*,*)pig,(igag(i),i=1,meng)
        PIG='VAR'
        IF(IPIG.LT.0)THEN                        !ACCELERATION
          PIG='ACC'
        ELSEIF(IPIG.EQ.0)THEN                    !VELOCITY
          PIG='VEL'
        ELSEIF(IPIG.GT.0)THEN                    !LENGTH
          IF(PMIN.LT.DZERO)PIG='LEN'             !OR VARIABLE
        ENDIF
        IF(BLAG)IPIG=IGAG(NREL)         !DO NOT SET NREL 4PI TOO LARGE
        IF(IPIG.LT.0.AND.PIG.EQ.'VAR')THEN       !FALLBACK TO VELOCITY
c          IF(BREL.OR.MPOLE.GT.2)IPIG=0           !NOW E_K DEPENDENT
        ENDIF
        IF(IPIG.LT.0)DAX=DZERO                   !ACCELERATION
        IF(IPIG.EQ.0)DAX=D8M4*(DONE-DZA)**2      !VELOCITY
        IF(IPIG.GT.0)DAX=D4M5*(DONE-DZA)**2      !LENGTH
c        write(*,*)pig,ipig,(igag(i),i=1,meng)
        NAX=0
        IF(BLAG)THEN
          DO I=1,MENG
            IF(DYY(I).LT.DAX)NAX=I
          ENDDO
          NAX=NAX+1
        ENDIF
      ENDIF
C
      IPIG0=IPIG
C
C INITIALIZE FOR NLAG-POINT LAGRANGE INTERPOLATION FORMULA FOR
C  BOUND-CONTINUUM INTEGRALS.
C  NLAG MUST BE AN EVEN NUMBER .GE. 2 . READ IN SRADCON.
C  DEFAULT:   NLAG=6.
C
C      NLAGP2=NLAGP-2
      NP1=1
      NP2=MAX(IONE,NLAGP)
      NPH=NP2/2
C      BBC1=MENG.LE.NP2
C      IF(BBC1)NP2=MENG
C
C INITIALIZE NLAGB-POINT LAGRANGE INTERPOLATION FORMULA FOR
C  BORN INTEGRALS.
C  NLAGB MUST BE AN EVEN NUMBER, DEFAULT:   NLAGB=4.
C  NPDEC DETERMINES THE NODES AND IS THE NUMBER OF INTERVALS PER
C  DECADE (OF MOMENTUM TRANSFER), DEFAULT: NPDEC=4.
C  THUS, THE VALUES OF NLAGB AND NPDEC ARE INTERTWINED.
C
      IF(MENGB.EQ.0)THEN               !FINITE ENERGY BORN
        MV0=MXD21
        MV1=MXNXV                      !K-SHELL
        IF(MA.EQ.1)THEN                !NO K-SHELL                  !MA0
          MV0=MV0-1
          MV1=MV1-NPDEC
        ENDIF
        IF(NLAGB.GT.MV0)THEN
          WRITE(6,*)'NOT ENOUGH K-VALUES FOR MOM. TRANSF. INTERP'
     X              ,MV0,NLAGB
          WRITE(0,*)'NOT ENOUGH K-VALUES FOR MOM. TRANSF. INTERP'
          GO TO 999
        ENDIF
        DELTA=DONE/NPDEC
        DELTA=10**DELTA
        VV(2)=10**IVV0
        VV(2)=DONE/VV(2)
        MV11=MV1-1
        DO I=3,MV11
          VV(I)=VV(I-1)*DELTA
        ENDDO
        VV(1)=VV(2)/2                 !FIRST POINT
        VV(MV1)=10*VV(MV11)           !INFINITE ENERGY POINT
        MINFB=MV11
        DO I=1,MV1
          V1(I)=VV(I)*NZA
        ENDDO
        DO I=1,MV0
          V0(I)=VV(I)*NZA
          MENGB=MENGB+MV1-I
        ENDDO
      ELSEIF(MENGB.EQ.1)THEN          !INFINITE ENERGY BORN ONLY
        MINFB=1
        V0(1)=DZERO
        V1(1)=DBIG*NZA
      ELSE
        MINFB=1
      ENDIF
C
C
      IF(BBORN)THEN
C
        IF(BPRNT0)THEN
          IF(MENGB.GT.1)THEN
            WRITE(6,706)MV0,MV1,(I,V1(I),I=1,MV1)
            WRITE(6,707)((I,J,J=I+1,MV1),I=1,MV0)
          ENDIF
          WRITE(6,704)
        ENDIF
C
        iflagb=0                        !counter for numerical failure
c
        ngrp=1
        if(irlx.lt.0)then
          ngrp=-irlx/100000             !until /nrborb/ in a module
          mxborb=-irlx-100000*ngrp
        endif
c
        IXD28=(MXORB*(MXORB+1))/2
        MXVORB=MXORB-MB*ngrp
        IF(NSL0.GT.0)THEN
          IXD33=(MXVORB*(MXVORB+1))/2
          IXD34=((IXD33+1)*IXD33)/2           !MAXIMAL FOR FULL CI
          if(kutls.le.0)then
            IXD34=2*IXD33         !MIX WITHIN CF MAY NEED INCREASE
          endif
        ELSE                                  !CA
          IXD33=(MXVORB*(MXVORB-1))/2
          IXD34=IXD33
        ENDIF
        IF(MENGB.EQ.1)THEN                    !INF
          IXD38=1
        ELSE
          IXD38=(MXNXV*(MXNXV-1))/2
     X               -((MXNXV-MXD21)*(MXNXV-1-MXD21))/2
        ENDIF
C
        IERR=0
        LHM=MPOLE/4
C
        IF(.NOT.BNRBORN)
     X  ALLOCATE (BL(IXD38,IXD34,0:LHM),OBO(IXD38),TM2(IXD34),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'RKINT: ALLOCATION FAILS FOR BORN'
          NF=0
          GO TO 998
        ENDIF
        BNRBORN=.TRUE.
C
        IF(NSL0.GT.0)THEN
C                             ,DBL(IXD33,MXBIF) - SET IN DIAGON/DIAGFS
        IF(.NOT.BNRBRN1)
     X    ALLOCATE (SBL(IXD33)
     X            ,MB3(0:IXD33),MB4(0:IXD33),INDX(IXD28)
     X            ,INDK(IXD34),INDL(IXD34),STAT=IERR)

        ELSE                                  !CA
C                         ,DBL(IXD33,MXBIF) - SET IN DIAGON/DIAGFS
          IF(.NOT.BNRBRN1)
     X    ALLOCATE (SBL(1)
     X            ,MB3(0:IXD33),MB4(0:IXD33),INDX(IXD28)
     X            ,INDK(IXD34),INDL(IXD34),STAT=IERR)
        ENDIF
        IF(IERR.NE.0)THEN
          WRITE(0,*)'RKINT: ALLOCATION FAILS FOR BORN1'
          NF=0
          GO TO 998
        ENDIF
        BNRBRN1=.TRUE.
C                                     !BORN INDEX
        N=0                           !WATCH THIS
        NC=0
        MB3(0)=0
c        tt=-done                                  !for logging run only
        DO J=0,LHM
          DO I=1,IXD34
            DO K=1,MENGB
              BL(K,I,J)=DZERO
c              obo(k)=done                         !for logging run only
            ENDDO
          ENDDO
        ENDDO
c
        if(kutls.le.0)then                      !identify effective core
          icore=0
          do k=1,kmax
            isum=0
            do i=mxorb,1,-1
              isum=isum+nel(i,k)
              if(isum.gt.1)then
                icore=max(icore,i)
                go to 10
              endif
            enddo
  10      enddo
c          write(*,*)'icore=',icore
        endif
C
      ENDIF
C
      DD0=DZERO
      N1=1                            !N1=NC FOR CA
      IPOLF2=IPOLFN/10
      btest=.false.
C
      DO K=1,MXORB                        !*****BEGIN OUTER ORBITAL LOOP
C
        IHAR(K)=10000
        IF(DEY(K).EQ.DZERO)GO TO 825
C       IF(K.LE.ABS(MPSEUD))GO TO 825
        IF(.NOT.BJUMP2)THEN
          DO I=1,MAXRS
            DPA(I)=DPNL(I,K)
            IF(ABS(DPA(I)).GT.D1M6)LIMR(K)=I
          ENDDO
          CALL DIFF(DPA,DP, MNH,DHNS,MJH)
        ENDIF
        IHAR(K)=QL(K)/2
        KLAST=K
C
  825   DO J=1,K                            !***BEGIN INNER ORBITAL LOOP
C
          IF(DEY(J)*DEY(K).EQ.DZERO)GO TO  828
C         IF(J.LE.ABS(MPSEUD))GO TO 828
          M=IVAL(K)+IVAL(J)
          IF(BJUMP.AND.M.EQ.0)GO TO 828
C
C DETERMINE MULTIPOLE RANGE
C
          IF(.NOT.BREL.AND.IGAGR.LT.0.AND..NOT.BBORN
     X                .AND.QL(K)+QL(J).EQ.0)GO TO 828       !827
C
          IN=ICOL(J,K,IZERO)
          LM=ABS(QL(K)-QL(J))/2
          m=max(lm,mpol00/2)
          if(mod(m,itwo).ne.mod(lm,itwo))m=m+1
          lm=m                                            !hold for Born
          mm=m-2
          if(mpol00.gt.0.and.mm.le.mpole/2)then
            if(bindb(in,mm/2))m=mm                         !allow for mk
            if(m.lt.0)m=m+2
          endif
          IF(M.EQ.0.and..not.bborn.and..not.brel2)M=2       !.and.j.eq.k
          IF(M.GT.MPOLE/2)GO TO 828                         !827
          MM=M
          M0=M
          LL=(QL(K)+QL(J))/2
          LP=MIN(LL,MPOLE/2)
          if(mod(ll,itwo).ne.mod(lp,itwo))lp=lp-1
          IF(BREL)LP=LP+2                             !.and.irtard.eq.0?
          IF(LP.EQ.0.AND.IGAGR.GT.0)LP=2
C
         IF(BJUMP2)THEN
C
          TM=FACT(K)*FACT(J)
          ACC(K,J)=TM*ACC(K,J)
C
          m8=0
          if(mod(ll,itwo).ne.mod(lp,itwo))lp=lp-1    !align to reach m0!
          do m=lp,m0,-2                     !loop high to low, for mxe1!
            DOSC(m,K,J)=TM*DOSC(m,K,J)
            IF(J.NE.K)DOSC(m,J,K)=TM*DOSC(m,J,K)
            if(bfot)m8=nfoss(m/2,k,j)
            if(m8.gt.0)then
              if(m.gt.mkmax.or.m.eq.0)then                 !all upscaled
                mxe1=1
              else
                mxe1=mxep+1
              endif
              do ist=1,2                     !=2 for mxe boundary interp
                do i=mxe1,meng
                  dfoss(m8,i,ist)=tm*dfoss(m8,i,ist)
                enddo
              enddo
              do i=1,mxe1-1
                dfoss(m8,i,2)=tm*dfoss(m8,i,2)
              enddo
              m80=nfoss(m/2,j,k)
              if(m8*m80.ne.m80*m80)then                    !for magnetic
                do i=1,meng
                  dfoss(m80,i,1)=tm*dfoss(m80,i,1)         !all upscaled
                enddo
              endif
            endif
          enddo
c          if(m+2.ne.m0)stop 'rkint: bjump2 mis-alignment?'
          if(m0.gt.0)then
            DOSC(0,K,J)=TM*DOSC(0,K,J)
            IF(J.NE.K)DOSC(0,J,K)=TM*DOSC(0,J,K)
          endif
c
          IF(BFOTJ)GO TO 828
          IF(IYY(J).GT.0.OR.IYY(K).LT.0)GO TO 828               !NOT B-F
          if(mxe1.eq.1)go to 828                !upscale (only) no shift
          lp0=lp
          mm=m0
          GO TO 340
C
         ENDIF
C
C INITIALIZE DOSC TO ZERO
C
          IF(.NOT.BJUMP)THEN
            DO I=0,IXD09                              !MXD09
              DOSC(I,K,J)=DZERO
              DOSC(I,J,K)=DZERO
            ENDDO
            ACC(K,J)=DZERO
          ENDIF
C
          DD=DZERO
          DB=DZERO
C
          OVL=DONE
          IF(IRLX.EQ.2)THEN    !OVERLAPS
            KF=IGRCF(J)
            KG=IGRCF(K)
            IF(KF.NE.KG.AND.KF*KG.GT.0)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              IF(IPAIR(KK).EQ.1)OVL=OVLPCF(KK)
            ENDIF
          ENDIF
C
C BORN
C
          IF(.NOT.BBORN)GO TO 841
C
          IF(MENGB.EQ.1.AND.LP.EQ.1)GO TO 841
          IF(NSL0.LT.0.AND.J.EQ.K)GO TO 841                 !CA
          IF(NW.GT.0)THEN
            IF(IEQ(J).LE.NNL(NW,1))GO TO 841
          ENDIF
C
          IF(2*LL.GT.MPOLE.AND.NMULTE.GT.100)WRITE(6,705)LL
C
          NC=NC+1
          IF(NC.GT.IXD33)GO TO 841
          MB4(NC)=J
          MB3(NC)=K                         !NOT USED BY CARATE
          IN=ICOL(J,K,IZERO)
          INDX(IN)=NC
          JP=MOD(LM,ITWO)
C
          if(kutls.le.0)then        !mix within a cf only restricts poss
            if(j.ne.k)then
              n1=nc
              btest=.false.
            else
              n1=1
              btest=.true.
            endif
          endif
          IF(NSL0.LT.0)N1=NC                                !CA
C
          DO ND=N1,NC
            L=MB3(ND)
            I=MB4(ND)
            if(btest)then           !mix within a cf only restricts poss
              if(l.ne.i)then
                go to 810
              else
                if(i.lt.j.and.i.gt.icore)go to 810
              endif
            endif
            KM=ABS(QL(L)-QL(I))/2
            IP=MOD(KM,ITWO)
            IF(IP.EQ.JP)THEN
              KP=(QL(L)+QL(I))/2
              KM=MAX(KM,LM)
              IF(MENGB.EQ.1.AND.KM.EQ.1)KM=KM+2             !SKIP DIPOLE
              KP=MIN(KP,LP)
              IF(KM.LE.KP)THEN
                N0=N
                IM=ICOL(I,L,IZERO)
                iflagbb=0
                DO LAM=KM,KP,2
                  LH=LAM/2
                  IF(BINDB(IN,LH).AND.BINDB(IM,LH))THEN     !NEEDED
                    N0=N+1
                    if(iflagbb.gt.0)then        !as will evntly overflow
                      iflagb=iflagb+1
                      go to 801
                    endif
C
                    CALL BORN(LAM,K,J,L,I,IHAR,LIMR,MENGB
     X                       ,MV0,MV1,V0,V1,OBO,OINT,TT)
C
                    IF(LAM.LT.0)GO TO 999                   !FAILURE
                    IF(LAM.EQ.1)TM2(N0)=TT
                    if(lam.gt.km+4)then
                      if(obo(mengb).gt.bl(mengb,n0,lh-1).or.
     x                   obo(mengb).lt.dzero)then           !inacc
                        iflagb=iflagb+1
                        iflagbb=iflagbb+1
c                        do ie=1,mengb
c                          obo(ie)=dzero
c                        enddo
                        go to 801
                      endif
                    endif
                    DO IE=1,MENGB
                      BL(IE,N0,LH)=OBO(IE)
                    ENDDO
  801               IF(BPRNT0)WRITE(6,699)N0,NC,K,J,L,I
     X                             ,2*LAM,(BL(IE,N0,LH),IE=1,MENGB)
c           call flush(6)
                  ENDIF
                ENDDO
                IF(N0.EQ.N+1)THEN
                  N=N+1
                  if(n.gt.ixd34)then
                    if(kutls.gt.0)then
                      write(6,*)'born index error,ixd34'     !shouldn't
                      write(0,*)'born index error,ixd34'     !shouldn't
                    else
c can't re-alloc BL(:,:,:) but don't want to inflate wrt CA, so tweak
                      write(6,*)'need to increase ixd34 for kutle.le.0'
                      write(0,*)'need to increase ixd34 for kutle.le.0'
                    endif
                    go to 999
                  endif
                  INDL(N)=NC
                  INDK(N)=ND
                ENDIF
              ENDIF
            ENDIF
  810     ENDDO
          IF(QL(K)+QL(J).EQ.0.AND.IGAGR.LT.0)GO TO 828      !827
C                                           .AND.NOT.BREL
C FIND LOWEST ALLOWED MULTIPOLE
C
  841     IN=ICOL(J,K,IZERO)
c
c 840  write(6,*)in,j,k,m,bindb(in,m/2)
  840     IF(.NOT.BINDB(IN,M/2))THEN
            M=M+2
            MM=M
            M0=M
            IF(MM.LE.LP)GO TO 840
            GO TO 828                                       !NONE EXIST
          ENDIF
C
          mp0=m                                             !for m1
          if(m.eq.0)then                                    !for born
            M=M+2
            IF(M.GT.LP)then
              if(brel2)go to 827                            !for m1
              GO TO 828
c            IF(.NOT.BINDB(IN,M/2))GO TO 828
            ENDIF
            MM=M
            M0=M
          endif
C
C MODE .LE. 2  SET CONTINUUM-CONTINUUM TO ZERO
C
          IF(MODE.LE.2.AND.QN(J).LT.0.AND.QN(K).LT.0)GO TO 338
C
C LENGTH
C
C BEGIN MULTIPOLE LOOP
C
  842     BPOL=IPOLF2.GT.0.AND.MM.EQ.1     !ipolf2.ge.0 gives v24 result
ct          m2=mm/2
ct          m1=mod(mm,itwo)
          IF(BREL2)THEN
            DO I=1,MAXRS
              DPA(I)=DPNL(I,K)*DPNL(I,J)+DQNL(I,K)*DQNL(I,J)
              DPA(I)=DPA(I)*DX(I)**MM
            ENDDO
          ELSE
            DO I=1,MAXRS
ct              t1=dx(i)**m2
ct              t2=t1
ct              if(m1.gt.0)t2=t2*dx(i)
ct              DPA(I)=(DPNL(I,K)*t1)*(DPNL(I,J)*t2)
              DPA(I)=DPNL(I,K)*DPNL(I,J)*DX(I)**MM
            ENDDO
          ENDIF
          IF(BPOL)THEN
            IF(IPOLF2.le.1)THEN       !.le.1 allows v24 result, if(bpol)
              DO I=1,MAXRS
                DPA(I)=DPA(I)*(DONE-ALAV*DPOL1(DX(I)))
              ENDDO
            ELSEIF(IPOLF2.EQ.2)THEN
              DO I=1,MAXRS
                DPA(I)=DPA(I)*(DONE-ALAV*DPOL2(DX(I)))
              ENDDO
            ELSE
              STOP 'SR.RKINT: HERE BE MONSTERS - 1'
            ENDIF
          ENDIF
C
          CALL WEDDLE(DD0,DPA,DB,MNH,DHNS,MJH,MAXRS)
C
          DB=DB*OVL
C
c      del=dey(j)-duy(j,j)-(dey(k)-duy(k,k))  !test use of orb ener a.u.
          IF(MM.GT.0)THEN
            IF(MM.EQ.M0)THEN
              DOSC(0,K,J)=DB       !for unit6 print
              DD=DB                !no longer used, recovered from dosc?
            ENDIF
            DOSC(MM,K,J)=DB
            MM=MM+2
c        if(mm.le.lp)write(6,*)in,j,k,mm,bindb(in,mm/2)
c            IF(MM.LE.LP.AND.BINDB(IN,MM/2))GO TO 842
            IF(MM.LE.LP)THEN                       !FOR STUPID COMPILERS
              IF(BINDB(IN,MM/2))GO TO 842             !TO NEXT MULTIPOLE
            ENDIF
          ELSE
c        db=db/del**2                         !test use of orb ener a.u.
            ACC(K,J)=-DB*DZM
            GO TO 641
          ENDIF
C
C ACCELERATION (DIPOLE)
C
          ACC(K,J)=DZERO
          IF(M.LT.2)THEN
            MM=-2
            IF(.NOT.BFOT)GO TO 842
            IF(BREL2)THEN
              DO I=1,MAXRS
                DPA(I)=DPNL(I,K)*DPNL(I,J)+DQNL(I,K)*DQNL(I,J)*DERV(I)
              ENDDO
            ELSE
              DO I=1,MAXRS
                DPA(I)=DPNL(I,K)*DPNL(I,J)*DERV(I)
              ENDDO
            ENDIF
C
            CALL WEDDLE(DD0,DPA,DB,MNH,DHNS,MJH,MAXRS)
C
            DB=-DB*OVL
            ACC(K,J)=DB
          ENDIF
C
C VELOCITY
C
  641     MM=M
C
C BEGIN MULTIPOLE LOOP
C
  741     MMM=MM-1
          D2=(IHAR(K)+1)*IHAR(K)-(IHAR(J)+1)*IHAR(J)
          IF(BREL2)THEN
            T=MM*2/DFSC
            DO I=1,MAXRS
              DPA(I)=((DPNL(I,K)*DPNL(I,J)+DQNL(I,K)*DQNL(I,J))*D2/DX(I)
     X               -(DPNL(I,K)*DQNL(I,J)-DQNL(I,K)*DPNL(I,J))*T)
     X                                                       *DX(I)**MMM
            ENDDO
          ELSE
            DD2=D2+MMM*MM
            DO I=1,MAXRS
              DPA(I)=(DPNL(I,K)*DD2/DX(I)+DP(I)*MM*2)*DPNL(I,J)
     X                                                       *DX(I)**MMM
            ENDDO
          ENDIF
C
          CALL WEDDLE(DD0,DPA,DC,MNH,DHNS,MJH,MAXRS)
C
          DC=DC*OVL
c      dc=-dc/(del*2)                        !test use of orb ener a.u.
C
          IF(J.NE.K)THEN
            IF(MM.EQ.M0)DOSC(0,J,K)=DC
            DOSC(MM,J,K)=DC
          ELSE
            DOSC(MM-1,J,K)=DC         !PUT DIAGONAL VELOCITY DOWN 1 POLE
          ENDIF
          MM=MM+2
c          IF(MM.LE.LP.AND.BINDB(IN,MM/2))GO TO 741
          IF(MM.LE.LP)THEN                         !FOR STUPID COMPILERS
            IF(BINDB(IN,MM/2))GO TO 741               !TO NEXT MULTIPOLE
          ENDIF
C
C PHOTOIONIZATION
C     (OPTIONALLY, TEST FULL RETARDATION ON B-B)
C
  827     CONTINUE
C
          IF(IYY(K).GT.0)THEN
            DEL=DEY(J)-DUY(J,J)-DYY(NREL)                          !A.U.
          ELSE
            DEL=DEY(J)-DUY(J,J)-DEY(K)+DUY(K,K)                    !A.U.
          ENDIF
C
          m=mp0
          M0=M
          MM=M
  826     IPIG=IPIG0
          M8=0
          IF(BFOT)M8=NFOSS(mm/2,K,J)
          IF(M8.GT.0.or.irtard.lt.0.and.qn(j).ne.qn(k))THEN
            IF(IRLX.EQ.2.and.m8.gt.0)THEN
              DO I=1,MENG
                DFOSS(M8,I,1)=DFOSS(M8,I,1)*OVL               !FOR RK4PI
              ENDDO
              M80=NFOSS(mm/2,J,K)
              IF(M8*M80.NE.M80*M80)THEN                    !FOR MAGNETIC
                DO I=1,MENG
                  DFOSS(M80,I,1)=DFOSS(M80,I,1)*OVL           !FOR RK4PI
                ENDDO
              ENDIF
            ENDIF
c
            brtard=irtard.ne.0.and.qn(j).gt.0
C                                                    ALWAYS DO PI LENGTH
            IF(BREL.and.brtard.and.mm.le.ixd09)THEN
              MP=MM+1
              TE=abs(DFSC*DEL)
              TJ=1/TE**MM
              DO I=1,MM
                TJ=TJ*(2*I+1)
              ENDDO
              if(mm.eq.0)go to 830               !m.eq.0 !as no electric
c
              IF(BREL2)THEN
C ORIGINAL GRANT (1974) WITH KAPPA DEPENDENCE - sync with fcf6/radial
c do *not* use with kappa average.
                tk1=ql(k)/2                 !continuum kappa
                tk2=-1                         !bound s-orbital
                DO I=1,-MAXRS
                  TPQ=DPNL(I,K)*DQNL(I,J)
                  TQP=DQNL(I,K)*DPNL(I,J)
                  TZ=DX(I)*TE
                  TB1=SBESS(MM,TZ,JSWTCH)
                  DPA(I)=(DPNL(I,K)*DPNL(I,J)+DQNL(I,K)*DQNL(I,J))*tb1
                  TB2=SBESS(MP,TZ,JSWTCH)
                  DPA(I)=DPA(I)-(TPQ-TQP)*TB2
                  DPA(I)=DPA(I)-(tk1-tk2)*(TPQ+TQP)*TB2/MP
                  DPA(I)=DPA(I)*TJ
                ENDDO
C FOR KAPPA-AVERAGE: USES CONTINUITY TO REMOVE EXPLICIT KAPPA-DEPENDENCE
c kappa dependent gives same answer as above.
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  TB2=SBESS(MP,TZ,JSWTCH)
                  TB1=SBESS(MM,TZ,JSWTCH)
                  DPA(I)=(DPNL(I,K)*DPNL(I,J)+DQNL(I,K)*DQNL(I,J))
     X                   *(TB1-TZ*TB2/MP)
                  DPA(I)=DPA(I)-
     X                  (DPNL(I,K)*DQNL(I,J)-DQNL(I,K)*DPNL(I,J))
     X                  *TZ*TB1/MP
                  DPA(I)=DPA(I)*TJ
                ENDDO
              ELSE
                DO I=1,MAXRS
                  TZ=DX(I)*TE
                  DPA(I)=DPNL(I,K)*DPNL(I,J)*TJ*SBESS(MM,TZ,JSWTCH)
                ENDDO
              ENDIF
              IF(BPOL)THEN
                IF(IPOLF2.le.1)THEN   !.le.1 allows v24 result, if(bpol)
                  DO I=1,MAXRS
                    DPA(I)=DPA(I)*(DONE-ALAV*DPOL1(DX(I)))
                  ENDDO
                ELSEIF(IPOLF2.EQ.2)THEN
                  DO I=1,MAXRS
                    DPA(I)=DPA(I)*(DONE-ALAV*DPOL2(DX(I)))
                  ENDDO
                ELSE
                  STOP 'SR.RKINT: HERE BE MONSTERS - 2'
                ENDIF
              ENDIF
C
              CALL WEDDLE(DD0,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
              DD=DD*OVL
              IF(MM.EQ.M0)DOSC(0,K,J)=DD
              DOSC(MM,K,J)=DD
            else
              if(brel.and.brtard)then
                mxmm=max(mxmm,mm)
                go to 828
              endif
              dd=dosc(mm,k,j)
            ENDIF
C
            IF(IPIG.GT.0.and.m8.gt.0)THEN                        !LENGTH
              DFOSS(M8,NREL,1)=DD
              DFOSS(M8,NREL,2)=DD*DEL**2     !for kshift=0 mxep boundary
            ENDIF
C
            IF(IPIG.LT.0)THEN                              !ACCELERATION
              IF(BREL)THEN
                IF(PIG.NE.'VAR')THEN
                 WRITE(6,*)'***SR.RKINT: ERROR, ACC GAUGE NOT CODED FOR'
     X                    ,' PI WITH RELATIVISTIC ORBITALS'
                 WRITE(0,*)'***SR.RKINT: ERROR, ACC GAUGE NOT CODED FOR'
     X                    ,' PI WITH RELATIVISTIC ORBITALS'
                 GO TO 999
                ELSE
                  IPIG=0                              !VELOCITY FALLBACK
                ENDIF
              ENDIF
              if(mm.gt.1)then
                IF(PIG.NE.'VAR')THEN
                 write(6,*)'***sr.rkint: error, acc gauge is for dipole'
     x                    ,' pi only'
                 write(0,*)'***sr.rkint: error, acc gauge is for dipole'
     x                   ,' pi only'
                 go to 999
                ELSE
                  IPIG=0                              !VELOCITY FALLBACK
                ENDIF
              endif
              T=-DONE
              IF(.NOT.BFOT)THEN
                IP=K
                IF(.NOT.BORT)IP=QL(K)/2+1
                IF(DADJUS(IP).LT.DZERO)T=DZA !not if use orb ener. above
                IF(DADJUS(IP).GE.DZERO)T=DZM !not if use orb ener. above
              ENDIF
c              DEL=DEY(J)-DUY(J,J)-DYY(NREL) !not if use orb ener. above
              if(m8.gt.0)then
                db=acc(k,j)
                DB=-DB*T/DEL**2              !not if use orb ener. above
                DFOSS(M8,NREL,1)=DB
                DFOSS(M8,NREL,2)=DB*DEL**2   !for kshift=0 mxep boundary
              endif
            ENDIF
C
            IF(IPIG.EQ.0)THEN                                  !VELOCITY
              IF(BREL.and.brtard)THEN
                IF(BREL2)THEN
                  MMM=MM-1
                  T=-2*DEL*TJ/(2*MM+1)
C ORIGINAL GRANT (1974) WITH KAPPA DEPENDENCE - sync with fcf6/radial
c do *not* use with kappa average.
                  tk1=ql(k)/2               !continuum kappa
                  tk2=-1                       !bound s-orbital
                  DO I=1,-MAXRS
                    TPQ=DPNL(I,K)*DQNL(I,J)
                    TQP=DQNL(I,K)*DPNL(I,J)
                    TZ=DX(I)*TE
                    TB0=SBESS(MMM,TZ,JSWTCH)
                    TB2=SBESS(MP,TZ,JSWTCH)
                    DPA(I)=                -(TPQ-TQP)*(TB0+TB2)*MM
                    DPA(I)=DPA(I)+(tk1-tk2)*(TPQ+TQP)*(TB0-TB2*MM/MP)
                    DPA(I)=DPA(I)*T
                  ENDDO
C FOR KAPPA-AVERAGE: USES CONTINUITY TO REMOVE EXPLICIT KAPPA-DEPENDENCE
C AS SUCH IT DIFFERS ONLY TRIVIALLY (A BESSEL RECURRENCE) FROM LENGTH
c kappa dependent gives same answer as above.
                  DO I=1,MAXRS
                    TZ=DX(I)*TE
                    TB0=SBESS(MMM,TZ,JSWTCH)
                    TB2=SBESS(MP,TZ,JSWTCH)
                    DPA(I)=(DPNL(I,J)*DPNL(I,K)+DQNL(I,J)*DQNL(I,K))*TZ
     X                    *(TB0-TB2*MM/MP)
                    TB1=SBESS(MM,TZ,JSWTCH)
                    DPA(I)=-(DPNL(I,K)*DQNL(I,J)-DQNL(I,K)*DPNL(I,J))
     X                    *TZ*TB1*(MM+MP)/MP+DPA(I)
                    DPA(I)=DPA(I)*T
                  ENDDO
                ELSE
                  DD2=(IHAR(K)+1)*IHAR(K)-(IHAR(J)+1)*IHAR(J)
                  CALL DIFF(DPNL(1,J),DPA,MNH,DHNS,MJH)
                  DO I=1,MAXRS
                    TZ=DX(I)*TE
                    DPA(I)=
     X              DPNL(I,J)*DPNL(I,K)*DD2*SBESS(MM,TZ,JSWTCH)/DX(I)**2
     X      +(DP(I)*DPNL(I,J)-DPNL(I,K)*DPA(I))*SBESSP(MM,TZ,JSWTCH)*TE
                    DPA(I)=DPA(I)*TJ
                  ENDDO
                ENDIF
C
                CALL WEDDLE(DD0,DPA,DC,MNH,DHNS,MJH,MAXRS)
C
                IF(J.NE.K)THEN
                  IF(MM.EQ.M0)DOSC(0,J,K)=DC
                  DOSC(MM,J,K)=DC
                ELSE
                  DOSC(MM-1,J,K)=DC   !PUT DIAGONAL VELOCITY DOWN 1 POLE
                ENDIF
              ELSE
                MX=MM
                IF(J.EQ.K)MX=MMM
                DC=DOSC(MX,J,K)
              ENDIF
c              DEL=DEY(J)-DUY(J,J)-DYY(NREL)!not if use orb ener. above
              if(m8.gt.0)then
                T=-DC/(DEL*2)               !=dc if use orb. ener. above
                DFOSS(M8,NREL,1)=T
                DFOSS(M8,NREL,2)=T*DEL**2    !for kshift=0 mxep boundary
              endif
            ENDIF
C
  830       IF(MPOLE.GT.2.AND.BREL2)THEN         !WE (MAY) NEED MAGNETIC
              M80=NFOSS(mm/2,J,K)
              IF(M80.GT.0)THEN
                mp=mm+1
                T=-2/(DFSC*(mp+2))
                IF(brtard)THEN
                  T=T*TJ*(2*mp+1)/TE
                  DO I=1,MAXRS
                    TZ=DX(I)*TE
                    TB2=SBESS(mp,TZ,JSWTCH)
                    DPA(I)=(DPNL(I,K)*DQNL(I,J)+DQNL(I,K)*DPNL(I,J))*TB2
                  ENDDO
                ELSE
                  DO I=1,MAXRS
                    DPA(I)=(DPNL(I,K)*DQNL(I,J)+DQNL(I,K)*DPNL(I,J))
     X                    *DX(I)**mp
                  ENDDO
                ENDIF
C
                CALL WEDDLE(DD0,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
                DD=DD*T
                DFOSS(M80,NREL,1)=DD
                DFOSS(M80,NREL,2)=DD*DEL**2  !kshift=0 mxep bndry unused
              ENDIF
            ENDIF
c
c increment multipole
            mm=mm+2
            bpol=.false.                               !as must be first
c            if(mm.le.lp.and.bindb(in,mm/2))then
            if(mm.le.lp)then                       !for stupid compilers
              if(bindb(in,mm/2))go to 826
            endif
C
          ENDIF
          GO TO 828
C
C CASE OF RYDBERG APPROX BY ZERO-ENERGY CONTINUUM
C (NO RETARDATION, SO NEED NREL "SMALL")
C
  338     IF(.NOT.BFOT)GO TO 828
          IF(IYY(J).GT.0.OR.IYY(K).LT.0)GO TO 828
          ACC(K,J)=DZERO                                !DON'T USE
          lp0=lp                                        !sigh...
c          if(kshift.eq.0)then      !always need for magnetic
            tm=nnew
            tm=tm-screen(j)         !can use, as we do have q.d. here
            tn=nnold
            tn=tn-screen(j)         !can use, as we do have q.d. here
            factj=(tn/tm)**3
            factj=sqrt(factj)
c          endif
C
  339     if(mm.gt.mkmax.or.mm.eq.0)then                   !all upscaled
            mxe1=1
          else
            mxe1=mxep+1
          endif
          m8=nfoss(mm/2,k,j)
          if(m8.gt.0)then
            do ist=1,2                       !=2 for mxe boundary interp
              do i=mxe1,meng
                dfoss(m8,i,ist)=factj*dfoss(m8,i,ist)
              enddo
            enddo
            m80=nfoss(mm/2,j,k)
            if(m8*m80.ne.m80*m80)then                      !for magnetic
              do i=1,meng
                dfoss(m80,i,1)=factj*dfoss(m80,i,1)        !all upscaled
              enddo
            endif
          endif
          if(nrel.ge.mxe1)then
            dosc(mm,k,j)=factj*dosc(mm,k,j)
            if(j.ne.k)dosc(mm,j,k)=factj*dosc(mm,j,k)
            if(mm.eq.m0.and.m0.gt.0)then
              dosc(0,k,j)=factj*dosc(0,k,j)
              if(j.ne.k)dosc(0,j,k)=factj*dosc(0,j,k)
            endif
            if(mm.gt.mkmax)go to 829                    !quick/safe exit
            go to 340
          endif
C
          MN=0
          IF(IPIG.GT.0)MN=mm                            !LENGTH
          IF(IPIG.LT.0.OR.DYY(NREL).LE.DAX)then         !ACCELERATION
            MN=-2
            if(mm.ne.1)then                             !zero non-dipole
              rem=dzero
              dd=d1m75
              go to 353
            endif
          ENDIF
          IF(IPIG.EQ.0.AND.MN.EQ.0)THEN                 !VELOCITY
             WRITE(6,905)NREL
             WRITE(0,*)'REDUCE NREL FOR FREE-FREE PI VELOCITY GAUGE'
             GO TO 999
C            MN=-1
C            DLL=MAX(QL(J),QL(K))*(QL(K)-QL(J))/2
C            DO I=1,MAXRS
C              DPA(I)=(DPNL(I,K)*DLL/DX(I)+DP(I)*2)*DPNL(I,J)
C            ENDDO
          ELSE                                      !LENGTH/ACCELERATION
            DO I=1,MAXRS
              DPA(I)=DPNL(I,K)*DPNL(I,J)
            ENDDO
            IF(BREL2)THEN
              DO I=1,MAXRS
                DPA(I)=DPA(I)+DQNL(I,K)*DQNL(I,J)
              ENDDO
            ENDIF
            IF(MN.EQ.-2.AND.BFOT)THEN               !ACCELERATION
              DO I=1,MAXRS
                DPA(I)=-DPA(I)*DERV(I)
              ENDDO
            ELSE
              IF(MN.EQ.1.AND.ALAV*RCAV.NE.DZERO)THEN      !2-BODY POL
                IF(IPOLF2.EQ.1)THEN
                  DO I=1,MAXRS
                    DPA(I)=DPA(I)*(DONE-ALAV*DPOL1(DX(I)))
                  ENDDO
                ELSEIF(IPOLF2.EQ.2)THEN
                  DO I=1,MAXRS
                    DPA(I)=DPA(I)*(DONE-ALAV*DPOL2(DX(I)))
                  ENDDO
                ELSE
                  STOP 'SR.RKINT: HERE BE MONSTERS - 3'
                ENDIF
              ENDIF
              DO I=1,MAXRS
                DPA(I)=DPA(I)*DX(I)**MN
              ENDDO
            ENDIF
          ENDIF
C
          CALL WEDDLE(DD0,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
          REM=DZERO
          IF(MN.EQ.0)GO TO 353                      !VELOCITY
C
C      EVALUATE LONG-RANGE INTEGRAL
C
          DTH=DX(MAXRS)-DX(MXRM)
          DD1=DPNL(MXRM,K)
          DD2=DPNL(MAXRS,K)
          DD3=DPNL(MXRM,J)
          DD4=DPNL(MAXRS,J)
          DX1=DX(MAXRS)
          TM=SCREEN(K)
          TN=SCREEN(J)
          DB=DTWO*DYY(NREL)
          DC=-QN(J)
          DC=DC-TN
          DS=DZA/DC
          DS=DS*DS
          DNORM=DS/(PIH*DC)
          DNORM=SQRT(DNORM)
          ML1=QL(K)/2
          DS=ML1*(ML1+1)
          ML2=QL(J)/2
          DC=ML2*(ML2+1)
C
          CALL ASS2X(DX1,DTH,DX2,DD1,DD2,DD3,DD4,DB,DD0,DS,DC,DD0,DD0,
     X               DD0,DD0,DZA,MN,REM2)
C
          CALL ASSX(DX2,MN,TM,TN,DB,DD0,DZA,ML1,ML2,DS,DC,DD0,DD0,DD0,
     X              DD0,REM)
C
          REM=REM*DNORM
          REM=REM2+REM
C              IF(MN.EQ.-1)REM=REM*DLL
          IF(MN.EQ.-2)REM=-REM*DZA                  !ACCELERATION
C
  353     M8=NFOSS(mm/2,K,J)
          DD=DD+REM
          DD=DD*OVL
C
          IF(MN.gt.0)DD=DD*DYY(NREL)**2             !LENGTH
CWORSE    IF(MN.gt.0)DD=DD*(DYY(NREL)+DSHIFT(J))**2
          IF(MN.EQ.-1)DD=DD*DYY(NREL)/2             !ALT VELOCITY (TEST)
C
          IF(M8.GT.0)THEN
            IF(IRLX.EQ.2)THEN
              DO I=1,MENG
                DFOSS(M8,I,2)=DFOSS(M8,I,2)*OVL
              ENDDO
            ENDIF
            DFOSS(M8,NREL,2)=DD
          ENDIF
C
C LOOP OVER CONTINUUM ENERGIES
C
 340      IF(M8.EQ.0)GO TO 829
C
          IF(DSHIFT(J).EQ.DZERO)THEN               !SHIFT WAS EXPLICIT
            DO I=1,mxe1-1
              DFOSS(M8,I,1)=DFOSS(M8,I,2)/DYY(I)**2
            ENDDO
            GO TO 829
          ENDIF
C
          DO I=1,mxe1-1                            !=mxep if mm.le.mkmax
            TM=DYY(I)+DSHIFT(J)
            XP0=DZERO
C
C USE +1.1 TO EXTRAP HIGH E FROM NEAREST NEIGHEBOUR RATHER THAN INTERP.
C
            IF(TM.LT.-D1PT1*DYY(I).OR..NOT.BLAG)THEN
              DAS=DFOSS(M8,I,2)
              GO TO 354
            ENDIF
            IF(NAX.GT.MENG)THEN
              WRITE(6,*)' *** TOO FEW PI ENERGIES FOR FREE-FREE',
     X                  ' INTERPOLATION'
              WRITE(0,*)' *** TOO FEW PI ENERGIES FOR FREE-FREE',
     X                  ' INTERPOLATION'
              GO TO 999
            ENDIF
CNAX            IF(BBC1)GO TO 341
C
            DO L=NAX,MENG
              IF(DYY(L).GE.TM)THEN
                LP=L
                GO TO 343
              ENDIF
            ENDDO
            LP=MENG
C
C343        IF(BBC2)GO TO 344
 343        NP2=LP+NPH-1
            NP1=LP-NPH
            IF(NP1.LT.NAX)THEN
              NP1=NAX
              NP2=NP1+2*NPH-1
              NP2=MIN(NP2,MENG)
              GO TO 341
            ENDIF
            IF(NP2.GT.MENG)THEN
              NP1=NP1-NP2+MENG
              NP2=MENG
              NP1=MAX(NP1,NAX)
            ENDIF
C
C           GO TO 341
C344        NP2=LP
C           NP1=LP-1
C           DO 346 M=1,NLAGP2
C           IF(NP2.EQ.MENG)GO TO 347
C           IF(NP1.LE.1)GO TO 348
C           DD=DYY(NP2+1)-TM
C           DAS=TM-DYY(NP1-1)
C           IF(DD.LE.DAS)NP2=NP2+1
C           IF(DD.GT.DAS)NP1=NP1-1
C346        CONTINUE
C           GO TO 341
C347        NP1=NP2-NLAGP+1
C           GO TO 341
C348        NP2=NLAGP
C           NP1=1
C
 341        DAS=DZERO
            DO L=NP1,NP2
              DD=DONE
              DO M=NP1,NP2
                IF(L.NE.M)THEN
                  DD=DD*(TM-DYY(M))
                  DD=DD/(DYY(L)-DYY(M))
                ENDIF
              ENDDO
              DDY(L)=DD
            ENDDO
c          if(tm.lt.dyy(nax))then         !test forcing zero energy pi=0
c            do l=np1,np2
c              ddy(l)=ddy(l)*tm/dyy(l)
c            enddo
c          endif
C
            IF(TM.LT.DYY(NAX))XP0=D0PT35     !BETTER, BY COMP WITH EXACT
            DO M=NP1,NP2
              DAS=DAS+DDY(M)*DFOSS(M8,M,2)/DYY(M)**XP0
            ENDDO
C
 354        DFOSS(M8,I,1)=DAS*TM**XP0/TM**2    !N.B. TM=DYY(I)+DSHIFT(J)
C
          ENDDO
C
C   END LOOP OVER CONTINUUM ENERGIES
C
COLD      IF(DYY(1).EQ.DZERO.AND.DSHIFT(J).LT.DYY(2).AND.BLAG
COLD     X.and.mxe1.gt.1)
COLD     XDFOSS(M8,1,1)=DFOSS(M8,2,1)*(DONE+DYY(2)/DSHIFT(J))**D1PT5
C
          IF(NREL.GE.mxe1)THEN
COLD        DDD=DFOSS(M8,NREL,2)
COLD        IF(MN.EQ.-2)DDD=DDD/(DYY(NREL)+DSHIFT(J))**2
COLD        IF(MN.EQ.-1)DDD=DDD/(DYY(NREL)+DSHIFT(J))
            DDD=DFOSS(M8,NREL,1)
C
            if(mm.eq.m0.and.m0.gt.0)then
              DOSC(0,K,J)=DDD       !NO E SHIFT ON THIS (LENGTH) ELEMENT
              DOSC(0,J,K)=DZERO
            endif
            DOSC(mm,K,J)=DDD
            DOSC(mm,J,K)=DZERO
          ENDIF
c
c increment multipole
  829     mm=mm+2
c          if(mm.le.lp0.and.bindb(in,mm/2))then
          if(mm.le.lp0)then                        !for stupid compilers
            if(bindb(in,mm/2))then
              if(bjump2)then
                if(mm.gt.mkmax)go to 828               !already upscaled
                m8=nfoss(mm/2,k,j)
                go to 340
              else
                go to 339
              endif
            endif
          endif
C
C
  828   ENDDO                               ! *** END INNER ORBITAL LOOP
C
      ENDDO                                 ! *** END OUTER ORBITAL LOOP
C
C
      if(mxmm.gt.ixd09)then        !should not happen with ixd09=ixblm+2
        write(6,703)mxmm-2,mxmm
  703   format(/'*** full retardation restricted to lambda=',i2,'  set'
     x         ,' (ixd09=)ixblm+2=',i2,' to get full expansion.')
      endif
c
      IF(BBORN)THEN
        IF(NC.GT.IXD33)THEN                       !NO LONGER POSSIBLE...
          T=NC
          NU=NINT(SQRT(8*T+1))
          NU=(NU-1)/2
          WRITE(6,*)'**SR.RKINT DIMENSION ERROR: INCREASE MXGRB TO: '
     X             ,NU
          WRITE(0,*)'**SR.RKINT DIMENSION ERROR: INCREASE MXGRB'
          GO TO 999
        ELSE
          MB3(0)=NC
          MB4(0)=N
        ENDIF
        if(kutls.le.0)then                        !print alloc & usage
          if(bprnt0)write(6,*)'ixd34=',ixd34,'  usage=',n
          if(btime)write(0,*)'ixd34=',ixd34,'  usage=',n
        endif
        if(iflagb.gt.0)then                      !high multipole failure
          write(0,*)'*** attention: ',iflagb,' Born integrals were'
     x  ,' zeroed-out due to numerical inaccuracy - see olg file'
          write(6,*)'*** attention: ',iflagb,' Born integrals were'
     x  ,' zeroed-out due to numerical inaccuracy'
        endif
      ENDIF
C
      IF(BPRNT0)THEN
        WRITE(6,983)(QN(K),IHAR(K),K=1,KLAST)
        DO K=1,KLAST
          WRITE(6,982)QN(K),IHAR(K),(DOSC(0,K,J),J=1,KLAST)
        ENDDO
        IF(.NOT.BFOTJ)THEN
          WRITE(6,984)PIG
          m0=mpol00
          if(brel2)m0=m0-2
          if(m0.lt.0)m0=0
          DO M=m0,MPOLE,2
            MM=M/2
            WRITE(6,985)MM
            if(mm.gt.mkmax)then                            !all upscaled
              mxe1=1
            else
              mxe1=mxep+1
            endif
            md=mod(mm,itwo)
            DO K=1,KLAST
              DO J=1,K-1
                IF(mod(INT((QL(K)+QL(J))/2,SP),itwo).eq.md)THEN
                  M8=NFOSS(mm/2,K,J)    !AS NFOSS ASSUMES CORRECT PARITY
                  IF(M8.GT.0)THEN
                    WRITE(6,700)M8,J,K,(DFOSS(M8,I,1),I=1,MENG)
                    IF(QN(J).LT.0)WRITE(6,700)M8,J,K,
     X              (DFOSS(M8,I,2),I=1,mxe1-1)   !/(DYY(I)+DSHIFT(J))**2
                    M80=NFOSS(mm/2,J,K)
                    IF(M8*M80.NE.M80*M80)THEN
                      WRITE(6,700)M80,K,J,(DFOSS(M80,I,1),I=1,MENG)
                    ENDIF
                  ENDIF
                ENDIF
              ENDDO
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
  998 RETURN
C
  999 NF=-1
      GO TO 998
C
  699 FORMAT(I7,I5,I3,I4,I5,I4,I6,7F14.7,1X/(32X,7F14.7))
  700 FORMAT(I5,I8,I9,10X,1P,7E14.6,1X/(32X,7E14.6))
  704 FORMAT(/'   N(B)  NC B(A,  B,   C,  D, 2LBD)  = BORN-INTEGRALS')
  705 FORMAT('***STRONG WARNING: BORN MULTIPOLE EXPANSION MAY BE'
     X,' INCOMPLETE, SET KPOLE=',I3)
  706 FORMAT(/I2,'-',I2,' BORN MOMENTUM TRANSFERS:',1X,10(I3,1PE9.2)/
     X(31X,10(I3,E9.2)))
  707 FORMAT(/31X,7(7X,I3,'-',I3)/(31X,7(7X,I3,'-',I3)))
  905 FORMAT('***SR.RKINT: REDUCE NREL FOR FREE-FREE PI VEL GAUGE:',I4)
  982 FORMAT(I4,I2,(2X,15F8.4))
  983 FORMAT(/" DIPOLE LENGTH INTEGRALS (K=1, FOR /L-L'/=1)  AND"
     X," QUADRUPOLE (K=2) INTEGRALS  <NL! R**K !N'L'>; ('N**' STANDS"
     X," FOR: NL NOT COMPUTED)"/8X,"ABOVE THE DIAGONAL ARE VELOCITY"
     X," INTEGRALS <NL! 2*D/DR+(L'(L'+1)-L(L+1))/R !N'L'>      "
     X/3X,"N L",(2X,15(I3,I2,3X)))
  984 FORMAT(/12X,'A',8X,'C',14X,
     X' PHOTO-IONIZATION (2K-POLE) INTEGRALS; GAUGE=',A3,' :')
  985 FORMAT(/' K=',I2/)
C
      END SUBROUTINE RKINT
C
C                             *******************
C
      SUBROUTINE RKX(DP1,DP2,DQ1,DQ2,JJ,DPA,DP,DX,DPOLA,REM,ovlp,SUM)
C
C-----------------------------------------------------------------------
C
C  SR.RKX CALCULATES THE EIE SLATER INTEGRAL USING INPUT YK (DP),
C    INCLUDING ANY LONG-RANGE CONTRIBUTION. AND ANY EXHANGE OVERLAP.
C
C  IT CALLS:
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DP1(*),DP2(*),DQ1(*),DQ2(*),DPA(*),DP(*),DX(*)
C
      common /com1/dpot(maxb1),tol,mend
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBFR/GR(MAXB1)
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
C-----------------------------------------------------------------------
      DPOL1(X)=SQRT(DONE-EXP(-(X/RCAV)**6))/X**2
      DPOL2(X)=X/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
      BREL2=ABS(IREL).EQ.2
      IPOLF2=IPOLFN/10
      MI=ABS(JJ)/2
C
      IF(BREL2)THEN
        IF(JJ.GT.0)THEN
          DO I=1,MAXRS
            GR(I)=DP1(I)*DP2(I)+DQ1(I)*DQ2(I)
            DPA(I)=GR(I)*(DP(I)+REM*DX(I)**MI)
          ENDDO
        ELSE
          DO I=1,MAXRS
            GR(I)=DP1(I)*DP2(I)+DQ1(I)*DQ2(I)
            DPA(I)=GR(I)*DP(I)
          ENDDO
        ENDIF
      ELSE
        IF(JJ.GT.0)THEN
          DO I=1,MAXRS
            GR(I)=DP1(I)*DP2(I)
            DPA(I)=GR(I)*(DP(I)+REM*DX(I)**MI)
          ENDDO
        ELSE
          DO I=1,MAXRS
            GR(I)=DP1(I)*DP2(I)
            DPA(I)=GR(I)*DP(I)
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,DPA,SUM,MNH,DHNS,MJH,MAXRS)
c
      if(jj.eq.0)then
        if(ovlp.eq.dzero)then                                    !direct
ctest          call weddle(dzero,gr,ovlp0,mnh,dhns,mjh,maxrs)  !e.g.rlx2
          sum=sum+rem       !*ovlp0     !subtract any divergent monopole
        elseif(mort.ne.-3)then                                 !exchange
          call weddle(dzero,gr,ovlp0,mnh,dhns,mjh,maxrs)
          do i=1,maxrs
            dpa(i)=gr(i)*dpot(i)
          enddo
          call weddle(dzero,dpa,rem0,mnh,dhns,mjh,maxrs)
          rem0=-rem0/(dpot(maxrs)*dx(maxrs))          !a.u. per electron
c      write(6,*)ovlp*rem0,ovlp0*rem
          xovlp=ovlp*rem0+ovlp0*rem
          xovlp=xovlp/dtwo                                      !average
          sum=sum+xovlp
          ovlp=ovlp*ovlp0
        else
          ovlp=dzero
        endif
      endif
C
      IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN           !DIELECTRIC POLARIZATION
        IF(IPOLF2.EQ.1)THEN
          DO I=1,MAXRS
            DPA(I)=DPOL1(DX(I))*GR(I)
          ENDDO
        ELSEIF(IPOLF2.EQ.2)THEN
          DO I=1,MAXRS
            DPA(I)=DPOL2(DX(I))*GR(I)
          ENDDO
        ELSE
          STOP 'SR.RKX: HERE BE MONSTERS'
        ENDIF
        CALL WEDDLE(DZERO,DPA,DPOLB,MNH,DHNS,MJH,MAXRS)
c        write(0,*)(qrl(i,l),i=1,5),db,alav*dpola*dpolb
        SUM=SUM-ALAV*DPOLA*DPOLB
      ENDIF
C
      RETURN
C
      END SUBROUTINE RKX
C
C                             *******************
C
      SUBROUTINE ROMB(ID,BCF,L,R1,I1,F1,R2,I2,F2,VM,V0,V1,M0,S1,S2,S3,
     X                S4,S5,XBINT,XOINT,EB,EO,TOLR,TM2)
C
C-----------------------------------------------------------------------
C
C  SR.ROMB IMPLEMENTS A SINGLE STEP OF ROMBERG'S RULE.
C  (A. BURGESS, DAMTP, CAMBRIDGE)
C
C  IT CALLS:
C    SR.FILON
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      DIMENSION XBI(0:20),XOI(0:20),F1(0:*),F2(0:*)
      DIMENSION S1(0:*),S2(0:*),S3(0:*),S4(0:*),S5(0:*)
C
      X0=V0/(V0+VM)
      X1=V1/(V1+VM)
      X=X0
      V=V0
      K=0
C
  1   CALL FILON(L,V,R1,I1,F1,FB1,FO1)
      IF(BCF)THEN
        CALL FILON(L,V,R2,I2,F2,FB2,FO2)
      ELSE
        FB2=FB1
        FO2=FO1
      ENDIF
      T=V+VM
      T=T*T/VM
      T2=FB1*FB2*V
      IF(L.EQ.0)THEN
        T1=T2
        T2=FO1*FO2*V
      ELSE
        IF(L.GT.1)THEN
          T1=FB1*FB2*V**(L+L-3)
        ELSEIF(V.GT.D1M7)THEN
          T1=(FB1*FB2-TM2*VM/(V+VM))/V
        ELSE
          T1=TM2/VM
c        stop 'romb'
        ENDIF
        DO J=1,L
          T2=T2*V*V
        ENDDO
      ENDIF
C
      S1(K)=V
      S2(K)=FB1
      S3(K)=FB2
      S4(K)=T1
      S5(K)=T2
      IF(K.EQ.0)THEN
        XB0=T*T1
        XO0=T*T2
        X=X1
        V=V1
        K=ID
        GO TO 1
      ENDIF
      XB0=(T*T1+XB0)*DHALF
      XO0=(T*T2+XO0)*DHALF
      H=X1-X0
      XBI(0)=XB0*H
      XOI(0)=XO0*H
      SB=DZERO
      SO=DZERO
      M=0
C
  3   M=M+1
      H=H*DHALF
      X=X0-H
      N=2**(M-1)
      DO I=1,N
        X=X+H+H
        V=VM*X/(1-X)
        T=V+VM
        T=T*T/VM
        CALL FILON(L,V,R1,I1,F1,FB1,FO1)
        IF(BCF)THEN
          CALL FILON(L,V,R2,I2,F2,FB2,FO2)
        ELSE
          FB2=FB1
          FO2=FO1
        ENDIF
        T2=FB1*FB2*V
        IF(L.EQ.0)THEN
          T1=T2
          T2=FO1*FO2*V
        ELSE
          IF(L.GT.1)THEN
            T1=FB1*FB2*V**(L+L-3)
          ELSEIF(V.GT.D1M7)THEN
            T1=(FB1*FB2-TM2*VM/(V+VM))/V
          ELSE
            T1=TM2/VM
c         stop 'romb'
          ENDIF
          T2=FB1*FB2*V
          DO J=1,L
            T2=T2*V*V
          ENDDO
        ENDIF
        SB=T1*T+SB
         SO=T2*T+SO
        K=NINT(((X-X0)*ID)/(X1-X0))
        S1(K)=V
        S2(K)=FB1
        S3(K)=FB2
        S4(K)=T1
        S5(K)=T2
      ENDDO
C
      T0=XBI(0)
      XBI(0)=(XB0+SB)*H
      U0=XOI(0)
      XOI(0)=(XO0+SO)*H
      DO I=1,M
        T3=DONE/(2**(I+I)-1)
        T1=XBI(I-1)
        U1=XOI(I-1)
        T2=(T1-T0)*T3+T1
        U2=(U1-U0)*T3+U1
        T3=T0
        T0=XBI(I)
        XBI(I)=T2
        U3=U0
        U0=XOI(I)
        XOI(I)=U2
      ENDDO
C
      EB=ABS((T2-T3)/T2)
      EO=ABS((U2-U3)/U2)
C
c       write(77,*)m,t3,t2,eb
      IF(M.LT.M0.AND.EB.GT.TOLR)GO TO 3
c       write(77,*)m,v0,v1
C
      XBINT=T2
      XOINT=U2
C
      RETURN
C
      END SUBROUTINE ROMB
C
C                             *******************
C
      SUBROUTINE ROTSYM(N,NP,BEIVEC,C,S,IP,IQ,A,V,MXMAT)
C
C-----------------------------------------------------------------------
C
C  SR.ROTSYM EXECUTES A JACOBI ROTATION IN THE ROW IP AND THE COLUMN IQ
C  OF A AND V. C,S=COSINES,SINES OF THE ROTATION. THE RESULTS ARE AGAIN
C  IN A AND V. N,NP=ACTUAL DIMENSIONS OF A AND V,A(I,J),I=1,NP,J=1,N.
C  BEIVEC SEE SR.JACORD.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(MXMAT,MXMAT),V(MXMAT,MXMAT)
C
      H=A(IP,IQ)*S/C
      A(IP,IP)=A(IP,IP)-H
      A(IQ,IQ)=A(IQ,IQ)+H
C
      DO J=1,IP-1
        H=C*A(J,IP)-S*A(J,IQ)
        A(J,IQ)=S*A(J,IP)+C*A(J,IQ)
        A(J,IP)=H
      ENDDO
C
      DO J=IP+1,IQ-1
        H=C*A(IP,J)-S*A(J,IQ)
        A(J,IQ)=S*A(IP,J)+C*A(J,IQ)
        A(IP,J)=H
      ENDDO
C
      DO J=IQ+1,N
        H=C*A(IP,J)-S*A(IQ,J)
        A(IQ,J)=S*A(IP,J)+C*A(IQ,J)
        A(IP,J)=H
      ENDDO
C
      IF(.NOT.BEIVEC)RETURN
C
      DO J=1,NP
        H=C*V(J,IP)-S*V(J,IQ)
        V(J,IQ)=S*V(J,IP)+C*V(J,IQ)
        V(J,IP)=H
      ENDDO
C
      RETURN
C
      END SUBROUTINE ROTSYM
C
C***********************************************************************
C
      FUNCTION SINTER(N,XN,YN,X)
C
C-----------------------------------------------------------------------
C
C APPLY LAGRANGE INTERPOLATION IN COMPLEX PLANE TO TRIGONOMETRIC
C EXPANSION IN XN,YN FOR X IN INTERVAL [0:1].
C COULD ABSORB PI INTO XN ETC FOR SPEED.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION XN(*),YN(*)
C
      PI=ACOS(-DONE)
C
      P=0
      DO K=1,N
        A=0
        F=1
        DO M=1,N
          IF(M.NE.K)THEN
            A=A+XN(M)
            S=SIN(PI*(X-XN(M)))
            S=S/SIN(PI*(XN(K)-XN(M)))
            F=S*F
          ENDIF
        ENDDO
        IF(MOD(N,ITWO).EQ.0)F=F*SIN(PI*(X-A))/SIN(PI*(XN(K)-A))  !EVEN
        P=P+F*YN(K)
      ENDDO
C
      SINTER=P
C
      END FUNCTION SINTER
C
C                             *******************
C
      FUNCTION SJS(J1,J2,J3,L1,L2,L3,FCT)
C
C-----------------------------------------------------------------------
C
C  FN.SJS EVALUATES THE WIGNER 6J-SYMBOL:
C  THE SIX QUANTUM NUMBER ARGUMENTS HAVE TWICE THEIR PHYSICAL VALUE;
C  FACTORIALS MUST BE SUPPLIED BY FCT(I)=(I/2-1)!/32**(I/2-1),I=4,M,2
C  (FCT(2)=0!=1), AND PHASE FACTORS BY FCT(I)=MOD(I+1,4)-1,I=1,MXDFS,2.
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION FCT(MXDFS)
C
      OMEGA=DZERO
C
      IF(J1+J2.LT.J3)GO TO 700
      IF(J1+L2.LT.L3)GO TO 700
      IF(J2+L3.LT.L1)GO TO 700
      IF(J3+L1.LT.L2)GO TO 700
C
      IF(ABS(J1-J2).GT.J3)GO TO 700
      IF(ABS(J1-L2).GT.L3)GO TO 700
      IF(ABS(J2-L3).GT.L1)GO TO 700
      IF(ABS(J3-L1).GT.L2)GO TO 700
C
      IJ0=J1+J2+J3+2
      IJ1=J1+L2+L3+2
      IJ2=L1+J2+L3+2
      IJ3=L1+L2+J3+2
      IF(MOD(IJ0,ITWO)+MOD(IJ1,ITWO)+MOD(IJ2,ITWO)+MOD(IJ3,ITWO).NE.0)
     X   GO TO 700
      IWMIN=MAX(IJ0,IJ1,IJ2,IJ3)+2
C
      ID1=IJ0+IJ1-J1-J1+2
      ID2=IJ0+IJ2-J2-J2+2
      ID3=IJ0+IJ3-J3-J3+2
      IWMAX=MIN(ID1,ID2,ID3)-2
C
      IF(IWMAX.LT.IWMIN)GO TO 700
      CALL DIMUSE('MXDFS',IWMAX)
      IF(IWMAX.GT.MXDFS)THEN       !SHOULD NOT HAPPEN, CHECKED IN ALGEB0
        WRITE(6,703)IWMAX
        WRITE(0,*)'FN.SJS: FACTORIAL ARRAY TOO SHORT'
        GO TO 700
      ENDIF
C
      DO IW=IWMIN,IWMAX,2
        OMEGA=-FCT(IW-1)*FCT(IW)/(FCT(ID1-IW)*FCT(ID2-IW)*FCT(ID3-IW)*
     X         FCT(IW-IJ0)*FCT(IW-IJ1)*FCT(IW-IJ2)*FCT(IW-IJ3))+OMEGA
      ENDDO
C
      IJ0=IJ0+2
      IJ1=IJ1+2
      IJ2=IJ2+2
      IJ3=IJ3+2
      OMEGA=OMEGA*SQRT(
     X     (FCT(ID1-IJ0)*FCT(ID2-IJ0)*FCT(ID3-IJ0)/FCT(IJ0))*
     X     (FCT(ID1-IJ1)*FCT(ID2-IJ1)*FCT(ID3-IJ1)/FCT(IJ1))*
     X     (FCT(ID1-IJ2)*FCT(ID2-IJ2)*FCT(ID3-IJ2)/FCT(IJ2))*
     X     (FCT(ID1-IJ3)*FCT(ID2-IJ3)*FCT(ID3-IJ3)/FCT(IJ3)))/16
C
 700  SJS=OMEGA
C
      RETURN
C
 703  FORMAT('FN.SJS: FACTORIAL ARRAY TOO SHORT; INCREASE TO GREATER'
     X,' THAN',I5)
C
      END FUNCTION SJS
C
C                             *******************
C
      SUBROUTINE SLATRI(ICOUNT,N,KK)
C
C-----------------------------------------------------------------------
C
C  SR.SLATRI CALCULATES SLATER INTEGRALS INVOLVING CONTINUUM FUNCTIONS
C  (ORBITAL N) AT THE ICOUNT'TH INTERPOLATION ENERGY, INDEXED BY KK,
C  AND (IF BKUTOO) 2-BODY NON-FINE STRUCTURE INTEGRALS.
C
C  IT CALLS:
C    SR.ASSX
C    SR.ASS2X
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C    FN.ELAM
C    FN.XTWO
C    FN.ZLAM
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: QRL,IRL
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2,IXFSL
      USE COMMON_NRBNFI, ONLY: DZLI,DXTWOI,DETAI,FRI,GRI
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DL2(MAXB1),TOL,MDMM
      COMMON /COM3/DDUM,DZDUM,TM       !TM IS STILL USED BELOW
      COMMON /COM4/DUM4(MAXB1)
      COMMON /COM6/DA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBFR/DP(MAXB1)
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
C
      SAVE DEHLD
C
C-----------------------------------------------------------------------
      DPOL1(X)=SQRT(DONE-EXP(-(X/RCAV)**6))/X**2
      DPOL2(X)=X/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
      PI=ACOS(-DONE)
      PIH=PI/DTWO
C
      BREL2=ABS(IREL).EQ.2
      BORT=MORT.LT.0
      BKUTOO=KUTOO.NE.0
      IPOLF2=IPOLFN/10
      MDEN10=MOD(MDEN,ITEN)
      MXRM=MAXRS-1
C
      DRY=DYY(ICOUNT)*DTWO
C
      DM=DZERO
      DD=DZERO
      DZA=MION-NZION-1
C
      IF(BKUTOO)THEN                 !SWAP CONTINUUM FR->DPNL
        IF(ICOUNT.EQ.1.OR.NREL.EQ.1.AND.ICOUNT.EQ.2)THEN!BACK-UP NREL'TH
          DEHLD=DEY(N)
          DEY(N)=DRY/DTWO
          DO I=1,MAXRS
            FRI(I)=DPNL(I,N)
            DPNL(I,N)=FR(I)
            GRI(I)=DQNL(I,N)
            DQNL(I,N)=GR(I)
          ENDDO
        ELSE                         !JUST LOAD NEW CONTINUUM
          DEY(N)=DRY/DTWO
          DO I=1,MAXRS
            DPNL(I,N)=FR(I)
            DQNL(I,N)=GR(I)
          ENDDO
        ENDIF
      ENDIF
C
      DO 102 J=1,IRL
C
        KP=NRLI(J)
C  ****TEST                                       108
        IF(KP.GT.0)then                   !.AND. for stupid compilers
          if(DRLI(ICOUNT,KP).NE.DZERO)GO TO 102
        endif
        IF(QRL(5,J).GT.2*MAXLAM)GO TO 102
        N1=QRL(1,J)
C
C FALLING ORDER MEANS THAT IF 'A' IS NOT *THE* CONTINUUM ORBITAL N
C THEN NEITHER IS 'B,C OR D'.  SLATER INTEGRAL (A,B,C,D)
C
        IF(N1.NE.N)GO TO 102
        N2=QRL(3,J)
        IF(IYY(N2).GT.0.AND.MODE.LE.2)GO TO 102
C
        IF(QRL(5,J).GE.0)GO TO 103
C
C ONE-BODY INTEGRALS
C
        IF(.NOT.BLAG)GO TO 325
        IF(.NOT.BORT)GO TO 83
        IF(BREL2)GO TO 83                                          !BREL
        IF(MORT.EQ.-3.AND.BREL)GO TO 83
C
        DO I=1,MAXRS
          DP(I)=DQNL(I,N2)*FR(I)
        ENDDO
        IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN!PERT DH1
          DO I=1,MAXRS
            T=EXP(-DX(I)/DEBYE)
            DP(I)=DP(I)+DTWO*DPNL(I,N2)*FR(I)*(DONE-T)*DZ/DX(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DP(I)=DP(I)-DTWO*DPNL(I,N2)*FR(I)*VSC(I)
          ENDDO
        ENDIF
        IF(MPSEUD.NE.0)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)+DTWO*DPNL(I,N2)*FR(I)*(DZ/DX(I)-POTHAM(I))
          ENDDO
        ENDIF
        GO TO 57
C
  83    IF(BREL2)THEN
          DO I=1,MAXRS
            DP(I)=(DPNL(I,N2)*FR(I)+DQNL(I,N2)*GR(I))*DL2(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DP(I)=DPNL(I,N2)*FR(I)*DL2(I)
          ENDDO
        ENDIF
        IF((MDEN.EQ.11.OR.MDEN.EQ.1.AND.NPITER.LT.0)
     X                                  .AND.DENE.GT.DZERO)THEN!PERT DH1
          DO I=1,MAXRS
            T=EXP(-DX(I)/DEBYE)
            DP(I)=DP(I)+DTWO*DP(I)*((DONE-T)*DZ/DX(I)+VSC(I))/DL2(I)
          ENDDO
C        ELSEIF(MDEN10.EQ.2)THEN                           !IS NO 2-BODY
        ENDIF
        IF(MPSEUD.NE.0)THEN
          DO I=1,MAXRS
            DP(I)=DP(I)+DTWO*DP(I)*(DZ/DX(I)-POTHAM(I))/DL2(I)
          ENDDO
        ENDIF
C
  57    CALL WEDDLE(DM,DP,DD,MNH,DHNS,MJH,MAXRS)
C
  325   IF(KP.LE.0)THEN
          KK=KK+1
          IF(KK.GT.IXFSL)GO TO 102
          KP=KK
          NRLI(J)=KK
        ENDIF
C
        DRLI(ICOUNT,KP)=DD/DTWO
C
        GO TO 102                                      ! ****  TEST  108
C
C TWO-BODY INTEGRALS
C
  103   BCALC=.FALSE.
        MJ=(QL(N1)+QL(N2))/2+2
        JJ=QRL(5,J)
        MI=JJ/2
C
        DO  L=J,IRL                                    !START YLAMK LOOP
C
          IF(QRL(1,L).NE.N1)GO TO 104
          IF(QRL(3,L).NE.N2)GO TO 104
          IF(QRL(5,L).NE.JJ)GO TO 104
          M1=QRL(2,L)
          IF(IYY(M1).GT.0.AND.MODE.LE.2)GO TO 104
          IF(.NOT.BLAG)GO TO 326
          M2=QRL(4,L)
C
          IF(BCALC)GO TO 105
          BCALC=.TRUE.
C
C CALCULATE YLAMDA
C
          IF(BREL2)THEN
            DO I=1,MAXRS
              DP(I)=FR(I)*DPNL(I,N2)+GR(I)*DQNL(I,N2)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DP(I)=FR(I)*DPNL(I,N2)
            ENDDO
          ENDIF
C
          IF(BREL)THEN
            DEL=DEY(N2)-DUY(N2,N2)-DRY/DTWO                 ! A.U.
            CALL YLAMKR(MI,MJ,DEL,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
          ELSE
            CALL YLAMK(MI,MJ,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
          ENDIF
C
          IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN       !DIELECTRIC POLARIZATION
            IF(IPOLF2.EQ.1)THEN
              DO I=1,MAXRS
                DP(I)=DPOL1(DX(I))*DP(I)          !DPNL(I,N1)*DPNL(I,N2)
              ENDDO
            ELSEIF(IPOLF2.EQ.2)THEN
              DO I=1,MAXRS
                DP(I)=DPOL2(DX(I))*DP(I)          !DPNL(I,N1)*DPNL(I,N2)
              ENDDO
            ELSE
              STOP 'SR.SLATRI: HERE BE MONSTERS - 1'
            ENDIF
            CALL WEDDLE(DM,DP,DPOLA,MNH,DHNS,MJH,MAXRS)
          ENDIF
C
          REM=DZERO
          IF(MI.EQ.0.OR.QN(N2).GT.0)GO TO 105
C
C LONG-RANGE INTEGRAL LAMBDA .GT. 0
C
          DX1=DX(MAXRS)
          DT=DX(MAXRS)-DX(MXRM)
          DD=FR(MXRM)
          TN=FR(MAXRS)
          DD1=DPNL(MXRM,N2)
          DD2=DPNL(MAXRS,N2)
          DE=DRY
          ML1=QL(N1)/2
          DS=ML1*(ML1+1)
          ML2=QL(N2)/2
          DC=ML2*(ML2+1)
          MN=-MI-1
C
          CALL ASS2X(DX1,DT,DX2,DD,TN,DD1,DD2,DE,DM,DS,DC,DM,DM,DM,DM
     X              ,DZA,MN,REM2)
C
          TN=SCREEN(N2)
C
          CALL ASSX(DX2,MN,TM,TN,DE,DM,DZA,ML1,ML2,DS,DC,DM,DM,DM,DM
     X             ,REM)
C
          DNORM=-QN(N2)
          DNORM=DNORM-TN
          DNORM=DZA*DZA/(PIH*DNORM**3)
          DNORM=SQRT(DNORM)
c          dnorm=1           !<<<<<<<<<<<<<<<<<<<<<<<<<<<<TEST CONT-CONT
          REM=REM*DNORM
C
C****TEST
C     IF(BREL2)THEN
C       DO I=1,MAXRS
C         DP(I)=(FR(I)*DPNL(I,N2)+GR(I)*DQNL(I,N2))*DX(I)**MN
C       ENDDO
C     ELSE
C       DO I=1,MAXRS
C         DP(I)=FR(I)*DPNL(I,N2)*DX(I)**MN
C       ENDDO
C     ENDIF
C     CALL WEDDLE(DM,DP,DD,MNH,DHNS,MJH,MAXRS)
C      SUM=DD+REM2+REM
C     WRITE(6,1111)DD,DX1,REM2,DX2,REM,SUM
C1111 FORMAT(6F12.6)
C
          REM=REM2+REM
C
C CALCULATE SLATER INTEGRAL
C
  105     IF(BREL2)THEN
            DO I=1,MAXRS
              DUM4(I)=DPNL(I,M1)*DPNL(I,M2)+DQNL(I,M1)*DQNL(I,M2)
              DP(I)=DUM4(I)*(DA(I)+REM*DX(I)**MI)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DUM4(I)=DPNL(I,M1)*DPNL(I,M2)
              DP(I)=DUM4(I)*(DA(I)+REM*DX(I)**MI)
            ENDDO
          ENDIF
C
          CALL WEDDLE(DM,DP,DD,MNH,DHNS,MJH,MAXRS)
C
          DD=DD*SCALER                        !COWAN SLATER SCALE FACTOR
C
          IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN       !DIELECTRIC POLARIZATION
            IF(IPOLF2.EQ.1)THEN
              DO I=1,MAXRS
                DP(I)=DPOL1(DX(I))*DUM4(I)       !DPNL(I,M1)*DPNL(I,M2)
              ENDDO
            ELSEIF(IPOLF2.EQ.2)THEN
              DO I=1,MAXRS
                DP(I)=DPOL2(DX(I))*DUM4(I)       !DPNL(I,M1)*DPNL(I,M2)
              ENDDO
            ELSE
              STOP 'SR.SLATRI: HERE BE MONSTERS - 2'
            ENDIF
            CALL WEDDLE(DM,DP,DPOLB,MNH,DHNS,MJH,MAXRS)
c            write(0,*)icount,(qrl(i,l),i=1,5),dd,alav*dpola*dpolb
            DD=DD-ALAV*DPOLA*DPOLB
          ENDIF
C
C
  326     KP=NRLI(L)
          IF(KP.LE.0)THEN
            KK=KK+1
            IF(KK.GT.IXFSL)GO TO 104
            KP=KK
            NRLI(L)=KK
          ENDIF
C
          DRLI(ICOUNT,KP)=DD
C
C  EVALUATE TWO-BODY NON-FINE-STRUCTURE INTEGRALS, CONVERT ZL,X2 TO A.U.
C
          IF(BKUTOO)THEN
            DZLI(ICOUNT,KP)=DZERO
            DXTWOI(ICOUNT,KP)=DZERO
            DETAI(ICOUNT,KP)=DZERO
            IF(KUTOO.NE.88)DXTWOI(ICOUNT,KP)=XTWO(MI,N1,M1,N2,M2)
            IF(KUTOO.NE.99)THEN
              DZLI(ICOUNT,KP)=ZLAM(MI,N1,M1,N2,M2)
              IF(KUTOO.LT.98)DETAI(ICOUNT,KP)=ELAM(MI,N1,M1,N2,M2)
            ENDIF
            DZLI(ICOUNT,KP)=DZLI(ICOUNT,KP)/DTWO
            DXTWOI(ICOUNT,KP)=DXTWOI(ICOUNT,KP)/DTWO  !  /DONE     JONES
          ENDIF
C
  104   ENDDO                                            !END YLAMK LOOP
C
C
C **TEST PRINT
C 108 KP=NRLI(J)
C     WRITE(6,701)J,(QRL(I,J),I=1,5),DRLI(ICOUNT,KP)
C 701 FORMAT(I5,3X,2(I4,I5),I6,F14.7)
C
C
  102 ENDDO                                    !END SLATER INTEGRAL LOOP
C
      IF(BKUTOO)THEN              !SWAP CONTINUUM BACK, IF LAST TIME
        IF(ICOUNT.EQ.MENG.OR.NREL.EQ.MENG.AND.ICOUNT.EQ.MENG-1)THEN
          DEY(N)=DEHLD
          DO I=1,MAXRS
            DPNL(I,N)=FRI(I)
            DQNL(I,N)=GRI(I)
          ENDDO
        ENDIF
      ENDIF
C
      RETURN
C
      END SUBROUTINE SLATRI
C
C                             *******************
C
      SUBROUTINE SLATR(BPRNT0)
C
C-----------------------------------------------------------------------
C
C  SR.SLATR EVALUATES SLATER INTEGRALS AND (IF BKUTOO)
C  2-BODY NON-FINE STRUCTURE INTEGRALS.
C
C  THE FOUR ELECTRON-ARGUMENTS (1,2,3.. FOR 1S,2S,2P..) HAVE BEEN
C  STORED IN QRL(I,L),I=1,4, AND 2*LAMBDA IN QRL(5,L).
C
C  IT CALLS:
C    SR.ASSX
C    SR.ASS2X
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C    FN.ELAM
C    FN.XTWO
C    FN.ZLAM
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: QRL,IRL,NAD
      USE COMMON_INTS,   ONLY: DRL
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2,IXFSL
      USE COMMON_NRBNF2, ONLY: DETA,DXSI,DZL,DXTWO
      USE COMMON_NRBNFI, ONLY: DZLI,DXTWOI,DETAI,FRI,GRI
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD12=100)
C
      PARAMETER (PIH=1.5707963D0)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM4/DUM4(MAXB1)
      COMMON /COM6/DPA(MAXB1)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBCOW/SCALER,ISCALR
      COMMON /NRBDR/IDR,NMIN,NMAX,NS0,NSX,NSW,NRAD,JND,NDR(MXD12)
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSHF/DSHIFT(MAXGR),MSHIFT,KSHIFT,MKMAX,MXEP
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
C-----------------------------------------------------------------------
      DPOL1(X)=SQRT(DONE-EXP(-(X/RCAV)**6))/X**2
      DPOL2(X)=X/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
      BREL2=ABS(IREL).EQ.2
      BDR=IDR.NE.0
      BKUTOO=KUTOO.NE.0
      BCONT=MODE.EQ.2.OR.MODE.EQ.3
C
      DZA=MION-NZION-1
      MXRM=MAXRS-1
C
      IF(BPRNT0)THEN
        IF(ABS(SCALER-DONE).GT.D1M8)WRITE(6,555)SCALER
        IF(KUTOO.EQ.0)WRITE(6,300)
        IF(KUTOO.NE.0)WRITE(6,302)
      ELSEIF(ISCALR.GT.0)THEN
        WRITE(6,555)SCALER
      ENDIF
C
      IF(BJUMP)THEN                 !JUST RE-COMPUTE OR RE-SCALE RYDBERG
C
        DO J=1,IRL
          M=0
          TM=DONE
          DO I=1,4
            N=QRL(I,J)
            IF(N.GT.0)THEN
              M=M+IVAL(N)
              TM=TM*FACT(N)
            ENDIF
          ENDDO
          IF(BCONT)THEN
            KK=NRLI(J)
          ELSE
            KK=0
          ENDIF
          IF(M.GT.0)THEN
            IF(BJUMP2)THEN
              DRL(J)=DRL(J)*TM      !RE-SCALE
              IF(BKUTOO)THEN
                DZL(J)=DZL(J)*TM
                DXTWO(J)=DXTWO(J)*TM
                DETA(J)=DETA(J)*TM
              ENDIF
              IF(KK.GT.0)THEN
                DO I=1,MENG
                  DRLI(I,KK)=DRLI(I,KK)*TM
                ENDDO
                IF(BKUTOO)THEN
                  DO I=1,MENG
                    DZLI(I,KK)=DZLI(I,KK)*TM
                    DXTWOI(I,KK)=DXTWOI(I,KK)*TM
                    DETAI(I,KK)=DETAI(I,KK)*TM
                  ENDDO
                ENDIF
              ENDIF
            ELSE
              DRL(J)=DZERO          !ZERO-OUT FOR RE-COMPUTE (+2NFS)
            ENDIF
          ENDIF
C
          IF(BJUMP2.AND.BPRNT0)THEN
            IF(KK.EQ.0)WRITE(6,700)J,(QRL(I,J),I=1,5),DRL(J)
            IF(KK.GT.0)WRITE(6,700)J,(QRL(I,J),I=1,5)
     X                              ,(DRLI(IC,KK),IC=1,MENG)
            IF(BKUTOO)THEN
              IF(KK.EQ.0)WRITE(6,703)DXTWO(J),DZL(J),DETA(J)
              IF(KK.GT.0)THEN
                WRITE(6,703)(DXTWOI(IC,KK),IC=1,MENG)
                WRITE(6,703)(DZLI(IC,KK),IC=1,MENG)
                WRITE(6,703)(DETAI(IC,KK),IC=1,MENG)
              ENDIF
            ENDIF
          ENDIF
        ENDDO
C
        IF(BJUMP2)GO TO 805                                      !RETURN
C
      ELSE                                 !INITIALIZE AND COMPUTE *ALL*
C                                          !2-NFS DO NOT NEED SEPARATE
        DO  L=1,IRL
          DRL(L)=DZERO
        ENDDO
C
        IF(MODE.EQ.4)THEN
          KK=0
          DO J=1,IRL
            IF(QRL(5,J).GT.2*MAXLAM)GO TO 837
            N1=QRL(1,J)
            N3=QRL(3,J)
            IF(IYY(N1)*IYY(N3).GT.0)GO TO 837
            N2=QRL(2,J)
            IF(QRL(5,J).GT.0.AND.IYY(N2).GT.0)GO TO 837
            KK=KK+1
            IF(KK.LE.IXFSL)NRLI(J)=KK
  837     ENDDO
C
          IF(KK.GT.IXFSL)THEN
            WRITE(6,252)KK
            NF=-1
            GO TO 805
          ENDIF
        ENDIF
      ENDIF
C
C OUTER LOOP TO DETERMINE SLATER INETGRALS
C
      BXTRP=.FALSE.
      DD=DZERO
      IPOLF2=IPOLFN/10
C
      DO J=1,IRL
C
        IF(DRL(J).NE.DZERO)GO TO 814
        IF(QRL(5,J).GT.2*MAXLAM)GO TO 814
        N1=QRL(1,J)
        N2=QRL(3,J)
        IF(N2.LE.ABS(MPSEUD))GO TO 814
        IF(QRL(5,J).GE.0)GO TO 823
C
        DRL(J)=DUY(N1,N2)                             !TRANSFER ONE-BODY
        IF(BKUTOO)THEN
          DZL(J)=DZERO
          DXTWO(J)=DZERO
          DETA(J)=DZERO
        ENDIF
        IF(BCONT)THEN
          KK=NRLI(J)
        ELSE
          KK=0
        ENDIF
        IF(KK.GT.0)THEN
          IF(IRLX.EQ.2)THEN
            KF=IGRCF(N1)
            KG=IGRCF(N2)
            IF(KF*KG.GT.0)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KKK=((K2-1)*(K2-2))/2+K1
              OVL=OVLPCF(KKK)
              DO I=1,MENG
                DRLI(I,KK)=DRLI(I,KK)*OVL
              ENDDO
            ENDIF
          ENDIF
          DRLI(NREL,KK)=DRL(J)
          IF(BKUTOO)THEN
            DO I=1,MENG
              DZLI(I,KK)=DZERO
              DXTWOI(I,KK)=DZERO
              DETAI(I,KK)=DZERO
            ENDDO
          ENDIF
        ENDIF
        GO  TO 814
C
C  MODE=2 SETS ALL SLATER INTEGRALS WITH MORE THAN ONE CONTINUUM
C  ORBITAL TO ZERO, EXCEPT FOR BOUND ORBITALS APPROXIMATED  BY A K=0
C  CONTINUUM ORBITAL. LONG-RANGE INTEGRALS DEALT WITH USING AMPLITUDE
C  -PHASE METHOD OF BURGESS & SHEOREY (1974 J.PHYS.B)  AND BADNELL
C  (1983 J.PHYS.B AND UNPUBLISHED).
C
  823   IF(MODE.GT.2)GO TO 610
        IF(IYY(N2).GT.0)GO TO 814            !MAKES USE OF FALLING ORDER
        BXTRP=.FALSE.
        IF(QN(N1).GT.0.OR.QN(N2).GT.0)GO TO 610
        BXTRP=.TRUE.
        IF(IYY(N1).GT.0)GO TO 610            !MAKES USE OF FALLING ORDER
C       IF(N1.NE.N2)GO TO 814
C
  610   IF(BREL2)THEN
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N1)*DPNL(I,N2)+DQNL(I,N1)*DQNL(I,N2)
          ENDDO
        ELSE
          DO I=1,MAXRS
            DPA(I)=DPNL(I,N1)*DPNL(I,N2)
          ENDDO
        ENDIF
C
        M2=(QL(N1)+QL(N2))/2+2
        JJ=QRL(5,J)
        MI=JJ/2
C
        IF(BREL)THEN
          DEL=DEY(N1)-DUY(N1,N1)-(DEY(N2)-DUY(N2,N2))             ! A.U.
          CALL YLAMKR(MI,M2,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,IZERO)
        ELSE
          CALL YLAMK(MI,M2,DPA,DP,DD1,DD2,MNH,DHNS,MJH,IZERO)
        ENDIF
C
        IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN         !DIELECTRIC POLARIZATION
          IF(IPOLF2.EQ.1)THEN
            DO I=1,MAXRS
              DPA(I)=DPOL1(DX(I))*DPA(I)          !DPNL(I,N1)*DPNL(I,N2)
            ENDDO
          ELSEIF(IPOLF2.EQ.2)THEN
            DO I=1,MAXRS
              DPA(I)=DPOL2(DX(I))*DPA(I)          !DPNL(I,N1)*DPNL(I,N2)
            ENDDO
          ELSE
            STOP 'SR.SLATR: HERE BE MONSTERS - 1'
          ENDIF
          CALL WEDDLE(DD,DPA,DPOLA,MNH,DHNS,MJH,MAXRS)
        ENDIF
C
        REM=DZERO
        IF(.NOT.BXTRP.OR.MI.EQ.0)GO TO 205
C
C  EVALUATE LONG-RANGE INTEGRAL
C
        DTH=DX(MAXRS)-DX(MXRM)
        DD1=DPNL(MXRM,N1)
        DD2=DPNL(MAXRS,N1)
        DD3=DPNL(MXRM,N2)
        DD4=DPNL(MAXRS,N2)
        DX1=DX(MAXRS)
        TM=SCREEN(N1)
        TN=SCREEN(N2)
        DB=DTWO*DYY(NREL)
        IF(.NOT.BDR)DB=DB+DSHIFT(N1)*DTWO
        DS=DONE
        IF(IYY(N1).LT.0)THEN
          DB=DZERO
          DS=-QN(N1)
          DS=DS-TM
          DS=DZA*DZA/(PIH*DS**3)
        ENDIF
        DC=-QN(N2)
        DC=DC-TN
        DC=DZA*DZA/(PIH*DC**3)
        DNORM=DS*DC
        DNORM=SQRT(DNORM)
c        dnorm=1             !<<<<<<<<<<<<<<<<<<<<<<<<<<<<TEST CONT-CONT
        ML1=QL(N1)/2
        DS=ML1*(ML1+1)
        ML2=QL(N2)/2
        DC=ML2*(ML2+1)
        MN=-MI-1
C
        CALL ASS2X(DX1,DTH,DX2,DD1,DD2,DD3,DD4,DB,DD,DS,DC,DD,DD,DD,DD
     X            ,DZA,MN,REM2)
C
        CALL ASSX(DX2,MN,TM,TN,DB,DD,DZA,ML1,ML2,DS,DC,DD,DD,DD,DD,REM)
C
        REM=REM*DNORM
C
C        SUM=REM2+REM
C        WRITE(6,1111)DX1,REM2,DX2,REM,SUM
C1111    FORMAT(5F12.6)
C
        REM=REM2+REM
C
C INNER LOOP OVER ALL INTGERALS UTILIZING THIS YLAMK
C
 205    DO L=J,IRL
C
          IF(QRL(1,L).NE.N1)GO TO 815
          IF(QRL(3,L).NE.N2)GO TO 815
          IF(QRL(5,L).NE.JJ)GO TO 815
          M1=QRL(2,L)
          M2=QRL(4,L)
          IF(M2.LE.ABS(MPSEUD))GO TO 815
          IF(MODE.GT.2)GO TO 611
          IF(IYY(M1).GT.0)GO TO 815
C
C  IF(QN(N1).GT.0.OR.IYY(N1).GT.0  )GO TO 611
C  IF(QN(N2).GT.0.AND.QN(M1).GT.0)GO TO 815
C
C  CONT-CONT AGAIN
C
  611     IF(BREL2)THEN
            DO I=1,MAXRS
              DUM4(I)=DPNL(I,M1)*DPNL(I,M2)+DQNL(I,M1)*DQNL(I,M2)
              DPA(I)=DUM4(I)*(DP(I)+REM*DX(I)**MI)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DUM4(I)=DPNL(I,M1)*DPNL(I,M2)
              DPA(I)=DUM4(I)*(DP(I)+REM*DX(I)**MI)
            ENDDO
          ENDIF
C
          CALL WEDDLE(DD,DPA,DB,MNH,DHNS,MJH,MAXRS)
C
          DB=DB*SCALER                        !COWAN SLATER SCALE FACTOR
C
          IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN       !DIELECTRIC POLARIZATION
            IF(IPOLF2.EQ.1)THEN
              DO I=1,MAXRS
                DPA(I)=DPOL1(DX(I))*DUM4(I)       !DPNL(I,M1)*DPNL(I,M2)
              ENDDO
            ELSEIF(IPOLF2.EQ.2)THEN
              DO I=1,MAXRS
                DPA(I)=DPOL2(DX(I))*DUM4(I)       !DPNL(I,M1)*DPNL(I,M2)
              ENDDO
            ELSE
            STOP 'SR.SLATR: HERE BE MONSTERS - 2'
            ENDIF
            CALL WEDDLE(DD,DPA,DPOLB,MNH,DHNS,MJH,MAXRS)
c            write(0,*)(qrl(i,l),i=1,5),db,alav*dpola*dpolb
            DB=DB-ALAV*DPOLA*DPOLB
          ENDIF
C
          OVL=DONE
          IF(IRLX.EQ.2)THEN     !OVERLAPS
            KF=IGRCF(N1)
            KG=IGRCF(N2)
            IF(KG.EQ.0)KG=IGRCF(M1)
            IF(KF.NE.KG.AND.KG.GT.0)THEN
              K1=MIN(KF,KG)
              K2=MAX(KF,KG)
              KK=((K2-1)*(K2-2))/2+K1
              OVL=OVLPCF(KK)
              IF(IPAIR(KK).EQ.1)THEN   !SURELY THIS CAN BE SIMPLIFIED...
                IF(IEQ(N1).EQ.IEQ(N2))THEN
                  K=((N1-1)*(N1-2))/2+N2
                ELSEIF(IEQ(M1).EQ.IEQ(M2))THEN
                  IF(IGRCF(M1).EQ.0)GO TO 612
                  K=((M1-1)*(M1-2))/2+M2
                ELSEIF(KF.NE.IGRCF(M1))THEN
                  IF(IEQ(N1).EQ.IEQ(M1))THEN
                    K=((N1-1)*(N1-2))/2+M1
                  ELSEIF(IEQ(M2).EQ.IEQ(N2))THEN
                    IF(IGRCF(M2).EQ.0)GO TO 612
                    K1=MIN(M2,N2)
                    K2=MAX(M2,N2)
                    K=((K2-1)*(K2-2))/2+K1
                  else
                    write(6,*)'slater: why are we here?',
     x                        kf,kg,n1,m1,n2,m2
                    write(0,*)'slater: why are we here?'
                    nf=-1
                    go to 805                                    !return
                  ENDIF
                ELSE
                  IF(IEQ(N1).EQ.IEQ(M2))THEN
                    K=((N1-1)*(N1-2))/2+M2
                  ELSEIF(IEQ(M1).EQ.IEQ(N2))THEN
                    K1=MIN(M1,N2)
                    K2=MAX(M1,N2)
                    K=((K2-1)*(K2-2))/2+K1
                  else
                    write(6,*)'slater: why are we here?',
     x                        kf,kg,n1,m1,n2,m2
                    write(0,*)'slater: why are we here?'
                    nf=-1
                    go to 805                                    !return
                  ENDIF
                ENDIF
                OVL=OVL/OVLPGR(K)
              ENDIF
            ENDIF
          ENDIF
C
 612      DRL(L)=DB*OVL
C
          IF(BCONT)THEN                               !BOUND-CONT INTERP
            KK=NRLI(L)
            IF(KK.GT.0)THEN
              IF(IRLX.EQ.2)THEN
                DO I=1,MENG
                  DRLI(I,KK)=DRLI(I,KK)*OVL
                ENDDO
              ENDIF
              DRLI(NREL,KK)=DRL(L)
            ENDIF
          ELSE
            KK=0
          ENDIF
C
C  EVALUATE TWO-BODY NON-FINE-STRUCTURE INTEGRALS, CONVERT ZL,X2 TO A.U.
C
          IF(BKUTOO)THEN
            DZL(L)=DZERO
            DXTWO(L)=DZERO
            DETA(L)=DZERO
            IF(KUTOO.NE.88)DXTWO(L)=XTWO(MI,N1,M1,N2,M2)*OVL
            IF(KUTOO.NE.99)THEN
              DZL(L)=ZLAM(MI,N1,M1,N2,M2)*OVL
              IF(KUTOO.LT.98.OR.L.LE.NAD(0))DETA(L)=ELAM(MI,N1,M1,N2,M2)
     X                                             *OVL
            ENDIF
            DZL(L)=DZL(L)/DTWO
            DXTWO(L)=DXTWO(L)/DTWO
C JONES                       DONE
            IF(KK.GT.0)THEN
              IF(IRLX.EQ.2)THEN
                DO I=1,MENG
                  DZLI(I,KK)=DZLI(I,KK)*OVL
                  DXTWOI(I,KK)=DXTWOI(I,KK)*OVL
                  DETAI(I,KK)=DETAI(I,KK)*OVL
                ENDDO
              ENDIF
              DZLI(NREL,KK)=DZL(L)
              DXTWOI(NREL,KK)=DXTWO(L)
              DETAI(NREL,KK)=DETA(L)
            ENDIF
          ENDIF
C
  815   ENDDO                    ! *** END INNER SLATER LOOP
C
  814   IF(BPRNT0)THEN
          IF(BCONT)THEN
            KK=NRLI(J)
            IF(KK.EQ.0)WRITE(6,700)J,(QRL(I,J),I=1,5),DRL(J)
            IF(KK.GT.0)WRITE(6,700)J,(QRL(I,J),I=1,5)
     X                            ,(DRLI(IC,KK),IC=1,MENG)
          ELSE
            KK=0
            WRITE(6,700)J,(QRL(I,J),I=1,5),DRL(J)
          ENDIF
          IF(BKUTOO)THEN
            IF(KK.EQ.0)WRITE(6,703)DXTWO(J),DZL(J),DETA(J)
            IF(KK.GT.0)THEN
              WRITE(6,703)(DXTWOI(IC,KK),IC=1,MENG)
              WRITE(6,703)(DZLI(IC,KK),IC=1,MENG)
              WRITE(6,703)(DETAI(IC,KK),IC=1,MENG)
            ENDIF
          ENDIF
        ENDIF
C
      ENDDO                      ! *** END OUTER SLATER LOOP
C
  805 RETURN
c
  252 FORMAT(' *****STORAGE EXCEEDED IN SR.SLATER, INCREASE MXFSL TO ',
     XI5)
  300 FORMAT(/ '   I(R)   R(  A,  B,   C,  D, 2LBD ) = SLATER-INTEGRALS'
     X,'    (2LAMBDA=-1 DENOTES ONE-BODY INTEGRALS '
     X,'<A!-D**2/DR**2+L(L+1)/R**2-2Z/R!C>)')
  302 FORMAT(//'   I(R)   R(  A,  B,   C,  D, 2LBD ) = SLATER-INTEGRALS'
     X,': BELOW IS 0.5*TWO-BODY NON-FINE-STRUCTURE INTEGRALS'
     X,' (2LBD+1)*X2, ZLBD, ETALBD.')
  555 FORMAT(//' *** COWAN SLATER INTEGRAL SCALE FACTOR: ',F7.4)
  700 FORMAT(I7,3X,2(I5,I4),I6,7F14.7,1X/(34X,7F14.7))
  703 FORMAT(34X,7F14.7,1X/(34X,7F14.7))
C
      END SUBROUTINE SLATR
C
C                             *******************
C
      SUBROUTINE SLATRX(FRX,PSHFTX,MDIM1,MDIM2,MDIM3
     X                 ,DRL,DZL,DXTWO,DETA
     X                 ,M1,M2,LNEW,MAXLX,MPOSC)
C
C-----------------------------------------------------------------------
C
C  SR.SLATRX CALCULATES/UPDATES THE DEIE SLATER INTEGRALS (INCLUDING THE
C  EXCHANGE OVERLAP) AND (IF BKUTOO) 2-BODY NON-FINE STRUCTURE INTEGRALS
C
C  IT CALLS:
C    SR.LDFGX
C    SR.RKX
C    SR.YLAMKX
C    FN.ELAM
C    FN.XTWO
C    FN.ZLAM
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_DXRL,   ONLY: QRL,IRLAST               !,IRL !IS GLOBAL
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION FRX(MDIM1,MDIM2,MDIM3),PSHFTX(MDIM2,MDIM3)
     X         ,DRL(*),DZL(*),DXTWO(*),DETA(*)
C
c      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBDW6/QPOS(MAXGR),QPOS0(MAXGR)
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSPL/FR(MAXB1),DERV1(MAXB1),DERV2(MAXB1),GR(MAXB1)
C
      BPRNT0=JPRINT.GE.4                      !FOR DETAILED PRINTOUT
c      BPRNT0=JPRINT.NE.-3
      BKUTOO=KUTOOX.NE.0
      BREL2=ABS(IREL).EQ.2
C
      MAXRS1=MAXRS
      IF(BREL2)MAXRS1=MAXRS1+1
C
      IF(BPRNT0)THEN
        WRITE(6,300)M1,DYY(M1),M2,DYY(M2)
        IF(BKUTOO)WRITE(6,302)
      ENDIF
C
C INITIALIZE
C
      IRL1=IRLAST(LNEW)                              !LOCAL IRL FOR LNEW
C
      IF(BKUTOO)THEN
        DO  L=1,IRL1
          DRL(L)=DZERO
          DXTWO(L)=DZERO
          DZL(L)=DZERO
          DETA(L)=DZERO
        ENDDO
      ELSE
        DO  L=1,IRL1
          DRL(L)=DZERO
        ENDDO
      ENDIF
C
      MLAMX2=MXLAMX*2
C
C OUTER LOOP TO DETERMINE SLATER INETGRALS
C
cc      write(63,*)'L=',lnew
c      icountt=0
C
      DO J=1,IRL1
C
        IF(DRL(J).NE.DZERO)GO TO 814
        JJ=QRL(5,J)
        IF(JJ.LT.0)GO TO 814      !NOT NEEDED FOR THIS LTOT (CASE INAST)
C
        N1=QRL(1,J)
        N2=QRL(3,J)
        IF(QL(N1).LT.0)GO TO 814  !NOT NEEDED FOR THIS LTOT (CASE INAST)
        IF(QL(N2).LT.0)GO TO 814  !NOT NEEDED FOR THIS LTOT (CASE INAST)
        n3=n2
C
        BDIR=QN(N2).LT.0                              !DIRECT
c        BEX=.NOT.BDIR                                 !EXCHANGE
c
c        if(abs(ql(n1)-ql(n2)).gt.qrl(5,j).or.ql(n1)+ql(n2).lt.qrl(5,j))
c     x write(63,*)j,ql(n1),ql(n2),qrl(5,j)
C
C DETERMINE YLAMK
C
        Q1=QPOS(N1-MPOSC)
        q1=abs(q1)
        IF(BDIR)THEN
C
          Q2=QPOS(N2-MPOSC)
          q2=abs(q2)
          T1=PSHFTX(M1,Q1)
          T2=PSHFTX(M2,Q2)
          DEL=DYY(M1)-DYY(M2)                         !BREL ONLY
C
          CALL YLAMKX(FRX(1,M1,Q1),FRX(1,M2,Q2),FRX(MAXRS1,M1,Q1)
     X               ,FRX(MAXRS1,M2,Q2),N1,N2,JJ,M1,M2,T1,T2,DEL,FR,GR
     X               ,DX,DPOLA,REM,ovlp)
C
          IF(BKUTOO)THEN
            if(n1.eq.n2)then                  !same orb. (l) but diff. e
              n2=n1+1-2*((n1-mposc)/lcondwj)
              lhold=ql(n2)
              ql(n2)=ql(n1)
            else
              lhold=ql(n2)
            endif
            CALL LDFGX(M1,N1,FRX(1,M1,Q1),FRX(MAXRS1,M1,Q1)
     X                ,MAXRS,BREL,BREL2)
            CALL LDFGX(M2,N2,FRX(1,M2,Q2),FRX(MAXRS1,M2,Q2)
     X                ,MAXRS,BREL,BREL2)
          ENDIF
C
        ELSE
C
          IF(LNEW.GT.MAXLX.OR.JJ.GT.MLAMX2)GO TO 814
          DEL=DYY(M1)-(DEY(N2)-DUY(N2,N2))*DTWO       !RYD
C
          CALL YLAMKX(FRX(1,M1,Q1),DPNL(1,N2),FRX(MAXRS1,M1,Q1)
     X               ,DQNL(1,N2),N1,N2,-JJ,M1,M2,T1,T2,DEL,FR,GR
     X               ,DX,DPOLA,REM,ovlp)
C
          IF(BKUTOO)THEN
            CALL LDFGX(M1,N1,FRX(1,M1,Q1),FRX(MAXRS1,M1,Q1)
     X                ,MAXRS,BREL,BREL2)
          ENDIF
C
        ENDIF
C
C INNER LOOP OVER ALL INTGERALS UTILIZING THIS YLAMK
C
c        icount=0
        DO L=J,IRL1
C
          IF(QRL(1,L).NE.N1)GO TO 815
          IF(QRL(3,L).NE.n3)GO TO 815
          IF(QRL(5,L).NE.JJ)GO TO 815
          K1=QRL(2,L)
          K2=QRL(4,L)
          IF(QL(K1).LT.0)GO TO 815!NOT NEEDED FOR THIS LTOT (CASE INAST)
          IF(QL(K2).LT.0)GO TO 815!NOT NEEDED FOR THIS LTOT (CASE INAST)
C
C DETERMINE SLATER RK (A.U.)
C
c        if(abs(ql(k1)-ql(k2)).gt.qrl(5,j).or.ql(k1)+ql(k2).lt.qrl(5,j))
c     x write(63,*)j,ql(k1),ql(k2),qrl(5,j)
c
          IF(BDIR)THEN
            rem0=rem
            if(jj.eq.0.and.k1.ne.k2)rem0=dzero          !could test rlx2
            CALL RKX(DPNL(1,K1),DPNL(1,K2),DQNL(1,K1)
     X              ,DQNL(1,K2),JJ,FR,GR,DX,DPOLA,REM0,ovlp,SUM)
c            sum=0.                                             !test ex
          ELSE
            Q2=QPOS(K1-MPOSC)
            q2=abs(q2)
            ovlp0=ovlp
            CALL RKX(FRX(1,M2,Q2),DPNL(1,K2),FRX(MAXRS1,M2,Q2)
     X              ,DQNL(1,K2),-JJ,FR,GR,DX,DPOLA,REM,ovlp0,SUM)
c            sum0=sum
c                                                   add-in energy factor
c            if(jj.eq.0
c     x                .and.dadjus(k2).gt.dzero            !test
c     x                .and.dadjus(n2).gt.dzero            !exc. pseudos
c     x                                        )then
            if(jj.eq.0)then
              dex=-dyy(m1)/dtwo+dey(k2)-duy(k2,k2)
     x            -dyy(m2)/dtwo+dey(n2)-duy(n2,n2)                 !a.u.
              dex=dex/dtwo                                      !average
              sum=sum+ovlp0*dex
c            write(6,*)m1,m2,n1,k1,n2,k2,sum0,ovlp0,sum
            endif
c            sum=sum0                                 !test drop overlap
c            sum=0.                                             !test nx
          ENDIF
C
          DRL(L)=SUM
C
C  EVALUATE TWO-BODY NON-FINE-STRUCTURE INTEGRALS, CONVERT ZL,X2 TO A.U.
C
          IF(BKUTOO)THEN
            IF(.NOT.BDIR)THEN
              if(n1.eq.k1)then                !same orb. (l) but diff. e
                k1=n1+1-2*((n1-mposc)/lcondwj)
                lhold=ql(k1)
                ql(k1)=ql(n1)
              else
                lhold=ql(k1)
              endif
              CALL LDFGX(M2,K1,FRX(1,M2,Q2),FRX(MAXRS1,M2,Q2)
     X                  ,MAXRS,BREL,BREL2)
            ENDIF
            MI=JJ/2
            DXTWO(L)=XTWO(MI,N1,K1,N2,K2)/DTWO
            DZL(L)=ZLAM(MI,N1,K1,N2,K2)/DTWO
            DETA(L)=ELAM(MI,N1,K1,N2,K2)
            if(.not.bdir)ql(k1)=lhold
          ENDIF
c
c          icount=icount+1
C
  815   ENDDO                    ! *** END INNER SLATER LOOP
c
        if(bkutoo.and.bdir)ql(n2)=lhold
c
c        write(63,*)j,icount,bdir
c        call flush(63)
c        icountt=icountt+icount
C
  814   IF(BPRNT0)THEN
          TEST=DRL(J)
          IF(BKUTOO)TEST=TEST+DXTWO(J)+DZL(J)+DETA(J)
          IF(TEST.NE.DZERO)WRITE(6,700)J,(QRL(I,J),I=1,5),DRL(J)
          IF(BKUTOO)WRITE(6,703)DXTWO(J),DZL(J),DETA(J)
        ENDIF
C
      ENDDO                      ! *** END OUTER SLATER LOOP
c
c      write(63,*)'icountt=',icountt
C
      RETURN
C
  300 FORMAT(/ '   I(R)   R(  A,  B,   C,  D, 2LBD ) = SLATER-INTEGRALS'
     X,3X,'FOR    E(',I2,')=',F10.3,5X,'E(',I2,')=',F10.3,'  RYD')
  302 FORMAT(
     X': BELOW IS 0.5*TWO-BODY NON-FINE-STRUCTURE INTEGRALS (2LBD+1)*X2'
     X,', ZLBD, ETALBD.')
  700 FORMAT(I7,3X,2(I5,I4),I6,7F14.7,1X/(34X,7F14.7))
  703 FORMAT(34X,7F14.7,1X/(34X,7F14.7))
C
      END SUBROUTINE SLATRX
C
C***********************************************************************
C
      SUBROUTINE SPLYN(N,SX,SY,I1,E1,I2,E2,SA,SB,SC,SD,SS)
C
C-----------------------------------------------------------------------
C
C ALAN BURGESS, D.A.M.T.P. CAMBRIDGE.
C
C CUBIC SPLINE FITTING TO THE DATA POINTS (SX(J),SY(J)),J=1,2...N
C WITH KNOTS AT SX(J),J=2,3...(N-1),
C IN THE FORM SY(X)=SA(J)+Z*(SB(J)+Z*(SC(J)+Z*SD(J))),
C FOR X IN THE RANGE (SX(J),SX(J+1)),
C WHERE Z=X-(SX(J)+SX(J+1))/2.
C ONE OF THE FOLLOWING END CONDITIONS MUST BE CHOSEN FOR EACH END:
C (1)SPECIFIED END FIRST DERIVATIVES; SET I1=1, E1=(DY/DX)(X=SX(1))
C                                         I2=1, E2=(DY/DX)(X=SX(N))
C (2)SPECIFIED END 2ND DERIVATIVES; SET I1=2, E1=((D/DX)**2)Y (X=SX(1))
C                                       I2=2, E2=((D/DX)**2)Y (X=SX(N))
C (3)END 2ND DERIVATIVE =NEXT-TO-END 2ND DERIVATIVE; SET I1=3, I2=3
C                                            (NO NEED TO SET E1,E2)
C (4)3RD DERIVATIVE CONTINUOUS AT FIRST AND LAST KNOTS; SET I1=4, I2=4
C                                              (NO NEED TO SET E1,E2).
C N.B. THE CHOSEN CONDITIONS NEED NOT BE THE SAME FOR THE TWO ENDS.
C  INPUT: N,SX(J),SY(J) (J=1,2...N),I1,E1,I2,E2.
C  OUTPUT: SA(J),SB(J),SC(J),SD(J) (J=1,2...(N-1))
C          SS(J) (J=1,2...N), THE SECOND DERIVATIVE OF Y.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION SA(N),SB(N),SC(N),SD(N),SX(N),SY(N),SS(N)
C
      H1=SX(2)-SX(1)
      T1=(SY(2)-SY(1))/H1
C
      IF(I1.EQ.1)THEN
        SB(1)=H1+H1
        SC(1)=H1
        SD(1)=6*(T1-E1)
      ELSEIF(I1.EQ.2)THEN
        SB(1)=1
        SC(1)=0
        SD(1)=E1
      ELSEIF(I1.EQ.3)THEN
        SB(1)=1
        SC(1)=-1
        SD(1)=0
      ELSEIF(I1.EQ.4)THEN
        SB(1)=1
        SC(1)=0
        SD(1)=0
      ELSE
        WRITE(6,*)'SR.SPLYN: ILLEGAL VALUE FOR I1:',I1
        STOP 'SR.SPLYN: ILLEGAL VALUE FOR I1'
      ENDIF
C
      IF(I2.EQ.1)THEN
        H2=SX(N)-SX(N-1)
        SA(N)=H2
        SB(N)=H2+H2
        SD(N)=6*(E2-(SY(N)-SY(N-1))/H2)
      ELSEIF(I2.EQ.2)THEN
        SA(N)=0
        SB(N)=1
        SD(N)=E2
      ELSEIF(I2.EQ.3)THEN
        SA(N)=-1
        SB(N)=1
        SD(N)=0
      ELSEIF(I2.EQ.4)THEN
        SA(N)=0
        SB(N)=1
        SD(N)=0
      ELSE
        WRITE(6,*)'SR.SPLYN: ILLEGAL VALUE FOR I2:',I2
        STOP 'SR.SPLYN: ILLEGAL VALUE FOR I2'
      ENDIF

      N1=N-1
      DO J=2,N1
        H2=SX(J+1)-SX(J)
        T2=(SY(J+1)-SY(J))/H2
        SA(J)=H1
        SB(J)=2*(H1+H2)
        SC(J)=H2
        SD(J)=6*(T2-T1)
        H1=H2
        T1=T2
      ENDDO
C
      IF(I1.EQ.4)THEN
        SA(2)=0
        H1=SX(2)-SX(1)
        H2=SX(3)-SX(2)
        SB(2)=SB(2)+H1+H1*H1/H2
        SC(2)=SC(2)-H1*H1/H2
      ENDIF
      IF(I2.EQ.4)THEN
        SC(N-1)=0
        T1=SX(N-1)-SX(N-2)
        T2=SX(N)-SX(N-1)
        SA(N-1)=SA(N-1)-T2*T2/T1
        SB(N-1)=SB(N-1)+T2+T2*T2/T1
      ENDIF
C
      CALL TRIMAT(N,SA,SB,SC,SD,SS)
C
      IF(I1.EQ.4)SS(1)=((H1+H2)*SS(2)-H1*SS(3))/H2
      IF(I2.EQ.4)SS(N)=((T1+T2)*SS(N-1)-T2*SS(N-2))/T1
C
      DO J=1,N1
        H1=SX(J+1)-SX(J)
        T1=H1*H1/4
        SD(J)=(SS(J+1)-SS(J))/(6*H1)
        SC(J)=(SS(J+1)+SS(J))/4
        SB(J)=(SY(J+1)-SY(J))/H1-T1*SD(J)
        SA(J)=(SY(J+1)+SY(J))/2-T1*SC(J)
      ENDDO
C
      RETURN
C
      END SUBROUTINE SPLYN
C
C***********************************************************************
C
      FUNCTION SPVAL(N,SX,SY,SA,SB,SC,SD,X1,J1)
C
C-----------------------------------------------------------------------
C
C ALAN BURGESS, D.A.M.T.P. CAMBRIDGE.
C
C EVALUATES  CUBIC SPLINE FIT TO SY(X) AT X=X1, WHERE X1 LIES IN THE
C INTERVAL (SX(J1),SX(J1+1)), GIVEN THE SPLINE COEFFICIENTS
C SA(J),SB(J),SC(J),SD(J) PRODUCED BY SUBROUTINE SPLYN.
C J1 NEED NOT BE SET AS INPUT, BUT EXECUTION MAY BE QUICKER IF IT IS.
C  INPUT: SX(J), SY(J), J=1,2...N  : NOTE, SY(J) NOT NEEDED. (NRB)
C         SA(J),SB(J),SC(J),SD(J), J=1,2...N-1
C         X1
C         J1 (OPTIONAL).
C  OUTPUT: SPVAL=SY(X1).
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION SX(N),SY(N),SA(N),SB(N),SC(N),SD(N)
C
      IF(SX(1).LT.SX(N))THEN
        I1=1
        I2=N
        I=1
      ELSE
        I1=N
        I2=1
        I=-1
      ENDIF
C
      IF((J1-I1)*(J1-I2+I).GT.0)J1=I1
C
    2 IF(X1.LT.SX(J1))THEN
        IF(J1.EQ.I1)GO TO 9
        J1=J1-I
        GO TO 2
      ENDIF
C
    6 IF(X1.GT.SX(J1+I))THEN
        IF(J1.EQ.(I2-I))GO TO 9
        J1=J1+I
        GO TO 6
      ENDIF
C
    9 J2=J1+I
      Z=X1-(SX(J2)+SX(J1))/2
      IF(J2.GT.J1)J2=J1
C
      SPVAL=SA(J2)+Z*(SB(J2)+Z*(SC(J2)+Z*SD(J2)))
C
      RETURN
C
      END FUNCTION SPVAL
C
C                             *******************
C
      SUBROUTINE SOCC
C
C-----------------------------------------------------------------------
C
C  SR.SOCC CALCULATES THE BLUME AND WATSON CONTRIBUTIONS TO THE
C  SPIN-ORBIT PARAMETERS.
C
C  IT CALLS:
C    SR.NLAM
CC    SR.RAD
C    SR.RADBP1
C    SR.VLAM0
C    SR.ZETA
C
C-----------------------------------------------------------------------
C
      USE COMMON_CCLSH,  ONLY: NW,NNL
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_COEFF,  ONLY: QRLP,IRLP
      USE COMMON_REL,    ONLY: DMASS,DCD,D2LL
      USE COMMON_RELINT, ONLY: DRLP1,DNL
      USE COMMON_NRBINT, ONLY: DRLI,DYY,IYY,NRLI,MENG,NREL,NLAG,NLAGP
     X                        ,BLAG,BBC2
      USE COMMON_NRBNF2, ONLY: DXSI
      USE COMMON_NRBOLP, ONLY: OVLPGR,OVLPCF,IPAIR
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DFS(MXDFS),TNINT(3,2)
C
      COMMON /BASIC/NF,KVAR,MGAP(10)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
      COMMON /NRBZSP/ZESP(MAXLL),IZESP,NWRM
C
      IF(IRLP.LE.0)  GO TO 500
C
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
      IF(BPRNT0)THEN
        IF(IZESP.NE.0)WRITE(6,189)IZESP,(I,ZESP(I),I=1,ABS(IZESP))
        IF(KUTOO.NE.98)WRITE(6,180)
        IF(KUTOO.EQ.98)WRITE(6,187)
      ENDIF
C
      MXLAM=ABS(MAXLAM)
      NMULT=NMULTE-1                              !LIMIT NO OF MULIPOLES
C
      DFS(1)=1
      DFS(2)=1
      DO K=3,MXDFS,2
        DFS(K)=-DFS(K-2)
        DFS(K+1)=(K-1)*DFS(K-1)/32
      ENDDO
c
      if(irlx.lt.0)then
        ngrp=-irlx/100000             !until /nrborb/ in a module
        mxborb=-irlx-100000*ngrp
      endif
C
C RUN THROUGH ALL PAIRS OF VALENCE ELECTRON QUANTUM NUMBERS
C
      IF(KUTOO.EQ.98)THEN
C DXSI ONLY USED FOR TEST PURPOSES
        DO I=1,MXORB
          IF(DEY(I).EQ.DZERO)GO TO 86
          DO J=I,MXORB
            IF(DEY(J).EQ.DZERO)GO TO 85
            M=IVAL(I)+IVAL(J)
            IF(BJUMP.AND.M.EQ.0)GO TO 85
            DXSI(I,J)=DZERO
            DXSI(J,I)=DZERO
  85      ENDDO
  86    ENDDO
      ENDIF
C
      K0=0
C
C START LOOP OVER ALL COEFFICIENTS
C
      DO 510 LP=1,IRLP
C
        K1=QRLP(1,LP)
        K3=QRLP(2,LP)
        K=QRLP(4,LP)
c        K=(K3-1)/MAXGR
C
        DC1=DZERO
        IF(K.NE.0)GO TO 30                          !RADIATIVE INTEGRALS
C
        M=IVAL(K1)+IVAL(K3)
        IF(BJUMP.AND.M.EQ.0)THEN
          DC1=DRLP1(LP)
          GO TO 16
        ENDIF
C
        DI=DZERO                                    !DIRECT
        W1=DZERO                                    !EXCHANGE
C
        IMT=0
C        IF(QN(K1).LT.0)IMT=IMT+1
C        IF(QN(K3).LT.0)IMT=IMT+1
        IF(IYY(K1).GT.0)IMT=IMT+1
        IF(IYY(K3).GT.0)IMT=IMT+1
        IF(MODE.LE.2.AND.IMT.Ge.1)GO TO 16
c        IF(BREL.AND.K1.NE.K3)GO TO 16
C
        N1=ABS(QN(K1))
        N3=ABS(QN(K3))
C
        MQLA=QL(K1)
        QLA=MQLA/2
        MQLB=0
C
        V1=DZERO
        V2=DZERO
        V3=DZERO
C
        OVL=DONE
        IF(IRLX.EQ.2)THEN            !DETERMINE OVERLAP
          KF=IGRCF(K1)
          KG=IGRCF(K3)
          IF(KF.NE.KG.AND.KF*KG.GT.0)THEN
            KK1=MIN(KF,KG)
            KK2=MAX(KF,KG)
            KK=((KK2-1)*(KK2-2))/2+KK1
            IF(IPAIR(KK).EQ.1)OVL=OVLPCF(KK)
          ENDIF
        ENDIF
C
        J2=-1
        K2=0
        GO TO 12
C
C J2 NUMBERS THE ELECTRONS IN THE CORE C0,  J2=1,2,.....NW AND
C SO CANNOT BE A CONTINUUM ELECTRON OR A DR VALENCE ELECTRON.
C
 11     K2=NNL(J2,1)
        if(irlx.lt.0)then
          ngrp1=igrcf(k1)
          k2=k2+(ngrp1-1)*mxborb
        endif
C
 13     K4=NNL(J2,1)                               !K2
        if(irlx.lt.0)then
          ngrp3=igrcf(k3)
          k4=k4+(ngrp3-1)*mxborb
        endif
C
        MQLB=QL(K2)
        QLB=MQLB/2
        IF(BREL)DCD(K2,K2)=DZERO
C
C CALCULATE THE DIRECT INTEGRAL, N(ABAB,LBD=0).
C
        M0=3
C
        CALL NLAM(M0,K1,K2,K3,K4,IZERO,DM)
C                                      CALL RAD(K1,K2,K3,K4,IZERO,DM,M0)
C
        DM=DM*OVL
C
        DI=DI-((MQLB+1)*4)*DM       !DIRECT B&W
C
CPRNT WRITE(6,182)  J2,      K1,K2,K3,K4,  DM
C
        TNINT(2,1)=DZERO
        TNINT(3,1)=DZERO
        TNINT(2,2)=DZERO
        TNINT(3,2)=DZERO
        QX=QLA+QLB
        L=ABS(MQLB-MQLA)/2
        K=L-3
        IF(L.EQ.0)THEN
          DC1=DONE
          L=1
          K=-1
        ENDIF
C
 165    K=K+1
        TNINT(1,1)=TNINT(2,1)
        TNINT(2,1)=TNINT(3,1)
        TNINT(1,2)=TNINT(2,2)
        TNINT(2,2)=TNINT(3,2)
C
C COMPUTE N-INTEGRALS (IF M0=+3)  AND V-INTEGRALS (M0=-3)
C
        DM=DZERO
        DK=DZERO
        IF(K.GT.MXLAM.OR.K.GT.2*NMULT)GO TO 45
C
C        CALL RAD(K1,K2,K4,K3,K,DK,M0)
C
        IF(M0.GT.0)THEN
          CALL NLAM(M0,K1,K2,K4,K3,K,DK)
        ELSEif(m0.lt.0)then
          CALL VLAM0(M0,K1,K2,K4,K3,K,DK)
        else
          write(6,*) 'socc: m0=0 ??'
          write(0,*) 'socc: m0=0 ??'
          nf=-1
          go to 500
        ENDIF
C
        DK=DK*OVL
C
        DM=DK
        IF(M0*K1.EQ.3*K3)GO TO 45
C
C USE THE RELATION N(AB,BA,K)=N(BA,AB,K) IN CASE A=C.
C
C        CALL RAD(K2,K1,K3,K4,K,DM,M0)
C
        IF(M0.GT.0)THEN
          CALL NLAM(M0,K2,K1,K3,K4,K,DM)
        ELSEif(m0.lt.0)then
          CALL VLAM0(M0,K2,K1,K3,K4,K,DM)
        else
          write(6,*) 'socc: m0=0 ??'
          write(0,*) 'socc: m0=0 ??'
          nf=-1
          go to 500
        ENDIF
C
        DM=DM*OVL
C
  45    TNINT(3,2)=DM
        TNINT(3,1)=DK
C
C TNINT(J1,1) CONTAINS INTEGRALS OF THE TYPE N(AB,BC) AND TNINT(J1,2)
C CONTAINS INTEGRALS N(BA,CB). THE INDEX J1 GIVES THE ORDER OF THE
C INTEGRAL, THUS J1=I CORRESPONDS TO ORDER K+I-3.
C
CPRNT WRITE(6,183)     K,M0,               DK, DM
        M0=-M0
        IF(K.LT.L)GO TO 165
C
        MK=2*K
        DK=K
        DKU=K+1
        IF(M0.LE.0)THEN
C
C    IF QLA+QLB+K IS AN ODD INTEGER THEN THE CONTRIBUTIONS FROM V1
C    AND V3 ARE ZERO.
C
          DC1=VCC(MQLA,MK,MQLB,IZERO,IZERO,IZERO,DFS)
          DM=QLA*(QLA+1)+K*(K+1)-QLB*(QLB+1)
          W1=-DM/(MQLA*(QLA+1))
          V1=V1-6*DC1*DC1*W1*(TNINT(2,1)-TNINT(2,2))
C         =V1-6*DC1*DC1*W1*(V(K1,K2,K4,K3,K-1)-V(K2,K1,K3,K4,K-1))
          V3=V3-3*DC1*DC1*W1*((DM-MK*DKU)*(DK*TNINT(3,1)-DKU*TNINT(1,2))
     X                      +DM*(DK*TNINT(3,2)-DKU*TNINT(1,1)))/(DK*DKU)
        ELSE
C
          MS=QX+K
          IWT=(MS+1)*(MS-MQLB)*(MS-MQLA)*(MS-MK+1)
          W1=DSIX*IWT/(MQLA*(MQLA+2))
C         DC1=VCC(MQLA,MK-2,MQLB,IZERO,IZERO,IZERO,DFS)
          DM=DC1*DC1*(TNINT(2,1)+TNINT(2,2))/(DK*DKU)
          V2=V2+W1*DM
          IF(KUTOO.NE.98)GO TO 101
C
C TEST TWO-BODY NON-FINE-STRUCTURE VALENCE-CLOSED SHELL CONTRIB.
C
          IF(KUTOO*QLA*QLB.NE.0)THEN
          WO1=IWT
C
C JONES (A.U.)  WO1=IWT/(2*(MQLB+1))
C
          DXSI(K1,K3)=DXSI(K1,K3)+WO1*DM
C
C         T=(MK+1)*(MK-1)*DC1*DC1
C         WRITE(6,*)K,T,DC1
C
          ENDIF
C
        ENDIF
C
CP101 WRITE(6,184) DC1,W1, V1,V2,V3
C
 101    IF(K.LT.QX)  GO TO 165
C
C BLUME AND WATSON CLOSED-SHELL:
C ONLY NEED TO CONSIDER EACH CLOSED SHELL ONCE,
C SO INCREASE J2 BY THE NUMBER OF ELECTRONS IN THE CLOSED SHELL
C (IREL .LT. 0 USES POTENTIAL DERIVATIVE - SO SKIP)
C (IZESP.GT. 0 USES PURE NUCLEAR SCREENING BY ZESP - SO SKIP)
C
 12     IF(IREL.GE.0.AND.IZESP.LE.0)THEN
          J2=J2+2*(MQLB+1)
          IF(J2.LT.NW)GO TO 11
C
C OPTIONALLY FORCE R-MATRIX BLUME & WATSON "CLOSED-SHELL" CONTRIBUTION
C (ADJUST TESTS ON N2,N1,N3 TO REPRODUCE DESIRED R-MATRIX RESULT.)
C
          IF(J2.LT.NWRM)THEN
            K2=K2+1
            N2=ABS(QN(K2))
            IF(N2.LT.N1.AND.N2.LT.N3)
     X      GO TO 13
          ENDIF
        ENDIF
C
C IF ALL THE CORE ELECTRONS HAVE BEEN CONSIDERED, THE NEXT SET OF
C EQUIVALENT ELECTRONS IN THE VALENCE SHELLS MAY BE CONSIDERED
C
C SUM OF B&W EXCHANGE CONTRIBUTIONS
C
        W1=V1+V2+V3
C
C *** NUCLEAR SPIN-ORBIT
C
        IF(BREL)THEN
C UNCOMMENT IF REL ORB S-O INTEGRAL COMPUTED IN RADIAL/RADCON.
c          DK=DCD(K1,K3)
c          write(0,*)k1,k3
c          write(0,*)dk
          DCD(K1,K3)=DZERO
          DCD(K3,K1)=DZERO
c      GO TO 26
        ENDIF
C
        CALL ZETA(K1,K3,DK)        !CALL RAD(K1,K2,K3,K4,IZERO,DK,IZERO)
c
c      write(0,*)k1,k3,dk
C
c   26   CONTINUE
C
C COMBINE NUCLEAR WITH ANY DIRECT AND EXCHANGE BLUME & WATSON
C
        DC1=2*NZION*DK+DI+W1
C
C MULTIPY BY ANY SCREENING FACTOR
C (IZESP.GT.0 HAS ALREADY SWITCHED-OFF ANY B&W, OR POTENTIAL DERVATIVE)
C
        IF(IZESP.NE.0)THEN
          IZ=ABS(IZESP)
          IZ=MIN(IZ,INT(QLA,SP))
          DC1=DC1*ZESP(IZ)
        ENDIF
C
  16    DM=DTWO*DKCM*DC1
        DKU=DM/NZION**4
        DRLP1(LP)=DC1
C
        IF(KUTOO.NE.98)THEN
          IF(.NOT.BJUMP.AND.BPRNT0)WRITE(6,181)LP,K1,K3,DC1,DM,DKU,DI,W1
          IF(BJUMP.AND.BPRNT0)WRITE(6,181)LP,K1,K3,DC1,DM,DKU
        ELSE
          DXSI(K3,K1)=DXSI(K1,K3)
          IF(.NOT.BJUMP.AND.BPRNT0)WRITE(6,186)LP,K1,K3,DC1,DM,DKU,DI,W1
     X                                        ,DXSI(K1,K3)
          IF(BJUMP.AND.BPRNT0)WRITE(6,186)LP,K1,K3,DC1,DM,DKU,DZERO
     X                                   ,DZERO,DXSI(K1,K3)
        ENDIF
C
        GO TO 510                                !EXIT LOOP
C
C---------------------------------------------------------------------
C
C  THE FOLLOWING SECTION PROVIDES FOR RELATIVISTIC RADIATIVE INTEGRALS
C
C---------------------------------------------------------------------
C
  30    K2=K1                                      !-K*MAXGR
        K4=K3                                      !-K*MAXGR
        IF(K0.EQ.0)THEN
          K0=K
C TMP K=-K0
          IF(BPRNT0)WRITE(6,185)
        ENDIF
C
        M=IVAL(K2)+IVAL(K4)
        IF(BJUMP)THEN
          IF(M.EQ.0)THEN
            DC1=DRLP1(LP)
            GO TO 17
          ELSEIF(QN(K4).LT.0)THEN                !CONT-CONT (RYD APPROX)
            tm=nnew
            tm=tm-screen(k4)           !can use, as we do have q.d. here
            tn=nnold
            tn=tn-screen(k4)           !can use, as we do have q.d. here
            factj=(tn/tm)**3
            factj=sqrt(factj)
            DC1=DRLP1(LP)*factj
            GO TO 17
          ENDIF
        ENDIF
C
        IMT=0
C        IF(QN(K2).LT.0)IMT=IMT+1
C        IF(QN(K4).LT.0)IMT=IMT+1
        IF(IYY(K2).GT.0)IMT=IMT+1
        IF(IYY(K4).GT.0)IMT=IMT+1
C
        IF(MODE.GT.2.OR.IMT.LE.1)THEN
C
          M0=0
          IF(K.GT.8)M0=1000*QRLP(3,LP)
C
          CALL RADBP1(K2,K4,K,DC1,M0)
C
          if(m0.lt.0)then                        !should not occur (now)
            nf=-1
            go to 500
          endif
C
          OVL=DONE
          IF(IRLX.EQ.2.AND.K.LT.9)THEN            !DETERMINE OVERLAP
            KF=IGRCF(K2)
            KG=IGRCF(K4)
            IF(KF.NE.KG.AND.KF*KG.GT.0)THEN
              KK1=MIN(KF,KG)
              KK2=MAX(KF,KG)
              KK=((KK2-1)*(KK2-2))/2+KK1
              IF(IPAIR(KK).EQ.1)OVL=OVLPCF(KK)
            ENDIF
          ENDIF
          DC1=DC1*OVL
        ENDIF
C
  17    IF(BPRNT0)WRITE(6,188)LP,K1,K3,DC1,K
C
        DRLP1(LP)=DC1
C
C END M1+BP RADIATIVE
C
  510 CONTINUE
C
C END LOOP OVER ALL COEFFICIENTS
C
  500 RETURN
C
  180 FORMAT(//5X,'ZETA(   A    B ) = SPIN-ORBIT PARAMETERS',37X,
     X 'BLUME AND WATSON CLOSED SHELL CONTRIBUTION, IN 2RY'/33X,'2*RY',
     X 17X,'1/CM',13X,'Z**4/CM',14X,'DIRECT CONTRIBUTION',4X,
     X 'EXCHANGE CONTRIB.')
  181 FORMAT(I5,4X,2I5,8X,E14.7,2(5X,1PE14.7),11X,2(7X,0PE14.6))
CP182 FORMAT(/21X,'.   DM',6X,,I4,8X,4I4,E18.5)
CP183 FORMAT(20X,'..N1- OR V1-2',4X ,2I4,16X,2E18.5)  184FOR./77X,3E18.5
CP184 FORMAT (19X,'...DC1,W1,V1-3',28X,2E18.5/77X,3E18.5)
  185 FORMAT(47X,'NOW FOLLOWING ARE RADIATIVE INTEGRALS')
  186 FORMAT(I5,2X,2I5,5X,1PE14.7,2(3X,E14.7),1X,2(7X,E14.6)
     X,5X,E14.7)
  187 FORMAT(//5X,'ZETA( A    B ) = SPIN-ORBIT PARAMETERS',19X,'BLUME'
     X,' AND WATSON CLOSED SHELL CONTRIBUTION, IN 2RY.',5X
     X,'| ORBIT-ORBIT'
     X/27X,'*2RY',14X,'1/CM',11X,'Z**4/CM',10X,'DIRECT CONTRIB.'
     X,4X,'EXCHANGE CONTRIB.',5X,'| XI PARAMETER')
  188 FORMAT(I5,4X,2I5,8X,E14.7,I7)
  189 FORMAT(//5X,'EFFECTIVE SPIN-ORBIT SCREENING PARAMETERS FOR IZESP='
     X,I3//5X,'L=',10(I7,F10.4))
C
      END SUBROUTINE SOCC
C
C                             *******************
C
      SUBROUTINE SPOR0(KK,QLMC,QBML,QBMS,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.SPOR0 CHECKS WHICH SLATER-STATES OF TWO CFS DIFFER BY ZERO OR ONE
C  PAIR AND SETS POINTERS TO THEM FOR LATER USE BY SPOR1 IF THEY SATISFY
C  THE SPIN-ORBIT SELECTION RULES. IT CLOSELY RESEMBLES SR.FLGLX0 - NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2,KPTCFM,KINT,MPOINT,IXSTX
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION QLMC(MAXEL,*),QBML(*),QBMS(*)
C
      ALLOCATABLE :: BTEMP(:,:),KTEMP(:),LTEMP(:),MTEMP(:)
     X              ,JTEMP(:),NTEMP(:)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,JGAP(5)
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
C
      NF1=NF+1
      NF2=NF*NF
C
      BEQCFS=KG.EQ.KF
C
C LOCAL (SMALL)
C
      ALLOCATE (BTEMP(NF,NF),KTEMP(NF2+1),LTEMP(NF2),MTEMP(NF))
      ALLOCATE (JTEMP(NF),NTEMP(NF))
C
      DO L=1,NF
        J=QCG(L,KG)
        JTEMP(L)=IEQ(J)
        K=QCG(L,KF)
        NTEMP(L)=IEQ(K)
      ENDDO
C
      K=0
      DO I=NF,1,-1
        DO L=NF,1,-1
          BTEMP(L,I)=JTEMP(L).EQ.NTEMP(I)
          IF(BTEMP(L,I))THEN
            K=K+1
            LTEMP(K)=L
            KTEMP(K)=I
          ENDIF
        ENDDO
      ENDDO
      KTEMP(K+1)=0
      KMX=K
C
      DEALLOCATE (JTEMP,NTEMP)
C
C INITIALIZE GROUP RANGES
C
      IXD02=QCL0/2
C
      MG2=IXD02
      MG1=-IXD02
C
      MG2P=IXD02
      MG1P=-IXD02
C
C LOOP OVER INITIAL ML GROUPS OF CONFIG KF
C
      DO MG=MG2,MG1,-1
C
        M1=MPOINT(MG+1,KF)+1                      !SLATER-STATE RANGE
        M2=MPOINT(MG,KF)
C
C LOOP OVER FINAL MLP GROUPS OF CONFIG KG
C
        IF(BEQCFS)MG1P=MG
C
        DO MGP=MG2P,MG1P,-1
C
          M1P=MPOINT(MGP+1,KG)+1                  !SLATER-STATE RANGE
          M2P=MPOINT(MGP,KG)
C
C LOOP OVER INITIAL SLATER STATES OF ML
C
          DO M=M1,M2
C
            J=M
            QMS=QBMS(J)
            QML=QBML(J)
            QMJ=QML+QMS
C
C LOOP OVER FINAL SLATER STATES OF MLP
C
            IF(BEQCFS.AND.MG.EQ.MGP)M2P=M
C
            DO MP=M1P,M2P
C
              JD=MP
C
              NEN2=0
              IF(JD.EQ.J)GO TO 75             !SO BEQCFS=.TRUE.
C
              QMSP=QBMS(JD)
              IF(ABS(QMS-QMSP).GT.2)GO TO 57         !NO S.O.
C
              QMLP=QBML(JD)
              QMJP=QMLP+QMSP
              IF(QMJ.NE.QMJP)GO TO 57
C
              NK=0
C
C DETERMINE THE PAIR OF INDIVIDUAL SETS IN WHICH SLATER
C STATE JD DIFFERS FROM J, AND THE PHASE FACTOR THAT RESULTS FROM
C THE REMAINING NF-1 SETS:
C
              N1=0
              MU=0
              DO I=1,NF
                MTEMP(I)=0
              ENDDO
C
C CASES WHERE ORBITAL NL'S MATCH
C
              I0=0
              DO K=1,KMX
                I=KTEMP(K)
                L=LTEMP(K)
                IF(I.NE.I0)THEN                   !NEED TO CHECK L STILL
                  IF(QLMC(L,JD).EQ.QLMC(I,J))THEN
                    MTEMP(I)=L
                    I0=I
                  ELSEIF(KTEMP(K+1).NE.I)THEN     !HAVE MOVED TO A NEW I
                    NK=NK+1
                    IF(NK.GT.1)GO TO 57
                    N1=I
                    MU=I+MU
                  ENDIF
                ENDIF
              ENDDO
C
C CASES WHERE ORBITALS DO NOT MATCH, SEE IF A DIFFERENCE
C HAS ALREADY BEEN FLAGGED, IF NOT, DO SO.
C
              DO I=NF,1,-1
                IF(MTEMP(I).EQ.0.AND.N1.NE.I)THEN
                  DO L=NF,1,-1
                    IF(.NOT.BTEMP(L,I))THEN
                      NK=NK+1
                      IF(NK.GT.1)GO TO 57
                      N1=I
                      MU=I+MU
                      GO TO 580
                    ENDIF
                  ENDDO
                ENDIF
 580          ENDDO
C
              ICG1=QCG(N1,KF)
              LP=QL(ICG1)
              IF(LP.EQ.0)GO TO 57  !S-STATES GIVE NO SPIN-ORBIT CONTRIBS
C
              K=0
              DO L=NF,1,-1
                DO I=NF,1,-1
                  IF(MTEMP(I).EQ.L)GO TO 60
                ENDDO
                K=K+1
                N2=L
                MU=L+MU
                IF(K.EQ.NK)GO TO 74
  60          ENDDO
C
  74          ICG2=QCG(N2,KG)
              IF(QL(ICG2).NE.LP)GO TO 57        !ZERO IF L-VALUES DIFFER
              IF(QN(ICG1).GE.90.AND.QN(ICG2).GE.90)GO TO 57
C
              IPHASE=(1-2*MOD(MU,ITWO))               !*IPHASE
C
C  NK.EQ.1 HERE
C
              IF(NK.NE.1)THEN
                WRITE(6,*)'SPOR0: ERROR, SHOULD NOT BE HERE',KF,KG,J,JD
                STOP 'SPOR0: ERROR, SHOULD NOT BE HERE'
              ENDIF
C
              NEN2=NF1*N1+N2
              NEN2=NEN2*IPHASE
C
C FLAG THIS PAIR AS INTERACTING (TBD DON'T BOTHER TO STORE J=JD CASE?)
C
  75          KINT=KINT+1
              IF(KINT.GT.IXSTX)THEN               !COULD PACK FURTHER...
C
                IXXX=7*(IXSTX/5)
C
                WRITE(6,*)'*** SPOR0: increasing MXSTX from ',IXSTX
     X                    ,' TO: ',IXXX
                WRITE(0,*)'*** SPOR0: increasing MXSTX from ',IXSTX
     X                    ,' TO: ',IXXX
C
                CALL RE_ALLOC(KINTI,IONE,IXSTX,IXXX,IERR)
                CALL RE_ALLOC(KINTF,IONE,IXSTX,IXXX,IERR)
                CALL RE_ALLOC(KEN2,IONE,IXSTX,IXXX,IERR)
C
                IF(IERR.NE.0)THEN
                  WRITE(0,*)'SPOR0: RE-ALLOCATION FAILS FOR KINTI etc'
                  NF=0
                  GO TO 1
                ENDIF
C
                IXSTX=IXXX
C
              ENDIF
C
              KINTI(KINT)=J
              KINTF(KINT)=JD
              KEN2(KINT)=NEN2
C              WRITE(6,*)KF,J,'  **  ',KG,JD
C
  57          CONTINUE
C
            ENDDO           !END FINAL ML SLATER STATE LOOP
C
          ENDDO           !END INITIAL ML SLATER STATE LOOP
C
          KPTCFM(MGP,MG,KK)=KINT
          IF(BEQCFS)KPTCFM(MG,MGP,KK)=KINT
C
        ENDDO           !END FINAL MLP GROUP LOOP FOR KG
C
      ENDDO           !END INITIAL ML GROUP LOOP FOR KF
C
    1 DEALLOCATE (BTEMP,KTEMP,LTEMP,MTEMP)
C
      RETURN
C
      END SUBROUTINE SPOR0
C
C                             *******************
C
      SUBROUTINE SPOR1(QLMC,MAXEL,MAM,NAM,IZY)
C
C-----------------------------------------------------------------------
C
C  SR.SPOR1 EVALUATES SLATER-STATE INTERACTIONS FOR THE SPIN-ORBIT
C  MATRIX ELEMENTS - NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_COEFF,  ONLY: IXSOC,IXSOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-6)
C
      DIMENSION QLMC(MAXEL,*),MAM(*),NAM(*)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,MGAP(5)
      COMMON /COMRES/DVC12,ICLRS,ICLRR,BLX
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
C
      IRLPS1=IRLPS0+1
      IF(ICLRS.LT.0)GO TO 40
C
C     IN LOOPS 64,65 SCAN THROUGH SLATER STATES IN INITIAL AND
C     FINAL STATES RESP., AND CALCULATE CONTRIBUTIONS DUE TO EACH PAIR.
C
      DO 64 J1=JA,JB
C
        L1=MAM(J1)
C
        DO 65 J2=JAP,JBP
C
          L2=NAM(J2)
C
CTHIS NEXT STATEMENT RESOLVES INTERACTIONS BY SLATER STATE
COLD      IRKPS00=IRKPS+1
C
          DO I=IRLPS1,IRLPS
            IORIG1(I)=0
          ENDDO
C
          NK=0
          N1=0
          IF(L2.EQ.L1)GO TO 88                     !DIAGONAL
C
C    NOW COMPARE INITIAL AND FINAL SLATERSTATES, L1 AND L2,
C    AND SELECT ONLY THE ONES WHICH DIFFER IN ONE SET OF QUANTUM NUMBERS
C
          DO ICG2=1,NF
            N1=ICG2+N1
            DO ICG1=1,NF
              IF(QLMC(ICG1,L1).NE.QLMC(ICG2,L2))GO TO 67
              IF(IEQ(QCG(ICG1,KF)).NE.IEQ(QCG(ICG2,KG)))GO TO 67
              N1=N1-ICG1
              GO TO 66
  67        ENDDO
            IF(NK.NE.0)GO TO 65         !SS DIFFER IN MORE THAN ONE PAIR
            NK=1
            N2=ICG2
  66      ENDDO
C
C     L1 AND L2 DIFFER IN ONE PAIR, IN POSITIONS NUMBERED N1 AND N2
C
          GO TO 87
C
  88      N1=N1+1
          IF(N1.GT.NF)GO TO 65
C         N2=N1
  87      ICG1=QCG(N1,KF)
          LP=QL(ICG1)
C
          IF(LP.EQ.0)GO TO 81      !S-STATES GIVE NO SPIN-ORBIT CONTRIBS
C
          ICG2=ICG1
          IF(NK.NE.0)ICG2=QCG(N2,KG)
          IF(QN(ICG1).GE.90.AND.QN(ICG2).GE.90)GO TO 65
C
C     FIND THE AZIMUTHAL COMPONENTS OF L AND S FOR THE INDIVIDUAL
C     ELECTRONS,WHOSE NUMBERS ARE N1,N2.
C
          MAUX=QLMC(N1,L1)
          QLML1=((MAUX+100)/2)*2-100
          QLMS1=(MAUX-QLML1)*2-1
          DD=QLMS1*QLML1
C
          IF(NK.NE.0)THEN                   !OFF-DIAGONAL
C
            IF(QL(ICG2).NE.LP)GO TO 65      !ZERO IF THE L-VALUES DIFFER
C
C     NOW PROCEED FOR (L+).(S-) OR (L-).(S+) RATHER THAN (L0).(S0)
C
C           QLML2=((100+QLMC(N2,L2))/2)*2 -100
C           QLMS2=(QLMC(N2,L2)-QLML2)*2-1
C           QLMS2+QLML2=QLMS1+QLML1 FOR NK=0,1
C
            IF(QLMC(N2,L2).NE.MAUX)THEN
              MAUX=QLMS1+QLML1
              DD=SQRT(REAL((LP-MAUX+1)*(LP+MAUX+1),WP))
            ENDIF
            IF(((N1+N2)/2)*2.NE.N1+N2)DD=-DD
            IF(ICG2.GT.ICG1)THEN
              MAUX=ICG2
              ICG2=ICG1
              ICG1=MAUX
            ENDIF
          ENDIF
C
          DD=DVC12*DD/DFOUR
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
          DO J=IRLPS1,IRLPS
            IF(QRLPS(2,J).NE.ICG2)  GO TO 72
            IF(QRLPS(1,J).NE.ICG1)  GO TO 72
            I=IORIG1(J)
            IF(I.GT.0)THEN
              DRKPS(I)=DRKPS(I)+DD
              GO TO 81
            ENDIF
            L=J
            GO TO 82
  72      ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
          L=IRLPS+1
          IF(L.GT.IXS1I)THEN                                    !GO TO 1
C
            IXXX=7*(IXS1I/5+1)
C
            WRITE(6,*)'*** SPOR1: increasing MXS1I from ',IXS1I,' to: '
     X                ,IXXX
            WRITE(0,*)'*** SPOR1: increasing MXS1I from ',IXS1I,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRLPS,IONE,IFOUR,IONE,IXS1I,IFOUR,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR1: REALLOCATION FAILS FOR QRLPS'
              NF=0
              GO TO 999
            ENDIF
C
            IXXX0=MAX(IXS1I,IXSOI)
            IXXX1=MAX(IXXX,IXSOI)
            IF(IXXX1.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG1,IONE,IXXX0,IXXX1,IERR)
            CALL RE_ALLOC(JORIG1,IONE,IXS1I,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR1: REALLOCATION FAILS FOR IORIG1,JORIG1'
              NF=0
              GO TO 999
            ENDIF
C
            IXS1I=IXXX
C
          ENDIF
C
          IRLPS=L
          QRLPS(1,L)=ICG1
          QRLPS(2,L)=ICG2
C
  82      IRKPS=IRKPS+1
          IF(IRKPS.GT.IXS1C)THEN                                !GO TO 1
C
            IXXX=7*(IXS1C/5+1)
C
            WRITE(6,*)'*** SPOR1: increasing MXS1C from ',IXS1C,' to: '
     X                ,IXXX
            WRITE(0,*)'*** SPOR1: increasing MXS1C from ',IXS1C,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRKPS,IONE,IXS1C,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR1: REALLOCATION FAILS FOR DRKPS'
              NF=0
              GO TO 999
            ENDIF
C
            CALL RE_ALLOC(NRKPS,IONE,IXS1C,IXXX,IERR)
            CALL RE_ALLOC(NSTJ1,IONE,IXS1C,IXXX,IERR)
            CALL RE_ALLOC(NSTJ1D,IONE,IXS1C,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR1: REALLOCATION FAILS FOR NRKPS,NSTJ1'
              NF=0
              GO TO 999
            ENDIF
C
            IXS1C=IXXX
C
          ENDIF
C
          IORIG1(L)=IRKPS
          NRKPS(IRKPS)=L
          DRKPS(IRKPS)=DD
          NSTJ1(IRKPS)=L1
          NSTJ1D(IRKPS)=L2
C
  81      IF(NK.EQ.0)  GO TO 88
C
C     NK.EQ.1 FOR STATES WHICH DIFFER IN ONE SET OF ONE-ELECTRON
C     QUANTUM NOS, THE NECESSARY TERM HAS ALREADY BEEN EVALUATED,
C     THEREFORE PROCEED TO NEXT PAIR OF SLATER STATES.
C
  65    ENDDO                 !END SCAN OF INITIAL SLATER STATES
C
  64  ENDDO                 !END SCAN OF FINAL SLATER STATES
C
C
C     IF THE COEFFICIENTS OF THE SPIN-ORBIT PARAMETERS IN THE MATRIX
C     ELEMENT HAVE NOT BEEN COMPLETELY CALCULATED, RETURN - SPOR1 WILL
C     BE CALLED AGAIN, FOR DIFFERENT (MS,ML) GIVING THE SAME MS+ML=QMJ.
C
      IF(BLX)RETURN
C
C     ELIMINATE COEFFICIENTS /DRKPS/.LT.TYNY AND ARGUMENTS QRLPS THAT
C     HAVE BEEN LISTED BEFORE IN THE REFERENCE LIST
C     IF(KF.GT.0)RETURN
C
  40  ICLRS=0
      IF(IRKPS.LT.IRKPS0)RETURN
C
      K=IRKPS0-1
      KP=0
      DO I=IRLPS1,IRLPS
        IORIG1(I)=0
      ENDDO
C
      DO 91 I=IRKPS0,IRKPS
C
        JD0=NRKPS(I)
        JD=ABS(JD0)
        IF(ABS(DRKPS(I)).LT.TYNY)THEN
          IF(IORIG1(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QRLPS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
C
        K=K+1
        DRKPS(K)=DRKPS(I)
        NSTJ1(K)=NSTJ1(I)
        NSTJ1D(K)=NSTJ1D(I)
C
  94    IF(JD.LE.IRLPS0)THEN
          WRITE(6,*)'SPOR1: INFORM NRB OF STOP HERE'
          WRITE(0,*)'SPOR1: INFORM NRB OF STOP HERE'
          NF=-1
          GO TO 999
C        LP=JD
C        GO TO 92
        ENDIF
C
        IF(IORIG1(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,IRLPS0
            DO J=1,2
              IF(QRLPS(J,JD).NE.QRLPS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG1(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG1(JD)
          GO TO 92
        ENDIF
C
        IORIG1(JD)=LP
        DO J=1,2
          QRLPS(J,LP)=QRLPS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          NRKPS(K)=LP
C          IF(JD0.LT.0)NRKPS(K)=-NRKPS(K)
        ENDIF
C
  91  ENDDO
C
C
      IRLPS=IRLPS-KP
      IRKPS=K
 999  RETURN
C
 1    IZY=-1
      GO TO 999
C
      END SUBROUTINE SPOR1
C
C                             *******************
C
      SUBROUTINE SPOR1F(QLMC,MAXEL,NAM,IZY)
C
C-----------------------------------------------------------------------
C
C  SR.SPOR1F EVALUATES SLATER-STATE INTERACTIONS FOR THE SPIN-ORBIT
C  MATRIX ELEMENTS. IT DIFFERS FROM SPOR1 IN THAT THE INTERACTING
C  PAIRS HAVE ALREADY BEEN SET-UP BY SR.SPOR0 - NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_COEFF,  ONLY: IXSOC,IXSOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
      USE COMMON_NRBFL0, ONLY: KINTI,KINTF,KEN2
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-6)
C
      DIMENSION QLMC(MAXEL,*),NAM(*)
     X         ,NEJ(2),NEN(2)
C
      COMMON /BASIC/NF,KF,KG,JA,JB,JAP,JBP,MGAP(5)
      COMMON /COMRES/DVC12,ICLRS,ICLRR,BLX
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
C
      POINTER :: N1,N2
      TARGET :: NEN
C
      N1=>NEN(1)
      N2=>NEN(2)
C
c      EQUIVALENCE (NEN(1),N1),(NEN(2),N2)
C
      IRLPS1=IRLPS0+1
      IF(ICLRS.LT.0)GO TO 40
C
      brev=kf.lt.kg
      NF1=NF+1
C
C BEGIN MAIN SLATER-STATE INTERACTION LOOP (64)
C
      DO 64 J1=JA,JB
C
        kk=nam(j1)
        if(brev.or.kk.lt.0)then
          kk=abs(kk)
          i1=2
          i2=1
        else
          i1=1
          i2=2
        endif
        nej(i1)=kinti(kk)
        nej(i2)=kintf(kk)
        l1=nej(1)
        l2=nej(2)
c
c      write(6,*)kf,j,'      ',kg,jd
C
        DO I=IRLPS1,IRLPS
          IORIG1(I)=0
        ENDDO
C
        DDH=DONE
        NK=0
        N1=0
        IF(L2.EQ.L1)GO TO 88                !DIAGONAL
C
C NK=1,  L1 AND L2 DIFFER IN ONE PAIR, IN POSITIONS NUMBERED N1 AND N2
C
        nk=1
        nen2=ken2(kk)
c                              if(nen2.eq.0)stop 'nen2 error'
        if(nen2.lt.0)then
          ddh=-ddh
          nen2=-nen2
        endif
        nen(i1)=nen2/nf1
c                     if(nen(i1).eq.0)stop 'nen(1) error'
        nen(i2)=nen2-nen(i1)*nf1
c                     if(nen(i2).eq.0)stop 'nen(2) error'
c
        GO TO 87
C
C NK=0
C
  88    N1=N1+1
        IF(N1.GT.NF)GO TO 64
C       N2=N1
  87    ICG1=QCG(N1,KF)
        LP=QL(ICG1)
C                                  !RETAIN TESTS FOR NK=0 LOOP OVER ORBS
        IF(LP.EQ.0)GO TO 81        !S-STATES GIVE NO SPIN-ORBIT CONTRIBS
C
        ICG2=ICG1
        IF(NK.NE.0)ICG2=QCG(N2,KG)
        IF(QN(ICG1).GE.90.AND.QN(ICG2).GE.90)GO TO 64
C
C   FIND THE AZIMUTHAL COMPONENTS OF L AND S FOR THE INDIVIDUAL
C   ELECTRONS,WHOSE NUMBERS ARE N1,N2.
C
        MAUX=QLMC(N1,L1)
        QLML1=((MAUX+100)/2)*2-100
        QLMS1=(MAUX-QLML1)*2-1
        DD=QLMS1*QLML1
C
        IF(NK.NE.0)THEN                     !OFF-DIAGONAL
C                                           !SO NO TEST NEEDED
C          IF(QL(ICG2).NE.LP)GO TO 64       !ZERO IF THE L-VALUES DIFFER
C
C   NOW PROCEED FOR (L+).(S-) OR (L-).(S+) RATHER THAN (L0).(S0)
C
C         QLML2=((100+QLMC(N2,L2))/2)*2 -100
C         QLMS2=(QLMC(N2,L2)-QLML2)*2-1
C         QLMS2+QLML2=QLMS1+QLML1 FOR NK=0,1
C
          IF(QLMC(N2,L2).NE.MAUX)THEN
            MAUX=QLMS1+QLML1
            DD=SQRT(REAL((LP-MAUX+1)*(LP+MAUX+1),WP))
          ENDIF
C          IF(((N1+N2)/2)*2.NE.N1+N2)DDH=-DDH     !TAKE FROM SPOR0
          IF(ICG2.GT.ICG1)THEN
            MAUX=ICG2
            ICG2=ICG1
            ICG1=MAUX
          ENDIF
        ENDIF
C
        DD=DDH*DVC12*DD/DFOUR
C
C STORE CONTRIBUTION TO (EXISTING) COEFFICIENT
C
        DO J=IRLPS1,IRLPS
          IF(QRLPS(2,J).NE.ICG2)GO TO 72
          IF(QRLPS(1,J).NE.ICG1)GO TO 72
          I=IORIG1(J)
          IF(I.GT.0)THEN
            DRKPS(I)=DRKPS(I)+DD
            GO TO 81
          ENDIF
          L=J
          GO TO 82
  72    ENDDO
C
C CANNOT FIND OLD SET OF ARGUMENTS, SO START CONSTRUCTING A NEW SET
C
        L=IRLPS+1
        IF(L.GT.IXS1I)THEN                                      !GO TO 1
C
          IXXX=7*(IXS1I/5+1)
C
          WRITE(6,*)'*** SPOR1F: increasing MXS1I from ',IXS1I,' to: '
     X              ,IXXX
          WRITE(0,*)'*** SPOR1F: increasing MXS1I from ',IXS1I,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC2(QRLPS,IONE,IFOUR,IONE,IXS1I,IFOUR,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SPOR1F: REALLOCATION FAILS FOR QRLPS'
            NF=0
            GO TO 999
          ENDIF
C
          IXXX0=MAX(IXS1I,IXSOI)
          IXXX1=MAX(IXXX,IXSOI)
          IF(IXXX1.GT.IXXX0)
     X    CALL RE_ALLOC(IORIG1,IONE,IXXX0,IXXX1,IERR)
          CALL RE_ALLOC(JORIG1,IONE,IXS1I,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SPOR1F: REALLOCATION FAILS FOR IORIG1,JORIG1'
            NF=0
            GO TO 999
          ENDIF
C
          IXS1I=IXXX
C
        ENDIF
C
        IRLPS=L
        QRLPS(1,L)=ICG1
        QRLPS(2,L)=ICG2
C
  82    IRKPS=IRKPS+1
        IF(IRKPS.GT.IXS1C)THEN                                  !GO TO 1
C
          IXXX=7*(IXS1C/5+1)
C
          WRITE(6,*)'*** SPOR1F: increasing MXS1C from ',IXS1C,' to: '
     X              ,IXXX
          WRITE(0,*)'*** SPOR1F: increasing MXS1C from ',IXS1C,' to: '
     X              ,IXXX
C
          CALL RE_ALLOC(DRKPS,IONE,IXS1C,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SPOR1F: REALLOCATION FAILS FOR DRKPS'
            NF=0
            GO TO 999
          ENDIF
C
          CALL RE_ALLOC(NRKPS,IONE,IXS1C,IXXX,IERR)
          CALL RE_ALLOC(NSTJ1,IONE,IXS1C,IXXX,IERR)
          CALL RE_ALLOC(NSTJ1D,IONE,IXS1C,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'SPOR1F: REALLOCATION FAILS FOR NRKPS,NSTJ1'
            NF=0
            GO TO 999
          ENDIF
C
          IXS1C=IXXX
C
        ENDIF
C
        IORIG1(L)=IRKPS
        NRKPS(IRKPS)=L
        DRKPS(IRKPS)=DD
        NSTJ1(IRKPS)=L1
        NSTJ1D(IRKPS)=L2
C
  81    IF(NK.EQ.0)GO TO 88
C
C     NK.EQ.1 FOR STATES WHICH DIFFER IN ONE SET OF ONE-ELECTRON
C     QUANTUM NOS, THE NECESSARY TERM HAS ALREADY BEEN EVALUATED,
C     THEREFORE PROCEED TO NEXT INTERACTION.
C
  64  ENDDO               !END SLATER-STATE INTERACTION LOOP
C
C
C     IF THE COEFFICIENTS OF THE SPIN-ORBIT PARAMETERS IN THE MATRIX
C     ELEMENT HAVE NOT BEEN COMPLETELY CALCULATED, RETURN - SPOR1 WILL
C     BE CALLED AGAIN, FOR DIFFERENT (MS,ML) GIVING THE SAME MS+ML=QMJ.
C
      IF(BLX)RETURN
C
C     ELIMINATE COEFFICIENTS /DRKPS/.LT.TYNY AND ARGUMENTS QRLPS THAT
C     HAVE BEEN LISTED BEFORE IN THE REFERENCE LIST
C     IF(KF.GT.0)RETURN
C
  40  ICLRS=0
      IF(IRKPS.LT.IRKPS0)RETURN
C
      K=IRKPS0-1
      KP=0
      DO I=IRLPS1,IRLPS
        IORIG1(I)=0
      ENDDO
C
      DO 91 I=IRKPS0,IRKPS
C
        JD0=NRKPS(I)
        JD=ABS(JD0)
        IF(ABS(DRKPS(I)).LT.TYNY)THEN
          IF(IORIG1(JD).GT.0)GO TO 91
          JD0=0               !RE-INDEX QRLPS AS MAY OCCUR LATER
          GO TO 94
        ENDIF
C
        K=K+1
        DRKPS(K)=DRKPS(I)
        NSTJ1(K)=NSTJ1(I)
        NSTJ1D(K)=NSTJ1D(I)
C
  94    IF(JD.LE.IRLPS0)THEN
          WRITE(6,*)'SPOR1: INFORM NRB OF STOP HERE'
          WRITE(0,*)'SPOR1: INFORM NRB OF STOP HERE'
          NF=-1
          GO TO 999
C        LP=JD
C        GO TO 92
        ENDIF
C
        IF(IORIG1(JD).EQ.0)THEN
          LP=JD-KP
          DO L=1,IRLPS0
            DO J=1,2
              IF(QRLPS(J,JD).NE.QRLPS(J,L))GO TO 95
            ENDDO
            KP=KP+1
            IORIG1(JD)=L
            LP=L
            GO TO 92
  95      ENDDO
        ELSE
          LP=IORIG1(JD)
          GO TO 92
        ENDIF
C
        IORIG1(JD)=LP
        DO J=1,2
          QRLPS(J,LP)=QRLPS(J,JD)
        ENDDO
C
  92    IF(JD0.NE.0)THEN
          NRKPS(K)=LP
C          IF(JD0.LT.0)NRKPS(K)=-NRKPS(K)
        ENDIF
C
  91  ENDDO
C
C
      IRLPS=IRLPS-KP
      IRKPS=K
 999  RETURN
C
 1    IZY=-1
      GO TO 999
C
      END SUBROUTINE SPOR1F
C
C                             *******************
C
      SUBROUTINE SPOR2(mam,nam,KK,IZY)
C
C-----------------------------------------------------------------------
C
C  SR.SPOR2 EVALUATES ALGEBRAIC CONTRIBUTIONS TO THE SPIN-ORBIT MATRIX
C  ELEMENTS BY LOOPING OVER ALL SLATER-STATE INTERACTIONS - NRB.
C
C  IT CALLS:
C    SR.RE_ALLOC
C    SR.RE_ALLOC2
C
C-----------------------------------------------------------------------
C
      USE COMMON_DC,     ONLY: BFAST,DC
      USE COMMON_COEFF,  ONLY: DRKP,QRLP,IRLP,NRKP,IXSOC,IXSOI
      USE COMMON_COEFFS, ONLY: DRKPS,QRLPS,NRKPS,IXS1C,IXS1I
      USE COMMON_NSTS1,  ONLY: NADS1,NSTJ1,NSTJ1D,IORIG1,JORIG1
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC,RE_ALLOC2
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (TYNY=1.0D-9)
      PARAMETER (TTYNY=10*TYNY)
C
      DIMENSION mam(*),nam(*)
C
      COMMON /BASIC/NF,KF,KG,JGAP(4),IGAP,NJ2,NJP2,MGAP(2)
      COMMON /NXRLP/IRKP,IRKP0
      COMMON /NSSADR/IRKPS,IRKPS0,IRLPS,IRLPS0,IRSS,IRSS0,NLS,NLS00
C
      IRLP0=IRLP
C      IRLP1=IRLP0+1
C
      DO J=1,IRLPS
        JORIG1(J)=0
      ENDDO
C
C BEGIN MAIN LOOP 65 OVER SLATER STATE INTERACTIONS
C
      K0=NADS1(KK-1)+1
C
      DO 65 KS=K0,NADS1(KK)
C
        L1=NSTJ1(KS)
        L2=NSTJ1D(KS)
C
        IF(BFAST)THEN
          DDH=DC(L1+NJ2)*DC(L2+NJP2)*DRKPS(KS)
        ELSE
          m1=mam(l1)
          if(m1.eq.0)go to 65
          m2=nam(l2)
          if(m2.eq.0)go to 65
          DDH=DC(m1)*DC(m2)*DRKPS(KS)
        ENDIF
C
        IF(ABS(DDH).LT.TYNY)GO TO 65
C
        N=NRKPS(KS)
        L=JORIG1(N)
        IF(L.GT.0)THEN
          K=IORIG1(L)
          DRKP(K)=DRKP(K)+DDH
        ELSE
C
C CANNOT FIND AN OLD SET OF ARGUMENTS EQUAL TO THE NEW SET, SO
C MUST START CONSTRUCTING A NEW COEFFICIENT.
C
          L=IRLP+1
          IF(L.GT.IXSOI)THEN                                    !GO TO 1
C
            IXXX=7*(IXSOI/5+1)
C
            WRITE(6,*)'*** SPOR2: increasing MXSOI from ',IXSOI,' to: '
     X                ,IXXX
            WRITE(0,*)'*** SPOR2: increasing MXSOI from ',IXSOI,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC2(QRLP,IONE,IFOUR,IONE,IXSOI,IFOUR,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR2: REALLOCATION FAILS FOR QRLP'
              NF=0
              GO TO 1
            ENDIF
C
            IXXX0=MAX(IXS1I,IXSOI)
            IXXX1=MAX(IXS1I,IXXX)
            IF(IXXX1.GT.IXXX0)
     X      CALL RE_ALLOC(IORIG1,IONE,IXXX0,IXXX1,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR2: REALLOCATION FAILS FOR IORIG1'
              NF=0
              GO TO 1
            ENDIF
C
            IXSOI=IXXX
C
          ENDIF
C
          IRKP=IRKP+1
          IF(IRKP.GT.IXSOC)THEN                                 !GO TO 1
C
            IXXX=7*(IXSOC/5+1)
C
            WRITE(6,*)'*** SPOR2: increasing MXSOC from ',IXSOC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** SPOR2: increasing MXSOC from ',IXSOC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DRKP,IONE,IXSOC,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR2: REALLOCATION FAILS FOR DRKP'
              NF=0
              GO TO 1
            ENDIF
C
            CALL RE_ALLOC(NRKP,IONE,IXSOC,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'SPOR2: REALLOCATION FAILS FOR NRKP'
              NF=0
              GO TO 1
            ENDIF
C
            IXSOC=IXXX
C
          ENDIF
C
          IRLP=L
          QRLP(1,L)=QRLPS(1,N)
          QRLP(2,L)=QRLPS(2,N)
          QRLP(3,L)=0
          QRLP(4,L)=0
          JORIG1(N)=L
          IORIG1(L)=IRKP
          NRKP(IRKP)=L
          DRKP(IRKP)=DDH
C
        ENDIF
C
  65  ENDDO
C
C IF THE MATRIX ELEMENT HAS BEEN CALCULATED CLEAR THE ARRAY  DRKP
C OF ZEROS AND ADJUST NRKP.
C
      IF(IRKP.LT.IRKP0)RETURN
C
      K=IRKP0-1
      N1=0
C
      DO I=IRKP0,IRKP
        IF(ABS(DRKP(I)).LT.TTYNY)GO TO 90
        K=K+1
        DRKP(K)=DRKP(I)
        N2=INT(NRKP(I))
        LP=N2-N1
        DO L=1,IRLP0
          DO J=1,2
            IF(QRLP(J,N2).NE.QRLP(J,L))GO TO 94
          ENDDO
          LP=L
          GO TO 91
  94    ENDDO
        N1=N1-1
        DO J=1,2
          QRLP(J,LP)=QRLP(J,N2)
        ENDDO
  91    NRKP(K)=LP
  90    N1=N1+1
      ENDDO
C
      IRLP=IRLP-N1
      IRKP=K
      RETURN
C
  1   IZY=-1
      RETURN
C
      END SUBROUTINE SPOR2
C
C                             *******************
C
      SUBROUTINE STOPOT(Z,MIONX,MK,AJUST0,DX1,MPOT,MI,MTI,DXI,X,POT,TOL
     X                 ,MEND,MPP)
C
C-----------------------------------------------------------------------
C
C                N.R. BADNELL    D.A.M.T.P.   CAMBRIDGE
C
C  SR.STOPOT CALCULATES A SLATER-TYPE-ORBITAL UNIVERSAL POTENTIAL, FOR
C  MIONX ELECTRONS - WHICH MAY BE N- (SR.RADIAL) OR N+1 (SR.RADCON).
C
C  BORT=.FALSE.
C  FOR MIONX ELECTRONS, FILL UP PRINCIPAL QUANTUM NUMBER SHELLS WITH
C  MIONX-1 ELECTRONS. ADJUSTABLE PARAMETER IS APPLIED TO ALL SHELLS.
C
C  BORT=.TRUE.
C  CALCULATE NEW STO POTENTIAL FOR EACH NL ORBITAL MK, BASED ON
C  CONFIGURATION NO MCFSTO(MK). IF NONE SPECIFIED THEN
C  AVERAGES NUMBER OF ELECTRONS FOR EACH ORBITAL OVER NUMBER OF
C  CONFIGURATIONS WHICH CONTAIN THEM. EXCLUDE CORRELATION CONFIGS
C  ALSO, EXCLUDE VALENCE DR, CONTINUUM AND SPECTATOR ELECTRONS.
C  ELECTRON WITH PRINCIPAL QUANTUM NUMBER NS IS A SPECTATOR ELECTRON
C  IF THERE ARE NO ELECTRONS WITH P.Q. NO NS-1 IN ANY OF THE CONFIGS
C  IF REQUIRE INPUT OF CONTINUUM ORBITALS FROM RADWIN RESET
C  DKEY TO 999, SEE BELOW.
C  SHELL NUMBER EQUALS PRINCIPAL QUANTUM NUMBER I.E. MC(N)=N.
C  ADJUSTABLE PARAMETER SCALES RADIAL COORDINATE AND IS APPLIED
C  TO ALL SHELLS, FOR NOW.
C
C  QUANTITIES REQUIRED: TOL AND ALL ARGUMENTS UP TO DX
C
C  Z=NUCLEAR CHARGE, MIONX=NUMBER OF ELECTRONS IN THE ION
C
C  ADJUST=SCALING PARAMETER (A VALUE GT 1.0 CONTRACTS THE EFFECTIVE
C  RADIAL SCALE, I.E. Z FALLS OFF MORE SLOWLY TOWARDS RESIDUAL ZN.
C
C  DXI(J),J=1,MI=STEP LENGTH IN THE J'TH INTERVAL -- STEP LENGTH IS
C  DOUBLED IN SUCCESSIVE INTERVALS, DX1=DXI(1) IS INPUT - SO ARE THE
C  NUMBERS MTI(J) OF STEPS IN THE MI INTERVALS J
C
C  DX(I),I=1,MPOT=RADIAL DISTANCE AT THE MPOT RADIAL POINTS I;
C  MPOT MUST BE EITHER EXACT OR LE 0 AND WILL BE EXACT ON RETURN.
C
C  MEND=INDEX OF THE LAST POINT FOR WHICH THE EFFECTIVE CHARGE HAS
C  NOT NECESSARILY THE RESIDUAL VALUE ZN; FOR X.GT.X(MEND) THE
C  POTENTIAL IS ZN/X=(Z-MIONX+1)/X. IF THE RANGE X(MPOT) IS TOO
C  SMALL FOR THE EFFECTIVE CHARGE TO DROP TO ZN CONTROL IS RETURNED
C  WITH DX1=2*DX1 -- WHILE DXI(1) CONTAINS THE ORIGINAL DX1.
C
C  POT(I),I=1,MPOT=VALUE OF THE POTENTIAL AT THE POINTS X(I).
C  POT(I) WAS STORED IN /COM1/- POT,TOL,MEND NOW OUTPUT THROUGH
C  ARGUMENT LIST & THEN STORED IN /COM1/IN RADIAL FOR USE IN RADWAV.
C
C  X(MEND) IS LAST POINT FOR WHICH POT*X/ZN .GT. TOL (TYPICALLY=0
C  THEN POTENTIAL IS COULOMB TO 1% AT DX(MEND))
C
C  IT CALLS:
C    SR.POTIN
C    SR.VPNL
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C      PARAMETER (MXD14=100)
C
      PARAMETER (D7999=7999.0D0)
      PARAMETER (TOLH=D1M2)
      PARAMETER (TOLW=1.D-3)   !TOLERANCE FOR MATCHING OCCUPATION NOS WK
C
      ALLOCATABLE :: MEL(:)
      ALLOCATABLE :: CAV(:),PAV(:)
C
      DIMENSION POT(*),X(*),DXI(*),MTI(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /CALAN/DALAN(MXVAR),BALAN
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
C      COMMON /NRBCAV/ECAVX(MAXCF),ECAV(MAXCF),AJUSTX,ICAV
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
C      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
C
      DATA MP0/0/,MP00/0/
C
C CHECK HISTORIC USAGE
C
      IF(Z.EQ.DZERO)THEN
        WRITE(0,*)'*** ERROR: SR.STOPOT NO LONGER INITIALS DX1,',
     X            ' CALL SR.MESH INSTEAD'
        WRITE(6,*)'*** ERROR: SR.STOPOT NO LONGER INITIALS DX1,',
     X            ' CALL SR.MESH INSTEAD'
        GO TO 999
      ENDIF
C
C GO READ EXTERNAL POTENTIAL (& RETURN)
C
      IF(MHF*MK.GT.0)THEN
C
        CALL POTIN(Z,MIONX,MK,MPOT,X,POT,MEND)
C
        GO TO 300                                 !RETURN
C
      ENDIF
C
C SOME INITIALIZATIONS
C
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
C
      BREL2=ABS(IREL).EQ.2
      BORT=MORT.LT.0
C
      IF(MPP.LT.MP0)MP0=MPP
C
      NOCCM=MOD(NOCC,I1000)
C
      MCFMXX=MCFMX
      IF(MCFMXX.GT.I1000)MCFMXX=0         !AVERAGE OVER MOD(MCFMX,I1000)
C
C     DTOL=0.01
      DTOL=TOL
C
C     DKEY=999                            !FLAG EXCLUDE RADWIN FROM POT
      DKEY=5999                           !FLAG EXCLUDE RYDBERG AS WELL
C
C NEGATIVE SCALING PARAMETERS/LAMDAS FLAG SCREENED HYDROGENIC
C
      AJUST=AJUST0
      IF(ABS(AJUST).LT.D1M2.AND.MPP.LT.2)AJUST=DONE      !FOR DIRECT STO
C
      IF(AJUST.LT.DZERO)THEN
        TA=-AJUST*Z
        TB=(DONE+AJUST)*Z
        ZH=Z/DTWO
        MEND=1
        DO J=1,MPOT
          T=EXP(-ZH*X(J))            !HISTORIC CUSP CONDITION AT ORIGIN
          T=T*TB
          POT(J)=(TA+T)/X(J)
          IF(ABS(T/TA).GT.TOLH)MEND=J
        ENDDO
        IF(MEND.LT.MPOT)GO TO 300                 !RETURN
        DX1=DX1+DX1
        T=T/X(MEND)
        WRITE(6,996) AJUST,X(MEND),POT(MEND),T
        GO TO 300                                 !RETURN
      ENDIF
C
C DETERMINE INITIAL ASYMPTOTIC CHARGE
C
      ZN=1-MIONX
      ZN=Z+ZN
      ZN1=ZN
      IF(NINT(ZN1).EQ.0)ZN1=DONE
C
C IF ONLY ONE ELECTRON IS PRESENT THE POTENTIAL IS PURELY COULOMBIC
C
      IF(MIONX.EQ.1)THEN
        MEND=1
        DO I=1,MPOT
          POT(I)=ZN/X(I)
        ENDDO
        GO TO 300                                 !RETURN
      ENDIF
C
      ISWCH0=0
      DO I=1,MXORB                                          !MAXGR
        IF(QN(I).LT.0.OR.IVAL(I).NE.0.OR.SCREEN(I).GE.D7999)ISWCH0=1
      ENDDO
      BNLSUB=(MIONX-ISWCH0).GT.NLSTOE.OR.BALAN   !RESOLVE BY NL-SUBSHELL
C
      ISWCH=0
      IF(QN(MK).LT.0.OR.IVAL(MK).NE.0.OR.SCREEN(MK).GE.D7999)ISWCH=1
C
      IF(MCFMXX.LT.0.AND.ISWCH.EQ.1)THEN       !CASE IF -MCFMX TOO LARGE
        KF=KMAX
        IF(KCUT.GT.0.AND.IEQ(0).GE.0)KF=MIN(KCUT,KMAX)
        DO K=1,KF
          I=QCG(NF,K)
          IF(QN(I).LT.0.OR.IVAL(I).NE.0.OR.SCREEN(I).GE.D7999)MCFMXX=K
        ENDDO
        MCFMXX=-MCFMXX
      ENDIF
C
C GO TO SELF-CONSISTENT
C
      IF(MPP.GT.1)GO TO 50
C
      IF(BORT)GO TO 12
C
C V(LL) POTENTIAL
C
      MXSH=10
      ALLOCATE (MEL(MXSH))
C
      IOK=2
      NN=MIONX-1
      MS=0
      IF(NN.GT.88)MS=-1                                   !JUICYS
C
      IF(MSHELL.GT.0)GO TO 15
      IF(MS.EQ.0)GO TO 14
C
      MSHELL=2
      MEL(1)=88
      MEL(2)=NN-88
      GO TO 15
C
   14 MC(1)=1
      MEL(1)=2
      MC(2)=2
      MEL(2)=8
C
      IF(NN.GT.56)GO TO 8
C
      MC(3)=3
      MEL(3)=8
      MC(4)=4
      MEL(4)=2
      MC(5)=3
      MEL(5)=10
      MC(6)=4
      MEL(6)=6
      MC(7)=5
      MEL(7)=2
      MC(8)=4
      MEL(8)=10
      MC(9)=5
      MEL(9)=6
      MC(10)=6
      MEL(10)=2
      GO TO 9
c
    8 MC(3)=3
      MEL(3)=18
      MC(4)=4
      MEL(4)=18
      MC(5)=5
      MEL(5)=8
      MC(6)=6
      MEL(6)=2
      MC(7)=4
      MEL(7)=14
      MC(8)=5
      MEL(8)=10
      MC(9)=6
      MEL(9)=6
      MC(10)=7
      MEL(10)=2
C
    9 DO I=1,MXSH
        NN=NN-MEL(I)
        IF(NN.LE.0)GO TO 11
      ENDDO
C
   11 NN=NN+MEL(I)
      MEL(I)=NN
      MSHELL=I
C
   15 IF(NOCCM.NE.0)THEN
        MSHELL=ABS(NOCCM)
        IF(MSHELL.GT.MXSH)THEN
          WRITE(6,*)'*** SR.STOPOT: ONLY MXSH=',MXSH,' SHELLS DEFINED'
     X              ,'BUT USER NOCC GIVES MSHELL=',MSHELL
          WRITE(0,*)'*** SR.STOPOT: ONLY MXSH=',MXSH,' SHELLS DEFINED'
     X              ,'BUT USER NOCC GIVES MSHELL=',MSHELL
          GO TO 999
        ENDIF
        WKT=0
        DO I=1,MSHELL
          WKT=WKT+TEL(I)
        ENDDO
        IF(ABS(WKT-MIONX).GT.TOLW)THEN
          WRITE(6,1005)WKT,MIONX
          WRITE(0,1005)WKT,MIONX
          GO TO 999
        ENDIF
      ELSE
        DO I=1,MSHELL
          TEL(I)=MEL(I)
        ENDDO
      ENDIF
      GO TO 30
C
C V(NL) POTENTIAL
C
C
  12  CONTINUE
      IF(IEQ(0).GT.0.AND.IRLX.LT.0)THEN                  !NO COMMON CORE
        MA0=0
        MB0=0
      ELSE                                                  !COMMON CORE
        MA0=MA
        MB0=MB
      ENDIF
      BCORE=IEQ(MK).GE.MA0.AND.IEQ(MK).LE.MB0              !IEQ UNNECESS
C
      MXSH=10
      IF(BNLSUB)MXSH=MXORB
C
      ALLOCATE (MEL(MXSH))
C
      DO J=1,MXSH
        MC(J)=J
        IF(BNLSUB)MC(J)=MOD(INT(QN(J),SP),I70)      !CASE RADWIN FLAGGED
      ENDDO
C
      IF(BNLSUB)THEN
        MS=MK
        IF(QN(MK).LT.0)MS=-MS
      ELSE
        MS=QN(MK)
        MS=MOD(MS,I70)
      ENDIF
C
C USER INPUT OCCUPATION NUMBERS
C
      IF(NOCCM.NE.0)THEN
        MSHELL=ABS(NOCCM)
        IF(MS.LT.0.OR.IVAL(MK).GT.0)MS=0
        ZN=ZN+ISWCH0
        GO TO 30
      ENDIF
C
C DETERMINE OCCUPATION NUMBERS FROM FLAGGED CONFIG(S)
C
      DO J=1,MXSH
        TEL(J)=DZERO
        MEL(J)=0
      ENDDO
C
      MSHELL=0
      KAV=0
      NZ=0
C
      IF(MCFMXX.GT.0.AND.(IEQ(0).GE.0.OR.IEQ(0).LT.0.AND.BCORE))THEN
C
C DETERMINE OCCUPATION NUMBERS FOR CONFIG. SPECIFIED FOR THIS ORBITAL
C (N.B. MCFSTO(MK) NOT SPECIFIED FOR VALENCE, CASE IEQ(0).LT.0)
C
        IF(MK.GT.MCFMXX)THEN
          KS=MCFSTO(MCFMXX)
        ELSE
          KS=MCFSTO(MK)
        ENDIF
        KF=KS
        IF(KS.LE.0)THEN
          IF(BCORE)THEN                            !AVERAGE OVER ALL CFS
            KS=1
            KF=KMAX
          ELSE
            WRITE(6,992)KS,MK
            WRITE(0,*)'SR.STOPOT: CONFIGURATION NOT SET FOR ORBITAL'
            GO TO 999
          ENDIF
        ENDIF
        IF(KS.GT.KMAX)THEN
          DO J=1,MXORB
            NN=NEL(J,KMAX)
            IF(NN.NE.0)THEN
              TEL(J)=ABS(NN)
              MSHELL=J
            ENDIF
          ENDDO
          IF(MS.LT.0.OR.IVAL(MK).GT.0)MS=0
          ZN=ZN+ISWCH0
          GO TO 30
        ENDIF
      ELSE
C
C USE CONFIGURATION AVERAGE
C
        KS=1
        KF=KMAX
        IF(IEQ(0).GE.0)THEN
          IF(KCUT.GT.0)KF=MIN(KCUT,KMAX)
          IF(MCFMX.GT.I1000)KF=MIN(MOD(MCFMX,I1000),KMAX) !SO NOT KCUT
          IF(mcfmxx.lt.0)kf=min(-mcfmxx,kmax)
        ENDIF
      ENDIF
C
  19  bdw=idw.ne.0.and.qn(mk).lt.0
c           allow target average but an override for cont e.g. Laguerres
      if(bdw.and.mcfsto(mk).ne.0)then
        ks=mcfsto(mk)
        kf=ks
      endif
c
      DO 23 K=KS,KF
C
        IF(.NOT.BCORE.and.mcfmxx.ge.0)THEN
C
C AVERAGE OVER ONLY THOSE CONFIGS THAT CONTAIN MK.
C
          DO I=1,NF
            IF(QCG(I,K).EQ.MK)THEN
              IF(IEQ(0).LT.0.AND.MCFSTO(MK).EQ.0)MCFSTO(MK)=K
              GO TO 21
            ENDIF
          ENDDO
          IF(MCFMXX.LE.0)then
            if(bdw)go to 21
            GO TO 23
          ENDIF
COLD      IF(IVAL(MK).GT.0.OR.SCREEN(MK).GT.DKEY)GO TO 21
          MF=QCG(NF,K)
          IF(SCREEN(MK).GT.DKEY.AND.(QN(MF).LT.0.OR.IVAL(MF).NE.0.OR.
     X       SCREEN(MF).GT.DKEY).or.bdw)GO TO 21
C
          IF(IEQ(0).GT.0.AND.IEQ(MK).LE.MB)GO TO 21
          IF(IEQ(0).LT.0)GO TO 23
C
          MS=0
          IF(MHF.GE.-100.OR.MK.NE.MCFMXX)THEN     !NEED FOR POTOUT='YES'
            WRITE(6,993) MK,K
            WRITE(0,*)'*****ERROR IN SR.STOPOT: ORBITAL NOT FOUND IN CF'
            GO TO 999
          ENDIF
        ENDIF
C
C USE MCFMX.LT.0 TO AVERAGE OVER -MCFMX
C
  21    KAV=KAV+1
        N0=100
        IOK=0
C                                                       I1=1
        DO 25 I=1,MXORB                             !L=1,NF
C          I=QCG(L,K)
          I1=NEL(I,K)
          IF(I1.LE.0)GO TO 25                               !ALL CORE
          IF(I.EQ.MK)IOK=IOK+I1
          MJ=QN(I)
          J=MOD(MJ,I70)
          IF(BNLSUB)J=I
          NZ=NZ+I1
          IF(IVAL(I).GT.0.AND.(QN(I).GE.ABS(QN(MK)).OR.QN(MK).LT.0))
     X                            GO TO 25
          if(dadjus(i).lt.dzero.and.qn(mk).lt.0)go to 25      !for dw
          IF(SCREEN(I).GT.DKEY)GO TO 25
          IF(QN(I).LT.0)GO TO 25
          IF(J.GT.MXSH)GO TO 25
          IF((J-N0).GT.1.AND.ABS(MS).LT.J)GO TO 25
          NZ=NZ-I1
          N0=J
          IF(J.GT.MSHELL)MSHELL=J
          MEL(J)=MEL(J)+I1
  25    ENDDO
C
        IF(MS.GT.MXSH.OR.MS.LT.0.OR.IVAL(MK).GT.0)NZ=NZ-1
C
  23  ENDDO
C
      IF(KAV.EQ.0)THEN
        IF(MCFMXX.EQ.0.AND.KF.LT.KMAX)THEN       !CORRELATION ORBITAL
          KF=KMAX                                   !NOT IN KCUT, SO
          GO TO 19
        ELSE
          WRITE(6,991)MK,KF
          WRITE(0,*)'*****ERROR IN SR.STOPOT: ORBITAL NOT FOUND IN CFS'
          GO TO 999
        ENDIF
      ENDIF
C
      IF(MB.GT.0)THEN
        DO I=MA,MB
          MJ=QN(I)
          J=MOD(MJ,I70)
          IF(BNLSUB)J=I
          IF(J.GT.MSHELL)MSHELL=J
          MEL(J)=MEL(J)+2*(QL(I)+1)*KAV
        ENDDO
      ENDIF
C
      T1=KAV
      TZ=NZ
      TZ=TZ/T1
      ZN=ZN+TZ
      IF(MPP.EQ.0)THEN
        NZ=NINT(TZ)
        IF(ABS(TZ-NZ).GT.TOLW)THEN          !FOR MCFMX.GT.0 NZ IS 0 OR 1
          IF(BPRNT0)WRITE(6,1001)TZ
C          WRITE(0,1001)TZ
C          GO TO 999
        ENDIF
      ENDIF
c      write(6,*)mk,ajust,zn
C
      DO J=1,MSHELL
        T2=MEL(J)
        TEL(J)=T2/T1
c        if(t2.ne.dzero)write(6,*)j,tel(j)
      ENDDO
C
      IF(MS.LT.0.OR.IVAL(MK).GT.0)MS=0
C
C POTENTIAL RE-ENTRY POINT
C
  30  CONTINUE
C
c      write(66,*)-mk,ajust
      DO J=1,MSHELL
        ALF(J)=AJUST
        IF(BALAN)ALF(J)=DALAN(J)
C       WRITE(6,997)J,ALF(J)
c        if(tel(j).ne.dzero)write(6,*)j,tel(j)
      ENDDO
C
      DZ=-Z
      MEND=1
      TS=DONE
      MN=QN(MK)
      MN=ABS(MN)
      IF(IOK.EQ.1)MN=-MN
      ML=QL(MK)/2
      ZN1=ZN
      IF(NINT(ZN1).EQ.0)ZN1=DONE
C
      DO I=1,MPOT
C
        POT(I)=-ZEFX(MS,MN,ML,DZ,TS,MSHELL,MC,TEL,ALF,X(I),MEXPOT)
C
c        write(6,887) i,x(i),pot(i)
c 887    format(i5,2f16.6)
C
        T=POT(I)*X(I)/ZN1
        IF(ABS(T).GT.DTOL)MEND=I
        POT(I)=POT(I)+ZN/X(I)
C
      ENDDO
c
c      do j=1,mend
c        write(66,887)j,x(j),pot(j),x(j)*pot(j)
c 997    format(i5,3f16.6)
c      enddo
C
      IF(MEND.GE.MPOT)THEN
        DX1=DX1+DX1
        DZ=ZN/X(MPOT)
        T=POT(I)-DZ
        WRITE(6,996)AJUST,X(MPOT),DZ,T
      ENDIF
      GO TO 300                                   !RETURN
C
C SELF-CONSISTENT
C
  50  CONTINUE
C
C NOCC.LT.0 USES A DIFFERENT POTENTIAL FOR EACH ORBITAL.
C IF MCFMX IS SET APPROPRIATELY, IT CAN BE THE SAME AVERAGE
C POTENTIAL FOR EACH ORBITAL SAVE FOR THE OMITTED SELF-INTERACTION
C TERM I.E. THE ORBITALS ARE (STILL) NOT ORTHOGONAL.
c
      if(nocc.lt.0.or.iswch.gt.0)then
C
        BPRNTX=MCFMXX.LT.0.AND.BPRNT0.AND.MP00.EQ.0
        IF(BPRNTX.AND.MP00.EQ.0)WRITE(6,994)NOCCM,MCFMXX
C
        CALL VPNL(Z,MIONX,MK,WK,AJUST,MPOT,MI,MTI,DXI,POT,DTOL,MEND)
c
c        write(6,*)mk,wk
c        do j=1,mend
c          write(6,887)j,x(j),x(j)*pot(j)
c 887      format(i5,3f10.6)
c        enddo
C
        IF(BPRNTX)THEN
          WKT=0
          DO J=1,MSHELL
            IF(TEL(J).NE.DZERO)THEN
              WKT=WKT+TEL(J)
              WRITE(6,995)J,TEL(J)
c          write(0,*)j,tel(j)
            ENDIF
          ENDDO
          WRITE(6,1000)WKT
          WRITE(6,997)
        ENDIF
C
        MP0=MPP
        IF(BPRNT0)MP00=MP0
C
        wkt=0
        do k=1,mxorb
          wkt=wkt+tel(k)
        enddo
        if(abs(wkt-mionx).gt.tolw.and.abs(wkt-mionx+iswch).gt.tolw
     x                          .and.abs(wkt-mionx+iswch0).gt.tolw)then
          IF(BPRNT0)WRITE(6,1003)WKT,MIONX-iswch,MK
          if(iswch.eq.1)then
            write(0,1003)wkt,mionx-iswch,mk
            if(.not.bprnt0)write(6,1003)wkt,mionx-iswch,mk
            if(nocc.lt.0)go to 999
          endif
        endif
      endif
C
C NOCC.GE.0 USES A SINGLE UNIQUE POTENTIAL BY AVERAGING OVER THE
C POTENTIALS USED FOR EACH ORBITAL - THE AVERAGE OF THE MODEL
C CONFIGURATION.
C
      IF(MPP.GT.MP0.and.nocc.ge.0)THEN
C
        ALLOCATE (CAV(MPOT),PAV(MPOT))
C
        DO I=1,MPOT
          PAV(I)=DZERO
          CAV(I)=DZERO
        ENDDO
C
        IF(BPRNT0.AND.MP00.EQ.0)WRITE(6,994)NOCCM,MCFMXX
        WKT=0
        DO K=1,MXORB                                          !MAXGR
          IF(DEY(K).NE.DZERO.AND.IVAL(K).EQ.0.AND.SCREEN(K).LT.DKEY.and.
     x      (noccm.eq.0.or.noccm.ne.0.and.tel(k).gt.tolw))THEN
C
            CALL VPNL(Z,MIONX,K,WK,AJUST,MPOT,MI,MTI,DXI,POT,DTOL,MEND)
C
            IF(BPRNT0.AND.MP00.EQ.0)THEN
c              write(0,995)k,wk
              WRITE(6,995)K,WK
            ENDIF
            WKT=WKT+WK
            IF(WK.GT.TOLW)THEN
              DO I=1,MPOT
                T=DPNL(I,K)*DPNL(I,K)
                IF(BREL2)T=T+DQNL(I,K)*DQNL(I,K)
                T=T*WK
                PAV(I)=PAV(I)+POT(I)            !*T !IF NOT IN VPNL
                CAV(I)=CAV(I)+T
              ENDDO
            ENDIF
          ENDIF
        ENDDO
        IF(BPRNT0.AND.MP00.EQ.0)THEN
          WRITE(6,1000)WKT
          WRITE(6,997)
        ENDIF
C
c        if(mp0.eq.0)write(0,*)wkt
        IF(ABS(WKT-MIONX).GT.TOLW.and.abs(wkt-mionx+iswch0).gt.tolw)THEN
          IF(BPRNT0)WRITE(6,1002)WKT,MIONX-iswch0
c          WRITE(0,1002)WKT,MIONX-iswch0
c          GO TO 999
        ENDIF
C
C (RE-) INITIALIZE POT
C
        ZN=ZN+iswch0-iswch
        ZN1=ZN
        IF(NINT(ZN1).EQ.0)ZN1=DONE
        DO I=1,MPOT
          POT(I)=PAV(I)/CAV(I)
          T=POT(I)-ZN/X(I)
          T=T*X(I)/ZN1
          IF(ABS(T).GT.DTOL)MEND=I
c          if(bprnt0)write(77,*)i,x(i),x(i)*pot(i),-pot(i)
        ENDDO
C
        DEALLOCATE (CAV,PAV)
C
        MP0=MPP
        IF(BPRNT0)MP00=MP0
C
        IF(MEND.LT.MPOT)GO TO 300
C
        T=POT(MPOT)*X(MPOT)
C
        WRITE(6,1006)MK,X(MPOT),ZN,T
C
      ENDIF
C
  300 CONTINUE
C
      IF(ALLOCATED(MEL))DEALLOCATE (MEL)
C
      RETURN
C
  999 NF=-1
      GO TO 300
C
  991 FORMAT(' *** ERROR IN SR.STOPOT: ORBITAL',I4,' NOT FOUND IN'
     X,' THE FIRST',I4,' CONFIGURATIONS')
  992 FORMAT( '*** ERROR IN SR.STOPOT: NON-VALID CONFIGURATION',I3
     X,' SPECIFIED FOR ORBITAL ', I3)
  993 FORMAT( '*** ERROR IN SR.STOPOT: ORBITAL ', I3,
     X' NOT FOUND IN CONFIGURATION ', I3)
  994 FORMAT(//' CONFIGURATION AVERAGE OCCUPATION NUMBERS FOR NOCC=',I3
     X,5X,'MCFMX=',I5/)
  995 FORMAT(I3,F10.4)
  996 FORMAT( ' SR.STOPOT  (ADJUST,X(MPOT),COUL-POT(MPOT),NON-COUL) =',
     X4F10.5/ '  RETURN WITH INITIAL STEP LENGTH DOUBLED')
  997 FORMAT(///)
 1000 FORMAT(/'SUM',F10.3)
 1001 FORMAT(' *** SR.STOPOT: WARNING, ASYMPTOTIC CHARGE= Z-N+',F6.2)
 1002 FORMAT(' *** SR.STOPOT: SR.VPNL GIVES FICTIONAL AVERAGE CF'
     X              ,' WITH WK.NE.MION:',F6.2,I3)
 1003 FORMAT(' *** SR.STOPOT: SR.VPNL GIVES FICTIONAL AVERAGE CF'
     X              ,' WITH WK.NE.MION:',F6.2,I3,' FOR ORBITAL',I3)
 1005 FORMAT('*** SR.STOPOT: USER INPUT NOCC GIVES'
     X              ,' WK.NE.MION:',F6.2,I3)
 1006 FORMAT(' *** SR.STOPOT: NOT ENOUGH MESH POINTS FOR ORBITAL?',I5
     X,' CHECK IF ASYMPTOTIC POTENTIAL ACCURATE ENOUGH:',1P,3E11.3)
C
      END SUBROUTINE STOPOT
C
C                             *******************
C
      SUBROUTINE STORAD(ZA,MAXRS,MAXPS,MXORB)
C
C-----------------------------------------------------------------------
C
C  SR.STORAD INITIALIZES DPNL TO STO'S.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /CHARY/DEY(MAXGR)
C
      DO I=1,MXORB
        IF(DEY(I).EQ.DZERO)GO TO 1
        IF(QN(I).LT.0.OR.QN(I).GT.10)GO TO 1
        N=QN(I)
        XNT=1                                    !AVOID INTEGER OVERFLOW
        DO J=1,N
          XNT=XNT*2*J*(2*J-1)
        ENDDO
        AN=REAL(N*XNT/2,WP)
        AN=SQRT(ZA/AN)
        T=N
        T=ZA/T
        DO J=1,MAXRS
          DPNL(J,I)=DZERO
          TX=T*DX(J)
          IF(TX.LT.D1P2)DPNL(J,I)=AN*(TX+TX)**N*EXP(-TX)
          IF(ABS(DPNL(J,I)).GT.D1M6)MAXPS=MAX(MAXPS,J)
        ENDDO
   1  ENDDO
C
      RETURN
C
      END SUBROUTINE STORAD
C
C                             *******************
C
      SUBROUTINE SYMLS
C
C-----------------------------------------------------------------------
C
C  SR.SYMLS
C     DETERMINES THE LSP SYMMETRIES AND CHANNEL LIST BASED-UPON THE USER
C     SPECIFIED MINST, MAXST  & MINLT, MAXLT, OR DIRECT LSP INPUT,
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBIAD, ONLY: IADD
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /BASIC/NF,INASTX,NCHMX,J1,J2,J1P,J2P,ND1,NDP1,LL(2),MAXLX0
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBOO/KUTOO,KUTOOX,MAXLOO
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                    !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD(NCOR)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
C
C INITIALIZATIONS
C
      BKUTOO=KUTOOX.NE.0
C
      BPRNT0=JPRINT.NE.-3
C
      BTHRSH=LVMAX.GE.0
C
C SCATTERING SYMMETRY RESTRICTIONS
C
      IF(MXLAMX.EQ.1000)THEN                     !MAX EXCHANGE MULTIPOLE
        IF(MAXLX.GE.100)THEN
          MXLAMX=NXLL+3                      !TWICE MAX ORB L+3 (was +1)
        ELSE
C          MXLAMX=(MAXLX+1)/2
          MXLAMX=MAXLX-NXLL/2
        ENDIF
      ENDIF
C
C      IF(MAXLX.GE.100)MAXLX=2*MXLAMX                !MAX L FOR EXCHANGE
      IF(MAXLX.GE.100)MAXLX=MXLAMX+NXLL/2            !MAX L FOR EXCHANGE
      IF(INAST0.LE.0.AND.MAXLX.LT.MAXLT+2)THEN
        MAXLX=MAX(MAXLX,INT(QCL0/2-1,SP))  !ALL CHANNELS TO SCALE DIRECT
      ENDIF
      MAXLX0=MAXLX                            !PASS THRU TO FLGLX1,RESX1
C
      IF(MAXLOO.GE.100)MAXLOO=MAXLX
C
      WRITE(6,1007)
      WRITE(6,1112)MAXLX
      IF(MXLAMX.NE.1000)WRITE(6,152)MXLAMX
      IF(NMULTE.LT.100)WRITE(6,153)NMULTE
      IF(BKUTOO)WRITE(6,154)MAXLOO
C
      IF(INAST0.GT.0)THEN
C
        WRITE(6,1113)
        MAXLT=0
        DO I=1,INAST0
          IS=LSPI(I)/10000
          IP=LSPI(I)-IS*10000
          IL=IP/10
          IP=IP-IL*10
          WRITE(6,1114)I,IS,IL,IP
          MAXLT=MAX(MAXLT,IL)
        ENDDO
        MAXLT=-MAXLT                                    !FLAG FOR ALGXLS
C
      ELSE

        IF(ABS(MODD).GT.1)THEN
C
          IF(BTHRSH)THEN
C
            MAXL=LVMAX+QCL0/2
            IF(MAXLT.EQ.1000)MAXLT=MAXL
            IF(MAXLT.GT.MAXL)THEN
              WRITE(6,1007)
              WRITE(6,1008)MAXL,LVMAX
              WRITE(6,1007)
              MAXLT=MAXL
            ELSEIF(MAXLT.LT.MAXL)THEN
              WRITE(6,1007)
              WRITE(6,1009)MAXLT,LVMAX,MAXL
              WRITE(6,1007)
C              MAXLT=MAXL                     !ALLOW USER TO RESTRICT...
            ENDIF
C
            MINL=LVMIN-QCL0/2
            MINL=MAX(IZERO,MINL)
            IF(MINLT.GT.MINL)THEN
              WRITE(6,1007)
              WRITE(6,1010)MINLT,LVMIN,MINL
              WRITE(6,1007)
c              MINLT=MINL                     !ALLOW USER TO RESTRICT...
            ELSEIF(MINLT.LT.MINL)THEN
              WRITE(6,1007)
              WRITE(6,1011)MINL,LVMIN
              WRITE(6,1007)
              MINLT=MINL
            ENDIF
C
          ELSE
C
            IF(MAXLT.EQ.1000)MAXLT=30
            IF(MAXLT.GT.100)THEN
              MAXLT=100
              WRITE(0,*)'*** SR.SYMLS: REDUCING MAXLT TO',MAXLT
              MINLT=MIN(MINLT,MAXLT)
            ENDIF
C
            IF(MINLT.LT.0)MINLT=0
C
          ENDIF

        ENDIF
C
        IF(MINSP.LT.1)MINSP=1                 !2S+1 TOT
        I1=MOD(INT(QCS0,SP),ITWO)
        I0=MOD(MINSP-1,ITWO)
        IF(I0.EQ.I1)MINSP=MINSP+1
        MAXSP=MIN(MAXSP,INT(QCS0+2,SP))
C
        WRITE(6,1115)MINSP,MAXSP,MINLT,MAXLT
C
        IF(IPAR.NE.2)WRITE(6,1119)IPAR
        IPAR=ABS(IPAR)
        IPAR=MOD(IPAR,ITHREE)                     !0-EVEN, 1-ODD, 2-BOTH
        IPART=MAX(IONE,IPAR)
C
      ENDIF
C
      WRITE(6,1007)
C
C SET-UP SCATTERING SYMMETRY LIST
C
      IF(INAST0.GT.0)THEN
C
        INAST=INAST0
        INASTX=999
        IFORE=0
        LFACT=100
C
      ELSE
C
        INAST=0
        INASTX=0                   !999 for no use of symmetry,0 for use
cpar        inastx=999                                              !par
        IFORE=(MAXSP-MINSP)/2
        IF(MINSP.GT.1)IFORE=IFORE+1
        IFORE=IFORE*IPART
C
        IP0=MOD(IPAR,ITWO)
        IP1=MIN(IPAR,IONE)
        FACTL=REAL(LFACT,WP)/D100
        IL=MINLT
C
   54   DO IS=MINSP,MAXSP,2
          DO IP=IP0,IP1
            INAST=INAST+1
            BLX=INAST.LE.MAXSL
            IF(BLX)LSPI(INAST)=10000*IS+10*IL+IP
          ENDDO
        ENDDO
C
        if(lfact.gt.100)il0=il
        IF(IL.GT.MAX(MAXLX,15_SP))IL=NINT(IL*FACTL)
        IL=IL+1
        IF(IL.LE.MAXLT)GO TO 54
        if(lfact.gt.100)then
          if(lrglam.gt.il0)lrglam=il0               !case factl "misses"
          maxlt=il0
        endif
C
        CALL DIMUSE('MAXSL',INAST)
C
        IF(INAST.GT.MAXSL)THEN
          WRITE(6,194)INAST
          WRITE(0,194)INAST
          GO TO 999
        ENDIF
C
      ENDIF
C
C SET-UP CHANNEL LIST BY GROUP
C
      MXX=0
      NNN=0
      NCHTOT=0
      NCHMX=0
      INAST0=INAST                     !SINCE WILL REDUCE IF NO CHANNELS
      IX=0
      IPAR4=0
      ncorr=0
C
      DO I0=1,INAST0
C
        IX=IX+1
        IS=LSPI(IX)/10000
        IP=LSPI(IX)-IS*10000
        IL=IP/10
        IP=IP-IL*10
C                                                                 !ALIGN
        MTS=IS-1
        MTL=IL+IL
        MTP=IP+IP
C
        LUP=0
        LLOW=999
        NN=0
        DO N=1,NSL0
          IF(QSI(N)+1.ne.MTS.and.QSI(N)-1.ne.MTS)GO TO 60
          if(il.gt.maxlx.and.qsi(n).gt.mts)go to 60                  !nx
          LCON=MIN(INT(QLI(N),SP),LCONDW-1)
          LMIN=ABS(MTL-LCON)
          LMAX=MTL+LCON
          I1=MOD(LMAX,IFOUR)
          IF(MTP.NE.ABS(I1-QPI(N)))THEN                    !ALIGN PARITY
            LMAX=LMAX-2
            LMIN=LMIN+2
          ENDIF
          IF(LMAX.GE.LMIN)THEN
            NN=NN+1
            BLY=NN.LE.MXCHG
            IF(BLY)THEN
              ITARG(NN,IX)=N
              LLCH(1,NN,IX)=LMIN
              LLCH(2,NN,IX)=LMAX
            ENDIF
            QSNX=QSI(N)
            LUP=MAX(LUP,LMAX)
            LLOW=MIN(LLOW,LMIN)
          ENDIF
  60    ENDDO
C
C SINCE WE ARE KEYED ON SMALL L. (THIS IS "APPROXIMATE" FOR 2FS!)
C
c        IF(BTHRSH.AND.(LVMAX.LT.LLOW/2.OR.LVMIN.GT.LUP/2))NN=0  !DROP
c
c Can't use if scaling non-exchange since indexing currently assumes
c same S present for each Lp, i.e. we can use MAXST or IPAR (or MAXLT)
c since the same selection is applied to ALL symmetries but cannot vary
c selection between symmetries. Not a big saving since it likely only
c affects a couple of symmetries on the final L. So, re-working the
c NX indexing is not a high priority esp. since BTHRSH is ADAS-specific.
C
        IF(NN.GT.0)THEN
          MXX=MAX(MXX,NN)
          NWT=IS
          if(il.gt.maxlx)nwt=-2*(qsnx+1)                          !nx
C
          IF(BPRNT0)WRITE(6,1116)IX,NWT,IL,IP
C
          NCHG(IX)=NN
          NADG(IX)=NNN-ncorr
C
c          nchs=0
          NCHL=0
          IF(BLY)THEN
            DO N=1,NN
              NC=ITARG(N,IX)
              MC=NSL(NC)
              MCI=NGRPI(NC)
              L1=LLCH(1,N,IX)
              L2=LLCH(2,N,IX)
              LD=((L2-L1)/4+1)
              NCH=MC*LD
              DO L=L1,L2,4
                DO M=1,MC
                  J1=M+MCI
                  NCHL=NCHL+1
c                  if(jndex(j1).gt.0)nchs=nchs+1
                  IF(BPRNT0)WRITE(6,1117)NCHL,J1,L/2
c                  write(6,1118)nch,j1,qsi(j1)+1,qli(j1)/2,qpi(j1)/2,l/2
                ENDDO
              ENDDO
              DO NP=1,N
                ND=ITARG(NP,IX)
                beqgrp=nc.eq.nd
                beqgrpl=beqgrpl0.and.beqgrp
                IF(NMETAG(NC)+NMETAG(ND).LT.2)THEN
                  IF(beqgrp)THEN
                    LDP=(LD*(LD+1))/2
                    LD=1
                    NCH=MC
                  ELSE
                    L1P=LLCH(1,NP,IX)
                    L2P=LLCH(2,NP,IX)
                    LDP=((L2P-L1P)/4+1)
                  ENDIF
                  MCP=NSL(ND)
                  NCHP=MCP*LDP
                  NNN=NNN+NCH*NCHP
                  if(bcorr)then
                    nco=0
                    nce=0
c            do li=l1,l2,4
c              lf2=l2p
c              if(nc.eq.nd)then
c                lf2=li
c                l1p=llch(1,np,ix)
c              endif
c              do lf=l1p,lf2,4
                    mcip=ngrpi(nd)
                    do m=1,mc
                      j1=m+mci
                      j=jndex(j1)
                      do mp=1,mcp
                        j1p=mp+mcip
c                        if(j1p.gt.j1-ione0.and.li.eq.lf)go to 61
                        jp=jndex(j1p)
                        if(j.lt.0.and.jp.lt.0)then
                          nco=nco+1                         !corr.-corr.
                          if(j1.eq.j1p)nce=nce+1
                        endif
                      enddo
c   61                 continue
                    enddo
c               enddo
c             enddo
                    ncorr=ncorr+nco*ld*ldp
                  endif
                ENDIF
              ENDDO
              IF(beqgrpl.and.NMETAG(NC).LT.1)THEN
                LD=(L2-L1)/4+1
                MM=MC+ione0
                NNN=NNN-LD*(MM*(MM-1))/2                   !FOR LI.EQ.LF
                if(bcorr)ncorr=ncorr-ld*(nco-nce)/2        !for li.eq.lf
              ENDIF
            ENDDO
            NCHMX=MAX(NCHMX,NCHL)
            NCHTOT=NCHTOT+NCHL
          ENDIF                                  ! nchs,
          IF(.NOT.BPRNT0)WRITE(6,1120)IX,NWT,IL,IP,     NCHL
        ELSE                                            !QUIETLY DISCARD
          INAST=INAST-1
          IF(IL.GT.MAXLX.AND.IS.GT.1)IPAR4=1
          LHOLD=LSPI(IX)
          DO I=IX+1,INAST0
            LSPI(I-1)=LSPI(I)
          ENDDO
          LSPI(INAST0)=LHOLD                            !NEED FOR IC
          IX=IX-1
        ENDIF
C
        IF(IL.LE.MAXLX)INASTX=MAX(INASTX,IX)
C
      ENDDO
C
      CALL DIMUSE('MXCHG',MXX)
C
      IF(MXX.GT.MXCHG)THEN
        WRITE(6,195)MXX
        WRITE(0,195)MXX
        GO TO 999
      ENDIF
C
      IADD=NNN-ncorr                           !for corr.-corr. omission
c
c      if(ncorr.gt.0)then
c        write(0,*)iadd,ncorr,iadd-ncorr
c        stop   'ncorr test'
c      endif
C
      IF(MAXLT.LT.0)THEN         !NO SCALING, EXCHANGE CAN BE OFF THOUGH
        INASTX=INAST
      ELSE
        INASTX=INASTX+2*(IFORE-IPAR4)                !FURTHER THAN XCHNG
        INASTX=MIN(INASTX,INAST)
      ENDIF
C INASTX IS PASSED THRU TO SR.ALGXLS VIA COMMON/BASIC/....
C      NAST=INAST
C
      RETURN
C
 999  WRITE(6,190)
      NF=-1                                                       !ABORT
C
      RETURN
C
  152 FORMAT(/44X,' MAX EXCHANGE LAMDA (MXLAMX)=',I3)
  153 FORMAT(/44X,' No. OF MULTIPOLES (NMULTE) =',I3)
  154 FORMAT(/44X,' MAX  2-BODY NFS  L (MAXLOO)=',I3)
  190 FORMAT( ' SR.SYMLS: FAILURE - CASE SKIPPED')
  194 FORMAT('***SR.SYMLS: TOO MANY SYMMETRIES, INCREASE MAXSL',
     X              ' TO:',I4)
  195 FORMAT('***SR.SYMLS: TOO MANY CHANNEL GROUPS, INCREASE',
     X            ' MXCHG TO:',I4)
 1007 FORMAT(//1X,136('-')//)
 1008 FORMAT(/' NOTE: REDUCING MAXLT TO',I3,', THAT NEEDED BY LVMAX='
     X,I3)
 1009 FORMAT(/' ***WARNING: YOU HAVE SET MAXLT=',I3,', LESS THAN THAT'
     X,' FORMALLY NEEDED BY LVMAX=',I3/22X,'SET MAXLT=',I3
     X,', TO SATISFY TRIANGLE RELATION')
 1010 FORMAT(/' ***WARNING: YOU HAVE SET MINLT=',I3,', GREATER THAT'
     X,' FORMALLY NEEDED BY LVMIN=',I3/22X,'SET MINLT=',I3
     X,', TO SATISFY TRIANGLE RELATION')
 1011 FORMAT(/' NOTE: INCREASING MINLT TO',I3,', THAT NEEDED BY LVMIN='
     X,I3)
 1112 FORMAT(' *** PARTIAL WAVE SYMMETRY RESTRICTIONS:',5X,'MAXIMUM'
     X,' EXCHANGE L (MAXLX) =',I3)
 1113 FORMAT(//'   SY 2S+1  L  (P-0/1 FOR EVEN/ODD)',5X,
     X'*** NO TOP-UP ***')
 1114 FORMAT(1X,4I4)
 1115 FORMAT(//' MINST=',I2,3X,'MAXST=',I2,5X,'MINLT=',I2,3X,'MAXLT=',I3
     X)
c 1118 format(7x,i8,i9,3i4,i10)
 1119 format(/' PARITY IPAR=',i2)
 1116 FORMAT(/' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3/
     X       13X,'CH',8X,'T',3X,'SMALL L')
 1117 FORMAT(7X,I8,I9,I10)
 1120 FORMAT(' SY=',I3,5X,'(2S+1) L P =',I3,I4,I3,5X,'NCHT=',I6)
c     X      ,2X,'(',I6,')')
C
      END SUBROUTINE SYMLS
C
C                             *******************
C
      SUBROUTINE SYMLSJ
C
C-----------------------------------------------------------------------
C
C  SR.SYMLSJ
C     DETERMINES THE LSJ SYMMETRIES AND CHANNEL LIST BASED-UPON THE USER
C     SPECIFIED MINJT, MAXJT. OR DIRECT JP INPUT, AND CHECKS CONSISTENCY
C     WITH ANY SUPPLIED LSP, MAXJFS.
C
C  IT CALLS:
C    SR.DIMUSE
C    SR.NUMSYM
C
C-----------------------------------------------------------------------
C
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBIAD, ONLY: IADJ                     !,IADJT
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /BASIC/NF,MXX,NCHMX,NGAP(9)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBCOR/EGAP(6),BECOR
      COMMON /NRBDW/IDW
     X             ,INAST0,MINSTB,MAXSTB,MINLTB,MAXLTB
     X             ,INASTJ0,MINJTB,MAXJTB,MAXLX,MAXJFS
     X             ,LFACT,JFACT,KUTSSX,LRGLAM,btop
      COMMON /NRBDW2/LCONDW,MGP2(5),LCONDWJ,MTJ,LVMIN,LVMAX
      COMMON /NRBDW4/DSPECE(MAXTM),INDEX(MAXTM),JNDEX(MAXTM),NSPECE
     X              ,NENERG
      COMMON /NRBDWJ/JSYMM(MXSYJ,MAXJG),NCHGJ(MAXJG),NADGJ(MAXJG)
      COMMON /NRBDWM/NMETA,NMETAJ,NMETAG(0:MAXSL),NMETGJ(MAXJG)
      COMMON /NRBDWX/LLCH(2,MXCHG,MAXSL),ITARG(MXCHG,MAXSL),NCHG(MAXSL)
      COMMON /NRBGRP/NGRPI(MAXSL),NADG(MAXSL)
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),INASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBLAM/MAXLAM,MXLAMX,NMULTE,KUTLS
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),INAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      common /nrbone/ione1,ione0
C
C-----------------------------------------------------------------------
C
c if elastic is dropped here then it has an effect on inelastic
c transitions between terms of same symmetry because they are mixed
c
cold  ione0=0                                    !=0 retain elastic here
c
c if bcor then we have algebraic correlation, and we know how ordered
c
      bcor=kmax*kcut.ne.kcut*kcut
c
c if becor then we have correlation by energy, and we know not where, so
c
      beqgrpl0=.not.becor                       !false for full li=lf mx
c
c if only algebraic then can reduce memory requirement  NAD/J(NCOR/J)
c
      bcorr=bcor.and..not.becor.and.kcutx.ge.0
C
C-----------------------------------------------------------------------
C
C INITIALIZATIONS
C
      BPRNT0=JPRINT.NE.-3
      BTEST=BPRNT0         !.TRUE.                    !DETAILED PRINTOUT
C
      BTHRSH=LVMAX.GE.0
C
C SCATTERING SYMMETRY RESTRICTIONS
C
      MTEST=MOD(INT(QCS0,SP),ITWO)
      WRITE(6,1111)
      WRITE(6,1112)MXLAMX
C
      IF(INASTJ0.GT.0)THEN
        WRITE(6,1113)
        INASTJ=INASTJ0
        IX=0
        DO I0=1,INASTJ0
          IX=IX+1
          IJ=JPI(IX)/10
          IF(IJ.LE.MAXJT)THEN            !LEGACY OF MAXJFS, NOT ON MAXLT
            IP=JPI(IX)-IJ*10
            WRITE(6,1114)IX,IJ,IP
            IF(MOD(IJ,ITWO).EQ.MTEST)THEN
              WRITE(6,1120)
              WRITE(0,*)'***SR.SYMLSJ ERROR: ILLEGAL TOTAL 2J REQUESTED'
              GO TO 999
            ENDIF
          ELSE                                          !QUIETLY DISCARD
            INASTJ=INASTJ-1
            jhold=jpi(ix)
            DO J=IX+1,INASTJ0
              JPI(J-1)=JPI(J)
            ENDDO
            jpi(inastj0)=jhold
            IX=IX-1
          ENDIF
        ENDDO
        MAXJT=-1                                        !FLAG FOR FUTURE
      ELSE
        IF(MAXJT.GT.200)MAXJT=60
        IF(MINJT.LT.0)MINJT=0
        IF(MOD(MINJT,ITWO).EQ.MTEST)MINJT=MINJT+1
        IF(MOD(MAXJT,ITWO).EQ.MTEST)MAXJT=MAXJT-1
        IF(MOD(MAXJFS,ITWO).EQ.MTEST)MAXJFS=MAXJFS-1
        IF(MAXJFS.GT.MAXJT)THEN
          WRITE(6,1111)
          WRITE(6,1110)
          MAXJFS=MAXJT
        ENDIF
        WRITE(6,1115)MINJT,MAXJT
        if(ipar.ne.2)write(6,1119)ipar
        ipar=abs(ipar)
        ipar=mod(ipar,ithree)                     !0-even, 1-odd, 2-both
      ENDIF
C
      WRITE(6,1111)
C
C SET-UP LSJ SCATTERING SYMMETRY LIST
C
      IF(INASTJ0.LE.0)THEN
        INASTJ=0
        IF(MINJT.GT.MAXJT)GO TO 57
C
        ip0=mod(ipar,itwo)
        ip1=min(ipar,ione)
        FACTJ=REAL(JFACT,WP)/D200
        IJ=MINJT
C
  54    DO IP=ip0,ip1
          INASTJ=INASTJ+1
          BLX=INASTJ.LE.MAXJG
          IF(BLX)JPI(INASTJ)=10*IJ+IP
        ENDDO
C
        if(jfact.gt.200)ij0=ij
        IF(IJ.GT.MAX(MAXJFS,30_SP))THEN
          IJ=NINT(IJ*FACTJ)
          IF(MOD(IJ,ITWO).NE.MOD(MAXJT,ITWO))IJ=IJ-1
        ENDIF
        IJ=IJ+2
        IF(IJ.LE.MAXJT)GO TO 54
        if(jfact.gt.200)then
          if(lrglam.gt.ij0)lrglam=ij0               !case factj "misses"
          maxjt=ij0
        endif
C
        CALL DIMUSE('MAXJG',INASTJ)
C
        IF(INASTJ.GT.MAXJG)THEN
          WRITE(6,194)INASTJ
          WRITE(0,194)INASTJ
          GO TO 999
        ENDIF
      ENDIF
C
  57  IF(INASTJ.EQ.0)THEN                            !NO J-SYMMS
        WRITE(0,*)'ATTENTION: NO J-SYMMETRIES FOR BP...'
        WRITE(6,1000)
        RETURN                                        !<----------RETURN
      ENDIF
C
C IDENTIFY LSP SYMMETRIES WHICH GIVE RISE TO THE REQUESTED JPI ONES.
C     INASTJ IS THE ACTUAL NUMBER OF JP SYMMS TO BE USED.
C
      MXX=0
      NNN=0
      NNN2=0
      NCHTOT=0
      NCHMX=0
      INASTJ00=INASTJ                  !SINCE WILL REDUCE IF NO LS SYMMS
      KX=0
      ncorr=0
      ncorr2=0
      JFAIL=0
C
      DO J0=1,INASTJ00
C
        KX=KX+1
        IJ=JPI(KX)/10
        IPJ=JPI(KX)-IJ*10
C
        NN=0
        JCOUNT=0
        CALL NUMSYM(IJ,IPJ,JCOUNT)            !NO. OF LSP SYMMS EXPECTED
        IF(JCOUNT.EQ.0)GO TO 50               !NONE POSSIBLE
C
        DO IX=1,INAST0        !inast0,1,-1    !MIRRORS ALGEB3 TERM ORDER
          if(nchg(ix).eq.0)go to 60
          IS=LSPI(IX)/10000
          IP=LSPI(IX)-IS*10000
          IL=IP/10
          IP=IP-IL*10
C
          IF(IP.NE.IPJ)GO TO 60
C                                                                 !ALIGN
          MTS=IS-1
          MTL=IL+IL
C          MTP=IP+IP
          IF(ABS(MTL-MTS).GT.IJ.OR.(MTL+MTS).LT.IJ)GO TO 60
          NN=NN+1
          BLY=NN.LE.MXSYJ
          IF(BLY)THEN
            JSYMM(NN,KX)=IX
          ENDIF
  60    ENDDO
C
        IF(NN.LT.JCOUNT.AND..NOT.BTHRSH)THEN        !ALLOW IF BTHRSH
          CALL NUMSYM(IJ,IPJ,JCOUNT)                !PRINT MISSING SYMMS
          JFAIL=JFAIL+JCOUNT-NN
        ELSEIF(NN.GT.JCOUNT)THEN
          WRITE(6,*)'SR.SYMLSJ: DROPPING',NN-JCOUNT,'SPECIFIED SLP FOR'
     x             ,'JP SYJ=',KX,':',IJ,IPJ
c          write(0,*)'sr.symlsj: something amiss with slp vs jp...'
          IF(BLY.and.BTEST)THEN
            WRITE(6,*)'SYJ=',KX,':',IJ,IPJ
            DO N=1,NN
              IX=JSYMM(NN,KX)
              IS=LSPI(IX)/10000
              IP=LSPI(IX)-IS*10000
              IL=IP/10
              IP=IP-IL*10
              nwt=is
              if(il.gt.maxlx)nwt=-2*is+2
              WRITE(6,*)'SYM=',IX,':',nwt,IL,IP
            ENDDO
          ENDIF
c          GO TO 999
        ENDIF
C
  50    IF(NN.GT.0)THEN
          MXX=MAX(MXX,NN)
C
          IF(BPRNT0)WRITE(6,*)' '
          IF(BTEST)WRITE(6,1116)KX,IJ,IPJ,NN
C
          NCHGJ(KX)=NN
          NADGJ(KX)=NNN2-ncorr2
c          write(0,*)'kx=',kx,' nadgj(kx)=',nadgj(kx)
C
          IF(BLY)THEN
            NCHJ=0
            DO NX=1,NN
              IX=JSYMM(NX,KX)
              IS=LSPI(IX)/10000
              IP=LSPI(IX)-IS*10000
              IL=IP/10
              IF(BPRNT0)THEN
                nwt=is
                if(il.gt.maxlx)nwt=-2*is+2
                WRITE(6,1117)IX,nwt,IL,IPJ
              ENDIF
              NCN=NCHG(IX)
              m1=1
              if(ij.gt.maxjfs)m1=nx
              DO MX=m1,NX
                JX=JSYMM(MX,KX)
                ISP=LSPI(JX)/10000
                IPP=LSPI(JX)-ISP*10000
                ILP=IPP/10
                NCNP=NCHG(JX)
c                write(0,*)'start symljs: ',kx,nx,mx,nnn2-ncorr2
                DO N=1,NCN
                  NC=ITARG(N,IX)
                  MC=NSL(NC)
                  L1=LLCH(1,N,IX)
                  L2=LLCH(2,N,IX)
                  LD=((L2-L1)/4+1)
                  NCH=MC*LD
                  if(bcorr)mci=ngrpi(nc)
                  if(ix.eq.jx)ncnp=n
                  DO NP=1,ncnp
                    ND=ITARG(NP,JX)
                    beqgrp=ix.eq.jx.and.nc.eq.nd
                    beqgrpl=beqgrpl0.and.beqgrp
                    b2fs=ij.le.maxjfs
     X         .and.     (IS+ISP-2)*(IL+ILP).GT.0
     x         .and.     abs(NMETAG(NC))+abs(NMETAG(ND)).lt.2
                    IF(NMETAG(NC)+NMETAG(ND).LT.2)THEN
                      IF(beqgrp)THEN
                        LDP=(LD*(LD+1))/2
                        LD=1
                        NCH=MC
                      ELSE
                        L1P=LLCH(1,NP,JX)
                        L2P=LLCH(2,NP,JX)
                        LDP=((L2P-L1P)/4+1)
                      ENDIF
                      MCP=NSL(ND)
                      NCHP=MCP*LDP
                      NADD=NCH*NCHP
                      NNN=NNN+NADD
                      if(b2fs)NNN2=NNN2+NADD
c
                      if(bcorr)then
                        nco=0
                        nce=0
c          do li=l1,l2,4
c            lf2=l2p
c            if(beqgrp)then
c              lf2=li
c              l1p=llch(1,np,ix)
c            endif
c            do lf=l1p,lf2,4
                        mcip=ngrpi(nd)
                        do m=1,mc
                          j1=m+mci
                          j=jndex(j1)
                          do mp=1,mcp
                            j1p=mp+mcip
c                if(ix.eq.jx.and.j1p.gt.j1-ione0.and.li.eq.lf)go to 61
                            jp=jndex(j1p)
                            if(j.lt.0.and.jp.lt.0)then
                              nco=nco+1                   !corr.-corr.
                              if(j1.eq.j1p)nce=nce+1
                            endif
                          enddo
c   61                   continue
                        enddo
c             enddo
c           enddo
                        naddc=nco*ld*ldp
                        ncorr=ncorr+naddc
                        if(b2fs)ncorr2=ncorr2+naddc
                      endif
                    ENDIF
                  ENDDO
                  if(beqgrpl.and.nmetag(nc).lt.1)then
                    LD=(L2-L1)/4+1
                    MM=MC+ione0
                    NADD=LD*(MM*(MM-1))/2
                    NNN=NNN-NADD             !FOR LI.EQ.LF
                    if(b2fs)NNN2=NNN2-NADD
                    if(bcorr)then
                      naddc=ld*(nco-nce)/2
                      ncorr=ncorr-naddc  !for li.eq.lf
                      if(b2fs)ncorr2=ncorr2-naddc
                    endif
                  endif
                  if(ix.eq.jx)nchj=nchj+nch
                ENDDO
c                write(0,*)'end symlsj: ',kx,nx,mx,nnn2-ncorr2
              ENDDO
            ENDDO
c                write(0,*)'end symlsj: ',kx,nnn2,-ncorr2
c       write(0,*)'nchj=',nchj
            NCHMX=MAX(NCHJ,NCHMX)
            NCHTOT=NCHTOT+NCHJ
          ENDIF
        ELSE                                            !QUIETLY DISCARD
          INASTJ=INASTJ-1
          jhold=jpi(kx)
          DO J=KX+1,INASTJ00
            JPI(J-1)=JPI(J)
          ENDDO
          jpi(inastj00)=jhold
          KX=KX-1
        ENDIF
C
      ENDDO
C
C      NASTJ=INASTJ                                              !RE-SET
C      IADJT=NNN-ncorr                               !NOT USED CURRENTLY
      IADJ=NNN2-ncorr2                                !ONLY USED BY 2-FS
C
      IF(JFAIL.GT.0)THEN
        WRITE(6,1121)JFAIL
        GO TO 999
      ENDIF
C
      CALL DIMUSE('MXSYJ',MXX)
C
      IF(MXX.GT.MXSYJ)THEN
        WRITE(6,195)MXX
        WRITE(0,195)MXX
        GO TO 999
      ENDIF
C
      RETURN
C
 999  WRITE(6,190)
      NF=-1                       !<-------------------- ABNORMAL RETURN
C
      RETURN
C
  190 FORMAT( ' SR.SYMLSJ: FAILURE - CASE SKIPPED')
  194 FORMAT('***SR.SYMLSJ: TOO MANY SYMMETRIES, INCREASE MAXJG',
     X              ' TO:',I4)
  195 FORMAT('***SR.SYMLSJ: TOO MANY LSP SYMMS PER JP, INCREASE',
     X            ' MXSYJ TO:',I4)
 1000 FORMAT(/' *** NO J-SYMMETRIES FOUND FOR BP RUN, CHECK INPUT'/)
 1110 FORMAT(/' NOTE: REDUCING MAXJFS TO MAXJT')
 1111 FORMAT(//1X,136('-')//)
 1112 FORMAT(' *** PARTIAL WAVE LEVEL SYMMETRY RESTRICTIONS:'
     X,5X,'MAX EXCHANGE LAMDA=',I3//)
 1113 FORMAT('  SYJ  2J   P')
 1114 FORMAT(1X,3I4)
 1115 FORMAT(' MINJT=',I2,3X,'MAXJT=',I3)
 1116 FORMAT(' SYJ=',I3,4X,'2J P =',I3,I3,'    FORMED BY   SY=',I2,
     X       '  (2S+1)  L  P ')
 1117 FORMAT(39X,I3,7X,I3,I4,I3)
 1119 format(/' PARITY IPAR=',i2)
 1120 FORMAT('***SR.SYMLSJ ERROR: REQUESTED TOTAL 2J NOT POSSIBLE FOR '
     X      ,'THIS ATOMIC TARGET - ADD/SUBTRACT 1 TO/FROM 2J')
 1121 FORMAT(//'*** SR.SYMLSJ ERROR: SPECIFY THE MISSING',I4
     X           ,' LSP SYMMETRIES LISTED ABOVE AND RE-RUN'//)
C
      END SUBROUTINE SYMLSJ
C
C                             *******************
C
      SUBROUTINE TARGET(TIME,TTIME)
C
C-----------------------------------------------------------------------
C
C  SR.TARGET EVALUATES ENERGY LEVELS, RADIATIVE & AUTOIONIZATION RATES,
C  AND PHOTOIONIZATION CROSS SECTIONS FROM (QUASI)-BOUND STATE TARGETS.
C
C  IT CALLS:
C    SR.ALGEB
C    SR.MINIM
C
C-----------------------------------------------------------------------
cparc                                                               !par
cpar      use comm_interface, only : iam                            !par
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRBLOO/LNEW,LCON,LSUM,LMAX,lcmin,BLOOP
      COMMON /NRBNAM/NF0,BNAME
      common /nrbtim/iw,iwp,btime,btimex
C
C-----------------------------------------------------------------------
c
c      if(.not.btime.and.btimex)then        !btime/x not initialized yet
cparc       if(iam.eq.0)then                                        !par
c          write(iw,*)'Starting target'
cparc       endif                                                   !par
c      endif
C
C INITIALIZE FOR ANY RYDBERG L-LOOP
C
      BLOOP=.FALSE.
      LSUM=0
      LNEW=-1
C
C-----------------------------------------------------------------------
C
C SR.ALGEB EVALUATES ANGULAR ALGEBRA (CA, LS AND IC).
C
  80  CONTINUE
C
      CALL ALGEB(IRET)
C
      IF(NF.Lt.0.OR.IRET.EQ.1)THEN
        IF(IRET.EQ.0)IRET=2
        GO TO 1999
      ENDIF
C
C-----------------------------------------------------------------------
C
C SR.MINIM SETS-UP & DIAGONALIZES H FOR LS & IC ENERGIES AND OPTIONALLY
C    EVALUATES RADIATIVE RATES (E_K & M_K), AUTOIONIZATION RATES,
C    PHOTOIONIZATION CROSS SECTIONS AND (INF &) FINITE ENERGY BORN
C    COLLISION STRENGTHS.
C
C
      CALL MINIM
C
C-----------------------------------------------------------------------
C
 1999 CONTINUE
C
      CALL CPU_TIME(TTIME)
C
      times=ttime-D60*time
      TTIME=TTIME/D60
      TIME=TTIME-TIME
C
      WRITE(6,999)TIME,TTIME
C
      TIME=TTIME
c
      if(.not.btime.and.btimex)then
cpar        if(iam.eq.0)then                                        !par
          write(iw,*)'Ending target: time=',nint(times),'sec,     '
     x               ,nint(times/60),'min'
cpar        endif                                                   !par
      endif
C
C-----------------------------------------------------------------------
C
      IF(IRET.EQ.0.AND.NF0.GT.0.AND.(.NOT.BNAME.OR.BLOOP))GO TO 80
C
      RETURN
C
  999 FORMAT(//1X,'CPU TIME=',F9.3,' MIN',5X,'TOTAL CPU TIME=',F9.3
     X,' MIN')
C
      END SUBROUTINE TARGET
C
C                   *********************
C
      SUBROUTINE TFDAPO(Z,NION,MK,ADJUST,ADJUS1,ADJUS2,DX1,NPOINT,NI,NTI
     X                 ,DXI,X,POT,DTOL,IEND,CRRCT1,CRRCT2)
C
C-----------------------------------------------------------------------
C
C  SR.TFDAPO CALCULATES A THOMAS-FERMI-DIRAC-AMALDI POTENTIAL.
C
C   QUANTITIES REQUIRED: ALL ARGUMENTS TO X (DXI NO LONGER USED)
C                        PLUS DIP/QUAD POLARIZATION COEFFS CRRCT1,CRRCT2
C
C  Z=NUCLEAR CHARGE
C  NION=NUMBER OF ELECTRONS IN THE ION
C  ADJUST=SCALING PARAMETER (A VALUE GT 1.0 CONTRACTS THE EFFECTIVE
C  RADIAL SCALE, I.E. Z FALLS OFF MORE SLOWLY TOWARDS RESIDUAL ZN.
C  DXI(J),J=1,NI=STEP LENGTH IN THE J'TH INTERVAL -- STEP LENGTH IS
C  DOUBLED IN SUCCESSIVE INTERVALS, DX1=DXI(1) IS INPUT-SO ARE THE
C  NUMBERS NTI(J) OF STEPS IN THE NI INTERVALS J;
C  X(I),I=1,NPOINT=RADIAL DISTANCE AT THE NPOINT RADIAL POINTS I;
C  IEND=INDEX OF THE LAST POINT FOR WHICH THE EFFECTIVE CHARGE HAS
C  NOT NECESSARILY THE RESIDUAL VALUE ZN; FOR X.GT.X(IEND) THE
C  POTENTIAL IS ZN/X=(Z-NION+1)/X. IF THE RANGE X(NPOINT) IS TOO
C  SMALL FOR THE EFFECTIVE CHARGE TO DROP TO ZN CONTROL IS RETURNED
C  WITH DX1=2*DX1 -- WHILE DXI(1) CONTAINS THE ORIGINAL DX1.
C  POT(I),I=1,NPOINT=VALUE OF THE POTENTIAL AT THE POINTS X(I).
C  POT(I) WAS STORED IN /COM1/- POT,DTOL,IEND NOW OUTPUT THROUGH
C  ARGUMENT LIST & THEN STORED IN /COM1/IN RADIAL FOR USE IN RADWAV.
C  DTOL, TYPICALLY 1.E-6, =ACCURACY; DTOL
C  MUST MATCH MACHINE PRECISION: A 24-BIT MANTISSA REQUIRES .GE.1.E-5
C
C  IT CALLS:
C    SR.CORTFD
C    SR.POTIN
C    SR.RK1ST
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
C      PARAMETER (MXD14=100)
C
      PARAMETER (TBB=.079157174720D0)   !(5/12)(E_X**2/E_K)=25/(32pi**2)
      PARAMETER (DMU0=.88534131027D0)            !(1/4)(9pi**2/2)**(1/3)
      PARAMETER (TOLP=1.D-5)         !SET POLARIZ=0 IF SMALLER THAN TOLP
C
      DIMENSION POT(*),X(*),DXI(*),NTI(*)
C
      DIMENSION F(2),FE(2)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
C      COMMON /NRBUNI/IUNIT(MXD14),NUNIT
C
      IF(Z.EQ.DZERO)THEN
        WRITE(0,*)'*** ERROR: SR.TFDAPO NO LONGER INITIALS DX1,',
     X            ' CALL SR.MESH INSTEAD'
        WRITE(6,*)'*** ERROR: SR.TFDAPO NO LONGER INITIALS DX1,',
     X            ' CALL SR.MESH INSTEAD'
        GO TO 999
      ENDIF
C
C SOME INITIALIZATIONS
C
      N=NION
      ZN=Z-N+1           !ASYMPTOTIC CHARGE AS SEEN BY A TAGRET ELECTRON
      TOLH=D1M2
C
C GO READ EXTERNAL POTENTIAL (MAYBE)
C
      IF(MHF*MK.GT.0)THEN
C
        CALL POTIN(Z,NION,MK,NPOINT,X,POT,IEND)
C
        GO TO 300                                 !RETURN
C
      ENDIF
C
C NEGATIVE SCALING PARAMETERS/LAMDAS FLAG SCREENED HYDROGENIC
C
      IF(ADJUST.LT.DZERO)THEN
        TA=-ADJUST*Z
        TB=(DONE+ADJUST)*Z
        ZH=Z/DTWO
        IEND=1
        DO J=1,NPOINT
          TT=EXP(-ZH*X(J))            !HISTORIC CUSP CONDITION AT ORIGIN
          TT=TT*TB
          POT(J)=(TA+TT)/X(J)
          IF(ABS(TT/TA).GT.TOLH)IEND=J
        ENDDO
        IF(IEND.LT.NPOINT)GO TO 300               !RETURN
        DX1=DX1+DX1
        TT=TT/X(IEND)
        WRITE(6,997)ADJUST,X(IEND),POT(IEND),TT
        GO TO 300                                 !RETURN
      ENDIF
C
C IF ONLY ONE ELECTRON IS PRESENT THE POTENTIAL IS PURELY COULOMBIC
C
      I=1
      IEND=1
      IF(N.EQ.1)GO TO 194
C
C *** NON-HYDROGENIC
C
      DMUE=((N/(N-DONE))**2/Z)**(DONE/DTHREE)*DMU0*ADJUST
C
C WE SHALL TRANSFORM X OF EN 2.20 TO Y WITH Y*Y=X
C
      Y1=DX1/(DTWO*DTWO)
      YY1=SQRT(Y1/DMUE)
      IF(YY1.GT.D1M2)YY1=D1M2
      Y1=YY1*YY1*DMUE
      IEND=0
      DLOW=DZERO
      YLOW=DZERO
      ILOW=1
      ISTEP=1
      m0=max(mstep-10,itwo)
C
C TRY THE INTEGRATION FROM THE END OF EACH INTERVAL UNTIL THE
C FUNCTION REACHES A VALUE GT 1 AT Y.EQ.0.
C
      DO 21 I=1,NI
C
        II=IEND+1
        NT0=NTI(I)
        IF(I.EQ.NI)NT0=min(nt0,m0*NTI(I-1))
   34   IEND=IEND+NT0
        IF(IEND.GT.NPOINT.and.npoint.eq.maxb1)THEN
          WRITE(6,993)IEND,NPOINT
          WRITE(0,*)'*** DIMENSION MAXB1 EXCEEDED IN SR.TFDAPO?'
          GO TO 999
        ENDIF
C
C FILL POT(I) TEMPORARILY WITH Y(I) CORRESPONDING TO X(I)
C
        DO J=II,IEND
          POT(J)=SQRT(X(J)/DMUE)
        ENDDO
        J=8
C
C IN THE FIRST INTERVAL THE INTEGRATION IS DONE FROM A SMALL
C DISTANCE TO ASSURE THAT THE FIRST FUNCTION VALUE AT Y.EQ.0 IS LT.1
C
        IF(I.EQ.1)GO TO 13
C
   33   ISTEP=7
        IF(I.EQ.NI)GO TO 11
        IF(I.LE.3)GO TO 21
        IF(ZN.LT.(DTWO+D1M1))GO TO 11
        IF(i.lt.8.and.MOD(I,ITWO).NE.0)GO TO 21    !MESH MAYBE TRUNCATED
   11   J=IEND
C
   12   ISTEP=ISTEP-1
        IF(ISTEP.EQ.1)GO TO 13
        IF(POT(J)-POT(J-ISTEP).GT.DHALF)GO TO 12 !REDUCE INTGRTN INTERVL
C
   13   IHIGH=J
        YHIGH=POT(J)
        Y0=YHIGH
C
        F(1)=TBB*Y0*Y0*DMUE/Z              !CALCULATE THE FUNCTION AT X0
C
        F(2)=DTWO*(F(1)-ZN/Z)/Y0   !CALCULATE THE FIRST DERIVATIVE AT X0
C
   20   Y0=POT(J)
        J=J-ISTEP
        BOOL=J.GT.0
        H=YY1-Y0
        IF(BOOL) H=POT(J)-Y0
C
        CALL RK1ST(Y0,F,H,ITWO,YY0,FE)     !INTEGRATE 1 STEP
C
        F(1)=FE(1)
        IF(FE(1).GT.D1P10)THEN
          J=IHIGH-NT0/10-1
          GO TO 13
        ENDIF
        F(2)=FE(2)
        IF(BOOL)GO TO 20
C
        HIGH=FE(1)+( SQRT(FE(1))*YY1)**3*D2THRD-FE(2)*(YY1/DTWO+YY1**4)
C
        IF(HIGH.GT.DONE)GO TO 22         !WE HAVE A WINNER
C
        IF(M0.GT.MSTEP)GO TO 21          !GIVE UP
C
        IF(I.EQ.NI)THEN                  !TREAT FINAL INTERVAL WITH TLC
          IF(IEND.GE.(II+17))THEN        !CUT IF TOO LONG
C            WRITE(6,994)IEND,HIGH       !SILENTLY
            IEND=(II-1+IEND)/2
C            WRITE(6,995)NI,II,IEND
            GO TO 33
          ELSE                           !CASE MESH TRUNACTED, GO TO END
            M0=999                       !FLAG FINAL ATTEMPT
            IEND=II-1
            NT0=NTI(NI)
            GO TO 34
          ENDIF
        ENDIF
C                                        !TRANSFER
        YLOW=YHIGH
        ILOW=IHIGH
        DLOW=HIGH
C
   21 CONTINUE
C
C END INTERVAL LOOP
C
      DX1=DX1+DX1
      WRITE(6,996)ADJUST,X(IEND),FE(1)
      GO TO 300                          !RETURN
C
C FIND AN IMPROVED APPROXIMATION TO Y0
C
   22 Y0=YLOW+(DONE-DLOW)*(YHIGH-YLOW)/(HIGH-DLOW)
      YHIGH=YHIGH+DTHREE*DTOL
      YLOW=YLOW-DTHREE*DTOL
      Y0=(Y0+(YHIGH+YLOW)/DTWO)/DTWO
C
   23 DO J=ILOW,IHIGH
        IF(POT(J).GT.Y0)THEN
          IEND=J-1
          GO TO 25
        ENDIF
      ENDDO
C
   25 J=IEND
C
C BOUNDARY CONDITION
C
      F(1)=TBB*Y0*Y0*DMUE/Z
      F(2)=DTWO*(F(1)-ZN/Z)/Y0
C
      YY0=Y0
   26 J=J-ISTEP
      BOOL=(J.GT.0)
      H=YY1-YY0
      IF(BOOL)H=POT(J)-YY0
C
      CALL RK1ST(YY0,F,H,ITWO,YL,FE)
C
      F(1)=FE(1)
      F(2)=FE(2)
      IF(.NOT.BOOL)GO TO 27
      YY0=POT(J)
      GO TO 26
C
C EXPAND AT YY1 IN A TAYLOR SERIES TO CALCULATE FE AT Y.EQ.0.
C
   27 FE(1)=FE(1)+( SQRT(FE(1))*YY1)**3*D2THRD-FE(2)*(YY1/DTWO+YY1**4)
      TOL1=FE(1)-DONE
      IF(YHIGH-YLOW.LT.YHIGH*DTOL/DTWO)THEN
        IF(TOL1.LT.DZERO)YHIGH=YHIGH-TOL1
        IF(TOL1.GT.DZERO)YLOW=YLOW-TOL1
      ENDIF
C
      ISTEP=1
      IF(ABS(FE(1)-DONE).GT.D1M1)ISTEP=2
      YL=(Y0*(DLOW-DONE)-YLOW*(FE(1)-DONE))/(DLOW-FE(1))
      YH=(Y0*(HIGH-DONE)-YHIGH*(FE(1)-DONE))/(HIGH-FE(1))
      IF(FE(1).LT.DONE)THEN
        YLOW=Y0
        DLOW=FE(1)
        ILOW=IEND
      ELSE
        YHIGH=Y0
        HIGH=FE(1)
        IHIGH=IEND+1
      ENDIF
C
      Y0=(YL+YH)/DTWO
      IF(Y0.LT.YLOW.OR.Y0.GE.YHIGH) Y0=(YLOW+YHIGH)/DTWO
      IF(ABS(FE(1)-DONE).GT.DTWO*DTOL)GO TO 23
C
C FIND THE FINAL VALUE FOR Y0
C
   70 RY0=Y0*Y0*DMUE
      V0=ZN/RY0-TBB
      DO I=1,NPOINT
        IF(X(I).GT.RY0)THEN
          IEND=I-1
          GO TO 90
        ENDIF
      ENDDO
      WRITE(6,993)NPOINT,IEND
      WRITE(0,*)'*** DIMENSION MAXB1 EXCEEDED IN SR.TFDAPO?'
      GO TO 999
C
   90 FE(1)=TBB*Y0*Y0*DMUE/Z
      FE(2)=DTWO*(FE(1)-ZN/Z)/Y0
      YY1=Y0
      I=IEND
  100 IF(I.EQ.0)THEN
        YY0=YY1
        YY1=SQRT(Y1/DMUE)
      ELSE
        XB=X(I)
        YY0=YY1
        YY1=SQRT(XB/DMUE)
      ENDIF
      F(1)=FE(1)
      F(2)=FE(2)
      H=YY1-YY0
C
C INTEGRATE FROM YY0 TO YY0+H
C
      CALL RK1ST(YY0,F,H,ITWO,TOL1,FE)
C
      IF(I.NE.0)THEN
        POT(I)=FE(1)*Z/XB+V0
        I=I-1
        GO TO 100
      ENDIF
C
C EXTRAPOLATE TO X=0
C
      FE(1)=FE(1)+(SQRT(FE(1))*YY1)**3*D2THRD-FE(2)*(YY1/DTWO+YY1**4)
      TOL1=FE(1)-DONE
      IF(YHIGH-YLOW.LT.YHIGH*DTOL/DFIVE)THEN
        IF(TOL1.GT.DZERO)YLOW=YLOW-TOL1
        IF(TOL1.LT.DZERO)YHIGH=YHIGH-TOL1
      ENDIF
      YL=(Y0*(DLOW-DONE)-YLOW*(FE(1)-DONE))/(DLOW-FE(1))
      YH=(Y0*(HIGH-DONE)-YHIGH*(FE(1)-DONE))/(HIGH-FE(1))
      IF(FE(1).GT.DONE)THEN
        YHIGH=Y0
        HIGH=FE(1)
      ELSE
        YLOW=Y0
        DLOW=FE(1)
      ENDIF
      Y0=(YL+YH)/DTWO
      IF(Y0.LE.YLOW.OR.Y0.GE.YHIGH)Y0=(YLOW+YHIGH)/DTWO
C
C IF THE APPROXIMATION IS NOT GOOD ENOUGH REPEAT THE PROCESS
C
      IF(ABS(TOL1).GE.DTOL)GO TO 70
      I=IEND+1
C
C FILL THE REMAINING POTENTIAL AS A COULOMB POTENTIAL
C
  194 DO J=I,NPOINT
        POT(J)=ZN/X(J)
      ENDDO
c
c      do j=1,i
c        write(65,*)x(j),pot(j),x(j)*pot(j)
c      enddo
C
C OPTIONALLY ADD-IN DIPOLE AND QUADRUPOLE POLARIZATION AS A PERTURBATION
C
      IF(ABS(ADJUS1-DONE).GT.TOLP.OR.ABS(ADJUS2-DONE).GT.TOLP)
     X               CALL CORTFD(X,POT,IEND,ADJUS1,ADJUS2,CRRCT1,CRRCT2)
C
C
  300 CONTINUE
C
      RETURN
C
  999 NF=-1
      GO TO 300
C
  993 FORMAT(/' SR.TFDAPO:  IEND.GT.NPOINT, TRY INCREASING MAXB1:',2I6)
C  994 FORMAT(I15,1PE12.3)
C  995 FORMAT(3I5)
  996 FORMAT(' SR.TFDAPO  (ADJUST,X(IEND),FE(1)) =',3F10.5/
     X'  RETURN WITH INITIAL STEP LENGTH DOUBLED')
  997 FORMAT(' SR.TFDAPO:  (ADJUST,X(IEND),COUL-POT(IEND),NON-COUL) =',
     X4F10.5/'  RETURN WITH INITIAL STEP LENGTH DOUBLED')
COLD  990 FORMAT(E14.7)
C
      END SUBROUTINE TFDAPO
C
C***********************************************************************
C
      SUBROUTINE TRIMAT(N,SA,SB,SC,SD,SY)
C
C-----------------------------------------------------------------------
C
C ALAN BURGESS, D.A.M.T.P. CAMBRIDGE.
C
C SOLUTION OF TRI-DIAGONAL MATRIX EQUATION BY FORWARD AND BACKWARD PASS
C (SEE 'MODERN COMPUTING METHODS', PAGES 97,98).
C  INPUT: N, (THE MATRIX IS N BY N)
C         SA(J), J=2,3...N (SUB-DIAGONAL ELEMENTS)
C         SB(J), J=1,2...N (DIAGONAL ELEMENTS)
C         SC(J), J=1,2...N-1 (SUPER-DIAGONAL ELEMENTS)
C         SD(J), J=1,2...N (RIGHT-HAND SIDE).
C  OUTPUT: N,SA,SB AND SC ARE PRESERVED, SD IS OVERWRITTEN
C         SY(J), J=1,2...N CONTAINS THE SOLUTION VECTOR.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION SA(N),SB(N),SC(N),SD(N),SY(N)
C
      SY(1)=SB(1)
      DO J=2,N
        T=SA(J)/SY(J-1)
        SY(J)=SB(J)-T*SC(J-1)
        SD(J)=SD(J)-T*SD(J-1)
      ENDDO
      SY(N)=SD(N)/SY(N)
      DO I=2,N
        J=N-I+1
        SY(J)=(SD(J)-SC(J)*SY(J+1))/SY(J)
      ENDDO
C
      RETURN
C
      END SUBROUTINE TRIMAT
C
C                             *******************
C
      FUNCTION TLAM(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.TLAM EVALUATES THE T-LAMDA INTEGRAL OF ORBIT-ORBIT INTERACTION.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      ALLOCATABLE :: D1(:),D2(:),D3(:)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      ALLOCATE (D1(MAXRS),D2(MAXRS),D3(MAXRS),STAT=IERR)          !MAXB1
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ULAM: ALLOCATION FAILS FOR D1,D2,D3'
        TLAM=DZERO
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=DPNL(I,K3)/DX(I)
      ENDDO
C
      CALL DIFF(D1,D2,MNH,DHNS,MJH)
C
      DO I=1,MAXRS
        D1(I)=D2(I)*DPNL(I,K1)*DX(I)
      ENDDO
      M=QL(K1)/2+QL(K3)/2+1
      IF(QL(K3).EQ.0)M=M+1
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DEL=DE1-DE3                                   ! A.U.
        DZ=NZION
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
C            DD1=DONE+T*(DE1+POT(I,1))
C            DD3=DONE+T*(DE3+POT(I,1))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k1)*rnorm(k3)
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
        CALL YLAMKR(LAM,M,DEL,D1,D2,DD1,DD2,MNH,DHNS,MJH,I1000)
      ELSE
        CALL YLAMK(LAM,M,D1,D2,DD1,DD2,MNH,DHNS,MJH,IZERO)
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=DPNL(I,K4)/DX(I)
      ENDDO
C
      CALL DIFF(D1,D3,MNH,DHNS,MJH)
C
      DO I=1,MAXRS
        D1(I)=D2(I)*D3(I)*DX(I)*DPNL(I,K2)
      ENDDO
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DEL=DE2-DE4                                   ! A.U.
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
C            DD2=DONE+T*(DE2+POT(I,1))
C            DD4=DONE+T*(DE4+POT(I,1))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k2)*rnorm(k4)
          DO I=1,MAXRS
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c            dd2=done+t*(de2+dz/dx(i))
c            dd4=done+t*(de4+dz/dx(i))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,D1,TT,MNH,DHNS,MJH,MAXRS)
C
      TP=2*LAM+1
      TLAM=DALF*TT/TP
C
      DEALLOCATE (D1,D2,D3,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'TLAM: DEALLOCATION FAILS FOR D1,D2,D3'
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
C     WRITE(6,100) K1, K2, K3, K4, 2*LAM, TLAM
C100  FORMAT(8X,2(I5,I4),I6,F14.7,' =TLAM')
C
      RETURN
C
      END FUNCTION TLAM
C
C                             *******************
C
      SUBROUTINE TOP1(NZA,LITLAM,EI,EJ,SS,OMT)
C
C-----------------------------------------------------------------------
C
C SR.TOP1 CALCULATES DIPOLE TOP-UP USING BURGESS (1974) FORMULA WITH
C         COULOMB-BETHE PARTIAL COLLISION STRENGTHS
C
C IT CALLS
C   FN.DIP (IONS
C   FN.DIP0 (NEUTRALS)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D16O3=16.0D0/3.0D0)
C
      PARAMETER (TOLE=1.D-10)
      PARAMETER (DEPS=1.D-5)
C
      DATA IPRTOP/0/
C
C
      IF(SS.LT.DZERO)THEN                                        !DIPOLE
C
        COEF=-D16O3*SS*LITLAM
        DELE=MAX(EI-EJ,TOLE)
C
        IF(NZA.GT.0)THEN                                         !ION
C
          TZLMSQ=DONE/(LITLAM*LITLAM)
C
          IFAIL=IPRTOP
          FI=FDIP(EI,LITLAM,EJ,LITLAM-1,IFAIL)
C
          IF(IFAIL.NE.0.AND.IPRTOP.EQ.2)
     X       WRITE(6,7205)IFAIL,EI,LITLAM,EJ,LITLAM-1
C
          IFAIL=IPRTOP
          FJ=FDIP(EI,LITLAM-1,EJ,LITLAM,IFAIL)
C
          IF(IFAIL.NE.0.AND.IPRTOP.EQ.2)
     X      WRITE(6,7205)IFAIL,EI,LITLAM-1,EJ,LITLAM
        ELSE                                                    !NEUTRAL
C
          TZLMSQ=DZERO
C
          IFAIL=IPRTOP
          FI=FDIP0(EI,LITLAM,EJ,LITLAM-1,DEPS,IFAIL)
C
          IF(IFAIL.NE.0.AND.IPRTOP.EQ.2)
     X       WRITE(6,7205)IFAIL,EI,LITLAM,EJ,LITLAM-1
C
          IFAIL=IPRTOP
          FJ=FDIP0(EI,LITLAM-1,EJ,LITLAM,DEPS,IFAIL)
C
          IF(IFAIL.NE.0.AND.IPRTOP.EQ.2)
     X       WRITE(6,7205)IFAIL,EI,LITLAM-1,EJ,LITLAM
C
        ENDIF
C
        IF(FI*FJ.NE.DZERO)THEN
C
          OMI=COEF*FI*FI
          OMJ=COEF*FJ*FJ
          OMT=(TZLMSQ+EJ)*OMI-(TZLMSQ+EI)*OMJ
          OMT=OMT/DELE
c
          if(omt.lt.dzero)then                           !case unforseen
            if(iprtop.eq.2)
     x         write(6,7206)ifail,ei,litlam-1,ej,litlam,fi,fj
            omt=dzero
          endif
C
        ELSE
          OMT=DZERO
        ENDIF
C
      ELSE
        OMT=DZERO
      ENDIF
C
      RETURN
C
 7205 FORMAT('SR.TOP1: FDIP FAILURE, IFAIL=',I2,' FOR E,L='
     X      ,2(1PE13.5,I3))
 7206 FORMAT('SR.TOP1: FDIP FAILURE, IFAIL=',I2,' FOR E,L='
     X      ,2(1PE13.5,I3),': FI,FJ=',2E13.5)
C
      END SUBROUTINE TOP1
C
C                             *******************
C
      SUBROUTINE TOP2(LITLAM,LRGLAM,EI,EJ,OMPW)
C
C-----------------------------------------------------------------------
C
C SR.TOP2 CALCULATES NON-DIPOLE (ALLOWED) TOP-UP USING GEOMETRIC
C         SERIES, GOING OVER TO DEGENERATE ENERGY LIMITING CASE.
C         SEE BURGESS, HUMMER & TULLY (1970) FOR BACKGROUND DETAILS.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DATA ITOP/-2/,IPRTOP/0/                       !ITOP=STGICF DEFAULT
C
      IF(OMPW.LT.DZERO)THEN
        OMPW=-OMPW
        IPRTOP=3
      ENDIF
C
      IF(LITLAM.GT.1)THEN                            !NON-DIPOLE ALLOWED
C
        TLTOP=LRGLAM
C
        IF(EI.EQ.DZERO)THEN
          AQ=DONE
        ELSE
          AQ=EJ/EI
        ENDIF
C
        IF(ITOP.EQ.-1)THEN
C
C      INTERPOLATE BETWEEN DEGENERATE AND NON-DEGENERATE LIMITS WHEN
C      L.LT.2*EJ/(EI-EJ), AS PER STGF DEFAULT
C
          O1=DONE+TLTOP/(LITLAM-DONE)
          O1=O1/DTWO
C
          IF(AQ.GT.0.99D0)THEN                              !CATCH EI=EJ
            OMPW=OMPW*O1
            IF(IPRTOP.EQ.3)WRITE(6,803)AQ,O1
          ELSE
            O2=DONE/(DONE-AQ)
            DQ=AQ*O2
            IF(TLTOP.GT.DTWO*DQ)THEN
              OMPW=OMPW*O2
              IF(IPRTOP.EQ.3)WRITE(6,804)DQ,O2
            ELSE
              T=TLTOP/(DQ*DTWO)
              O3=O2*T+O1*(DONE-T)
              OMPW=OMPW*O3
              IF(IPRTOP.EQ.3)WRITE(6,802)AQ,DQ,O1,O2,O3
            ENDIF
          ENDIF
C
        ELSE
C
C      INTERPOLATE BETWEEN DEGENERATE AND NON-DEGENERATE LIMITS WHEN
C      ENERGY-RATIO EXCEEDS J-RATIO, AS PER STGICF DEFAULT
C
          DQ=TLTOP/(TLTOP+1)
          DQ=DQ**(2*LITLAM-1)
C
          IF(AQ.LT.DQ)THEN
            O1=DONE/(DONE-AQ)
            OMPW=OMPW*O1
            IF(IPRTOP.EQ.3)WRITE(6,803)AQ,O1
          ELSE
            O2=DONE+TLTOP/(LITLAM-DONE)
            O2=O2/DTWO
            IF(AQ.LT.DONE)THEN
              O1=DONE/(DONE-AQ)
              O3=O1*((DONE-AQ)/(DONE-DQ))**2
     X                     +O2*(AQ-DQ)*(DTWO-AQ-DQ)/(DONE-DQ)**2
            ELSE
              O3=O2
            ENDIF
            OMPW=OMPW*O3
            IF(IPRTOP.EQ.3)WRITE(6,802)AQ,DQ,O1,O2,O3
          ENDIF
        ENDIF
C
      ENDIF
C
      RETURN
C
  802 FORMAT(18X,5F10.3)
  803 FORMAT(18X,F10.3,10X,F10.3)
  804 FORMAT(18X,10X,F10.3,10X,F10.3)
C
      END SUBROUTINE TOP2
C
C                             *******************
C
      FUNCTION TQDT(QD,NZ0,NE,N,L)
C
C-----------------------------------------------------------------------
C
C  FN.TQDT EVALUATES A ONE-ELECTRON ENERGY WITH NON-ZERO QUANTUM DEFECT
C
C   : QD0, UNIVERSAL QUANTUM DEFECT GIVEN BY
C         QD0*(NE**1.67-1)/(Z0**.67*Z**.33*(1+L**3))
C         CURRENT VALUE IN FUNCTION QDT IS QD0=0.182
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
      REAL(WP)QD,QD0
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (QD0=0.182D0)
C
      IF(N.LE.0)THEN
        QD=DZERO
        TQDT=DZERO
        RETURN
      ENDIF
C
      TZ0=NZ0
      TZ=NZ0-NE+1
      IF(L.LT.0.OR.NE.LE.1)THEN
        QD=DZERO
      ELSE
        TL=L**3+1
        TE=NE
        QD=QD0*(TE**D5THRD-DONE)/(TZ0**D2THRD*TZ**D1THRD*TL)
      ENDIF
C
      TN=N
      TN=TN-QD
      TQDT=-(TZ/TN)**2
C
      RETURN
C
      END FUNCTION TQDT
C
C                             *******************
C
      FUNCTION ULAM(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.ULAM EVALUATES THE U-LAMDA INTEGRAL OF ORBIT-ORBIT INTERACTION.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      ALLOCATABLE :: D1(:),D2(:),D3(:)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      ALLOCATE (D1(MAXRS),D2(MAXRS),D3(MAXRS),STAT=IERR)          !MAXB1
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ULAM: ALLOCATION FAILS FOR D1,D2,D3'
        ULAM=DZERO
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=DPNL(I,K1)*DPNL(I,K3)/DX(I)
        D2(I)=DPNL(I,K4)/DX(I)
      ENDDO
C
      CALL DIFF(D2,D3,MNH,DHNS,MJH)
C
      M=QL(K1)/2+QL(K3)/2+1
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DEL=DE1-DE3                                   ! A.U.
        DZ=NZION
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
C            DD1=DONE+T*(DE1+POT(I,1))
C            DD3=DONE+T*(DE3+POT(I,1))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k1)*rnorm(k3)
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
        CALL YLAMKR(LAM,M,DEL,D1,D2,DD1,DD2,MNH,DHNS,MJH,IONE)
      ELSE
        CALL YLAMK(LAM,M,D1,D2,DD1,DD2,MNH,DHNS,MJH,IONE)
      ENDIF
C
      DO I=1,MAXRS
        D2(I)=D2(I)*D3(I)*DPNL(I,K2)*DX(I)
      ENDDO
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DEL=DE2-DE4                                   ! A.U.
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
C            DD2=DONE+T*(DE2+POT(I,1))
C            DD4=DONE+T*(DE4+POT(I,1))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D2(I)=D2(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k2)*rnorm(k4)
          DO I=1,MAXRS
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c            dd2=done+t*(de2+dz/dx(i))
c            dd4=done+t*(de4+dz/dx(i))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D2(I)=D2(I)*dd/DSQ
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,D2,TT,MNH,DHNS,MJH,MAXRS)
C
      TP=LAM+2
      U=-TP*TT
C
      IF(LAM.NE.1)THEN
        DO I=1,MAXRS
          D2(I)=D3(I)*DPNL(I,K2)*DX(I)
        ENDDO
        M=1+QL(K2)/2+QL(K4)/2
        IF(QL(K4).EQ.0)M=M+1
C
        IF(BREL)THEN                       !SMALL R CORRECTION
          DE2=DEY(K2)-DUY(K2,K2)
          DE4=DEY(K4)-DUY(K4,K4)
          DEL=DE2-DE4                                   ! A.U.
          IF(BREL2)THEN
            DO I=1,MAXRS
              DD2=DONE+T*(DE2+DZ/DX(I))
              DD4=DONE+T*(DE4+DZ/DX(I))
C              DD2=DONE+T*(DE2+POT(I,1))
C              DD4=DONE+T*(DE4+POT(I,1))
              DSQ=DD2*DD4
              DSQ=SQRT(DSQ)
              D2(I)=D2(I)/DSQ
            ENDDO
          ELSE
            dd=rnorm(k2)*rnorm(k4)
            DO I=1,MAXRS
              DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
              DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c              dd2=done+t*(de2+dz/dx(i))
c              dd4=done+t*(de4+dz/dx(i))
              DSQ=DD2*DD4
              DSQ=SQRT(DSQ)
              D2(I)=D2(I)*dd/DSQ
            ENDDO
          ENDIF
          CALL YLAMKR(LAM,M,DEL,D2,D3,DD1,DD2,MNH,DHNS,MJH,IONE)
        ELSE
          CALL YLAMK(LAM,M,D2,D3,DD1,DD2,MNH,DHNS,MJH,IONE)
        ENDIF
C
        DO I=1,MAXRS
          D2(I)=D1(I)*D3(I)
        ENDDO
C
        CALL WEDDLE(DZERO,D2,TT,MNH,DHNS,MJH,MAXRS)
C
        TP=LAM-1
        U=U+TP*TT
      ENDIF
C
      TP=2*(2*LAM+1)
      ULAM=DALF*U/TP
C
      DEALLOCATE (D1,D2,D3,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'ULAM: DEALLOCATION FAILS FOR D1,D2,D3'
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
C     WRITE(6,100) K1, K2, K3, K4, 2*LAM, ULAM
C100  FORMAT(8X,2(I5,I4),I6,F14.7,' =ULAM')
C
      RETURN
C
      END FUNCTION ULAM
C
C                             *******************
C
      SUBROUTINE VA04A(X,E,N,NL,F,ESCALE,IPRINT,ICON,MAXIT)
C
C-----------------------------------------------------------------------
C
C  SR.VA04A HAS BEEN WRITTEN BY M.J.D.POWELL,
C  SEE REF.  M.J.D. POWELL, COMP.J.7(1965)303-7,
C  AND MODIFIED (BY WE) SO AS TO ACCEPT A RETURN VALUE NN=0 AFTER
C  CALL CALCFX(NN,X,F) AS A COMMAND TO QUIT WITHOUT FINISHING.
C  SR.CALCFX SUPPLIES THE VARIATIONAL FUNCTIONAL F.
C
C  IT CALLS:
C    SR.CALCFX
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (DTWENT=20.0D0)
      PARAMETER (DPT1=0.1D0)
      PARAMETER (DPT4=0.4D0)
      PARAMETER (DPT03=0.03D0)
      PARAMETER (DPT05=0.05D0)
C
      ALLOCATABLE :: W(:)
C
      DIMENSION  X(N),E(N)
C
      IXD29=N*(N+3)
      ALLOCATE (W(IXD29))
C
      FHOLD=DZERO
      DDMAG=DPT1*ESCALE
      SCER=DPT05/ESCALE
      NFCC=1
      NN=N
      J=NN+1
      JJ=J*NN
      JJJ=JJ+NN
      DO K=J,JJ
        W(K)=DZERO
      ENDDO
      ISGRAD=0
      ITERC=0
      IND=0
      INN=0
      K=0
      DO I=1,NN
        K=K+J
        W(K)=ABS(E(I))
        W(I)=ESCALE
      ENDDO
C
      CALL CALCFX(NL,X,F)
C
      IF(NL.EQ.0)GO TO 20                      !FAILURE (NF.LE.0)
C
      FKEEP=ABS(F)+ABS(F)
   5  ITONE=1
      ITERC=ITERC+1
      FP=F
      SUMM=DZERO
      IXP=JJ
      DO I=1,N
        IXP=IXP+1
        W(IXP)=X(I)
      ENDDO
C
      IF(NN.EQ.0)GO TO 77
C
      IDIRN=N+1
      ILINE=1
   7  DMAX=W(ILINE)
      DACC=DMAX*SCER
      D=DPT1*DMAX
      IF(DDMAG.LT.D)D=DDMAG
      DDMAX=DTWENT*DACC
      IF(DDMAX.GT.D)D=DDMAX
      DDMAX=DTEN*D
C
      IF(ITONE.LT.0)GO TO 71
C
      DL=DZERO
      DA=DL
      FA=F
      FPREV=F
      IS=5
C
   8  DD=D-DL
      DL=D
  58  K=IDIRN
      DO I=1,N
        X(I)=X(I)+DD*W(K)
        K=K+1
      ENDDO
C
      CALL CALCFX(NL,X,F)
C
      IF(NL.EQ.0)GO TO 20                      !FAILURE (NF.LE.0)
C
      IF(NN.EQ.0)  GO TO 77
C
      NFCC=NFCC+1
C
C      GO TO (10,11,12,13,14,96),IS
C
      IF(IS.EQ.1)THEN
        GO TO 10
      ELSEIF(IS.EQ.2)THEN
        GO TO 11
      ELSEIF(IS.EQ.3)THEN
        GO TO 12
      ELSEIF(IS.EQ.4)THEN
        GO TO 13
      ELSEIF(IS.EQ.5)THEN
        GO TO 14
      ELSEIF(IS.EQ.6)THEN
        GO TO 96
      ELSE
        STOP 'SR.VA04A: WE SHOULD NEVER GET HERE!'
      ENDIF
C
  14  IF(F.LT.FA)GO TO 15
      IF(F.GT.FA)GO TO 24
      IF(ABS(D).LT.DMAX)THEN
        D=D+D
        GO TO 8
      ELSE
        WRITE(6,1000)
        GO TO 20
      ENDIF
C
  15  FB=F
      DB=D
      GO TO 21
C
  24  FB=FA
      DB=DA
      FA=F
      DA=D
  21  IF(ISGRAD.NE.0)GO TO 83
  23  D=DB+DB-DA
      IS=1
      GO TO 8
C
  83  D=DHALF*(DA+DB-(FA-FB)/(DA-DB))
      IS=4
      IF((DA-D)*(D-DB).GE.DZERO)GO TO 8
  25  IS=1
      IF(ABS(D-DB).LE.DDMAX)GO TO 8
  26  IS=1
      D=DB+SIGN(DDMAX,DB-DA)
      DDMAX=DDMAX+DDMAX
      DDMAG=DDMAG+DDMAG
      IF(DDMAX.LE.DMAX)GO TO 8
      DDMAX=DMAX
      GO TO 8
C
  13  IF(F.GE.FA)GO TO 23
  28  FC=FB
      DC=DB
  29  FB=F
      DB=D
      GO TO 30
C
  12  IF(F.LE.FB)GO TO 28
      FA=F
      DA=D
      GO TO 30
C
  11  IF(F.GE.FB)GO TO 10
      FA=FB
      DA=DB
      GO TO 29
C
  71  DL=DONE
      DDMAX=DFIVE
      FA=FP
      DA=-DONE
      FB=FHOLD
      DB=DZERO
      D=DONE
  10  FC=F
      DC=D
  30  TA=(DB-DC)*(FA-FC)
      TB=(DC-DA)*(FB-FC)
      IF((TA+TB)*(DA-DC).GT.DZERO)GO TO 34
      FA=FB
      DA=DB
      FB=FC
      DB=DC
      GO TO 26
C
  34  D=DHALF*(TA*(DB+DC)+TB*(DA+DC))/(TA+TB)
      DI=DB
      FI=FB
      IF(FB.LE.FC)GO TO 44
      DI=DC
      FI=FC
  44  IF(ITONE.LT.0)GO TO 85
      IF(ABS(D-DI)-DACC.LE.DZERO)GO TO 41
      IF(ABS(D-DI)-DPT03*ABS(D).LE.DZERO)GO TO 41
      GO TO 45
C
  85  ITONE=0
  45  IF((DA-DC)*(DC-D).LT.DZERO)GO TO 47
      FA=FB
      DA=DB
      FB=FC
      DB=DC
      GO TO 25
C
  47  IS=2
      IF((DB-D)*(D-DC).GE.DZERO)GO TO 8
      IS=3
      GO TO 8
C
  41  F=FI
      D=DI-DL
      DD=SQRT((DC-DB)*(DC-DA)*(DA-DB)/(TA+TB))
      DO I=1,N
        X(I)=X(I)+D*W(IDIRN)
        W(IDIRN)=DD*W(IDIRN)
        IDIRN=IDIRN+1
      ENDDO
      W(ILINE)=W(ILINE)/DD
      ILINE=ILINE+1
C
      IF(IPRINT.NE.1)GO TO 51
  50  WRITE(6,1052)ITERC,NFCC,F,(X(I),I=1,N)
      IF(IPRINT.GT.1)GO TO 53
C
  51  IF(ITONE.LE.0)GO TO 38
C
      IF(FPREV-F-SUMM.LT.DZERO)GO TO 94
      SUMM=FPREV-F
      JIL=ILINE
  94  IF(IDIRN.LE.JJ)GO TO 7
      IF(IND.NE.0)GO TO 72
  92  FHOLD=F
      IS=6
      IXP=JJ
      DO I=1,N
        IXP=IXP+1
        W(IXP)=X(I)-W(IXP)
      ENDDO
      DD=DONE
      GO TO 58
C
  96  IF(IND.EQ.0)THEN
        IF(FP.LE.F)GO TO 37
        D=DTWO*(FP+F-DTWO*FHOLD)/(FP-F)**2
        IF(D*(FP-FHOLD-SUMM)**2.GE.SUMM)GO TO 37
      ENDIF
      J=JIL*N+1
      IF(J.LE.JJ)THEN
        DO I=J,JJ
          K=I-N
          W(K)=W(I)
        ENDDO
        DO I=JIL,N
          W(I-1)=W(I)
        ENDDO
      ENDIF
C
      ITONE=-1
      IDIRN=IDIRN-N
      K=IDIRN
      IXP=JJ
      AAA=DZERO
      DO  I=1,N
        IXP=IXP+1
        W(K)=W(IXP)
        DDMAG=ABS(W(K)/E(I))
        IF(DDMAG.GT.AAA)AAA=DDMAG
        K=K+1
      ENDDO
      DDMAG=DONE
      W(N)=ESCALE/AAA
      ILINE=N
      GO TO 7
C
  37  IXP=JJ
      AAA=DZERO
      F=FHOLD
      DO I=1,N
        IXP=IXP+1
        X(I)=X(I)-W(IXP)
        IF(AAA*ABS(E(I)).LT.ABS(W(IXP)))AAA=ABS(W(IXP)/E(I))
      ENDDO
      GO TO 72
C
  38  AAA=AAA*(DONE+DI)
      IF(IND.EQ.0)GO TO 72
      INN=0
      IF(AAA.LE.DPT1)GO TO 20
      GO TO 35
C
  72  IF(IPRINT.GE.2)GO TO 50
  53  IF(IND.NE.0)GO TO 88
      IF(AAA.GT.DPT1)GO TO 76
      IF(ICON.LE.1)GO TO 20
      IND=2
      IF(INN.GT.0)GO TO 101
      INN=2
      K=JJJ
      DO I=1,N
        K=K+1
        W(K)=X(I)
        X(I)=X(I)+DTEN*E(I)
      ENDDO
      FKEEP=F
C
      CALL CALCFX(NL,X,F)
C
      IF(NL.EQ.0)GO TO 20                      !FAILURE (NF.LE.0)
C
      NFCC=NFCC+1
      DDMAG=DZERO
      GO TO 108
C
  76  IF(F.LT.FP)GO TO 35
  78  WRITE(6,1080)
      GO TO 20
C
  88  IND=0
      if(fp.lt.f)fp=f                          !assume diff small...
  35  ISGRAD=1
      DDMAG=DPT4*SQRT(FP-F)
 108  IF(ITERC.LT.MAXIT)GO TO 5
      GO TO 81
C
  77  WRITE(6,1075)
      ITERC=ITERC-1
      IF(INN*IND.EQ.0)THEN
        FKEEP=FP
        JJJ=JJ
      ENDIF
C
  81  WRITE(6,1082)ITERC
C
      IF(F.GT.FKEEP)THEN
      F=FKEEP
        DO I=1,N
          JJJ=JJJ+1
          X(I)=W(JJJ)
        ENDDO
      ENDIF
C
  20  DEALLOCATE (W)
C
C     ======
      RETURN
C     ======          IS.GT.0  ON ENTRY IN FOLLOWING OFF-LINE SECTION
C
 101  FP=FKEEP
      IF(F.EQ.FKEEP)GO TO 78
      IF(F.GT.FKEEP)THEN
        IS=0
        FP=F
        F=FKEEP
      ENDIF
      IXP=JJ
      DO I=1,N
        IXP=IXP+1
        K=IXP+N
        FHOLD=W(K)
        IF(IS.EQ.0)THEN
          FHOLD=X(I)
          X(I)=W(K)
        ENDIF
        W(IXP)=FHOLD
      ENDDO
      JIL=2
      GO TO 92
C
1000  FORMAT(5X,'VA04A MAXIMUM CHANGE DOES NOT ALTER FUNCTION')
1052  FORMAT(//' ITERATION',I5,I15,' FUNCTION VALUES',
     X 9X,'F =',E21.14/(5E24.14))
1075  FORMAT(' VA04A ACCEPTS COMMAND FROM CALCFX TO GIVE UP ',24('/')/)
1080  FORMAT (5X,'VA04A ACCURACY LIMITED BY ERRORS IN F')
1082  FORMAT(I5,' ITERATIONS COMPLETED BY VA04A')
C
      END SUBROUTINE VA04A
C
C                             *******************
C
      SUBROUTINE VACPOL(Z,RGRID,N,TB)
C
C-----------------------------------------------------------------------
C
C  This routine sets up the vacuum polarization potential for a point
C  charge Z at each grid point using the analytic functions defined by
C  L. Wayne Fullerton and G. A. Rinker Jr. in Phys. Rev. A Vol 13, page
C  1283,(1976).
C
C  The potential is accumulated in array TB(I),I=1,N .
C
C  No subroutines called.
C
C  Based on PHN's GRASP0 routine and freely adapted by NRB.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (P0=-0.71740181754D0)
      PARAMETER (P1=1.1780972274D0)
      PARAMETER (P2=-0.37499963087D0)
      PARAMETER (P3=0.1308967553D0)
      PARAMETER (P4=-0.038258286439D0)
      PARAMETER (P5=-0.0000242972873D0)
      PARAMETER (P6=-0.3592014867D-3)
      PARAMETER (P7=-0.171700907D-4)
      PARAMETER (S0=-64.0514843293D0)
      PARAMETER (S1=0.711722714285D0)
      PARAMETER (CF0=64.0514843287D0)
      PARAMETER (CF1=-0.711722686403D0)
      PARAMETER (CF2=0.0008042207748D0)
      PARAMETER (D0=217.2386409D0)
      PARAMETER (D1=1643.364528D0)
      PARAMETER (D2=2122.244512D0)
      PARAMETER (D3=-45.12004044D0)
      PARAMETER (E0=115.5589983D0)
      PARAMETER (E1=1292.191441D0)
      PARAMETER (E2=3831.198012D0)
      PARAMETER (E3=2904.410075D0)
      PARAMETER (XX=163.0D0)
C
      DIMENSION RGRID(*),TB(*)
C
C-----------------------------------------------------------------------
C
C  The following are the analytic functions needed:
C
      P(X)=P0+X*(P1+X*(P2+X*(P3+X*(P4+X*(P5+X*(P6+X*P7))))))
      S(X)=S0+X*(S1+X)
      CF(X)=CF0+X*(CF1+X*CF2)
      D(X)=D0+X*(D1+X*(D2+X*(D3+X)))
      E(X)=E0+X*(E1+X*(E2+X*E3))
C-----------------------------------------------------------------------
C
      PI=ACOS(-DONE)
      FACTOR=-(DTWO*Z*DFSC)/(DTHREE*PI)
C
      DO I=1,N
        X=DTWO*RGRID(I)/DFSC
        IF(X.LE.DONE)THEN
          Y=X*X
          TB(I)=FACTOR*(P(X)+LOG(X)*S(Y)/CF(Y))
        ELSE
          IF(X.GE.XX)THEN
            TB(I)=DZERO
          ELSE
            Y=DONE/X
            TB(I)=FACTOR*EXP(-X)*D(Y)/E(Y)/X**(DTHREE/DTWO)
          ENDIF
        ENDIF
        TB(I)=TB(I)/RGRID(I)
      ENDDO
C
      END SUBROUTINE VACPOL
C
C                             *******************
C
      FUNCTION VCC(J1,J2,J,M1,M2,M,FCT)
C
C-----------------------------------------------------------------------
C
C  FN.VCC EVALUATES VECTOR COUPLING COEFFICIENTS.
C  THE SIX QUANTUM NUMBER ARGUMENTS HAVE TWICE THEIR PHYSICAL VALUE;
C  FACTORIALS MUSTBE SUPPLIED BY FCT(I)=(I/2-1)'/16**(I/2-1),I=4,MXDFS,2
C  (FCT(2)=0'=1), AND PHASE FACTORS BY FCT(I)=MOD(I+1,4)-1,I=1,MXDFS,2.
C
C  IT CALLS:
C    SR.DIMUSE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      INTEGER(SP) Z,ZMIN,ZMAX
C
      DIMENSION FCT(MXDFS)
C
      POINTER :: ZMIN,ZMAX,Z
      TARGET :: JG,JH,JI
C
      ZMIN=>JG
      ZMAX=>JH
      Z=>JI
C
c      EQUIVALENCE (ZMIN,JG),(ZMAX,JH),(Z,JI)
C
c      if(nint(fct(2)).ne.1)then    !this is initialized correctly by AS
c        write(6,*)'factorial array incorrect set-up',fct(2)
c        stop 'factorial array incorrect set-up'
c      endif
C
      CC=DZERO
C
      IF(M1+M2.NE.M)GO TO 1
      IF(ABS(M1).GT.J1)GO TO 1
      IF(ABS(M2).GT.J2)GO TO 1
      IF(ABS(M).GT.J)GO TO 1
      IF(J.LT.ABS(J1-J2))GO TO 1
      K0=J1+J2-J+2
      IF(K0.LE.0)GO TO 1
      JB=K0+2
      JJ=JB+J+J
C
      CALL DIMUSE('MXDFS',JJ)
C
      IF(JJ.GT.MXDFS)THEN         !SHOULD NOT HAPPEN, CHECKED IN ALGEB0
        WRITE(6,703)JJ,MXDFS
        WRITE(0,*)'****FCT.VCC: FACTORIAL ARRAY TOO SHORT'
        stop '****FCT.VCC: FACTORIAL ARRAY TOO SHORT'   !as no traceback
C        GO TO 1
      ENDIF
C
      ZMIN=0
      K4=J-J2+M1
      IF(K4.LT.0)ZMIN=-K4
      K3=J-J1-M2
      IF(K3+ZMIN.LT.0)ZMIN=-K3
      ZMAX=K0
      K2=J2+M2+2
      IF(K2.LT.ZMAX)ZMAX=K2
      K1=J1-M1+2
      IF(K1.LT.ZMAX)ZMAX=K1
      JC=K1+2
      JD=K2+2
C
      ZMIN=ZMIN+2
      DO Z=ZMIN,ZMAX,2
        CC=FCT(Z-1)/(FCT(Z)*FCT(JB-Z)*FCT(Z+K3)*FCT(JC-Z)*
     X                                FCT(Z+K4)*FCT(JD-Z))+CC
      ENDDO
C
      JB=K4+K1
      JC=K3+K2
C     JB=(J+J1-J2)+2, JH=(J+M1+M2)+2, JD=(J1+M1)+2; K1=(J1-M1)+2
C     JC=(J-J1+J2)+2, JI=(J-M1-M2)+2, JG=(J2-M2)+2; K2=(J2+M2)+2
      JD=K4+K0
      JG=K0+K3
      JH=K2+K4
      JI=K1+K3
      T=(REAL(J+1,WP)*FCT(K0)*FCT(JB)*FCT(JC)/(FCT(JJ)*16))*
     X             FCT(K1)*FCT(JG)*FCT(JH)*FCT(JI)*FCT(JD)*FCT(K2)
c
      if(t.lt.dzero)then          !graceful exit for any earlier problem
        write(6,*)'vcc:',J1,J2,J,M1,M2,M,t
        write(0,*)'vcc "failure"'
        t=dzero
c        stop 'vcc failure'
      endif
c
      CC=SQRT(T)*CC
    1 VCC=CC
C
      RETURN
C
  703 FORMAT('****FN.VCC: FACTORIAL ARRAY TOO SHORT,'
     X,I5,'.GT.MXDFS=',I5)
C
      END FUNCTION VCC
C
C                             *******************
C
      SUBROUTINE VCE(QLML,QLMS,QBML,QBMS,DU,DL,DS,NO,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR.VCE COMPUTES NB SIMULTANEOUS O.N. EIGENVECTORS DU(N,K),K=1,NB
C  WITH EIGENVALUES DS(K)/4 & DL(K)/4 OF TOTAL SPIN S AND ORBITAL L,
C  FROM A COMPLETE SET OF NB SLATER STATES J (=NO(N),N=1,NB),TO PAIRS
C  BIG MS,ML=QBMS/2,QBML/2 OF A CONFIGURATION KF WITH NF ELECTRONS;
C  TWICE LITTLE L,MS,ML OF I'TH ELECTRON  QL(QCGS(I)),QLMS,+L(I,J).
C
C  NRB: NOW ONLY CALLED FOR EQUIVALENT ELECTRON CONFIGURATION NL^Q
C       SO FAST (DIAGONALIZATION) *AND* MAXDF IS SMALL: 4F^7=119 !!!
C
C  INPUT: NB,NO,QLML,QLMS,QBML,QBMS, KF,NF,QCGS,QL; MAXEL
C
C  OUTPUT: DU,DL,DS;

C  N.B. WORKING ARRAYS: DV,DA (DU=DV*DA IN JACORD)
C
C  CONDITIONS: KF.LE.MAXCF, NF.LE.MAXEL.LE.MXEL0, NB.LE.MAXDF, NO.LE.MXS
C
C  REFERENCE: EQU'S 19-25 IN COMPUTER PHYS. COMMUN. 8(1974)270-306.
C
C  IT CALLS:
C    SR.DIAG
C    SR.JACORD
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QL,QN,QCGS
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXDF8=MAXDF)
C
      PARAMETER (TOL0=1.0D-14)
      PARAMETER (TOL1=3.0D-09)
C
      ALLOCATABLE :: DV(:,:),DA(:,:)
     X              ,DE(:),IWRK1(:),IWRK2(:)
C
      DIMENSION QLML(MAXEL,*),QLMS(MAXEL,*),QBML(*),QBMS(*)
     X         ,DU(MAXDF,*),DL(*),DS(*),NO(*)
C
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBVCX/NFS,KF,NB,JAS,JBS,KSI,KSF,NTGA,NTGB   !,QCGS(MXEL0)
C
C FOR MODULE CAN JUST RENAME THESE IN USE XXX, ONLY NF=>NFS ETC.
      POINTER :: NF,JA,JB
      TARGET :: NFS,JAS,JBS
C
      NF=>NFS
      JA=>JAS
      JB=>JBS
C
c      EQUIVALENCE (NF,NFS),(JA,JAS),(JB,JBS)
C
C LOCAL
C
      ALLOCATE (DV(MAXDF,MAXDF),DA(MAXDF,MAXDF)
     X         ,DE(MAXDF),IWRK1(MAXDF),IWRK2(MAXDF)
     X         ,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'VCE: ALLOCATION FAILS FOR DV,DA,DE,IWRK'
        NF=0
        RETURN
      ENDIF
C
      IF(IDIAG.EQ.0)THEN
        STOL=TOL1
        DTOL=TOL0
      ELSE
        STOL=TOL1
        DTOL=STOL
      ENDIF
C
      BMSEQS=.TRUE.
C
      DO 60  M12=1,2
C
        DO 61  K=1,NB
C
          J=NO(K)
          DO  I=1,NB
            DS(I)=DZERO
          ENDDO
          DS(K)=((M12-1)*QBML(J)+(2-M12)*QBMS(J))**2
C
          DO 62  I=1,NF
C
            N3=QCGS(I)
            NI=QLMS(I,J)
            JD=2
            IF(.NOT.BMSEQS)THEN
              NI=QLML(I,J)
              JD=(QL(N3)+2)*QL(N3)-NI*NI
            ENDIF
            DS(K)=JD+DS(K)
C
            DO 64  L=1,NF
C
              IF(L.EQ.I)GO TO 64
              N4=QCGS(L)
              DO JD=1,NF
                QLML(JD,1)=QLML(JD,J)
                QLMS(JD,1)=QLMS(JD,J)
              ENDDO
              IF(.NOT.BMSEQS)THEN
                QLML(I,1)=NI-2
                KG=(QL(N3)+NI)*(QL(N3)-NI+2)
                QL0=QLML(L,J)
                QLML(L,1)=QL0+2
                KP=(QL(N4)-QL0)*(QL(N4)+QL0+2)
              ELSE
                QLMS(I,1)=NI-2
                KG=(1+NI)*(3-NI)
                QS0=QLMS(L,J)
                QLMS(L,1)=QS0+2
                KP=(1-QS0)*(3+QS0)
              ENDIF
C
              IF(KG.LE.0 .OR. KP.LE.0)GO TO 64
              DD=KG*KP
              DD=SQRT(DD)
C
              DO JD=1,NF
                KG=QCGS(JD)
                IF(N3.NE.KG .AND. N4.NE.KG)GO TO 55
                DO KP=JD,NF
                  IF(QCGS(KP).NE.KG)GO TO 56
                  IF(KP.EQ.JD)GO TO 56
                  NRJ=QLML(KP,1)
                  QS0=QLMS(JD,1)
                  QL0=QLML(JD,1)
                  IF(.NOT.BMSEQS)THEN
                    IF(QL0.GE.NRJ)GO TO 58
                    QLML(JD,1)=NRJ
                    QLML(KP,1)=QL0
                    GO TO 59
                  ENDIF
                  IF(KP-JD.NE.1)GO TO 56
C            ASSUMING SLATER STATES IN SLATER ORDER -
  58              IF(QL0.NE.NRJ)GO TO 56
                  IF(QLMS(KP,1).EQ.QS0)GO TO 64
                  IF(QLMS(KP,1).LT.QS0)GO TO 56
  59              QLMS(JD,1)=QLMS(KP,1)
                  QLMS(KP,1)=QS0
                  DD=-DD
  56            ENDDO
  55          ENDDO
C
              DO KG=1,NB
                JD=NO(KG)
                DO KP=1,NF
                  IF(QLML(KP,JD).NE.QLML(KP,1))GO TO 66
                  IF(QLMS(KP,JD).NE.QLMS(KP,1))GO TO 66
                ENDDO
                DS(KG)=DS(KG)+DD
                GO TO 64
  66          ENDDO
C
  64        CONTINUE
C
  62      CONTINUE
C
C
C MATRIX S**2 (IF M12=1) OR L**2 IN DU; TAS CH.VII.4.8(P.221 IN 1964)
C
          IF(BMSEQS)THEN
            NLO=1                             !HISTORIC LAPACK USE NLO=K
            DO L=NLO,NB
              IF(ABS(DS(L)).LT.STOL)DS(L)=DZERO
              DU(L,K)=DS(L)
            ENDDO
          ELSE
            DO L=1,NB
              DU(L,K)=DS(L)
            ENDDO
          ENDIF
C
  61    CONTINUE
C
C
        IF(.NOT.BMSEQS)THEN
C
          DO L=1,NB
            DO I=L+1,NB
              DU(I,L)=(DU(I,L)+DU(L,I))/DTWO                 !SYMMETRIZE
              DU(L,I)=DU(I,L)
            ENDDO
          ENDDO
C
          DO L=1,NB
            DO I=1,NB
              DA(I,L)=DZERO
              DO K=1,NB
                DA(I,L)=DV(K,I)*DU(K,L)+DA(I,L)
              ENDDO
            ENDDO
          ENDDO
C
          NLO=1                               !HISTORIC LAPACK USE NLO=L
          DO L=1,NB
            DO I=NLO,NB
              DU(I,L)=DZERO
            ENDDO
            DO K=1,NB
              DO I=NLO,NB
                DU(I,L)=DA(I,K)*DV(K,L)+DU(I,L)
              ENDDO
            ENDDO
            DO I=NLO,NB
              IF(ABS(DU(I,L)).LT.STOL)DU(I,L)=DZERO
            ENDDO
          ENDDO
C
        ENDIF
C
C
        IF(IDIAG.EQ.0)THEN
C
C TRY HOUSEHOLDER-QL METHOD FIRST
C
          CALL DIAG(NB,NB,-IONE,DU,DE,DS,IWRK1,IWRK2,MXDF8)
C
          IF(NB.EQ.0)GO TO 999
C
          IF(BMSEQS)THEN
            DO K=1,NB
              DO I=1,NB
                DD=DU(I,K)
                IF(ABS(DD).LT.DTOL)DD=DZERO
                DV(I,K)=DD
              ENDDO
            ENDDO
            BMSEQS=.FALSE.
          ELSE
            DO K=1,NB
              DS(K)=DZERO
              DO I=1,NB
                DD=DU(I,K)
                IF(ABS(DD).LT.DTOL)DD=DZERO
                DS(K)=DD*DL(I)*DD+DS(K)
                DA(I,K)=DD
              ENDDO
            ENDDO
          ENDIF
          DO K=1,NB
            DL(K)=DE(K)
          ENDDO
C
C
        ELSE
C
C
C TRY (SLOWER) JACOBI METHOD
C
          BEIVEC=.TRUE.
          CALL JACORD(NB,BEIVEC,DU,DA,MXDF8)
C
          IF(BMSEQS)THEN
            DO K=1,NB
              DO I=1,NB
                DD=DA(I,K)
                IF(ABS(DD).LT.DTOL)DD=DZERO
                DV(I,K)=DD
              ENDDO
            ENDDO
            BMSEQS=.FALSE.
          ELSE
            DO K=1,NB
              DS(K)=DZERO
              DO I=1,NB
                DD=DA(I,K)
                IF(ABS(DD).LT.DTOL)DD=DZERO
                DS(K)=DD*DL(I)*DD+DS(K)
                DA(I,K)=DD
              ENDDO
            ENDDO
          ENDIF
          DO K=1,NB
            DL(K)=DU(K,K)
          ENDDO
C
C
        ENDIF
C
C
   60 CONTINUE                    ! END M12 LOOP
C
C
      DO L=1,NB
        DO I=1,NB
          DU(I,L)=DZERO
        ENDDO
        DO K=1,NB
          DO I=1,NB
            DU(I,L)=DV(I,K)*DA(K,L)+DU(I,L)
          ENDDO
        ENDDO
      ENDDO
C
 999  CONTINUE
C
C LOCAL
C
      DEALLOCATE (DV,DA,DE,IWRK1,IWRK2,STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'VCE: DE-ALLOCATION FAILS FOR DV,DA,DE,IWRK'
        NF=0
      ENDIF
C
C
      RETURN
C
      END SUBROUTINE VCE
C
C                             *******************
C
      SUBROUTINE VCG(QLML,QLMS,QBML,QBMS,DFS,IAXST,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR VCG COUPLES TWO SUBCONFIGURATIONS (OF SLATER STATES) TO FORM A
C  NEW SUBCONFIGURATION, COMPLETE WITH SLATERSTATE EXPANSION.
C  (SAME FUNCTION AS PJS'S OF THE SAME NAME OR WE'S COLLAG.)
C
C  IT CALLS:
C    SR.DISKDC
C    SR.RE_ALLOC
C
C  INPUT: RESULTS FROM VCU FOR TWO SUBCONFIGURATIONS OF CONFIGURATION KF
C  THE FIRST IS STORED IN THE USUAL LOCATIONS (SEE BELOW) THE SECOND
C  USES THE SAME ARRAYS BUT INDEXED BY NFS,JAS,JBS,NTGA,NTGB,
C  QCGS(MXEL0).
C  NEL(K,KF) EQUIVALENT ELECTRONS WITH ANGULAR LITTLE L=QL(K)/2;
C  JB=HIGHEST INDEX TO SLATER STATE ARRAYS QBXX AND QLXX OCCUPIED
C  BY CONFIGURATIONS .LT.KF; NTG(KF-1)=HIGHEST PREVIOUS INDEX TO
C  TERM ARRAYS XTGX; VCC-ARRAY DC (OF LENGTH MXD) HAS BEEN FILLED
C  UP TO MTGD IN PREVIOUS CALL.
C  QCS0,QCL0=2*(SMAX,LMAX) IN CONFIGURATIONS .LT.KF
C
C  OUTPUT: RESULTANT, STORED IN USUAL LOCATIONS WITH INDEXES UPDATED.
C  VIZ. NF=NUMBER OF ELECTRONS, QCG(I,KF)=GROUP NUMBER OF I'TH
C  ELECTRON, SLATERSTATES QLML+QLMS(I,J),I=1,NF,J=JA,JB QBML+QBMS(J);
C  NUMBER OF SL-TERMS=NTG(KF)-NTG(KF-1), TERMS 2S,2L,NO=QTGS,L,D
C  (K),K=NTG(KF-1),NTG(KF), COUPLING COEFFICIENTS DC(J+JTGD(K)).
C  PARITY QCP(KF) (0,2 FOR EVEN,ODD). UPDATED JB, MTGD, QCS0,QCL0
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN,QCGS,IXEL0
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBGCF, ONLY: KGSL,KGCF,NKSL
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C
      PARAMETER (TYNY=1.0D-5)
      PARAMETER (TTYNY=TYNY*TYNY)
C
      PARAMETER (IBUFF4=(2**30-1)+2**30)                       !2**31 -1
C
      INTEGER(EP) MDCF8,MDCFT8
     x           ,m8
C
      ALLOCATABLE :: NTJX(:),NTJXS(:),BSKP(:)
      ALLOCATABLE :: NX1(:),LX1(:)
C
      DIMENSION QLML(MAXEL,*),QLMS(MAXEL,*),QBML(*),QBMS(*),DFS(*)
      DIMENSION JHOLD(MAXSL)
C
      COMMON /BASIC/NF,KY,KG,JA,JB,JSP1,MSST,MGAP(5)
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /TERMS/NSL0,NSL(MAXSL),NFI(MAXCT),NFK(MAXCT),NFQ(MAXCT)
     X             ,QSI(MAXSL),QLI(MAXSL),QPI(MAXSL)
      COMMON /NRBAL3/MCFSS,KCFSS(MAXCF),KUTSS,NTJ(MAXCF),NFJ(MAXLV)
     X              ,KUTSO,QQCUT
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLIM/ECNTRB,ITANAL,BANAL(MAXCF)               !ALGEBRAIC
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBLSS/NESSH(MAXSL),NASTS,MINSTS,MAXSTS,MINLTS,MAXLTS
      COMMON /NRBPNT/NTGP(MAXCT),NTGS(MAXCT),NTP1,NTP2
      COMMON /NRBVCX/NFS,KF,NB,JAS,JBS,KSI,KSF,NTGA,NTGB   !,QCGS(MXEL0)
C
      DATA MSST0/0/
C
      BLOCAL=.FALSE.
C
      BFINAL=IAXST.LT.0
      IF(BFINAL)IAXST=-IAXST
C
      BDROP=.NOT.BFAST.AND.BFINAL
      MTGD0=MTGD
C
      BDISK=KF.GT.KUTDSK                   !USE DISKDC
      BDISK=BDISK.AND.BFINAL
C
      NF0=NF
      NF=NF+NFS
C
      DO I=1,NFS
        QCG(NF0+I,KF)=QCGS(I)
      ENDDO
C
C IF NO PREVIOUS TO COUPLE TO THEN INITIALIZE
C
      IF(NF0.EQ.0)THEN
        JA=JAS
        JB=JBS
        NTP1=0
        N1=NTGA+1
        QCS=QTGS(N1)
        QCL=QTGL(N1)
        K0=1
        J=0
        N=0
        DO I=N1,NTGB
          N=N+1
          NFI(N)=QTGS(I)
          NFK(N)=QTGL(I)
          NFQ(N)=QTGD(I)
          IF(QCS.EQ.QTGS(I).AND.QCL.EQ.QTGL(I))THEN
            J=J+1
          ELSE
            NKSL(K0,KF)=J
            QCS=QTGS(I)
            QCL=QTGL(I)
            K0=K0+1
            J=1
          ENDIF
        ENDDO
        NKSL(K0,KF)=J
        KSL0=K0
        NTP2=N
C
C IF FIRST AND FINAL THEN MUST COMPLETE FINAL TRANSFER ETC
C
        IF(BDROP)THEN                       !VARIABLE LENGTH
C
          CALL DIMUSE('MAXDC',MTGD)         !HOLD MAX BUFFER USED
C
C INDEX (SINCE NO GAPS)
C
          K=MTGD+1
          DO N=NTP2,1,-1
            DO J=JB,JA,-1
              K=K-1
              IDC(K)=J
            ENDDO
          ENDDO
C
          MTGD1=K
          K=K-1
          MTGD=K
          N=NTGA
C
          I11=1
          IF(BDISK)I11=-1
C
C REDUCE AND RE-INDEX
C
          DO K0=1,KSL0
            KTT=NKSL(K0,KF)
            DO KT=1,KTT
              N=N+1
COLD          DO N=N1,NTGB
              DO J=JA,JB
                K=K+1
                IF(ABS(DC(K)).GT.TTYNY)THEN
                  MTGD=MTGD+1
                  IDC(MTGD)=J
                  DC(MTGD)=DC(K)
                ENDIF
              ENDDO
              JTGD(N)=MTGD
              IF(I11.LT.0)THEN
                JTGD(N)=-JTGD(N)                             !FLAG FIRST
                I11=1
              ENDIF
            ENDDO
            IF(BDISK)THEN                                  !DUMP TO DISK
              CALL DISKDC(IUD,MTGD1,MTGD,KF,K0,-IONE,IZERO)
              MTGD=MTGD1-1
              I11=-1
            ENDIF
          ENDDO
C
          NTG(KF)=NTGB
          NTGA=NTG(KF)
          MSST0=MAX(IZERO,MSST0)                !for old <0 I*2 overflow
c       write(6,*)'vcg 1: msst0=',msst0
          CALL DIMUSE('MXST0',MSST0)            !update
          CALL DIMUSE('MAXCT',NTGB)
C
          IF(NTP2.EQ.0)THEN         !NO TERMS   - POSSIBLE????
            WRITE(6,505)KF
            IF(IDW.NE.0)NF=-1
          ENDIF
          GO TO 999
C
C FIXED LENGTH, COMPLETE SAVE ANY DISK WRITES, SO:
C
        ELSEIF(BDISK)THEN
C
          CALL DIMUSE('MAXDC',MTGD)                !HOLD MAX BUFFER USED
C
          JBA1=JB-JA+1
          NBA=NTGB-NTGA
          MTGD=MTGD-JBA1*NBA
          MTGD1=MTGD+1
C
          DO K0=1,KSL0
            KTT=NKSL(K0,KF)
            MTGD=MTGD+KTT*JBA1
            CALL DISKDC(IUD,MTGD1,MTGD,KF,K0,-IONE,IZERO)
            MTGD1=MTGD+1                             !SINCE DC HOLDS ALL
          ENDDO
C                             NEW INDEX
          MTGD=MTGD-JBA1*NBA
          MTGD1=MTGD+1
          N=NTGA
          DO K0=1,KSL0
            KTT=NKSL(K0,KF)
            DO KT=1,KTT
              N=N+1
              JTGD(N)=MTGD+1-JA
              MTGD=MTGD+JBA1
            ENDDO
            MTGD=MTGD1-1
          ENDDO
        ENDIF
C
        GO TO 50                    !AND RETURN EVNTLY
      ENDIF
C
      IF(NB.NE.0)GO TO 50           !VCU FAILURE - RETURN EVNTLY
C
C FLAG ANY TERMS TO BE SKIPPED, BASED ON ITANAL
C
      BSKP0=.FALSE.
      IF(ITANAL.GT.0)THEN                  !ONLY SET ON "FINAL" COUPLING
C
        ALLOCATE (NX1(IXEL0),LX1(IXEL0))
C
  10    READ(31,300,END=40)I00,NTT,KK,NFF,(NX1(IJ),LX1(IJ),IJ=1,NF)
C
        IF(NF.NE.NFF)THEN
          DO I=1,I00
            READ(31,*)
          ENDDO
          GO TO 10
        ENDIF
C
        DO N=NF,1,-1
          J=QCG(N,KF)
          IF(QN(J).NE.NX1(N).OR.QL(J).NE.2*LX1(N))THEN     !SKIP RECORDS
            DO I=1,I00
              READ(31,*)
            ENDDO
            GO TO 10
          ENDIF
        ENDDO
C
        BANAL(KF)=.TRUE.                   !FLAG MATCH SO DO NOT REWRITE
        IF(KF.LE.KCUT.AND.KK.LT.0)WRITE(6,302)KF
        IF(KF.GT.KCUT.AND.KK.GT.0)WRITE(6,303)KF
        BSKP0=.TRUE.
C
        ALLOCATE (BSKP(NTT))
C
        DO I=1,NTT
          BSKP(I)=.FALSE.
        ENDDO
        J0=0
        DO I=1,I00
          READ(31,301)I0,DD
          BSKP(I0)=DD.LT.ECNTRB
          IF(BSKP(I0))J0=J0+1
        ENDDO
C
        WRITE(6,304)KF,J0
        IF(I00.NE.J0)WRITE(6,305)I00-J0,ECNTRB
C
  40    DEALLOCATE (NX1,LX1)
C
      ENDIF
C
C INITIALIZE
C
      BCUT=KCUT**2.LT.KF*KCUT
      BCUTP=KCUTP**2.LT.KF*KCUTP
C
      BMSEQS=MPRINT+4.LT.0   !OLD+2. IF TRUE: SIZE CHECK ONLY - NO VCC'S
c      IF(BMSEQS)THEN
c        MTGDMX=0
c      ELSE
c        MTGDMX=MAXDC
c      ENDIF
C
C COUPLE THE TWO SUBCONFIG'S TERMS, STORED IN QTGX, TO FORM NEW SET.
C FIRST SET INDEXED BY NTG(KF-1)+1 THRU NTG(KF)
C SECOND SET INDEXED BY NTGA=NTG(KF)+1 THRU NTGB
C STORE RESULTANT (EVENTUALLY) IN QTGX, OVERWRITING ORIGINAL SETS,
C I.E RESULTANT STARTS AT NTG(KF-1)+1 STILL BUT WITH INCREMENTED NTG(KF)
C
      BMGE3=ABS(MODD).GE.3
C
      IF(.NOT.BMGE3)THEN                   !INITIALIZE FOR LOCAL MAX S,L
        QCS0=0
        QCL0=0
      ENDIF
C
C *TBD*: THE I,J LOOPS SHOULD REALLY BE OVER SYMMETRY GROUPS BECAUSE THE
C        TERMS ARE SYMMETRY ORDERED HERE - INELEGANT MORE THAN ANYTHING.
C
      K0=0
      K=NTGB
      DO I=NTG(KF-1)+1,NTG(KF)
        DO J=NTGA+1,NTGB
C
          QSTMN=QTGS(I)-QTGS(J)
          QSTMN=ABS(QSTMN)
          QSTMX=QTGS(I)+QTGS(J)
          QLTMN=QTGL(I)-QTGL(J)
          QLTMN=ABS(QLTMN)
          QLTMX=QTGL(I)+QTGL(J)
C
          DO QLT=QLTMX,QLTMN,-2
            DO QST=QSTMX,QSTMN,-2
C
              IF(BMGE3.AND.(QCS0.NE.QST.OR.QCL0.NE.QLT))GO TO 44
C
              LSPT=10000*(QST+1)+5*QLT+QCP(KF)/2     !QLT=2*L
C PARENT
              IF(NASTP.GT.0)THEN              !SEE IF PARENT TERM WANTED
                NASTP0=NLSPIP(KF)
                IF(NASTP0.EQ.0)GO TO 27           !UNRESTRICTED BY NASTP
                DO N=1,NASTP0
                  IF(LSPIP(N,KF).EQ.LSPT)GO TO 27    !YES
                ENDDO
                GO TO 44                             !NO
              ELSEIF(NASTP.LT.0)THEN
                IF(QST+1.LT.MINSTP.OR.QST+1.GT.MAXSTP)GO TO 44
                IF(QLT/2.LT.MINLTP.OR.QLT/2.GT.MAXLTP)GO TO 44
              ENDIF
C
  27          IF(KCUTP.GT.0)THEN           !LOOK FOR EXISTING PARENT SYM
                DO N=1,NASTKP
                  IF(LSKUTP(N).EQ.LSPT)GO TO 45     !FOUND
                ENDDO
                IF(BCUTP)GO TO 44                   !CORR, SO NOT WANTED
                NASTKP=NASTKP+1                     !WANTED, ADD TO LIST
                LSKUTP(NASTKP)=LSPT
c                write(6,*)'vcg',-nastkp,qst+1,qlt/2,qcp(kf)/2
                GO TO 45
              ENDIF
C FINAL CF
              IF(NAST.GT.0)THEN                      !SEE IF TERM WANTED
                DO N=1,NAST
                  IF(LSPI(N).EQ.LSPT)GO TO 28        !YES
                ENDDO
                GO TO 44                             !NO
              ELSEIF(NAST.LT.0)THEN
                IF(QST+1.LT.MINSP.OR.QST+1.GT.MAXSP)GO TO 44
                IF(QLT/2.LT.MINLT.OR.QLT/2.GT.MAXLT)GO TO 44
              ELSEIF(NASTJ.GT.0)THEN        !CHECK TRIANGLE CONTRIB TO J
                DO N=1,NASTJ
                  JT=JPI(N)/10
                  IF(QCP(KF)/2.EQ.JPI(N)-10*JT)THEN  !SAME PARITY
                    IF(QST+QLT.GE.JT.AND.ABS(QST-QLT).LE.JT)GO TO 28!YES
                  ENDIF
                ENDDO
                GO TO 44                            !NONE FOUND
              ELSEIF(NASTJ.LT.0)THEN        !CHECK TRIANGLE CONTRIB TO J
                 IF(QST+QLT.LT.MINJT.OR.ABS(QST-QLT).GT.MAXJT)GO TO 44
              ENDIF
C
   28         IF(KCUT.GT.0)THEN              !LOOK FOR EXISTING SYMMETRY
                DO N=1,NASTK
                  IF(LSKUT(N).EQ.LSPT)GO TO 45      !FOUND
                ENDDO
                IF(BCUT)GO TO 44                    !CORR, SO NOT WANTED
                NASTK=NASTK+1                       !WANTED, ADD TO LIST
                LSKUT(NASTK)=LSPT
c                write(6,*)'vcg',nastk,qst+1,qlt/2,qcp(kf)/2
              ENDIF
C
   45         IF(BSKP0)THEN
                K0=K0+1
                IF(BSKP(K0))GO TO 44
              ENDIF
C
              QCS0=MAX(QCS0,QST)
              QCL0=MAX(QCL0,QLT)
C
              K=K+1
              IF(K.LE.MAXCT)THEN
                NTGP(K)=I
                NTGS(K)=J
                QTGS(K)=QST
                QTGL(K)=QLT
c
c                qtgd(k)=0
c                do n=ntgb+1,k
c                 if(qtgs(n).eq.qst.and.qtgl(n).eq.qlt)qtgd(k)=qtgd(k)+1
c                enddo
c          write(6,100)i,qtgs(i)+1,qtgl(i)/2,j,qtgs(j)+1,qtgl(j)/2
c     x    ,k-ntgb,qst+1,qlt/2,qtgd(k)
c  100     format(i5,i3,i2,i5,i3,i2,i7,i3,2i2)
c
              ENDIF
   44       ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      IF(BSKP0)DEALLOCATE (BSKP)
C
      IF(K.GT.MAXCT)THEN
        WRITE(6,499)K
        WRITE(0,*)'*** SR.VCG: INCREASE MAXCT & MAXTM'
        NB=-2
        GO TO 50                                                 !RETURN
      ELSE
        NTT=K
        CALL DIMUSE('MAXCT',NTT)
      ENDIF
C
      IF(NTT.EQ.NTGB)THEN                            !NO RESULTANT TERMS
        JB=JA-1
        NTGB=NTG(KF-1)
        IF(KF.GT.KUTDSK)THEN
          N0=NTG(KUTDSK)
        ELSE
          N0=NTGB
        ENDIF
        IF(BFAST)THEN
          MTGD=JTGD(N0+1)-1+JA
        ELSE
          MTGD=abs(JTGD(N0))
        ENDIF
C
        IF(NFS.EQ.0.OR.BMGE3)GO TO 50                       !WILL RETURN
C
        IF(BCUT.OR.BCUTP)THEN
          WRITE(6,502)KF
          IF(IDW.EQ.0)GO TO 50
          NF=-1
          GO TO 999
        ELSE
          IF(ABS(NASTS)+NASTP+NAST+NASTJ.EQ.0)THEN
            WRITE(6,500)KF
            NF=-1
            GO TO 999
          ELSE
            IF(NAST+NASTJ.NE.0)THEN
              WRITE(6,501)KF
            ELSEIF(NASTP.NE.0)THEN
              WRITE(6,506)KF
            ELSE
              WRITE(6,507)KF
            ENDIF
            IF(IDW.EQ.0)GO TO 50
            NF=-1
            GO TO 999
          ENDIF
        ENDIF
      ENDIF
C
C SORT TERMS INTO STANDARD ORDER, BEFORE WE GENERATE SLATERSTATES
C
      K0=0
      N1=NTGB+1
      I=NTGB
C
      QCL=QCL0
C
  60  QCS=QCS0
C
  70  I0=I+1
      J=0
      DO K=N1,NTT
        IF(QTGL(K).EQ.QCL.AND.QTGS(K).EQ.QCS)THEN
          I=I+1
          NFI(I)=K
          J=J-1
          QTGD(I)=J
        ENDIF
      ENDDO
C
      IF(J.LT.0)THEN
        J=-J
        J0=J+1
        DO II=I0,I
          QTGD(II)=QTGD(II)+J0
        ENDDO
C
        K0=K0+1
        NKSL(K0,KF)=J               !NO. TERMS IN SL GROUP
      ENDIF
C
      QCS=QCS-2
      IF(QCS.GE.0)GO TO 70          !LOOP UP FOR NEXT SPIN
C
      QCL=QCL-2
      IF(QCL.GE.0)GO TO 60          !LOOP UP FOR NEXT ORB A.M.
C
      KSL0=K0                       !NO. OF SL GROUPS IN CF
C
C NOW RE-INDEX
C
      DO K=N1,NTT
        I=NFI(K)
        NFK(K)=QTGS(I)
        NFQ(K)=QTGL(I)
      ENDDO
C
C AND TRANSFER BACK
C
      DO K=N1,NTT
        QTGS(K)=NFK(K)
        QTGL(K)=NFQ(K)
c        write(6,*)k-ntgb,qtgs(k)+1,qtgl(k)/2,qtgd(k)
      ENDDO
C
C DITTO PARENT INFO
C
      DO K=N1,NTT
        I=NFI(K)
        NFK(K)=NTGS(I)
        NFQ(K)=NTGP(I)
      ENDDO
C
C AND TRANSFER BACK
C
      DO K=N1,NTT
        NTGS(K)=NFK(K)
        NTGP(K)=NFQ(K)
      ENDDO
C
C
C NOW FORM RESULTANT SLATERSTATES FROM THE TWO SUBCONFIG SETS
C FIRST SET INDEXED BY JA,JB
C SECOND SET INDEXED BY JAS,JBS
C RESULTANT INDEXED(EVENTUALLY) BY JA THRU NEW JB,
C OVERWRITING ORIGINAL SETS, ALL STORED IN DC.
C ORDERED BY DESCENDING ML, FOR IDW.GT.0.
C DOES NOT YET ASSUME THE ORIGINAL SETS WERE SO ORDERED,
C ALTHOUGH THEY MUST BE FOR IDW.NE.0 IN CASE VCG NOT NEEDED
C E.G. CF WITH SINGLE OPEN SUBSHELL.
C
      IF(MODD.GT.0.AND..NOT.BMGE3)THEN                        !RESET MOD
        MODD=-MODD
        WRITE(6,497)MODD
      ENDIF
C
      MSMAX=QCS0
      MLMAX=QCL0
C
      IF(MODD.EQ.0)THEN
        MSMIN=-MSMAX
        MLMIN=-MLMAX
        MJMIN=-999
        if(idw.ne.0)then
          if(jsp1.le.0)msmin=-NF+2*(NF/2)      !LS: ASSUMES MTMS=MST !!!
c          write(0,*)'jsp, msmin=',jsp1,msmin
        endif
      ELSEIF(MODD.EQ.-1)THEN
        MSMIN=-MSMAX
        MLMIN=-MLMAX
        MJMIN=NF-2*(NF/2)
      ELSEIF(MODD.EQ.-2)THEN
        MSMIN=NF-2*(NF/2)
        MLMIN=0
        MJMIN=-999
      ELSEIF(BMGE3)THEN                          !HAS LITTLE MEANING NOW
        MSMIN=QCS0
        MLMIN=QCL0
        MJMIN=-999
      ELSE
        WRITE(6,498)MODD
        WRITE(0,*)'*** SR.VCG: ILLEGAL MOD VALUE'
        NF=-1
        GO TO 999
      ENDIF
C
C LOCAL (TBD: USE ACTUAL DIMENSIONS)
      ALLOCATE (NTJX(IAXST),NTJXS(IAXST),STAT=IERR)
      IF(IERR.NE.0)THEN
        WRITE(0,*)'VCG: ALLOCATION FAILS FOR  NTJX,NTJXS'
        NF=0
        GO TO 999
      ENDIF
      BLOCAL=.TRUE.
C
      JBT=JBS
      JAT=JBT+1
      NTS=0
C
      MTML=MLMAX
C
  55  DO JS=JAS,JBS                                  !SLATERSTATE LOOP
        MBLS=QBML(JS)
        MBSS=QBMS(JS)
C
        DO J=JA,JB                                   !SLATERSTATE LOOP
          MBL=QBML(J)
          MBLT=MBL+MBLS
          IF(MBLT.NE.MTML)GO TO 57
C
          MBS=QBMS(J)
          MBST=MBS+MBSS
          MBJT=MBST+MBLT
C
C              APPLY SELECTION RULES
C     X        MBLT.GE.MLMIN .AND. MBLT.LE.MLMAX .AND.    !OMIT
          IF(
     X        MBST.GE.MSMIN .AND. MBST.LE.MSMAX .AND.
     X        MBJT.GE.MJMIN
     X       )THEN
C
            JBT=JBT+1
            IF(JBT.GT.IAXST)THEN                     !FLAG VIA VCU SS
              MSST=(JB-JA+1)*(JBS-JAS+1)+JBS
              IF(IAXST.LT.MXST0)THEN                 !CANNOT HAPPEN NOW
                write(0,*)iaxst,maxel
                WRITE(6,503)MSST,MSST*NF
                WRITE(0,*)
     X               '*** SR.VCG: DIMENSION EXCEEDED, INCREASE MXEST'
              ELSE                                   !THIS CAN STILL
                WRITE(6,5030)MSST
                WRITE(0,*)
     X               '*** SR.VCG: DIMENSION EXCEEDED, INCREASE MXST0'
              ENDIF
              NB=-3
              GO TO 50                               !RETURN
            ENDIF
            QBMS(JBT)=MBST
            QBML(JBT)=MBLT
            DO I=1,NF0
              QLMS(I,JBT)=QLMS(I,J)
              QLML(I,JBT)=QLML(I,J)
            ENDDO
            DO I=1,NFS
              QLMS(NF0+I,JBT)=QLMS(I,JS)
              QLML(NF0+I,JBT)=QLML(I,JS)
            ENDDO
            NTS=NTS+1
            NTJX(NTS)=J
            NTJXS(NTS)=JS
          ENDIF
  57    ENDDO
      ENDDO
C
      MTML=MTML-2
      IF(MTML.GE.MLMIN)GO TO 55
C
      MSST0=MAX(MSST0,JBT)                 !MAX SS STORAGE NEEDED BY VCG
C
      MTGD1=MTGD+1
      J1=JA-1
c
      m8=int(mtgd)
c
c      iv=mtgd
c      jcmax=0
c
c      write(0,*)'kf=',kf,' mtgd=',mtgd
C                                           !TERM LOOP
      NT=NTGB
      DO K0=1,KSL0                          !SYMETRY GROUP 1 LOOP FOR KF
C
        KTT=NKSL(K0,KF)
C
        MTGDMX=KTT*NTS+MTGD                 !MAXIMAL, EXCLUDING TINY...
C
        IF(.NOT.BMSEQS.AND.MTGDMX.GT.0)THEN !mtgdmx.le.0 -> I*4 overflow
          IF(MTGDMX.GT.IAXDC)THEN
C
            IXXX=7*(IAXDC/5+1)
            if(IXXX.LE.0)then               !IXXX.le.0 -> I*4 overflow
              m8=IAXDC/5+1
              m8=7*m8
              WRITE(6,508)m8
              WRITE(0,*)'*** SR.VCG: TOO MANY VCCs FOR I*4'
              NB=-1
              GO TO 999
            endif
            IXXX=MAX(IXXX,MTGDMX)
C
            WRITE(6,*)'*** VCG: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
            WRITE(0,*)'*** VCG: increasing MAXDC from ',IAXDC,' to: '
     X                ,IXXX
C
            CALL RE_ALLOC(DC,IZERO,MTGD,IXXX,IERR)
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'VCG: REALLOCATION FAILS FOR DC'
              NF=0
              GO TO 999
            ENDIF
C
            IF(DC(0).GT.DZERO)THEN
C
              IF(BFINAL)MTGD0=MTGD
              CALL RE_ALLOC(IDC,IONE,MTGD0,IXXX,IERR)
C
              IF(IERR.NE.0)THEN
                WRITE(0,*)'VCG: REALLOCATION FAILS FOR IDC'
                NF=0
                GO TO 999
              ENDIF
C
            ENDIF
C
            IAXDC=IXXX
C
          ENDIF
        ENDIF
C
       DO KT=1,KTT                          !TERM LOOP FOR GROUP 1
        NT=NT+1
C      DO NT=N1,NTT
C
        JTGD(NT)=MTGD+1-JAT
        QST=QTGS(NT)
        QLT=QTGL(NT)
        NP=NTGP(NT)
        NS=NTGS(NT)
        QSP=QTGS(NP)
        QLP=QTGL(NP)
        QSS=QTGS(NS)
        QLS=QTGL(NS)
        JT=JTGD(NP)
        JTS=JTGD(NS)
c
c        write(6,*)qst,qlt
c        jcount=0
C
        DO N=1,NTS                           !TERM LOOP 2, OF NEXT SUBCF
C
          JS=NTJXS(N)
          MBSS=QBMS(JS)
          MBLS=QBML(JS)
C
          J=NTJX(N)
          MBS=QBMS(J)
          MBL=QBML(J)
C
          MBST=MBS+MBSS
          MBLT=MBL+MBLS
C
c          MTGD=MTGD+1
          m8=m8+1
          mtgd=int(m8)
c
c          IF(MTGD.LE.MTGDMX)THEN
            DC(MTGD)=DZERO
            VC1=DC(JT+J)
            IF(ABS(VC1).GT.TYNY)THEN
              VC2=DC(JTS+JS)
              IF(ABS(VC2).GT.TYNY)THEN
                V1=
     X        VCC(INT(QSP,SP),INT(QSS,SP),INT(QST,SP),MBS,MBSS,MBST,DFS)
                V2=
     X        VCC(INT(QLP,SP),INT(QLS,SP),INT(QLT,SP),MBL,MBLS,MBLT,DFS)
                T=VC1*VC2*V1*V2
c
c                write(6,*)qsp,qss,qst,mbs,mbss,mbst
c     x              ,'  ',qlp,qls,qlt,mbl,mbls,mblt
c                write(6,*)nt,n,v1,v2,vc1,vc2,mtgd,t
c                if(abs(t).gt.tyny)then
c                  iv=iv+1
c                  jcount=jcount+1
c                endif
c
                IF(ABS(T).GT.TTYNY)THEN                    !<--- TTYNY
                  DC(MTGD)=T
                  IF(BDROP)IDC(MTGD)=N+J1
                ELSEIF(BDROP)THEN
                  MTGD=MTGD-1
                ENDIF
              ELSEIF(BDROP)THEN
                MTGD=MTGD-1
              ENDIF
            ELSEIF(BDROP)THEN
              MTGD=MTGD-1
            ENDIF
            m8=int(mtgd)
c          endif
C
        ENDDO                                      !TERM LOOP 2
c          write(6,*)nt-ntgb,jcount
c        jcmax=max(jcmax,jcount)
       ENDDO                                       !TERM LOOP OF GROUP 1
c
       itest4=ibuff4
       itest4=itest4+1
       if(m8.gt.ibuff4.and.itest4.lt.ibuff4)then
         WRITE(6,508)m8
         WRITE(0,*)'*** SR.VCG: TOO MANY VCCs FOR I*4'
         NB=-1
         GO TO 999
       endif
c
       IF(BDROP)JHOLD(K0)=MTGD                           !FINALIZE
       IF(BDISK)THEN
c         write(0,*)'k0=',k0,' mtgd=',mtgd-mtgd1+1
         IEND=MIN(MTGD,IAXDC)                                     !MAXDC
         CALL DISKDC(IUD,MTGD1,IEND,KF,K0,-IONE,IZERO)
         CALL DIMUSE('MAXDC',MTGD)                 !HOLD MAX BUFFER USED
         MTGD=MTGD1-1
         m8=int(mtgd)
       ENDIF
C
      ENDDO                                       !SYMMETRY GROUP 1 LOOP
C
c      write(0,*)kf,jcmax,iv-mtgd1+1,mtgd-mtgd1+1
      IF(BDISK)THEN
        MTGDMX=0
        CALL DIMUSE('MAXDC',MTGDMX)         !GET MAX USED
      ELSE
        MTGDMX=int(m8)                      !MTGD
      ENDIF
      IF(MTGDMX.LE.0)THEN             !.le.0 -> I*4 overflow
         WRITE(6,508)m8
         WRITE(0,*)'*** SR.VCG: TOO MANY VCCs FOR I*4'
         NB=-1
         GO TO 999
      ENDIF
      IF(MTGDMX.GT.IAXDC)THEN                       !SHOULD NOT BE SO...
        WRITE(0,*)'*** SR.VCG: RE-ALLOCATION ERROR...'
        WRITE(6,*)'*** SR.VCG: RE-ALLOCATION ERROR...'
        NF=-1
        GO TO 999
      ENDIF
C
      IF(BMSEQS)THEN                        !FILL-IN FOR DIMENSION CHECK
        DO J=MTGD1,MTGD
          DC(J)=DONE
        ENDDO
        DO NT=N1,NTT
          QTGD(NT)=-QTGD(NT)
        ENDDO
        IF(BDROP)THEN
          M=MTGD1-1
          DO NT=N1,NTT
            DO N=1,NTS
              M=M+1
              IDC(M)=N+J1
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C NOW OVERWRITE SUBCONFIGURATION STORAGE WITH RESULTANT
C (BACK-UP PARENT SLP FOR OPTIONAL PRINTING IN ALGEB1.)
C
      I0=NTG(KF-1)+1
      I1=JTGD(I0)-1+JA
C
      I=I1
      DO J=MTGD1,MTGD
        I=I+1
        DC(I)=DC(J)
      ENDDO
      IF(BDROP)THEN
        MHOLD=MTGD1-I1-1
        I=I1
        DO J=MTGD1,MTGD
          I=I+1
          IDC(I)=IDC(J)
        ENDDO
      ENDIF
C
      CALL DIMUSE('MAXDC',MTGD)                    !HOLD MAX BUFFER USED
      MTGD=I
C
      K=JA-1
      DO J=JAT,JBT
        K=K+1
        QBMS(K)=QBMS(J)
        QBML(K)=QBML(J)
        DO I=1,NF
          QLMS(I,K)=QLMS(I,J)
          QLML(I,K)=QLML(I,J)
        ENDDO
      ENDDO
C
      JB=K
C
      N=0
      DO I=NTG(KF-1)+1,NTG(KF)
        N=N+1
        NFI(N)=QTGS(I)
        NFK(N)=QTGL(I)
        NFQ(N)=QTGD(I)
      ENDDO
      NTP1=N
C
      DO I=NTGA+1,NTGB
        N=N+1
        NFI(N)=QTGS(I)
        NFK(N)=QTGL(I)
        NFQ(N)=QTGD(I)
      ENDDO
      NTP2=N
C
      J=NTG(KF-1)
      J0=JTGD(N1)-JTGD(J+1)               !AS  JA <- JAT
      DO N=N1,NTT
        J=J+1
        JTGD(J)=JTGD(N)-J0
        QTGS(J)=QTGS(N)
        QTGL(J)=QTGL(N)
        QTGD(J)=QTGD(N)
        NTGS(J)=NTGS(N)
        NTGP(J)=NTGP(N)
      ENDDO
C
      NTGB=J
C
  50  CONTINUE
C
      NTG(KF)=NTGB
      NTGA=NTG(KF)
C
C FINALLY, RE-DEFINE JTGD(N) TO GIVE THE *ABSOLUTE* POSITION OF
C THE *END* OF THE DC(I) ARRAY FOR TERM N.
C (ABSOLUTE SIMPLIFIES SPECIFICATION OF THE VARIABLE ARRAY LENGTH
C  WHILE *END* MEANS WE JUST NEED TO START AT JTGD(0)=0.)
C
      IF(BDROP)THEN
        JA1=JA-1
        N=NTG(KF-1)
        I11=1
        IF(BDISK)I11=-1
        DO K0=1,KSL0
          KTT=NKSL(K0,KF)
          DO KT=1,KTT-1
            N=N+1
            JTGD(N)=JTGD(N+1)+JA1
            IF(I11.LT.0)THEN
              JTGD(N)=-JTGD(N)                               !FLAG FIRST
              I11=1
            ENDIF
          ENDDO
          N=N+1
          JTGD(N)=JHOLD(K0)-MHOLD
          IF(I11.LT.0)JTGD(N)=-JTGD(N)                       !CASE KTT=1
          IF(BDISK)I11=-1
        ENDDO
c        if(n*ntgb.ne.ntgb*ntgb)stop 'vcg'
c for .not.bdisk only
c        DO N=NTG(KF-1)+1,NTG(KF)-1
c          JTGD(N)=JTGD(N+1)+JA1
c        ENDDO
c        JTGD(NTGB)=MTGD
c       write(6,*)'vcg 2: msst0=',msst0
        CALL DIMUSE('MXST0',MSST0)
      ENDIF
C
 999  CONTINUE
C
      IF(BFINAL)KGCF(KF)=KSL0
c
c      if(bdcwr)then
c        n=ntg(kf-1)
c        do k0=1,ksl0
c         ktt=nksl(k0,kf)
c         do kt=1,ktt
c          n=n+1
c         write(6,*)kf,k0,n,jtgd(n)
c         enddo
c        enddo
c      endif
C
      IF(BLOCAL)THEN
        DEALLOCATE (NTJX,NTJXS,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'VCG: DE-ALLOCATION FAILS FOR  NTJX,NTJXS'
          IF(NF.GT.0)NF=0
        ENDIF
      ENDIF
C
      RETURN
C
 300  FORMAT(3I6,I3,100(I3,I2))
 301  FORMAT(I6,6X,F13.3)
 302  FORMAT(/'*** ATTENTION: CONFIGURATION',I5,' IS NOW SPECTROSCOPIC'
     X,' BUT WAS CORRELATION IN ITANAL...')
 303  FORMAT(/'*** ATTENTION: CONFIGURATION',I5,' IS NOW CORRELATION'
     X,' BUT WAS SPECTROSCOPIC IN ITANAL...')
 304  FORMAT(//' CONFIGURATION CF=',I5,' DROPS',I5,' TERMS, BASED ON'
     X,' USER SUPPLIED ITANAL FILE')
 305  FORMAT(22X,' NOTE:',I5,' TERMS WERE RETAINED BECAUSE YOU HAVE'
     X,' REDUCED ECNTRB TO',F8.2,' /CM')
 497  FORMAT(/'*** SR.VCG: MOD RESET TO -MOD:',I3)
 498  FORMAT(/'*** SR.VCG: ILLEGAL MOD VALUE: ',I3)
 499  FORMAT(/'*** SR.VCG: INCREASE MAXCT & MAXTM TO;',I6)
 500  FORMAT(/'*** VCG ERROR COUPLING SUBCONFIGURATIONS OF KF=',I5)
 501  FORMAT(/'*** ATTENTION: BECAUSE OF NAST/J THE FOLLOWING',
     X                ' CF=',I5,' CONTRIBUTES NO TERMS/LEVELS...')
 502  FORMAT(/'*** ATTENTION: THE FOLLOWING CORRELATION CF=',I5,
     X              ' CONTRIBUTES NO TERMS/LEVELS...')
 503  FORMAT(/'*** SR.VCG: SLATER-STATE STORAGE (MAXST) NEEDED: ',I9
     X       /'    TRY INCREASING MXEST TO AT LEAST ',I10)
 5030 FORMAT(/'*** SR.VCG: INCREASE MXST0 TO AT LEAST:',I9)
c 504  FORMAT(/'*** SR.VCG: INCREASE MAXDC TO AT LEAST:',I11)
 505  FORMAT(/'*** ATTENTION: THE FOLLOWING CONFIGURATION CF=',I5,
     X              ' CONTRIBUTES NO TERMS/LEVELS...')
 506  FORMAT(/'*** ATTENTION: BECAUSE OF NASTP  THE FOLLOWING',
     X                ' CF=',I5,' CONTRIBUTES NO TERMS/LEVELS...')
 507  FORMAT(/'*** ATTENTION: BECAUSE OF NASTS  THE FOLLOWING',
     X                ' CF=',I5,' CONTRIBUTES NO TERMS/LEVELS...')
 508  FORMAT(//'*** SR.VCG: I*4 OVERFLOW FOR DC ARRAY INDEX, MTGD=',I11
     X,' - SET DEFAULT INTEGER SP=8 IN MODULE PRECSN, OR USE KUTDSK'//)
C
      END SUBROUTINE VCG
C
C                             *******************
C
      SUBROUTINE VCU(QLML,QLMS,QBML,QBMS,DL,DS,NO,IAXST,MAXEL)
C
C-----------------------------------------------------------------------
C
C  SR VCU SETS UP SLATER STATES TO A CONFIGURATION GIVEN AS GROUPS OF
C  EQUIVALENT ELECTRONS,  AND COMPUTES VECTOR COUPLING COEFFICIENTS
C  (VCC) FOR CONSTRUCTING TERMS OF TOTAL SL FROM THE SLATER STATES.
C  IT REQUIRES SR VCE (WHICH REQUIRES SR JACORD AND ROTSYM).
C  MODD, IN /MQVC/, RULES DIFFERENT MODES, SEE COMMENT AT THE END.
C  NB=0: SUCCESSFUL RUN; OTHERWISE STUDY RETURN-COMMENTS AND CHECK NB
C
C  INPUT: CONFIGURATION KF, CONSISTING OF GROUPS K=1,2..MAXGR OF
C  NEL(K,KF) EQUIVALENT ELECTRONS WITH ANGULAR LITTLE L=QL(K)/2;
C  NEL.LT.0 IS IGNORED IN THIS PROGRAM (MIGHT BE USED FOR MARKING
C  CLOSED SUBSHELLS ELSEWHERE). FOR A KF.GT.KCUT SEE NOTE AT END.
C  JB=HIGHEST INDEX TO SLATER STATE ARRAYS QBXX AND QLXX OCCUPIED
C  BY CONFIGURATIONS .LT.KF; NTG(KF-1)=HIGHEST PREVIOUS INDEX TO
C  TERM ARRAYS XTGX; VCC-ARRAY DC (OF LENGTH MXD) HAS BEEN FILLED
C  UP TO MTGD IN PREVIOUS CALL.
C  QCS0,QCL0=2*(SMAX,LMAX) IN CONFIGURATIONS .LT.KF
C
C  OUTPUT: NF=NUMBER OF ELECTRONS, QCGS(I)=GROUP NUMBER OF I'TH
C  ELECTRON, SLATERSTATES QLML+QLMS(I,J),I=1,NF,J=JA,JB QBML+QBMS(J);
C  NUMBER OF SL-TERMS ND=NTGB-NTGA, TERMS 2S,2L,NO=QTGS,L,D
C  (K),K=NTG(KF-1),NTG(KF), COUPLING COEFFICIENTS DC(J+JTGD(K)).
C  PARITY QCP(KF) (0,2 FOR EVEN,ODD). UPDATED JB, MTGD, QCS0,QCL0
C
C  IT CALLS:
C    SR.DIMUSE
C    SR.RE_ALLOC
C    SR.VCE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QL,QN,QCGS
      USE COMMON_DC,     ONLY: BFAST,DC,IDC,IAXDC,IXIDC
      USE COMMON_MQVC,   ONLY: MODD,KCUT,QCL0,QCS0,NEL,KMAX
      USE COMMON_NRBLSP, ONLY: BNRBLSP,LSPIP,NLSPIP,NASTP
     X                        ,MINSTP,MAXSTP,MINLTP,MAXLTP
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      USE REALLOCATE, ONLY: RE_ALLOC
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (STOL=1.0D-6)
      PARAMETER (TYNY=1.0D-5)
      PARAMETER (TTYNY=TYNY*TYNY)
      PARAMETER (DPT1=0.1D0)
C
      INTEGER(EP) MDCF8,MDCFT8
C
      ALLOCATABLE :: DU(:,:)
C
      DIMENSION QLML(MAXEL,*),QLMS(MAXEL,*),QBML(*),QBMS(*)
     X         ,DL(*),DS(*),NO(*)
C
      COMMON /BASIC/MGAP1(6),MSST,MGAP2(5)
      COMMON /OUTP1/MPRINT
      COMMON /QTG/MTGD,NXLL,NTT,NTG(0:MAXCF),JTGD(0:MAXCT),QCP(MAXCF)
     X           ,QTGS(MAXCT),QTGL(MAXCT),QTGD(MAXCT)
      COMMON /NRBDIJ/IDIAG,JRAD
      COMMON /NRBDSK/MDCF8,MDCFT8,MDCBUF,KUTDSK,MTGD1,IUD,KFBUFF
      COMMON /NRBJ/JPI(MAXJG),NJPI(MAXJG),NASTJ,MINJT,MAXJT,NEIGENJ
      COMMON /NRBKUT/KCUTX,LSKUT(MAXSL),NASTK            !KCUT IN /MQVC/
      COMMON /NRBKUTP/KCUTP,LSKUTP(MAXSL),NASTKP
      COMMON /NRBLS/LSPI(MAXSL),NLSPI(MAXSL),NAST,MINSP,MAXSP
     X             ,MINLT,MAXLT,IPAR,NEIGEN
      COMMON /NRBLSS/NESSH(MAXSL),NASTS,MINSTS,MAXSTS,MINLTS,MAXLTS
      COMMON /NRBVCX/NFS,KF,NB,JAS,JBS,KSI,KSF,NTGA,NTGB   !,QCGS(MXEL0)
C
C FOR MODULE CAN JUST RENAME THESE IN USE XXX, ONLY NF=>NFS ETC.
C OR SIMPLY REPLACE WITH SUBSHELL NAMES THROUGHOUT
      POINTER :: NF,JA,JB
      TARGET :: NFS,JAS,JBS
C
      NF=>NFS
      JA=>JAS
      JB=>JBS
C
c      EQUIVALENCE (NF,NFS),(JA,JAS),(JB,JBS)
C
c     data timev/0.d0/
c     save timev
C
      BCUT=KCUT**2.LT.KF*KCUT
      BCUTP=KCUTP**2.LT.KF*KCUTP
C
      IDIAG0=IDIAG
      JB0=JB
      MTGD0=MTGD
c
c store resultant at end of arrays so can sort by M_L on moving down.
c
      ja0=ja
      mshift=IAXST+jb0+1
C
  52  JB=JB0
      MTGD=MTGD0
      BMSEQS=MPRINT+2.LT.0  !OLD+2. IF TRUE: SIZE CHECK ONLY -- NO VCC'S
C
C COMPILE ALL THE SLATER STATES THAT FORM THE GIVEN CONFIGURATION --
C IN ARRAY LOCATIONS J=JA,JB, FOR NF ELECTRONS I=1,NF
C
      NB=-3
      ND=0
      KG=JB+2
      JA=KG-1
      NF=0
      KP=0
C
C LOOP OVER SUBCONFIGURATION DEFINED BY KSI,KSF
C
      DO K=KSI,KSF
        NRJ=NEL(K,KF)
        IF(NRJ.LE.0)GO TO 11          !CLOSED-SUBSHELL OR EMPTY
C
        NI=NF+1
        NU=NF+NRJ
        NF=NU
        IF(NU.GT.MAXEL)THEN           !TOO MANY ELECTRONS
          NB=-4
          GO TO 999
        ENDIF
C
        KP=NRJ*QL(K)+KP
        J=JA
        JD=KG-J
C
  15    KG=J+JD
        JB=KG-1
C
C MAX VCU SS STORAGE DETERMINED BY *UNCOUPLED* PARENT+SUBSHELL HERE.
        jmx=2*kg-jb0-1                  !~2*JB
        CALL DIMUSE('MXST0',jmx)
c        write(6,*)'vcu: jmx=',jmx
        IF(mshift.lt.2*kg)THEN  !NOT ENOUGH SS BUFFER STORAGE JMX.GE.MXS
          MSST=jmx
          GO TO 999
        ENDIF
C
        jx=mshift-j
        IF(NU.GE.NI)THEN
          MS=1
          ML=QL(K)
          DO I=NI,NU
            QCGS(I)=K
            QLMS(I,Jx)=MS
            QLML(I,Jx)=ML
            MS=-MS
            ML=ML-1-MS
          ENDDO
        ENDIF
C
        DO L=J,KG
          NU=L-JD
          IF(NU.LT.JA)NU=L
          lx=mshift-l
          DO I=1,NF
            IF(I.EQ.NI)NU=J
            nux=mshift-nu
            QLML(I,Lx)=QLML(I,NUx)
            QLMS(I,Lx)=QLMS(I,NUx)
          ENDDO
        ENDDO
C
        J=KG
        jx=mshift-j
        DO I=NI,NF
          MS=QLMS(I,Jx)
          ML=QLML(I,Jx)-1+MS
          IF(ML.LT.-QL(K))GO TO 11
          QLMS(I,Jx)=-MS
          QLML(I,Jx)=ML
          NU=I-1
          IF(I.EQ.NF)GO TO 15
          IF(QLMS(I+1,Jx).EQ.MS)GO TO 15
          IF(QLML(I+1,Jx).NE.ML)GO TO 15
        ENDDO
C
  11  ENDDO
C
      QCP(KF)=MOD(QCP(KF)+KP,IFOUR)               !ACCUMULATE SUB-SHELLS
C
C ACCUMULATE SUBSHELL SS WEIGHTS, TO FORM WHOLE CONFIG.
C
      MSST=(MSST-1)*(JB-JA+1)+1
c      write(0,*)ja-1,jb-1,msst-1
C
C FORM M_X
C
      mlmax=-999
      mlmin=999
      DO jj=JA,JB
        j=mshift-jj
        QBML(J)=0
        QBMS(J)=0
        DO I=1,NF
          QBML(J)=QLML(I,J)+QBML(J)
          QBMS(J)=QLMS(I,J)+QBMS(J)
        ENDDO
        mlmin=min(mlmin,INT(qbml(j),SP))
        mlmax=max(mlmax,INT(qbml(j),SP))
      ENDDO
c
c order by descending M_L.
c
      mtml=mlmax
      j0=jb0
  54  do jj=ja,jb
        j=mshift-jj
        if(qbml(j).eq.mtml)then
          j0=j0+1
          qbml(j0)=qbml(j)
          qbms(j0)=qbms(j)
          do i=1,nf
            qlml(i,j0)=qlml(i,j)
            qlms(i,j0)=qlms(i,j)
          enddo
        endif
      enddo
c
      mtml=mtml-2
      if(mtml.ge.mlmin)go to 54
c
      if(j0.ne.jb)then
        write(0,*)ja0,jb0,ja,jb,j0,mshift
        stop 'indexing error'
      endif
C
C LISTING OF ND TERMS (SL) CONTAINED IN THE (JB-JA+1) SLATER STATES
C IN ARRAY LOCATIONS K=NTG(KF-1)+1,NTG(KF) (FOR NTG(KF-1)-NTG(KF).LE.ND)
C
      BMGE3=ABS(MODD).GE.3
      NB=-2
      N2=NTGA                                     !NTG(KF-1) IF WHOLE CF
      N1=N2+1
      QCS=0                                       !LOCAL MAX S
      QCL=0                                       !LOCAL MAX L
C     QDS=999                                     !LOCAL MIN S
C     QDL=999                                     !LOCAL MIN L
      IF(.NOT.BMGE3)THEN
        QCS0=0                                    !WAS GLOBAL, NOW LOCAL
        QCL0=0                                    !WAS GLOBAL, NOW LOCAL
      ENDIF
      NF21=NF+NF+1
C
      KG=0
      IF(MODD.LE.-3)KG=2
C
C START TERM GENERATION LOOP
C
  41  QL0=-1
      QS0=0
      DO J=JA,JB
        MS=QBMS(J)
        ML=QBML(J)
        IF(MS.GE.-NF.AND.ML.GE.QL0)THEN
          IF(ML.GT.QL0.OR.MS.GT.QS0)THEN
            QL0=ML
            QS0=MS
          ENDIF
        ENDIF
      ENDDO
C
      IF(QL0.LT.0)GO TO 50
C
      IF(BMGE3)THEN
        IF(QL0.LT.QCL0-KG)GO TO 45
        IF(QS0.LT.QCS0)GO TO 45
        IF(QS0.GT.QCS0)GO TO 44
        IF(QL0.NE.QCL0)GO TO 44
      ENDIF
C
C APPLY USER SELECTIONS
C
      NRJ=NEL(KSF,KF)
      IF(NRJ.GT.0)THEN                     !KSI=KSF NORMALLY, NRJ<0 CORE
        IF(NASTS.GT.0)THEN                 !SEE IF SUB-SHELL/TERM WANTED
          BSKIP=.FALSE.
          NELS0=100000*KSF+1000*NRJ
          NELS=NELS0+10*(QS0+1)+QL0/2
          DO I=1,NASTS
            IF(NESSH(I).EQ.NELS0)THEN                        !SL NOT SET
              IF(QS0+1.GE.MINSTS.AND.QS0+1.LE.MAXSTS.AND.
     X           QL0/2.GE.MINLTS.AND.QL0/2.LE.MAXLTS)GO TO 26
              BSKIP=.TRUE.
            ELSE
              IO=NESSH(I)/100000
              IQ=(NESSH(I)-IO*100000)/1000
              IF(IO.EQ.KSF.AND.IQ.EQ.NRJ)THEN       !SPECTATOR SUB-SHELL
                IF(NESSH(I).EQ.NELS)GO TO 26
                BSKIP=.TRUE.
              ENDIF
            ENDIF
          ENDDO
          IF(BSKIP)GO TO 44
        ELSEIF(NASTS.LT.0)THEN
          NELS=100000*KSF+1000*NRJ
          DO I=1,-NASTS
            IF(NESSH(I).EQ.NELS)THEN                !SPECTATOR SUB-SHELL
              IF(QS0+1.LT.MINSTS.OR.QS0+1.GT.MAXSTS)GO TO 44
              IF(QL0/2.LT.MINLTS.OR.QL0/2.GT.MAXLTS)GO TO 44
            ENDIF
          ENDDO
        ENDIF
      ENDIF
C
  26  LSPT=10000*(QS0+1)+5*QL0+QCP(KF)/2    !QL0=2*L
C
      IF(NASTP.GT.0)THEN                    !SEE IF PARENT TERM WANTED
        NASTP0=NLSPIP(KF)
        IF(NASTP0.EQ.0)GO TO 27             !UNRESTRICTED BY NASTP
        DO I=1,NASTP0
          IF(LSPIP(I,KF).EQ.LSPT)GO TO 27
        ENDDO
        GO TO 44
      ELSEIF(NASTP.LT.0)THEN
        IF(QS0+1.LT.MINSTP.OR.QS0+1.GT.MAXSTP)GO TO 44
        IF(QL0/2.LT.MINLTP.OR.QL0/2.GT.MAXLTP)GO TO 44
      ENDIF
C
  27  IF(KCUTP.GT.0)THEN                   !LOOK FOR EXISTING PARENT SYM
        DO I=1,NASTKP
          IF(LSKUTP(I).EQ.LSPT)GO TO 101    !FOUND
        ENDDO
        IF(BCUTP)GO TO 44                   !CORR, SO NOT WANTED
        NASTKP=NASTKP+1                     !WANTED, ADD TO LIST
        LSKUTP(NASTKP)=LSPT
c        write(6,*)'vcu0',-nastkp,qs0+1,ql0/2,qcp(kf)/2
        GO TO 101
      ENDIF
C FINAL CF
      IF(NAST.GT.0)THEN                     !SEE IF TERM WANTED
        DO I=1,NAST
          IF(LSPI(I).EQ.LSPT)GO TO 28       !YES
        ENDDO
        GO TO 44                            !NO
      ELSEIF(NAST.LT.0)THEN
        IF(QS0+1.LT.MINSP.OR.QS0+1.GT.MAXSP)GO TO 44
        IF(QL0/2.LT.MINLT.OR.QL0/2.GT.MAXLT)GO TO 44
      ELSEIF(NASTJ.GT.0)THEN                !CHECK TRIANGLE CONTRIB TO J
        DO I=1,NASTJ
          JT=JPI(I)/10
          IF(QCP(KF)/2.EQ.JPI(I)-10*JT)THEN !SAME PARITY
            IF(QS0+QL0.GE.JT.AND.ABS(QS0-QL0).LE.JT)GO TO 28        !YES
          ENDIF
        ENDDO
        GO TO 44                            !NONE FOUND
      ELSEIF(NASTJ.LT.0)THEN                !CHECK TRIANGLE CONTRIB TO J
         IF(QS0+QL0.LT.MINJT.OR.ABS(QS0-QL0).GT.MAXJT)GO TO 44
      ENDIF
C
  28  IF(KCUT.GT.0)THEN                     !LOOK FOR EXISTING SYMMETRY
        DO I=1,NASTK
          IF(LSKUT(I).EQ.LSPT)GO TO 101     !FOUND
        ENDDO
        IF(BCUT)GO TO 44                    !CORR, SO NOT WANTED
        NASTK=NASTK+1                       !WANTED, ADD TO LIST
        LSKUT(NASTK)=LSPT
c        write(6,*)'vcu0',nastk,qs0+1,ql0/2,qcp(kf)/2
      ENDIF
C
C END USER SELECTION
C
  101 N2=N2+1                                     !NO. OF TERMS SELECTED
      IF(N2.GT.MAXCT)GO TO 44         !TERM ARRAYS TOO SMALL FOR PROBLEM
C
C DETERMINE  LOCAL MAX{S} AND MAX{L}
      IF(QCS.LT.QS0)QCS=QS0
      IF(QCL.LT.QL0)QCL=QL0
C
C DETERMINE LOCAL MIN{S} AND MIN{L}
C     IF(QDS.GT.QS0)QDS=QS0
C     IF(QDL.GT.QL0)QDL=QL0
C
      QTGS(N2)=QS0
      QTGL(N2)=QL0
      QTGD(N2)=0
      DO K=N1,N2
        IF(QTGL(K).EQ.QL0.AND.QTGS(K).EQ.QS0)QTGD(K)=QTGD(K)-1
      ENDDO
C
  44  ND=ND+1                             !NO. OF TERMS IN CF (NOT USED)
C
C STRIKE-OUT QBMS FOR THIS TERM
C
      jb0=ja-1
      ML=QL0                              !SINCE M_L IN DESCENDING ORDER
  45  MS=QS0
C
      bflag=.true.
      ja0=jb0+1
      ja00=ja0
      do j=ja0,jb
        if(qbml(j).gt.ml)then                   !not needed for this m_l
          ja00=j+1
        elseif(qbml(j).lt.ml)then     !have moved on to next (lower) m_l
          jb0=j-1
          go to 46
        elseif(bflag)then
          if(qbms(j).ge.-nf)then           !we have first non-strike-out
            ja00=j
            bflag=.false.
          endif
        endif
      enddo
      jb0=jb
C
  46  DO J=ja00,jb0
        IF(QBMS(J).EQ.MS)THEN                    !NOW QBML(J).EQ.ML HERE
          QBMS(J)=QBMS(J)-NF21                               !SO .LT.-NF
          GO TO 48
        ENDIF
      ENDDO
C                       NOTE LOOPS FROM MAX TO MIN - REVERSE OF HISTORIC
  48  MS=MS-2
      IF(MS.GE.-QS0)GO TO 46
C
      ML=ML-2
      IF(ML.GE.-QL0)GO TO 45
C
      GO TO 41
C
C TERMS COMPLETE
C
  50  NTGB=N2                                      !=NTG(KF) IF WHOLE CF
C
      IF(N2.GT.MAXCT)GO TO 999        !TERM ARRAYS TOO SMALL FOR PROBLEM
C
C CROSS OUT UNWANTED SLATER STATES J, SET UP VCC ORGANIZATION
C (AND FOR M=1, 2ND ENTRY THROUGH 30  NB=0, CANCEL FURTHER STATES)
C
      NB=-1
      NU=NF-(NF/2)*2
      NI=QCS+NU
      IF(BMSEQS)THEN                                    !SIZE CHECK ONLY
        DD=DONE
        IAXDC=-ABS(IAXDC)                   !.LT.0 TO SKIP DC SIZE CHECK
      ELSE
        DD=-DZERO
c        IAXDC=MAXDC
C
        ALLOCATE (DU(MAXDF,MAXDF),STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'VCU: ALLOCATION FAILS FOR DU'
          NF=0
          GO TO 999                                              !RETURN
        ENDIF
C
      ENDIF
C
C RE-ENTRY POINT
C
  30  L=JA-1
      IF(N2.LT.N1)GO TO 39
C
      DO 33 J=JA,JB
C
        ML=QBML(J)
        IF(ABS(ML).GT.QCL)GO TO 33
C
        I=L+1
        IF(NB.EQ.0)THEN
          MTGD=MTGD+N1-N2-1                 !can only decrease
          MS=QBMS(J)
          IF(ML+MS.NE.NU)GO TO 33
          IF(MTGD.LE.IAXDC)THEN             !case iaxdc.lt.0
            DO K=N1,N2
              JD=JTGD(K)
              DC(JD+I)=DC(JD+J)
            ENDDO
          ENDIF
          GO TO 36
        ENDIF
C
        MS=QBMS(J)+NF+NF+1
        IF(ABS(MS).GT.QCS)GO TO 33
C
        IF(BMGE3)THEN
          IF(MS.NE.QCS)GO TO 33
          IF(ML.GT.QCL)GO TO 33
          IF(ML.LT.QCL-KG)GO TO 33
          GO TO 36
        ENDIF
C
C MOD=0 (NOW NEED ALL MS,ML FOR SUB-SHELL RE-COUPLING)
        IF(MODD.EQ.0)GO TO 36
C MOD<0
        IF(MODD.LT.0.AND.ML+MS.LT.0)GO TO 33
C MOD>0
        IF(MODD.GT.0)THEN
          IF(MODD.EQ.1)THEN
            IF(ML.GT.NI)GO TO 33
            IF(ML+MS.LT.0)GO TO 33
          ELSE
            IF(ML.NE.0)GO TO 33
            IF(MS.NE.NU)GO TO 33
            GO TO 36
          ENDIF
        ENDIF
C
        DO K=N1,N2
CWE MOD=0
CWE          IF(MODD.EQ.0)THEN
CWE            IF(KCUT.EQ.0)GO TO 36!APPLY TO CORR ONLY? ->IF(.NOT.BCUT)
CWE            IF(MS.GT.QTGS(K)+2)GO TO 19
CWE            IF(MS.GE.-1)GO TO 36
COLFS   IF(MS+ML.GE.-1)GO TO 36
CWE            GO TO 33
CWE          ENDIF
C
          IF(ABS(MS).GT.QTGS(K))GO TO 19
          IF(ABS(ML).GT.QTGL(K))GO TO 19
C     IF(MODD.GE.-1)GO TO 36
          IF(MODD.GE.-1)THEN                       ! OR ABS(MODD)=1 NOW
            IF(NAST.NE.0.AND.MODD.EQ.-1)THEN
              MDF=QTGS(K)-QTGL(K)
              IF(MS+ML.LT.ABS(MDF))GO TO 19
            ENDIF
            GO TO 36
          ENDIF
          IF(MS*ML.LT.0)GO TO 33
          IF(NAST.NE.0.AND.MODD.EQ.-2)THEN
C            IF(MS.LT.QDS)GO TO 33
C            IF(ML.LT.QDL)GO TO 33
            IF(MS.LT.QTGS(K))GO TO 19
            IF(ML.LT.QTGL(K))GO TO 19
          ENDIF
          GO TO 36
C
  19    ENDDO
C
        GO TO 33
C
  36    L=I
        QBML(L)=ML
        QBMS(L)=MS
        DO I=1,NF
          QLML(I,L)=QLML(I,J)
          QLMS(I,L)=QLMS(I,J)
        ENDDO
C
  33  CONTINUE
C
      LJA1=L-JA+1
C
      MTGDMX=LJA1*(N2-N1+1)+MTGD
C
      IF(IAXDC.GT.0.AND.MTGDMX.GT.0)THEN    !mtgdmx.le.0 -> I*4 overflow
C
        IF(MTGDMX.GT.IAXDC)THEN
C
          IXXX=7*(IAXDC/5+1)
          IXXX=MAX(IXXX,MTGDMX)
C
          WRITE(6,*)'*** VCU: increasing MAXDC from ',IAXDC,' to: '
     X              ,IXXX
          WRITE(0,*)'*** VCU: increasing MAXDC from ',IAXDC,' to: '
     X              ,IXXX
C                               !MTGD???
          CALL RE_ALLOC(DC,IZERO,IAXDC,IXXX,IERR)
C
          IF(IERR.NE.0)THEN
            WRITE(0,*)'VCU: REALLOCATION FAILS FOR DC'
            NF=0
            GO TO 999
          ENDIF
C
          IF(DC(0).GT.DZERO)THEN
C
            CALL RE_ALLOC(IDC,IONE,MTGD0,IXXX,IERR) !ONLY MTGD0 SO FAR
C
            IF(IERR.NE.0)THEN
              WRITE(0,*)'VCU: REALLOCATION FAILS FOR IDC'
              NF=0
              GO TO 999
            ENDIF
C
          ENDIF
C
          IAXDC=IXXX
C
        ENDIF
C
        DO K=N1,N2
          MTGD=LJA1+MTGD
          JD=MTGD-L
          DO J=JA,L
            IF(NB.EQ.0)THEN
              I=JTGD(K)
              DD=DC(J+I)
            ENDIF
            DC(J+JD)=DD
          ENDDO
          JTGD(K)=JD
        ENDDO
C
      ELSE                         !FOR DIMENSION CHECK
C
        DO K=N1,N2
          JTGD(K)=JD
        ENDDO
C
        MTGD=MTGDMX
C
        IF(DC(0).NE.DZERO)THEN
          DO J=MTGD0+1,MTGD
            DC(J)=DZERO
          ENDDO
        ENDIF
C
      ENDIF
C
  39  JB=L
C
C NORMAL RETURN (NB=0) FOR MODD.EQ.1 (AFTER 2ND ENTRY, THROUGH 30);
C
      IF(NB.EQ.0)GO TO 999
C
C INCASES BMGE3=T OR KF.GT.KCUT: RETURN (NB=0) IF NO TERMS SL IN KF.
C
      IF(N2.LT.N1)GO TO 88
C
C AS PROBLEM TOO LARGE FOR VCC ARRAY DC(MAXDC).
C
      IF(MTGD.LE.0)THEN             !.le.0 -> I*4 overflow
        WRITE(0,*)'*** SR.VCU: TOO MANY VCCs FOR I*4'
        WRITE(6,*)'*** SR.VCU: TOO MANY VCCs FOR I*4',
     X            ', SET DEFAULT INTEGER SP=8 IN MODULE PRECSN'
        IF(KF.LE.KUTDSK)WRITE(6,*)'*** OR USE KUTDSK ***'
        NB=-1
        GO TO 999
      ENDIF
      IF(IAXDC.LT.0)THEN
        IAXDC=-IAXDC
      ELSEIF(MTGD.GT.IAXDC)THEN                     !SHOULD NOT BE SO...
        WRITE(0,*)'*** SR.VCU: RE-ALLOCATION ERROR...'
        WRITE(6,*)'*** SR.VCU: RE-ALLOCATION ERROR...'
        NF=-1
        GO TO 999
      ENDIF
C
C-----------------------------------------------------------------
C  VCE BY SIMULTANEOUSLY DIAGONALIZING  L**2 AND S**2  (IN SR VCE)
C-----------------------------------------------------------------
C
      IF(QCL0.LT.QCL)QCL0=QCL                              !GLOBAL MAX L
      IF(QCS0.LT.QCS)QCS0=QCS                              !GLOBAL MAX S
C
C     NO VCC'S WILL BE COMPUTED IN 'DIMENSION CHECK ONLY'
C
      IF(BMSEQS)GO TO 88                       !SO RETURN
C
      ML=QCL
      IF(MODD.GT.1)QCL=0
C
  85  MS=QCS
C
  86  NB=0
C
      DO J=JA,JB
        IF(QBML(J).EQ.ML.AND.QBMS(J).EQ.MS)THEN
          NB=NB+1
          IF(NB.LE.MAXDF)NO(NB)=J
        ENDIF
      ENDDO
C
C BUFFER ARRAYS DU,DL,DS,NO (DA,DV) TOO SMALL (NB.GT.0); AUGMENT MAXDF
C
      IF(NB.GT.MAXDF)GO TO 999
C
      IF(NB.EQ.0)GO TO 89
C
      CALL DIMUSE('MAXDF',NB)
C
C THIS CALL CAN BE REPLACED BY THE WHOLE BODY OF SR VCE.
C
      NB0=NB
C
c     call cpu_time(timei)
c
      CALL VCE(QLML,QLMS,QBML,QBMS,DU,DL,DS,NO,MAXEL)
C
      IF(NF.LE.0)GO TO 999
c
c     call cpu_time(timef)
c     write(71,*)'vce',nb,ml,ms,timef-timei
c     timev=timev+timef-timei
C
      IF(NB.EQ.0)THEN                                  !VCE DIAG FAILURE
        NB=NB0
        GO TO 999
      ENDIF
C
      DO 81 L=1,NB
C
        DO J=N1,N2
          NRJ=JTGD(J)
          QL0=QTGL(J)
          QS0=QTGS(J)
C
C IDENTIFY L'TH TERM, RESULTING FROM DIAGONALIZING S*(S+1) AND
C L*(L+1) FOR (MS,ML)/2, WITH ONE OF THE TERMS J=N1,N2
C
          IF(((QS0+2)*QS0-DS(L))**2
     X      +((QL0+2)*QL0-DL(L))**2.GT.NB*STOL*DPT1)GO TO 82
C
C AND CROSS OUT THE EXHAUSTED TERM
C
          QTGS(J)=QS0+1
C
C SET UP VCC (EIGENV OF DIAGON.) IN APPROPRIATE LOCATION OF DC:
C
          DO I=1,NB
            JD=NO(I)+NRJ
            DC(JD)=DU(I,L)
          ENDDO
C
C ESTABLISH PROPER PHASES WITH PREVIOUS (MS,ML); FOR DEGENERATE SL,
C DO SO AFTER THE LAST TERM, QTGD=1, HAS BEEN FOUND.(NEW USE FOR BMSEQS)
C
          BMSEQS=QTGD(J).LT.0
          QTGD(J)=ABS(QTGD(J))
          IF(BMSEQS.OR.QTGD(J).GT.1)GO TO 81
C
C NOTE HOW THE (IF-)LOOPS FOR MS AND ML ARE NESTED: STEP DOWN S
C WITHIN EACH ML=CONST COMPLEX, AND APPLY L- ONLY IF MS=S
C
          BMSEQS=MS.EQ.QS0
          N4=J
          N3=N4
          GO TO 91
  82    ENDDO
C
        GO TO 81
C
C ONLY IN CASE BMGE3=T OR KF.GT.KCUT; SEE COMPLETENESS CHECK IN DO84
C
  91    IF(N3.GT.N1)THEN              !FOR STUPID COMPILERS
          IF(QTGD(N3-1).GT.1)THEN     !BREAK INTO TWO
            N3=N3-1
            GO TO 91
          ENDIF
        ENDIF
C
        IF(BMSEQS)THEN
          DI=(QL0+ML+2)*(QL0-ML)
        ELSE
          DI=(QS0+MS+2)*(QS0-MS)
        ENDIF
C
        DO 92 I=1,NB
          JD=NO(I)
          DD=DZERO
          DO J=N3,N4
            NI=JTGD(J)+JD
            DD=DC(NI)**2+DD
            DC(NI)=DZERO
          ENDDO
C
          IF(DD.LT.TTYNY)GO TO 92
C
          DO J=JA,JB
C
            K=0
            IF(BMSEQS)K=2
            IF(QBML(J)-K.NE.ML)GO TO 94
            IF(QBMS(J)+K-2.NE.MS)GO TO 94
C
            DD=DZERO
            DO K=N3,N4
              NI=JTGD(K)+J
              DD=DC(NI)**2+DD
            ENDDO
C
            IF(DD.LT.TTYNY)GO TO 94
C
            KG=0
            KP=0
C
            DO NI=1,NF
              KP=KP+NI
              DO K=1,NF
                IF(QLML(K,J).EQ.QLML(NI,JD))THEN
C                IF(QLMS(K,J).NE.QLMS(NI,JD) .OR. QCGS(K).NE.QCGS(NI))
                  IF(QCGS(K)*QLMS(K,J).EQ.QCGS(NI)*QLMS(NI,JD))THEN
                    KP=KP-K
                    GO TO 97
                  ENDIF
                ENDIF
              ENDDO
              IF(KG.NE.0)GO TO 94
              KG=NI
  97        ENDDO
C
C SLATER STATES J AND JD DIFFER IN ONE INDIVIDUAL SET, IN POSITION
C KP AND KG; ENSURE THAT THE PAIR DOES NOT DIFFER IN NL:
C
            NI=QCGS(KP)
            IF(QCGS(KG).EQ.NI)THEN
              IF(BMSEQS)THEN
                DD=(QL(NI)+QLML(KP,J))*(QL(NI)-QLML(KG,JD))
              ELSE
                DD=(1+QLMS(KP,J))*2
              ENDIF
              ISGN=1-2*mod(abs(KG+KP),ITWO)           !(-1)**(KG+KP)
              DD=ISGN*SQRT(DD/DI)
              DO K=N3,N4
                NI=JTGD(K)+JD
                DC(NI)=DD*DC(NI+J-JD)+DC(NI)
              ENDDO
            ENDIF
  94      ENDDO
C
C SIGN ONLY NEEDS TO BE ESTABLISHED IF L'TH TERM SL NOT DEGENERATE
C
          IF(N4.EQ.N3)THEN
            IF(ABS(DC(NRJ+JD)).GT.TYNY)GO TO 90
          ENDIF
C
  92    CONTINUE
C
        GO TO 81
  90    DD=DC(NRJ+JD)/DU(I,L)
C
C VCC MAYBE TOO INACCURATE
C
        IF(ABS(ABS(DD)-DONE).GT.STOL)  THEN
          WRITE(6,*)"SR.VCU: ARE VCC'S ACCURATE ENOUGH? "
          WRITE(6,*)DC(NRJ+JD),DU(I,L),ABS(DD)-DONE
          IF(ABS(ABS(DD)-DONE).GT.100*STOL)THEN
            IF(IDIAG.EQ.0)THEN
              WRITE(6,1001)KF
              IDIAG=-1
              GO TO 52
            ENDIF
            GO TO 999
          ENDIF
        ENDIF
C
        IF(DD.LT.DZERO)THEN
          DO I=1,NB
            JD=NO(I)+NRJ
            DC(JD)=-DU(I,L)
          ENDDO
        ENDIF
C
  81  CONTINUE
C
C
C RESTORE 2*S-ARRAY, WHICH HAS BEEN USED FOR MARKING:
C
      DO J=N1,N2
        IF((QTGS(J)/2)*2.EQ.QTGS(J)-NU)THEN
          IF(QTGL(J).LT.ABS(ML))GO TO 84
          IF(QTGS(J).LT.ABS(MS))GO TO 84
C
          IF(IDIAG.EQ.0)THEN
            WRITE(6,1001)KF
C            IDIAG=-1
C            GO TO 52
          ENDIF
          IF(IDIAG.NE.0)WRITE(6,1000)
          WRITE(6,1002)  J, MS,ML,NB, (DS(I),DL(I),I=1,NB)
          GO TO 999
        ELSE
          QTGS(J)=QTGS(J)-1
        ENDIF
  84  ENDDO
C
  89  IF(BMGE3)GO TO 87                     !NORMAL RETURN FOR MODD.GE.3
C
      MS=MS-2
      IF(MS+QCS.GE.0)GO TO 86
C
  87  ML=ML-2
      IF(ML+QCL.GE.0)GO TO 85
C
  88  NB=0
C
C CANCEL AUXILIARY SLATER STATES AND COEFFICIENTS BEFORE RETURNING;
C
      IF(MODD.EQ.1)GO TO 30
C
 999  CONTINUE
C
      IDIAG=IDIAG0
C
C
      IF(ALLOCATED(DU))THEN
        DEALLOCATE (DU,STAT=IERR)
        IF(IERR.NE.0)THEN
          WRITE(0,*)'VCU: DE-ALLOCATION FAILS FOR DU'
          NF=0
        ENDIF
      ENDIF
C
c
c     write(71,*)'vce total',timev
c     call flush(71)
c     timev=0.d0
C
      RETURN                  !NORMAL RETURN FOR MODD.NE.1 (SINGLE PASS)
C
C-----------------------------------------------------------------------
C
C  KF.GT.KCUT(.GT.0):  ONLY THOSE TERMS RETAINED THAT SERVE AS
C           CORRELATION TERMS TO TERMS OF PREVIOUS CONFIGURATIONS KF.
C
C  MODD.EQ.0:
C      ALL VCC FOR ALL COMPLETE TERMS I OF CONFIG C  STORED IN DC
CWE    PROVIDED KCUT=0 IS SPECIFIED (WHICH DEFAULTS TO KCUT.GE.KF)
CWE    OTHERWISE RESTRICTIONS ON MS APPLY: SEE LOOP DO33.
CWE    COLFS MAY HAVE TO BE OPENED FOR FS-COLLISION PROBLEMS.
CNRB***OLD RESTRICTIONS SUPPRESSED NOW THAT WE RE-COUPLE SUB-SHELLS
C
C  MODD.EQ.1:
C      ONLY VCC FOR SLATER-STATES WITH /ML=MS/=MIN OF ALL TERMS I OF C
C
C  MODD.EQ.2:
C      ONLY VCC FOR SLATER-STATES WITH ML=0,MS=MIN OF ALL TERMS I OF C
C
C  MODD.EQ.-1,-2
C      EQUIV TO +1,+2 FOR ML,MS.LT.0, BUT ALL -,-.GT.0 RETAINED
C
C  MODD.GE.3:
C      ONLY SLATER-STATES AND VCC WITH ML=L,MS=S OF TERM 2S=QCS0,2L=QCL0
C
C  MODD.LE.-3:
C      ANY ML=L-1 ALSO INCLUDED (KCUT IGNORED FOR ABS(MODD).GE.3)
C
C  NOTE: AT THE BEGINNING FOR ANY MODD STORAGE FOR ALL SLATER-STATES
C       REQUIRED, AND FOR MODD=1 SOME VCC BUFFER IN DC (SEE LOOP 33).
C
C  CODE OF UNSUCCESSFUL RETURNS (NB.NE.0):
C  NB.EQ.-5: TOO MANY CONFIGURATIONS  - NOT USED
C        -4: TOO MANY ELECTRONS; AFFECTS QLMS,QLML
C        -3: TOO MANY SLATER STATES; "  " AND QBMS,QBML
C        -2: TOO MANY TERMS; AFFECTS QTGS,QTGL,QTGD,JTGD
C        -1: TOO MANY VCC; AFFECTS DC(MAXDC)
C    .GT. MAXDF: BUFFER ARRAYS DA,DU,DV,DL,DS,NO TOO SMALL
C    .GT. 0: NUMERICAL TROUBLE-ACCURACY.
C
C-----------------------------------------------------------------------
C
 1000 FORMAT(//' VCE FAILS -- EIGENVALUES INACCURATE-CHECK FOR ENOUGH'
     X,' SWEEPS IN JACORD')
c 1001 FORMAT(//' HOUSEHOLDER-QL METHOD FAILS FOR SIMULTANEOUS',
c     X' DIAGONALIZATION OF S**2 AND L**2 MATRICES'/' TRY THE (SLOWER)'
c     X,' JACOBI METHOD INSTEAD: ***SET IDIAG=1*** IN NAMELIST SALGEB')
 1001 FORMAT(//' NOTE: HOUSEHOLDER-QL METHOD FAILS FOR SIMULTANEOUS',
     X' DIAGONALIZATION OF S**2 AND L**2 MATRICES'/' TRYING THE'
     X,' (SLOWER) JACOBI METHOD INSTEAD FOR THIS CF=',I3,' ONLY.')
 1002 FORMAT(/4I5,10F10.5/(20X,10F10.5))
C
      END SUBROUTINE VCU
C
C     ******************************************************************
C
      SUBROUTINE VERTS(V,LV,N,W,IERR)
C
C      ________________________________________________________
C     |                                                        |
C     |       INVERT A SYMMETRIC MATRIX WITHOUT PIVOTING       |
C     |                                                        |
C     |NRB: MODIFIED TO ALLOW INPUT/OUTPUT OF UNPACKED MATRIX V|
C     |                                                        |
C     |    INPUT:                                              |
C     |                                                        |
C     |        V     --ARRAY CONTAINING MATRIX                 |
C     |                (ONLY THE LOWER HALF NEED BE DEFINED)   |
C     |                                                        |
C     |        LV    --LEADING (ROW) DIMENSION OF ARRAY V      |
C     |                SET .LE. 0 IF V ALREADY PACKED          |
C     |                                                        |
C     |        N     --MATRIX DIMENSION                        |
C     |                                                        |
C     |        W     --WORK ARRAY WITH LENGTH AT LEAST N       |
C     |                                                        |
C     |    OUTPUT:                                             |
C     |                                                        |
C     |        V     --INVERSE (IN LOWER HALF ONLY)            |
C     |________________________________________________________|
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION V(*),W(*)
C
      IERR=0
C
      IF(LV.LE.0)GO TO 4       !ALREADY PACKED
C     ----------------
CNRB |*** PACK V ***|
C     ----------------
      NH=LV-N
      I=0
      M=0
      L=N
      NG=(N*(N+1))/2
2     IF(L.EQ.NG)GO TO 4
      K=L+1
      M=M+1
      L=L+N-M
      I=I+NH+M
      DO J=K,L
        V(J)=V(I+J)
      ENDDO
      GO TO 2
C
4     NH=N
      K=1
10    IF(NH.EQ.1)GO TO 40
C     --------------------------
C     |*** SAVE PIVOT ENTRY ***|
C     --------------------------
      S=V(K)
      K=K+NH
      NG=K
      NH=NH-1
      M=NH
      IF(S.EQ.DZERO)GO TO 50
      J=0
20    J=J-M
      M=M-1
      L=NG+M
      T=V(NG+J)/S
C     ---------------------------
C     |*** ELIMINATE BY ROWS ***|
C     ---------------------------
      DO I=NG,L
        V(I)=V(I)-T*V(I+J)
      ENDDO
      NG=L+1
      IF(M.GT.0)GO TO 20
      GO TO 10
40    IF(V(K).NE.DZERO)GO TO 60
      IERR=2
      RETURN
50    IERR=1
      RETURN

C     ------------------------------------------
C     |*** SOLVE FOR ROWS OF INVERSE MATRIX ***|
C     ------------------------------------------
60    NG=N+N
      DO M=1,N
        L=((NG-M)*(M-1))/2
        NH=L
        K=M
        DO I=M,N
          W(I)=DZERO
        ENDDO
        W(M)=DONE
80      IF(K.EQ.N)GO TO 100
        T=W(K)/V(K+L)
        J=L
        L=L+N-K
        K=K+1
        IF(T.EQ.DZERO)GO TO 80
        DO I=K,N
          W(I)=W(I)-T*V(I+J)
        ENDDO
        GO TO 80
C     -----------------------------------
C     |*** BACK SUBSTITUTION BY ROWS ***|
C     -----------------------------------
100     W(N)=W(N)/V(K+L)
110     IF(K.EQ.M)GO TO 130
        J=K
        K=K-1
        L=L+K-N
        T=W(K)
        DO I=J,N
          T=T-W(I)*V(I+L)
        ENDDO
        W(K)=T/V(K+L)
        GO TO 110
130     DO I=M,N
          V(I+NH)=W(I)
        ENDDO
      ENDDO
C
      IF(LV.LE.0)RETURN                !LEAVE PACKED
C
C     ------------------
CNRB  |*** UNPACK V ***|
C     ------------------
      NH=LV-N
      I=(N-1)*NH+(N*(N-1))/2
      M=N-1
      L=(N*(N+1))/2
      K=L
C
200   IF(I.EQ.0)RETURN
C
      DO J=L,K,-1
        V(I+J)=V(J)
      ENDDO
      I=I-NH-M
      L=K-1
      M=M-1
      K=K-N+M
      GO TO 200
C
      END SUBROUTINE VERTS
C
C                             *******************
C
      SUBROUTINE VFREE(YFREE,EFREE,NION,TPLASMA,Z,RION,MAXP,MKK)
C
C-----------------------------------------------------------------------
C
C  SR.VFREE EVALUATES A SELF-CONSISTENT FREE ELECTRON PLASMA POTENTIAL
C  FOR A FIXED BOUND STATE CONFIGURATION.
C
C  IT CALLS:
C    SR.VXC
C    SR.WXC
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (A1=+0.3480242D0)
      PARAMETER (A2=-0.0958798D0)
      PARAMETER (A3=+0.7478556D0)
      PARAMETER (PP=0.47047D0)
      PARAMETER (D1PT1=1.1D0)
C
      PARAMETER (EPS=D1M2)                           !CONVERGENCE FACTOR
      PARAMETER (PAR=D1P1)      !ASYMPTOTIC PARAMETER FOR ERROR FUNCTION
C
      ALLOCATABLE :: DENB(:),DENF(:),DENF1(:),YXC(:),EDP(:)
      ALLOCATABLE :: MEL(:)
C
      DIMENSION YFREE(*)                        !=VSC(MAXRS) IN /NRBDEN/
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
C
C ERROR FUNCTION
C
      ERF(XX)=DONE-(A1/(DONE+PP*XX)+A2/(DONE+PP*XX)**2+A3/(DONE+PP*XX)
     X        **3)*EXP(-XX**2)
C
      PI=ACOS(-DONE)
C
C NO. OF SELF-CONSISTENT ITERATIONS ALLOWED
C
      NITT=20
C
C USER INPUT OCCUPATION NOS
C
      NOCCM=MOD(NOCC,I1000)
      IF(NOCCM.NE.0)THEN
        NWF=ABS(NOCCM)
        GO TO 30
      ENDIF
C
C DETERMINE OCCUPATION NUMBERS
C
      ALLOCATE (MEL(MXORB))
C
      NWF0=MXORB
      DO J=1,NWF0
        TEL(J)=DZERO
        MEL(J)=0
        IF(DEY(J).NE.DZERO)NWF=J
      ENDDO
C
      MK=ABS(MKK)
C
      IF(MORT.LT.0.AND.BSTO.AND.MK.NE.0)THEN
C CHECK FOR COMMON CORE
        IF(IEQ(0).GT.0.AND.IRLX.LT.0)THEN                !NO COMMON CORE
          MA0=0
          MB0=0
        ELSE                                                !COMMON CORE
          MA0=MA
          MB0=MB
        ENDIF
        BCORE=IEQ(MK).GE.MA0.AND.IEQ(MK).LE.MB0            !IEQ UNNECESS
C DETERMINE OCCUPTN NUMBERS FOR CONFIGURATION SPECIFIED FOR THIS ORBITAL
        KAV=0
        IF(MCFMX.GT.0)THEN
          IF(MK.GT.MCFMX)THEN
            KS=MCFSTO(MCFMX)
          ELSE
            KS=MCFSTO(MK)
          ENDIF
          KF=KS
        ELSE
C USE CONFIGURATION AVERAGE
          KS=1
          KF=KMAX
          IF(IEQ(0).GE.0)THEN
            IF(KCUT.GT.0)KF=MIN(KCUT,KMAX)
            IF(MCFMX.GT.I1000)KF=MIN(MOD(MCFMX,I1000),KMAX) !SO NOT KCUT
            IF(mcfmx.lt.0)kf=min(-mcfmx,kmax)
          ENDIF
        ENDIF
C
        DO K=KS,KF
          IF(.NOT.BCORE.and.mcfmx.ge.0)THEN
C
C AVERAGE OVER ONLY THOSE CONFIGS THAT CONTAIN MK.
            DO I=1,NF
              IF(QCG(I,K).EQ.MK)GO TO 81
            ENDDO
            IF(MCFMX.LE.0)GO TO 83
            IF(IEQ(0).GT.0.AND.IEQ(MK).LE.MB)GO TO 81
            IF(IEQ(0).LT.0)GO TO 83
            WRITE(6,1010)MK,K
            WRITE(0,*)'*****ERROR IN SR.VFREE, ORBITAL NOT FOUND IN CF'
            GO TO 999
          ENDIF
C USE MCFMX.LT.0 TO AVERAGE OVER ALL CONFIGS
C
  81      KAV=KAV+1
C
C EQUAL WEIGHTING, COULD TRY ALTERNATIVE......
          DO L=1,NF
            I=QCG(L,K)
            IF(QN(I).GT.0.AND.QN(I).LT.90)MEL(I)=MEL(I)+1
          ENDDO
  83    ENDDO
C
        IF(MB.GT.0)THEN
          DO I=MA,MB
            MEL(I)=MEL(I)+2*(QL(I)+1)*KAV
          ENDDO
        ENDIF
        T1=KAV
C       WRITE(6,*) MK
        DO J=1,NWF
          T2=MEL(J)
          TEL(J)=T2/T1
C         WRITE(6,*)J,TEL(J)
        ENDDO
C
      ELSE
C
C CHOOSE FIRST SUITABLE BOUND (MKK.GE.0) OR CONTINUUM (MKK.LT.0) CONFIG.
C
        IF(MA*MB.GT.0)THEN
          DO I=MA,MB
            TEL(I)=2*(QL(I)+1)
          ENDDO
        ENDIF
C
        DO M=1,KMAX                                               !MAXCF
          I=QCG(NF,M)
          IF(MKK.GE.0.AND.QN(I).GE.0.AND.QN(I).LT.90)GO TO 9
          IF(MKK.LT.0.AND.(QN(I).LT.0.OR.QN(I).GE.90))GO TO 9
        ENDDO
C
   9    DO N=1,NF
          I=QCG(N,M)
          IF(QN(I).GT.0.AND.QN(I).LT.90)TEL(I)=TEL(I)+DONE
        ENDDO
C
      ENDIF
C
C RE-ENTRY POINT FOR USER SUPPLIED OCCUPATION NOS
C
  30  CONTINUE
C
C     RION=(0.2387*(Z-N)/DPLASMA)**0.3333
C
      MAXR=NION                      !LIMITED BY YFREE(MAXRS)
C
      DO I=1,MAXR
        IF(DX(I).GT.RION)GO TO 2
      ENDDO
      I=MAXR
C
      IF(RION.GT.D1PT1*DX(MAXR))THEN             !wiggle room
        WRITE(6,1000)RION,DX(MAXR)
        GO TO 999
      ENDIF
C
   2  NION=I
      IF(MAXP.GT.0)THEN
        NO=MIN(NION,MAXP)
      ELSE
        N0=NION
      ENDIF
C
C INITIALIZE ARRAYS
C
      ALLOCATE (DENB(NION),DENF(NION),DENF1(NION),YXC(NION),EDP(NION))
C
      DO I=1,NION
        DENB(I)=DZERO
        DENF(I)=DZERO
        DENF1(I)=DZERO
        YFREE(I)=DZERO
        YXC(I)=DZERO
        EDP(I)=DZERO
      ENDDO
C
C CALCULATE BOUND ELECTRON DENSITY
C
      WOCC=DZERO
      DO J=1,NWF
        IF(TEL(J).NE.DZERO)THEN
          WOCC=WOCC+TEL(J)
          C=TEL(J)/(DFOUR*PI)
          DO I=1,NO
            DENB(I)=DENB(I)+C*(DPNL(I,J)/DX(I))**2   !DX(I)**2 NOT DX(I)
          ENDDO
        ENDIF
      ENDDO
C
C CALCULATE UNIFORM FREE ELECTRON DENSITY
C
      DO I=1,NION
        DENF(I)=(Z-WOCC)/((DFOUR/DTHREE)*PI*RION**3)
      ENDDO
C
C BEGIN SELF-CONSISTENT LOOP
C
      DO ITT=1,NITT
C
C CALCULATE TOTAL POTENTIAL AND THEN FREE ELECTRON DENSITY
C
        DO K=1,NION
C
C CALCULATE ELECTROSTATIC POTENTIAL
C
          V1=(DX(1)/DTWO)*((DENF(1)+DENB(1))*DX(1)**2)/DX(K)
          IF(K.GE.2)THEN
            DO J=2,K
              V1=V1+((DX(J)-DX(J-1))/DTWO)*((DENF(J)+DENB(J))*DX(J)**2
     X             +(DENF(J-1)+DENB(J-1))*DX(J-1)**2)/DX(K)
            ENDDO
          ENDIF
          V2=DZERO
          DO J=K+1,NION
            V2=V2+((DX(J)-DX(J-1))/DTWO)*((DENF(J)+DENB(J))*DX(J)
     X           +(DENF(J-1)+DENB(J-1))*DX(J-1))
          ENDDO
C
C CALCULATE EXCHANGE-CORRELATION POTENTIAL
C         WITH SELF-INTERACTION CORRECTION
C
          DENT=DENB(K)+DENF(K)
          CALL VXC(DENT,TPLASMA,UXCT)
C
          DENT=DENB(K)
          CALL VXC(DENT,TPLASMA,UXCB)
C
          VTOT=DFOUR*PI*(V1+V2)+UXCT-UXCB-Z/DX(K)
C
C CALCULATE FREE ELECTRON DENSITY FOR NEW POTENTIAL
C
          WA=-VTOT/TPLASMA
          IF(WA.LE.DZERO)THEN
            DENF1(K)=EXP(WA)
          ELSEIF(WA.GT.DZERO.AND.WA.LE.PAR)THEN
            DENF1(K)=EXP(WA)*(DONE-ERF(SQRT(WA)))+DTWO/SQRT(PI/WA)
          ELSEIF(WA.GT.PAR)THEN
            DENF1(K)=DTWO*SQRT(WA/PI)+DONE/SQRT(PI*WA)
          ENDIF
C
          IF(K.EQ.1)THEN
            ANF=(DX(K)/DTWO)*DFOUR*PI*(DENF1(K)*DX(K)**2)
          ELSE
            ANF=ANF+((DX(K)-DX(K-1))/DTWO)*DFOUR*PI*(DENF1(K)*DX(K)**2
     X         +DENF1(K-1)*DX(K-1)**2)
          ENDIF
C
        ENDDO
C
C NORMALIZE FREE ELECTRON DENSITY
C
        DO K=1,NION
          DENF1(K)=DENF1(K)*(Z-WOCC)/ANF
        ENDDO
C
C SELF-CONSISTENT CHECK
C
        TA=ABS(DENF(1)-DENF1(1))
        T=(DX(1)/DTWO)*DFOUR*PI*TA*DX(1)**2
        QU=INT(T)
        DO K=2,NION
          TA=ABS(DENF(K)-DENF1(K))
          TB=ABS(DENF(K-1)-DENF1(K-1))
          T=((DX(K)-DX(K-1))/DTWO)*DFOUR*PI*(TA*DX(K)**2+TB*DX(K-1)**2)
          QU=QU+INT(T)
        ENDDO
C
        IF(QU.LE.EPS*(Z-WOCC))GO TO 101
C
        DO  K=1,NION
          DENF(K)=DENF1(K)
        ENDDO
      ENDDO
C
      WRITE(6,*)'CONVERGENCE FAILURE IN VFREE'
      WRITE(0,*)'CONVERGENCE FAILURE IN VFREE'
      GO TO 999
C
C END SELF-CONSISTENT LOOP
C
 101  CONTINUE
C
C FINAL CALCULATION FOR FREE ELECTRON POTENTIAL
C
      DO K=1,NION
C
        V1=(DX(1)/DTWO)*(DENF1(1)*DX(1)**2)/DX(K)
        IF(K.GE.2)THEN
          DO J=2,K
            V1=V1+((DX(J)-DX(J-1))/DTWO)*(DENF1(J)*DX(J)**2
     X        +DENF1(J-1)*DX(J-1)**2)/DX(K)
          ENDDO
        ENDIF
        V2=DZERO
        DO J=K+1,NION
          V2=V2+((DX(J)-DX(J-1))/DTWO)*(DENF1(J)*DX(J)
     X      +DENF1(J-1)*DX(J-1))
        ENDDO
C
        DENT=DENF1(K)
        CALL VXC(DENT,TPLASMA,UXC)
C
        YXC(K)=UXC
        YFREE(K)=DFOUR*PI*(V1+V2)+UXC
C
        DENT=DENB(K)+DENF1(K)
        CALL WXC(DENT,TPLASMA,FXCT)
C
        DENT=DENB(K)
        CALL WXC(DENT,TPLASMA,FXCB)
C
        EDP(K)=DENB(K)*(YFREE(K)-YXC(K))+FXCT-FXCB
C
      ENDDO
C
C SCREENING CORRECTION TO BOUND ELECTRON ENERGY
C
      EFREE=(DX(1)/DTWO)*EDP(1)*DX(1)**2
      DO J=2,NION
        EFREE=EFREE+((DX(J)-DX(J-1))/DTWO)*(EDP(J)*DX(J)**2
     X       +EDP(J-1)*DX(J-1)**2)
      ENDDO
C
      EFREE=DFOUR*PI*EFREE
C
  900 CONTINUE
C
      IF(ALLOCATED(DENB))DEALLOCATE (DENB,DENF,DENF1,YXC,EDP)
      IF(ALLOCATED(MEL))DEALLOCATE (MEL)
C
      RETURN
C
  999 NF=-1
      GO TO 900
C
 1000 FORMAT(' ***SR.VFREE: RION=',1PD9.2,' EXCEEDS RADIAL MESH LIMIT'
     X,' DX(MAXRS)=',1PD9.2,' - PLASMA POTENTIAL TRUNCATED...')
 1010 FORMAT(' *****ERROR IN SR.VMPOT, ORBITAL',I4,' NOT FOUND IN'
     X,' CONFIGURATION',I4)
C
      END SUBROUTINE VFREE
C
C                             *******************
C
      FUNCTION VLAM(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.VLAM EVALUATES THE V-LAMDA INTEGRAL OF ORBIT-ORBIT INTERACTION, IT
C  IS NOT QUITE SAME AS V-LAMDA INTEGRAL OF SPIN-ORBIT, NO PARTIAL DIFF.
C
C  IT CALLS:
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      ALLOCATABLE :: D1(:),D2(:)
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      ALLOCATE (D1(MAXRS),D2(MAXRS),STAT=IERR)                    !MAXB1
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'VLAM: ALLOCATION FAILS FOR D1,D2'
        VLAM=DZERO
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=DPNL(I,K2)*DPNL(I,K4)
      ENDDO
      M=QL(K2)/2+QL(K4)/2+2
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DEL=DE2-DE4                                   ! A.U.
        DZ=NZION
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
C            DD2=DONE+T*(DE2+POT(I,1))
C            DD4=DONE+T*(DE4+POT(I,1))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k2)*rnorm(k4)
          DO I=1,MAXRS
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c            dd2=done+t*(de2+dz/dx(i))
c            dd4=done+t*(de4+dz/dx(i))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
        CALL YLAMKR(LAM,M,DEL,D1,D2,DD1,DD2,MNH,DHNS,MJH,-ITHREE)
      ELSE
        CALL YLAMK(LAM,M,D1,D2,DD1,DD2,MNH,DHNS,MJH,-ITHREE)
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=D2(I)*DPNL(I,K1)*DPNL(I,K3)
      ENDDO
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DEL=DE1-DE3                                   ! A.U.
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
C            DD1=DONE+T*(DE1+POT(I,1))
C            DD3=DONE+T*(DE3+POT(I,1))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k1)*rnorm(k3)
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,D1,TT,MNH,DHNS,MJH,MAXRS)
C
      VLAM=DALF*TT/DFOUR
C
      DEALLOCATE (D1,D2,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'VLAM: DEALLOCATION FAILS FOR D1,D2'
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
C     WRITE(6,100) K1, K2, K3, K4, 2*LAM, VLAM
C100  FORMAT(8X,2(I5,I4),I6,F14.7,' =VLAM')
C
      RETURN
C
      END FUNCTION VLAM
C
C                             *******************
C
      SUBROUTINE VLAM0(M0,K1,K2,K3,K4,K,DK)
C
C-----------------------------------------------------------------------
C
C  SR.VLAM0 EVALUATES THE V-INTEGRALS OF THE SPIN-ORBIT INTERACTION.
C
C  IT CALLS:
C    SR.DIFF
C    SR.WEDDLE
C    SR.YLAMKR
C    SR.YLAMK
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      DZ=NZION
      DD=DONE
      D00=DZERO
      INUKP=INUK+1
C
      DO I=1,MAXRS
        DPA(I)=DPNL(I,K3)/DX(I)
      ENDDO
C
      CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
      DO I=1,MAXRS
        DPA(I)=DPNL(I,K1)*DP(I)*DX(I)
      ENDDO
C
      I=(QL(K1)+QL(K3))/2+1
      IF(QL(K3).EQ.0)  I=I+1
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DEL=DE1-DE3                                   ! A.U.
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=INUKP,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
C            DD1=DONE+T*(DE1+POT(I,1))
C            DD3=DONE+T*(DE3+POT(I,1))
            D13=DD1*DD3
            d13=abs(d13)
            DPA(I)=DPA(I)/SQRT(D13)
          ENDDO
        ELSE
          DO I=INUKP,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            D13=DD1*DD3
            d13=abs(d13)
            DPA(I)=DPA(I)/SQRT(D13)
          ENDDO
          dd=dd*rnorm(k1)*rnorm(k3)
        ENDIF
        DO I=1,INUK
          DD1=DONE+T*(DE1+DNUK0(I))
          DD3=DONE+T*(DE3+DNUK0(I))
          DPA(I)=DPA(I)/SQRT(DD1*DD3)
        ENDDO
        CALL YLAMKR(K,I,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,M0)
      ELSE
        CALL YLAMK(K,I,DPA,DP,DD1,DD2,MNH,DHNS,MJH,M0)
      ENDIF
C
      DO I=1,MAXRS
        DP(I)=DPNL(I,K2)*DPNL(I,K4)*DP(I)*DX(I)
      ENDDO
C
      IF(BREL)THEN                       !SMALL R CORRECTION
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DEL=DE2-DE4                                   ! A.U.
        T=DALF4*DTWO
        IF(BREL2)THEN
          DO I=INUKP,MAXRS
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
C            DD2=DONE+T*(DE2+POT(I,1))
C            DD4=DONE+T*(DE4+POT(I,1))
            D24=DD2*DD4
            d24=abs(d24)
            DP(I)=DP(I)/SQRT(D24)
          ENDDO
        ELSE
          DO I=INUKP,MAXRS
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
c            dd2=done+t*(de2+dz/dx(i))
c            dd4=done+t*(de4+dz/dx(i))
            D24=DD2*DD4
            d24=abs(d24)
            DP(I)=DP(I)/SQRT(D24)
          ENDDO
          dd=dd*rnorm(k2)*rnorm(k4)
        ENDIF
        DO I=1,INUK
          DD2=DONE+T*(DE2+DNUK0(I))
          DD4=DONE+T*(DE4+DNUK0(I))
          DP(I)=DP(I)/SQRT(DD2*DD4)
        ENDDO
      ENDIF
C
      CALL WEDDLE(D00,DP,DKU,MNH,DHNS,MJH,MAXRS)
C
      DK=DKU*DD*DALF4
C
      RETURN
C
      END SUBROUTINE VLAM0
C
C                             *******************
C
      SUBROUTINE VMPOT(ZN,L,MAXRS,DX,DZ,MAXPS,MPP,MK,MXORB)
C
C-----------------------------------------------------------------------
C
C  SR.VMPOT EVALUATES A MODEL POTENTIAL
C
C  POLARIZATION: NORCROSS OR BAYLISS FORM
C  OR
C  DENSE PLASMA POTENTAL: DEBYE-HUCKEL, ION-SPHERE OR SELF-CONSISTENT
C                         FREE-ELECTRON.
C
C  IT CALLS:
C    SR.STORAD
C    SR.VFREE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D5M2=5.0D-2)
      PARAMETER (DCON1=0.23873D0)                       !1/(4*pi/3)
C
      DIMENSION DX(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /COM1/DPOT(MAXB1),TOL,MEND
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      DATA MK0/0/ !MOVE TO VSC MODULE AND INITIALIZE AT EVERY ALLOCATE
C
      IF(ZNP0.EQ.ZN.AND.MK0*MK.GT.0.AND.MDEN.LE.2)GO TO 900 !RETURN AS
C                                                    NO CHANGE TO VSC
      MK0=MK
C
      DO I=1,MAXRS
        VSC(I)=DZERO
      ENDDO
c
c Add C60 potential !!!
c
c      do i=1,maxrs
c        if(dx(i).gt.5.8.and.dx(i).lt.7.5)vsc(i)=vsc(i)+.604154/2
c      enddo
c      vsc(1)=d1m50                           !flag
C
      IF(L.LT.0)GO TO 900                    !RETURN
C
      ZNP0=ZN
C
      IF(IPOLFN.LE.0)GO TO 6
C
      LP=L+1
      IF(LP.GT.3)LP=3
cold      IF(ALFD(LP)*RCUT(LP).EQ.DZERO)GO TO 6
C
C ONE-BODY POLARIZATION POTENTIAL
C
      ZNP0=-99
      IPOLF1=MOD(IPOLFN,ITEN)
C
      IF(IPOLF1.EQ.1)THEN
C NORCROSS
        DO I=1,MAXRS
          VSC(I)=ALFD(LP)*(DONE-EXP(-(DX(I)/RCUT(LP))**6))/DX(I)**4
        ENDDO
      ELSEIF(IPOLF1.EQ.2)THEN
C BAYLISS
        DO I=1,MAXRS
          VSC(I)=ALFD(LP)*DX(I)*DX(I)/(DX(I)*DX(I)+RCUT(LP)*RCUT(LP))**3
        ENDDO
      ENDIF
C
C EVALUATE PLASMA SCREENING POTENTIAL:
C CAN NEGLECT PLASMA SCREENING POTENTIAL COMPARED TO NUCLEAR
C (TO WITHIN 100*TF%) FOR X.LT.XC1.
C PLASMA SCREENING COMPLETE FOR X.GT.XC2.
C
   6  IF(MDEN.LE.0)GO TO 900                 !RETURN
      IF(DENE.LE.DZERO)GO TO 900
C
      TF=D5M2
      MDEN10=MOD(MDEN,ITEN)
      IF(MDEN10.NE.1)GO TO 2
C
C DEBYE-HUCKEL
C
      IF(IPOLFN.GT.0)THEN
        WRITE(0,*)
     X  '*** ATTENTION: POLARIZATION POTENTIALS ARE BEING SCREENED BY '
     X ,' DEBYE-HUCKEL POTENTIAL'
        WRITE(6,*)
     X  '*** ATTENTION: POLARIZATION POTENTIALS ARE BEING SCREENED BY '
     X ,' DEBYE-HUCKEL POTENTIAL'
      ENDIF
C
c      write(0,*)mk,zn
      XC1=-LOG(DONE-TF)*DEBYE                       !-on +off
      XC2=-LOG(TF)*DEBYE                            !-on +off
c      write(0,*)xc1,xc2
C
C      IF(MDEN10.EQ.1)THEN
        IF(NPITER.GE.0)THEN
c          write(77,*)'mk,zn=',mk,zn
c          ifort=70+mk
          DO I=1,MAXRS
            T=DX(I)
cold            TZ=-ZN/T                             !LONG-RANGE ONLY
            T=-T/DEBYE
cold            VSC(I)=(VSC(I)+TZ)*(DONE-EXP(T))     !ADD TO TF/STO POTL
            VSC(I)=(VSC(I)-DPOT(I))*(DONE-EXP(T))    !INC. SHORT-RANGE
c
c            write(77,*)i,dx(i),t,tz*(done-exp(t))*dx(i)
c     x               ,-dpot(i)*(done-exp(t))*dx(i),dpot(i)*dx(i)
c            write(ifort,*)i,dx(i),vsc(i),vsc(i)*dx(i),dpot(i)*dx(i)
          ENDDO
c        ELSE               !use unperturbed radial orbital, pert H only
c          DO I=1,MAXRS
c            VSC(I)=DZERO
c          ENDDO
        ENDIF
        ZNP0=-98                             !CASE DPOT CHANGES
C      ENDIF
      GO TO 900                              !RETURN
C
C ION-SPHERE
C
   2  CONTINUE
C
      IF(IPOLFN.GT.0)THEN
        WRITE(0,*)
     X  '*** WARNING: POLARIZATION POTENTIALS ARE NOT NEUTRALIZED BY '
     X ,' ION-SPHERE POTENTIAL'
        WRITE(6,*)
     X  '*** WARNING: POLARIZATION POTENTIALS ARE NOT NEUTRALIZED BY '
     X ,' ION-SPHERE POTENTIAL'
      ENDIF
C                                            !DEFINE NEUTRALIZATION
      ZN1=ZN                                 !Z-N+1
COLD      IF(MK.GE.0)ZN1=ZN1-DONE            !Z-N
CUSER      ZN1=DENE/DENI
c      write(0,*)mk,zn,zn1
C
      R0=DCON1*ZN1/DENE                      !DCON1/DENI
      R0=R0**(DONE/DTHREE)
      XC1=(DTWO/DTHREE)*TF*R0
      XC2=R0
c      write(0,*)xc1,xc2
C
      IF(MDEN.NE.2)GO TO 4
      IF(DENE.LT.D1M20)GO TO 900             !RETURN
C
      TZ=-ZN1/(R0*DTWO)                      !UNIFORM
c
c      ifort=70 !+mk
c      write(ifort,*)'mk,zn1=',mk,zn1
c
      DO I=1,MAXRS
        T=DX(I)/R0
        IF(T.LT.DONE)THEN
          VSC(I)=VSC(I)+TZ*(DTHREE-T*T)
ct          VSC(I)=-DX(I)*DPOT(I)*(DTHREE-T*T)/(R0*DTWO)
        ELSE
          VSC(I)=VSC(I)-ZN1/DX(I)
ct          VSC(I)=-DPOT(I)
        ENDIF
c           write(ifort,*)i,dx(i),vsc(i),vsc(i)*dx(i),dpot(i)*dx(i)
      ENDDO
ct      ZNP0=-98                               !CASE DPOT CHANGES
      GO TO 900                              !RETURN
C
C SELF-CONSISTENT FREE ELECTRON POTENTIAL
C
   4  MP0=MP0+1
c     write(6,*)mpp,mp0,mk
C
C USE STORAD TO INITIALIZE PNL WITH STO'S AND SO DO NOT RETURN
C
      IF(MPP.EQ.1.AND.MP0.EQ.1.AND.MK.GE.0)
     X                                 CALL STORAD(ZN,MAXRS,MAXPS,MXORB)
C
c      r0=1.2*r0
      NION=MAXRS
      CALL VFREE(VSC,T,NION,TKAY,DZ,R0,MAXPS,MK)
C
      IF(NF.LE.0)GO TO 900                   !RETURN
C
      DO I=1,NION
        VSC(I)=-VSC(I)
c       write(6,*)i,dx(i),vsc(i)
      ENDDO
C
C      ZN1=ZN                                 !Z-N+1
C      IF(MK.GE.0)ZN1=ZN1-DONE                !Z-N
      ZN1=-DX(NION)*VSC(NION)                 !VFREE->Z-N
c      write(6,*)nion,r0,zn1,-DX(NION)*VSC(NION)
C
      NT=1
      DO I=NION+1,MAXRS
        VSC(I)=-ZN1/DX(I)
C
C TEST NEUTRALIZATION EFFECT (FOR VFREE ZN1=Z-N, I.E. MAP TO Z-N+1)
C
        IF(MK.GE.0)VSC(I)=VSC(I)-(DX(I)-R0)**NT/DX(I)**(NT+1)
C       VSC(I)=VSC(I)-(DONE-EXP(DONE-DX(I)/R0))/DX(I)
c       write(6,*)i,dx(i),vsc(i)
      ENDDO
c       write(6,*)maxrs,-dx(maxrs)*vsc(maxrs)
C
      IF(VSC(1).EQ.DZERO)VSC(1)=D1M50        !FLAG
C
 900  RETURN
C
      END SUBROUTINE VMPOT
C
C                             ******************
C
      SUBROUTINE VNUKE(DZ,MSTEP,DHNS0,MAXRS,DX,IFLG1,IFLG2)
C
C-----------------------------------------------------------------------
C
C  SR.VNUKE CALCULATES THE POTENTIAL DUE TO A FINITE NUCLEUS
C  FOR USE BY KAPPA-AVEGAGED RADIAL FUNCTIONS - THUS IT ALSO
C  CALCULATES THE FIRST AND SECOND DERIVATIVES AS WELL:
C  VIZ. DNUK0,DNUK1,DNUK2
C  THE EXPANSION COEFFICIENTS FOR THE FINITE NUCLEUS ARE ALSO SET
C
C  USER HAS SET:
C  INUKE=-1  - POINT NUCLEUS
C       = 0  - UNIFORM CHARGE DISTRIBUTION
C       = 1  - U6 DISTRIBUTION OF BOGDANOVICH & RANCOVA
C              LITHUANIAN J. PHYS. V42, 257 (2002).
C       = 2  - FERMI DISTRIBUTION (***NOT YET IMPLEMENTED***, GT 0 = U6)
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      PARAMETER (D2PT5=2.5D0)
C
c      PARAMETER (C1=2.2677D-5)             !GRASP
c      PARAMETER (C2=DZERO)                 !GRASP
      PARAMETER (C1=2.04D-5)
      PARAMETER (C2=1.40D-5)
      PARAMETER (C3=1.293D0)                !U6 TK0
      PARAMETER (C4=0.2D0)                  !SKIN
C
      DIMENSION DX(*)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /OUTP2/MPNCH,KUTCAS,KDUM,BPRINT
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      BPRNT0=BPRINT
      IF(BPRINT)BPRNT0=JPRINT.NE.-3
C
      IF(INUKE.LT.0)THEN                          !POINT, QUICK RETURN
        IF(BPRNT0.AND.BREL)WRITE(6,951)INUKE      !SKIP IF NON-REL
        INUK=0
        JZNM=0
        ZS0(0)=DZ
        RNUK=-DONE
        IFLG1=0
        IFLG2=0
        GO TO 1000
      ENDIF
C
C INITIALIZE
C
      IF(RNUK.LE.DZERO)THEN
        IF(ATM.LE.DZERO)ATM=D2PT5*DZ
        A=ATM**D1THRD
        RNUK=A*C1+C2
        IF(INUKE.GT.0)THEN
          IF(TK0.LE.DZERO)TK0=C3
          RNUK=RNUK*TK0
        ELSE
          TK0=DONE
        ENDIF
      ENDIF
C
      IF(SKIN.LT.DZERO)SKIN=C4*RNUK
      INUK0=MAX(ITWO,INUK0)
      IF(BPRNT0)THEN
        IF(INUKE.EQ.0)WRITE(6,952)INUKE,RNUK,ATM,SKIN
        IF(INUKE.GT.0)WRITE(6,953)INUKE,RNUK/ABS(TK0),ATM,TK0
      ENDIF
C
      T2=SKIN/2
      IFLG1=999999
      DO I=1,MAXRS
        IF(DX(I)-T2.LT.RNUK)IFLG1=I
        IF(DX(I).GT.RNUK)THEN
          INUK=I
c          write(0,*)inuk,dx(inuk-1),rnuk,dx(inuk)
          IF(INUK.GT.1)THEN
            IF(DX(I)-RNUK.GT.RNUK-DX(I-1))INUK=INUK-1
          ENDIF
          if(inuke.gt.0.and.inuk.lt.2)then
            mstep=mstep+1 !TBD watch for infinite loop if tfdapo doubles
            dhns0=dhns0/dtwo      !current allocation cannot handle this
            write(6,977)mstep
            if(dz.le.30)write(6,978)
            go to 1000
          endif
          RNUK=DX(INUK)
          GO TO 305
        ENDIF
      ENDDO
C
  305 IF(INUK.LT.INUK0)THEN
        INUK=0
        INUKP=1
        JZNM=0
        ZS0(0)=DZ
        RNUK=-DONE
        IFLG1=999999
      ELSE
C
c        write(0,*)'inuk=',inuk
        T0=DZ/RNUK
        INUKP=INUK+1
        IF(INUK.GT.MXNUK)THEN
          WRITE(6,976)INUK
          WRITE(0,*)'***SR.VNUKE: INCREASE MXNUK'
          GO TO 999
        ENDIF
C
        IF(INUKE.EQ.0)THEN            !UNIFORM
          DO I=1,INUK
            T=DX(I)/RNUK
            DNUK0(I)=DHALF*T0*(DTHREE-T*T)
            DNUK1(I)=-T0*T/RNUK
            DNUK2(I)=-T0/RNUK**2
c            write(6,*)i,dx(i),dnuk(i),dnuk1(i),dnuk2(i)
          ENDDO
          T1=DONE
          T3=DTHREE
        ELSE                          !U6
          IFLG1=999999
          T00=(T0*63)/32
          T8=8*RNUK**2
          DO I=1,INUK
            T=DX(I)/RNUK
            TT=T*T
            TTT=TT*TT
            DNUK0(I)=T00-T0*(42-(18-7*TT)*TTT)*TT/32
            DNUK1(I)=-T0*(21-(27-14*TT)*TTT)*DX(I)/T8
            DNUK2(I)=-T0*(21-(135-98*TT)*TTT)/T8
c            write(6,*)i,dx(i),dx(i)*dnuk(i),dnuk(i),dnuk1(i),dnuk2(i)
          ENDDO
          T1=21
          T1=T1/8
          T3=DTHREE*T1/DTWO
        ENDIF
C
C SET EXPANSION COEFFS (EVEN NORMALLY ZERO FOR FINITE)
C
        ZS0(0)=DZERO
        ZS0(1)=DHALF*T3*T0
        ZS0(2)=DZERO
        ZS0(3)=-DHALF*T1*T0/RNUK**2
        JZNM=3
C
      ENDIF
C
c      write(6,*)'inukp=',inukp
      IFLG2=0
      DO I=INUKP,MAXRS
        IF(DX(I)-T2.LT.RNUK)IFLG2=I
      ENDDO
C
C
 1000 RETURN
C
  999 NF=-1
      GO TO 1000
C
  951 FORMAT(/5X,'INUKE=',I2,': POINT NUCLEUS IN USE')
  952 FORMAT(/5X,'INUKE=',I2,': UNIFORM NUCLEAR CHARGE DISTRIBUTION '
     X,'WITH   R=',1PD10.3,'   AND   A= ',0PF5.1,' ,  BUT WITH SKIN='
     X,1PD10.3)
  953 FORMAT(/5X,'INUKE=',I2,': U6 NUCLEAR CHARGE DISTRIBUTION WITH'
     X,'   R=',1PE10.3,'   AND   A= ',0PF5.1,' ,  AND K0= ',0PF9.5)
  976 FORMAT(/'*** SR.VNUKE: INCREASE MXNUK TO AT LEAST:',I4)
C  977 FORMAT(/'*** SR.VNUKE: MESH AT ORIGIN TOO COARSE FOR FINITE ',
C    X'NUCLEUS, RECALCULATING WITH INITIAL STEP HALVED, I.E. MSTEP=',I2)
  977 FORMAT(/'*** SR.VNUKE: MESH AT ORIGIN TOO COARSE FOR FINITE ',
     X'NUCLEUS, RE-RUN WITH INITIAL STEP HALVED, I.E. SET MSTEP=',I2)
  978 FORMAT(15X,'ALTERNATIVELY, TRY A POINT NUCLEUS (INUKE=-1)...')
C
      END SUBROUTINE VNUKE
C
C                             *******************
C
      SUBROUTINE VNRKX(DP1,DP2,DQ1,DQ2,DE1,DE2,DPA,DP,DX,dnorm,DD)
C
C-----------------------------------------------------------------------
C
C  SR.VNYKX CALCULATES THE DEIE V & N "RK" FINE-STRUCTURE INTEGRAL
C
C  IT CALLS:
C    SR.WEDDLE
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DP1(*),DP2(*),DQ1(*),DQ2(*),DPA(*),DP(*),DX(*)
C
c      common /com1/dpot(maxb1),tol,mend
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
C
      BREL2=ABS(IREL).EQ.2
C
      DO I=1,MAXRS
        DPA(I)=DP1(I)*DP(I)*DP2(I)
      ENDDO
C
      IF(BREL)THEN
C        DEL=DE1-DE2                                   ! A.U.
        T=DALF4*DTWO
        DZ=NZION
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD2=DONE+T*(DE2+DZ/DX(I))
C            DD1=DONE+T*(DE1+DPOT(I))
C            DD2=DONE+T*(DE2+DPOT(I))
            DSQ=DD1*DD2
            DSQ=SQRT(DSQ)
            DPA(I)=DPA(I)/DSQ
          ENDDO
        ELSE
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQ1(I)/DP1(I)+DTWO*DZ/DX(I))
            if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
            DD2=DONE+DALF4*(DQ2(I)/DP2(I)+DTWO*DZ/DX(I))
            if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
            DSQ=DD1*DD2
            DSQ=SQRT(DSQ)
            DPA(I)=DPA(I)*dnorm/DSQ
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,DPA,DD,MNH,DHNS,MJH,MAXRS)
C
      DD=DD*DALF4
C
      RETURN
C
      END SUBROUTINE VNRKX
C
C                             *******************
C
      SUBROUTINE VNYKX(DP1,DP2,DQ1,DQ2,BINT,MI,ML,DE1,DE2,DPA,DP,DX
     X                ,dnorm)
C
C-----------------------------------------------------------------------
C
C  SR.VNYKX CALCULATES THE DEIE V & N "YK" FINE-STRUCTURE INTEGRAL
C
C  IT CALLS:
C    SR.DIFF
C    SR.YLAMKR
C    SR.YLAMK
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DP1(*),DP2(*),DQ1(*),DQ2(*),DPA(*),DP(*),DX(*)
C
c      common /com1/dpot(maxb1),tol,mend
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
C
      BREL2=ABS(IREL).EQ.2
C
      IF(BINT)MJ0=3                      !N
      IF(.NOT.BINT)MJ0=-3                !V
C
      IF(BINT)THEN
        DO I=1,MAXRS
          DPA(I)=DP2(I)*DP1(I)
        ENDDO
      ELSE
        DO I=1,MAXRS
          DPA(I)=DP2(I)/DX(I)
        ENDDO
C
        CALL DIFF(DPA,DP,MNH,DHNS,MJH)
C
        DO I=1,MAXRS
          DPA(I)=DP1(I)*DP(I)*DX(I)
        ENDDO
      ENDIF
C
      IF(BREL)THEN
        DEL=DE1-DE2                                   ! A.U.
        T=DALF4*DTWO
        DZ=NZION
        IF(BREL2)THEN
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD2=DONE+T*(DE2+DZ/DX(I))
C            DD1=DONE+T*(DE1+DPOT(I))
C            DD2=DONE+T*(DE2+DPOT(I))
            DSQ=DD1*DD2
            DSQ=SQRT(DSQ)
            DPA(I)=DPA(I)/DSQ
          ENDDO
        ELSE
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQ1(I)/DP1(I)+DTWO*DZ/DX(I))
            if(dd1.le.dzero)dd1=done+t*(de1+dz/dx(i))
            DD2=DONE+DALF4*(DQ2(I)/DP2(I)+DTWO*DZ/DX(I))
            if(dd2.le.dzero)dd2=done+t*(de2+dz/dx(i))
            DSQ=DD1*DD2
            DSQ=SQRT(DSQ)
            DPA(I)=DPA(I)*dnorm/DSQ
          ENDDO
        ENDIF
        CALL YLAMKR(MI,ML,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
      ELSE
        CALL YLAMK(MI,ML,DPA,DP,DD1,DD2,MNH,DHNS,MJH,MJ0)
      ENDIF
C
      IF(.NOT.BINT)THEN
        DO I=1,MAXRS
          DP(I)=DP(I)*DX(I)
        ENDDO
      ENDIF
C
      RETURN
C
      END SUBROUTINE VNYKX
C
C                             *******************
C
      SUBROUTINE VPNL(Z,MIONX,MKK,WK,AJUST0,MAXRS,MJH,MNH,DHNS,POT,DTOL
     X               ,MEND)
C
C-----------------------------------------------------------------------
C
C  SR.VPNL EVALUATES THE ELECTRON POTENTIAL GENERATED BY A FIXED
C  BOUND-STATE CONFIGURATION. E.G. FOR USE WITH GENERATION OF A
C  SELF-CONSISTENT RADIAL SOLUTION. USES NL SUB-SHELL RESOLUTION.
C  N.B. MIONX CAN IN PRINCIPLE BE N- (SR.RADIAL) OR N+1 (SR.RADCON).
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
      USE COMMON_MQVC,   ONLY: MODD,KCUT,NEL,KMAX
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXD01=14)
C
      PARAMETER (D0PT8=0.8D0)
      PARAMETER (D7999=7999.0D0)
      PARAMETER (DKEY=5999)
      PARAMETER (DFSC2=DFSC/DTWO)             !ALPHA/2
      PARAMETER (TOLW=1.D-3)   !TOLERANCE FOR MATCHING OCCUPATION NOS WK
      parameter (tolp0=5.d-2)      !defines end of wavefunction
      parameter (sigma=0.2d0)      !for exchange gaussian damping factor
C
      ALLOCATABLE :: MEL(:)
C
      DIMENSION MNH(*),DHNS(*),POT(*)
      DIMENSION DFS(MXDFS)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM6/DA(MAXB1)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBAL1/MSTAT(MAXCF),MXORB,NPRINT,MR,MA,MB,KSUBCF  !M*0
      COMMON /NRBDW/IDW,IGAP(MXD01),btop
      COMMON /NRBFR/DP(MAXB1)
      COMMON /NRBHF/MHF,MRAD,MSTEP,IXTRA,xmax
      COMMON /NRBORB/IEQ(0:MAXGR),IGRCF(MAXGR),ICFGP(MAXCF),IRLX
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      COMMON /NRBSTO/ALF(MAXGR),MC(MAXGR),TEL(MAXGR),MCFMX,NOCC
     X              ,MCFSTO(MAXGR),MEXPOT,NLSTOE,BFIX(MAXGR)
      COMMON /NRBVAL/FACT(MAXGR),IVAL(MAXGR),NNEW,NNOLD
     X              ,BJUMP,BJUMP2,BRAD
c      common /nrbinf/rinf2(maxgr)
C
      DFS(1)=1
      DFS(2)=1
      DO K=3,MXDFS,2
        DFS(K)=-DFS(K-2)
        DFS(K+1)=(K-1)*DFS(K-1)/32
      ENDDO
C
      BREL2=ABS(IREL).EQ.2
      MK=ABS(MKK)                          !MKK.LT.0 CURRENTLY NOT USED
      MS=MK
      IF(MK.GT.0)THEN
        IF(QN(MK).LT.0)MS=-MS
        IVALMK=IVAL(MK)
      ELSE
        IVALMK=0
      ENDIF
C
      ISWCH0=0
      DO I=1,MXORB
        IF(QN(I).LT.0.OR.IVAL(I).NE.0.OR.SCREEN(I).GE.D7999)ISWCH0=1
      ENDDO
      ISWCH=0
      IF(MK.GT.0)THEN
        IF(QN(MK).LT.0.OR.IVAL(MK).NE.0.OR.SCREEN(MK).GE.D7999)ISWCH=1
      ENDIF
C
      AJUST=AJUST0                           !(EXCHANGE) SCALING FACTOR
      IF(AJUST.EQ.DZERO)AJUST=DONE
      AJUST=D0PT8*AJUST                      !A LA COWAN
C
      MCFMXX=MCFMX
      IF(MCFMXX.GT.I1000)MCFMXX=0         !AVERAGE OVER MOD(MCFMX,I1000)
C
      IF(NOCC.LT.0)TOLX=10000
      IF(NOCC.GT.0)TOLX=10000
      if(nocc.eq.0)then
        if(mionx.ge.0)stop 'nocc=0 - inform nrb'      !shouldn't happen
      endif
C
      NOCCM=MOD(NOCC,I1000)
C
C USER INPUT OCCUPATION NOS
C
      IF(NOCCM.NE.0)THEN                                   !FOR CORE POT
        NCO=0
        IF(MA*MB.GT.0.AND.(MIONX.LT.0.OR.MK.EQ.0))THEN
          DO I=MA,MB
            NCO=NCO+NINT(TEL(I))
          ENDDO
        ENDIF
        MSHLL=ABS(NOCCM)
        TZ=ISWCH0-ISWCH
        GO TO 30
      ENDIF
C
C DETERMINE OCCUPATION NUMBERS FROM FLAGGED CONFIG(S)
C
      ALLOCATE (MEL(MXORB))
C
      DO J=1,MXORB
        TEL(J)=DZERO
        MEL(J)=0
      ENDDO
C
      MSHLL=0
      WK=0
      NZ=0
C
      IF(MK.NE.0.AND.MIONX.GT.0)THEN
C
C CHECK FOR COMMON CORE
        IF(IEQ(0).GT.0.AND.IRLX.LT.0)THEN                !NO COMMON CORE
          MA0=0
          MB0=0
        ELSE                                                !COMMON CORE
          MA0=MA
          MB0=MB
        ENDIF
        BCORE=IEQ(MK).GE.MA0.AND.IEQ(MK).LE.MB0            !IEQ UNNECESS
C
        KAV=0
        IF(MCFMXX.GT.0.AND.(IEQ(0).GE.0.OR.IEQ(0).LT.0.AND.BCORE))THEN
C
C DETERMINE OCCUPATION NUMBERS FOR CONFIG. SPECIFIED FOR THIS ORBITAL
C (N.B. MCFSTO(MK) NOT SPECIFIED FOR VALENCE, CASE IEQ(0).LT.0)
C
          IF(MK.GT.MCFMXX)THEN
            KS=MCFSTO(MCFMXX)
          ELSE
            KS=MCFSTO(MK)
          ENDIF
          KF=KS
          IF(KS.LE.0)THEN
            IF(BCORE)THEN                          !AVERAGE OVER ALL CFS
              KS=1
              KF=KMAX
            ELSE
              WRITE(6,1009)KS,MK
              WRITE(0,*)'SR.VPNL: CONFIGURATION NOT SET FOR ORBITAL'
              GO TO 999
            ENDIF
          ENDIF
          IF(KS.GT.KMAX)THEN
            DO J=1,MXORB
              NN=NEL(J,KS)
              IF(NN.NE.0)THEN
                TEL(J)=ABS(NN)
                MSHLL=J
              ENDIF
            ENDDO
            TZ=ISWCH0-ISWCH
            GO TO 30
          ENDIF
        ELSE
C
C USE CONFIGURATION AVERAGE
C
          KS=1
          KF=KMAX
          IF(IEQ(0).GE.0)THEN
            IF(KCUT.GT.0)KF=MIN(KCUT,KMAX)
            IF(MCFMX.GT.I1000)KF=MIN(MOD(MCFMX,I1000),KMAX)  !NOT KCUT
            IF(mcfmxx.lt.0)kf=min(-mcfmxx,kmax)
          ENDIF
        ENDIF
C
  89    bdw=idw.ne.0.and.qn(mk).lt.0
c           allow target average but an override for cont e.g. Laguerres
        if(bdw.and.mcfsto(mk).ne.0)then
          ks=mcfsto(mk)
          kf=ks
        endif
c
        DO K=KS,KF
          IF(.NOT.BCORE.and.mcfmxx.ge.0)THEN
C
C AVERAGE OVER ONLY THOSE CONFIGS THAT CONTAIN MK.
C
            DO I=1,NF
              IF(QCG(I,K).EQ.MK)THEN
                IF(IEQ(0).LT.0.AND.MCFSTO(MK).EQ.0)MCFSTO(MK)=K
                GO TO 81
              ENDIF
            ENDDO
            IF(MCFMXX.LE.0)then
              if(bdw)go to 81
              GO TO 83
            ENDIF
C
COLD        IF(IVAL(MK).GT.0.OR.SCREEN(MK).GT.DKEY)GO TO 81
            MF=QCG(NF,K)
            IF(SCREEN(MK).GT.DKEY.AND.(QN(MF).LT.0.OR.IVAL(MF).NE.0.OR.
     X         SCREEN(MF).GT.DKEY).or.bdw)GO TO 81
C
            IF(IEQ(0).GT.0.AND.IEQ(MK).LE.MB)GO TO 81
            IF(IEQ(0).LT.0)GO TO 83
C
            MS=0
            IF(MHF.GE.-100.OR.MK.NE.MCFMXX)THEN     !SHOULD BE CAUGHT...
              WRITE(6,1010)MK,K
              WRITE(0,*)'*****ERROR IN SR.VPNL: ORBITAL NOT FOUND IN CF'
              GO TO 999
            ENDIF
          ENDIF
C
C USE MCFMXX.LT.0 TO AVERAGE OVER ALL CONFIGS
C
  81      KAV=KAV+1
C
C EQUAL WEIGHTING, COULD TRY ALTERNATIVE......
C
C                                                          I1=1
          DO 85 I=1,MXORB                                 !L=1,NF
C            I=QCG(L,K)
            I1=NEL(I,K)
            IF(I1.LE.0)GO TO 85
            NZ=NZ+I1
            IF(IVAL(I).GT.0.AND.(QN(I).GE.ABS(QN(MK)).OR.QN(MK).LT.0))
     X                              GO TO 85
            if(DADJUS(i).lt.dzero.and.qn(mk).lt.0)go to 85      !for dw
            IF(SCREEN(I).GT.DKEY)GO TO 85
            IF(QN(I).LT.0)GO TO 85
            NZ=NZ-I1
            IF(I.GT.MSHLL)MSHLL=I
            MEL(I)=MEL(I)+I1
  85      ENDDO
          IF(MS.GT.MXORB.OR.MS.LT.0.OR.IVAL(MK).GT.0)NZ=NZ-1
  83    ENDDO
C
        IF(KAV.EQ.0)THEN
          IF(MCFMXX.EQ.0.AND.KF.LT.KMAX)THEN        !CORRELATION ORBITAL
            KF=KMAX                                     !NOT IN KCUT, SO
            GO TO 89
          ELSE
            WRITE(6,1011)MK,KF
            WRITE(0,*)'*****ERROR IN SR.VPNL: ORBITAL NOT FOUND IN CFS'
            GO TO 999
          ENDIF
        ENDIF
C
        IF(MB.GT.0)THEN
          DO I=MA,MB
            IF(I.GT.MSHLL)MSHLL=I
            MEL(I)=MEL(I)+2*(QL(I)+1)*KAV
          ENDDO
        ENDIF
C
        T1=KAV
        TZ=NZ
        TZ=TZ/T1
        NZ=NINT(TZ)
c        IF(ABS(TZ-NZ).GT.TOLW)THEN
c          WRITE(6,1001)TZ
c          WRITE(0,1001)TZ
c          GO TO 999
c        ENDIF
c           write(6,*)mk,ajust,zn
C
        DO J=1,MSHLL
          T2=MEL(J)
          TEL(J)=T2/T1
c           if(tel(j).ne.dzero)write(6,*)j,tel(j)
        ENDDO
C
      ELSE
C
C CHOOSE FIRST SUITABLE BOUND (MKK.GE.0) OR CONTINUUM (MKK.LT.0) CONFIG.
C
        NCO=0
        IF(MA*MB.GT.0)THEN
          DO I=MA,MB
            TEL(I)=2*(QL(I)+1)
            NCO=NCO+NINT(TEL(I))
            IF(I.GT.MSHLL)MSHLL=I
          ENDDO
        ENDIF
C
        IF(MIONX.GE.0.AND.MKK.NE.0)THEN
          DO M=1,KMAX
            I=QCG(NF,M)
            IF(MKK.GT.0.AND.QN(I).GE.0)THEN
              DO L=1,NF
                IF(QCG(L,M).EQ.MK)GO TO 9
              ENDDO
            ENDIF
            IF(MKK.LT.0)THEN                             !NOT USED
              IF(IVAL(I).GT.0.AND.QN(I).GE.ABS(QN(MK)))GO TO 9
              IF(SCREEN(I).GT.DKEY)GO TO 9
              IF(QN(I).LT.0)GO TO 9
            ENDIF
          ENDDO
          GO TO 30
C
   9      DO 86 N=1,NF
            I=QCG(N,M)
            IF(MKK.LT.0)THEN                             !NOT USED
              NZ=NZ+1
              IF(IVAL(I).GT.0.AND.QN(I).GE.ABS(QN(MK)))GO TO 86
              IF(SCREEN(I).GT.DKEY)GO TO 86
              IF(QN(I).LT.0)GO TO 86
              NZ=NZ-1
            ENDIF
            TEL(I)=TEL(I)+DONE
            IF(I.GT.MSHLL)MSHLL=I
  86      ENDDO
          IF(MKK.LT.0)THEN                             !NOT USED
            IF(MS.GT.MXORB.OR.MS.LT.0.OR.IVAL(MK).GT.0)NZ=NZ-1
          ENDIF
        ENDIF
C
        TZ=NZ
C
      ENDIF
C
C RE-ENTRY POINT FOR USER SUPPLIED OCCUPATION NOS
C
  30  CONTINUE
C
C SET EFFECTIVE OCCUPATION FOR THIS ORBITAL SUB-SHELL
C
      IF(MS.LT.0.OR.IVALMK.GT.0)THEN
        MS=0                                 !SELF-SCREENING NOT IN TEL
      ELSE
        MS=1
      ENDIF
      IF(MK.GT.0)WK=TEL(MK)+MS-1
C
C SET ASYMPTOTIC CHARGE
C
      IF(MIONX.GE.0)THEN
        ZN=MIONX-1-TZ
      ELSE
        ZN=NCO-TZ
      ENDIF
      ZN=Z-ZN
      ZN1=ZN
      IF(NINT(ZN1).EQ.0)ZN1=DONE
C
C INITIALIZE POT(I) WITH NUCLEAR POTENTIAL (ANY FINITE IS ADDED LATER)
C
      bporig=nocc.lt.0.or.mk.le.0.or.iswch.gt.0
c
      if(bporig)then
        DO I=1,MAXRS
          POT(I)=Z/DX(I)
        ENDDO
      else
        T=WK*Z
        IF(BREL2)THEN
          DO I=1,MAXRS
            POT(I)=T*(DPNL(I,MK)*DPNL(I,MK)+DQNL(I,MK)*DQNL(I,MK))/DX(I)
          ENDDO
        ELSE
          DO I=1,MAXRS
            POT(I)=T*DPNL(I,MK)*DPNL(I,MK)/DX(I)
          ENDDO
        ENDIF
      endif
C
      IF(MIONX.LT.0.AND.NCO.EQ.0)GO TO 900           !RETURN
C
C FORM CONFIGURATION AVERAGE POTENTIAL
C(STATIC ONLY IF FURNESS & MCCARTHY EXCHANGE)
C
      i1=0
c
      DO J=1,MSHLL
C
        BEQNL=J.EQ.MK.AND.MS.GT.0
C
        MJX=0
        C=TEL(J)
        IF(BEQNL)THEN
          C=C-DONE
          IF(MEXPOT.LE.0)MJX=MIN(INT(QL(J),SP),ISIX)
        ENDIF
C
        IF(ABS(C).GT.TOLW)THEN
C
C DIRECT
          IF(BREL2)THEN
            DO I=1,MAXRS
              DP(I)=DPNL(I,J)*DPNL(I,J)+DQNL(I,J)*DQNL(I,J)
            ENDDO
          ELSE
            DO I=1,MAXRS
              DP(I)=DPNL(I,J)*DPNL(I,J)
            ENDDO
          ENDIF
C
          MI=QL(J)+2
          F0=REAL((MI-1),WP)/REAL((2*MI-3),WP)
          F=DONE
C
          DO MJ=0,MJX,2
C
            CALL YLAMK(MJ,MI,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
C                                                            !NO RETARDN
            IF(MJ.GT.0)THEN
              DC1=
     X       VCC(INT(QL(J),SP),2*MJ,INT(QL(J),SP),IZERO,IZERO,IZERO,DFS)
              F=-F0*DC1*DC1/(MI-1)
            ENDIF
c            write(6,*)ql(j),2*mj,ql(j),'  f=',f
C
            if(bporig)then
              DO I=1,MAXRS
                POT(I)=POT(I)-C*F*DA(I)
              ENDDO
            else
              T=WK*C*F
              IF(BREL2)THEN
                DO I=1,MAXRS
                  POT(I)=POT(I)-T*DA(I)*
     X                (DPNL(I,MK)*DPNL(I,MK)+DQNL(I,MK)*DQNL(I,MK))
                ENDDO
              ELSE
                DO I=1,MAXRS
                  POT(I)=POT(I)-T*DA(I)*DPNL(I,MK)*DPNL(I,MK)
                ENDDO
              ENDIF
            endif
C
          ENDDO
C
C EXCHANGE
          IF(.NOT.BEQNL.AND.MEXPOT.EQ.0.AND.MS*MK.NE.0)THEN
c
            if(i1.eq.0.and.bporig)then
              de=dey(mk)-duy(mk,mk)
              de=de+de
              fnu=sqrt(-zn1*zn1/de)
              l=ql(mk)/2
              el=l
              a1=max(fnu*fnu-el*(el+done),dzero)
              a1=sqrt(a1)
              ri=fnu*(fnu+a1)
              ri=dthree*ri/zn1
              tolp=tolp0/zn1
c              write(6,*)ri/dthree,de,zn1,fnu
c
              do i=maxrs,1,-1
                if(abs(DPNL(I,MK)).gt.tolp)then
                  i1=i
c                  write(6,*)mk,dx(i),ri/dthree,rinf2(mk)
                  go to 50
                endif
              enddo
            endif
C
  50        ME1=ABS(QL(J)-QL(MK))/2
            ME2=(QL(J)+QL(MK))/2
            MI=ME2+2
            ME2=MIN(ME2,6_SP)
C
            IF(BREL2)THEN
              DO I=1,MAXRS
                DP(I)=DPNL(I,J)*DPNL(I,MK)+DQNL(I,J)*DQNL(I,MK)
              ENDDO
            ELSE
              DO I=1,MAXRS
                DP(I)=DPNL(I,J)*DPNL(I,MK)
              ENDDO
            ENDIF
C
            DO MJ=ME1,ME2,2
C
              CALL YLAMK(MJ,MI,DP,DA,DD1,DD2,MNH,DHNS,MJH,IZERO)
                                                             !NO RETARDN
              DC1=
     X      VCC(INT(QL(J),SP),2*MJ,INT(QL(MK),SP),IZERO,IZERO,IZERO,DFS)
              G=-DC1*DC1/(2*QL(MK)+2)
c            write(6,*)ql(j),2*mj,ql(mk),'  g=',g
              G=G*AJUST                            !TRY SCALING EXCHANGE
C
             if(bporig)then
              IF(BREL2)THEN
                DO I=1,i1                                         !MAXRS
                  T=DPNL(I,J)*DPNL(I,MK)+DQNL(I,J)*DQNL(I,MK)
                  T=T/(DPNL(I,MK)*DPNL(I,MK)+DQNL(I,MK)*DQNL(I,MK))
                  if(dx(i).gt.ri)t=t*exp(-((dx(i)/ri-done)/sigma)**2)
                  IF(ABS(T).LT.TOLX.or.dx(i).lt.ri)then
                    POT(I)=POT(I)-C*G*DA(I)*T
c                  else
c            write(6,99)j,mk,i,dx(i),t,DPNL(I,J),DPNL(I,MK),pot(i)*dx(i)
c 99    format(3i5,1p,5d10.3)
                  endif
                ENDDO
              ELSE
                DO I=1,i1                                         !MAXRS
c                  if(dpnl(i,mk).eq.dzero)then
c                    write(6,*)i,mk
c                    stop
c                  else
                  if(brel)then
                    dqnj=dpnl(i,j)
                    dqnk=dpnl(i,mk)
                    h=dx(i)
                    if(i.gt.1)then
                      dqnj=dqnj-dpnl(i-1,j)
                      dqnk=dqnk-dpnl(i-1,mk)
                      h=h-dx(i-1)
                    endif
                    dqnj=dfsc2*(dqnj/h-dpnl(i,j)/dx(i))
                    dqnk=dfsc2*(dqnk/h-dpnl(i,mk)/dx(i))
                    t=dpnl(i,j)*dpnl(i,mk)+dqnj*dqnk
                    t=t/(dpnl(i,mk)*dpnl(i,mk)+dqnk*dqnk)
                  else
                    T=DPNL(I,MK)
                    IF(T.EQ.DZERO)T=DPNL(I,J)/TOLX
                    T=DPNL(I,J)/T
                  endif
                  if(dx(i).gt.ri)t=t*exp(-((dx(i)/ri-done)/sigma)**2)
                  IF(ABS(T).LT.TOLX.or.dx(i).lt.ri)then
                    POT(I)=POT(I)-C*G*DA(I)*T
c                  else
c            write(6,99)j,mk,i,dx(i),t,DPNL(I,J),DPNL(I,MK),pot(i)*dx(i)
c 99    format(3i5,1p,5d10.3)
                  endif
                ENDDO
              ENDIF
             else
              T=WK*C*G
              IF(BREL2)THEN
                DO I=1,MAXRS
                  POT(I)=POT(I)-T*DA(I)*
     X                (DPNL(I,J)*DPNL(I,MK)+DQNL(I,J)*DQNL(I,MK))
                ENDDO
              ELSE
                DO I=1,MAXRS
                  POT(I)=POT(I)-T*DA(I)*DPNL(I,J)*DPNL(I,MK)
                ENDDO
              ENDIF
             endif
            ENDDO
C
          ENDIF
C
        ENDIF
C
      ENDDO
C
C STATIC + EXCHANGE (FURNESS & MCCARTHY 1973)
C?                                             .OR.MIONX.LT.0
      IF(MEXPOT.GT.0.OR.MEXPOT.EQ.0.AND.MS.EQ.0             )THEN
C
        DO I=1,MAXRS
          DP(I)=DZERO
        ENDDO
C
        DO J=1,MSHLL
          C=TEL(J)
          IF(J.EQ.MK.AND.MS.GT.0)C=C-DONE
          IF(ABS(C).GT.TOLW)THEN
            DO I=1,MAXRS
              DP(I)=DP(I)+C*(DPNL(I,J)/DX(I))**2
            ENDDO
          ENDIF
        ENDDO
C
        E=DZERO
C        E=-DEY(MK)+DUY(MK,MK)
        T2=AJUST/DTWO                              !TRY SCALING EXCHANGE
        IF(T2.GT.TOLW)THEN
          DO I=1,MAXRS
            T1=(E+POT(I))**2+DP(I)
            IF(T1.GT.DZERO)POT(I)=POT(I)+(SQRT(T1)-(E+POT(I)))*T2
          ENDDO
        ENDIF
C
      ENDIF
c
      if(.not.bporig)go to 900
C
C DETERMINE POINT OF ASYMPTOTIC COULOMB SCREENING
C
      DO I=1,MAXRS
        T=POT(I)-ZN/DX(I)
        T=T*DX(I)/ZN1
        IF(ABS(T).GT.DTOL)MEND=I
      ENDDO
C
      IF(MEND.LT.MAXRS)GO TO 900
c      if(abs(t).lt.2*dtol)go to 900
c      write(6,*)t,dtol
C
      T=POT(MAXRS)*DX(MAXRS)
C
      WRITE(6,1000)MK,DX(MAXRS),ZN,T
C
c      WRITE(6,*)MEND,MAXRS
c      do i=1,maxrs
c        write(6,1999)i,dx(i),pot(i),dx(i)*pot(i)
c 1999   format(i5,1p3e14.6)
c      enddo
C
  900 IF(ALLOCATED(MEL))DEALLOCATE (MEL)
C
      RETURN
C
  999 NF=-1
      GO TO 900
C
 1000 FORMAT(' *** SR.VPNL: NOT ENOUGH MESH POINTS FOR ORBITAL?',I5
     X,' CHECK IF ASYMPTOTIC POTENTIAL ACCURATE ENOUGH:',1P,3E11.3)
c 1001 FORMAT(' *** SR.VPNL: WARNING, ASYMPTOTIC CHARGE= Z-N+',F6.2)
 1009 FORMAT( '*** ERROR IN SR.VPNL: NON-VALID CONFIGURATION',I3
     X,' SPECIFIED FOR ORBITAL ', I3)
 1010 FORMAT(' *** ERROR IN SR.VPNL: ORBITAL',I4,' NOT FOUND IN'
     X,' CONFIGURATION',I4)
 1011 FORMAT(' *** ERROR IN SR.VPNL: ORBITAL',I4,' NOT FOUND IN'
     X,' THE FIRST',I4,' CONFIGURATIONS')
C
      END SUBROUTINE VPNL
C
C                             *******************
C
      SUBROUTINE VXC(DENS,TPLASMA,U)
C
C-----------------------------------------------------------------------
C
C  SR.VXC EVALUATES FREE ELECTRON PLASMA POTENTIAL, AT GIVEN TEMPERATURE
C  AND DENSITY.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (C1=4.7853D0)
      PARAMETER (C2=0.6109D0)
      PARAMETER (C3=2.83431D0)
      PARAMETER (C4=0.21512D0)
      PARAMETER (C5=5.27586D0)
      PARAMETER (C6=3.94309D0)
      PARAMETER (C7=7.91379D0)
      PARAMETER (C8=0.638168D0)
C
      PI=ACOS(-DONE)
C
      IF(DENS.LE.D1M8)THEN
        U=DZERO
      ELSE
        R=(DTHREE/(DFOUR*PI*DENS))**(DONE/DTHREE)
        T=(TPLASMA/C1)*DENS**(-DTWO/DTHREE)
C
C     EXCHANGE PART
C
        UX0=-C2/R
        UX=UX0*(DONE+C3*T**2-C4*T**3+C5*T**4)
        UX=UX/(DONE+C6*T**2+C7*T**4)*TANH(DONE/T)
C
C     CORRELATION PART
C     ASYMPTOTIC FORM FOR HIGH-T ELECTRON GAS
C
        UCHA=-C8/SQRT(T*R)
C
        U=UX+UCHA
      ENDIF
C
      RETURN
C
      END SUBROUTINE VXC
C
C                             *******************
C
      SUBROUTINE WEDDLE(A0,A,W,NH,HN,JH,NDIM)
C
C-----------------------------------------------------------------------
C
C  SR.WEDDLE INTEGRATES ARRAY A, USING WEDDLE'S RULE -- J.A.BELLING, UCL
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION A(NDIM),NH(JH),HN(JH)
C
      N=1
      A1=A0
      JH0=0
      W=DZERO
C
      DO J=1,JH
        J1=NH(J)
        IF(N+J1-1.GT.NDIM)THEN
          J1=NDIM-N+1
          IF(J1.LT.6)GO TO 999         !& RETURN: FOR MAXPS, CAN NEGLECT
          JH0=J
        ENDIF
        H=HN(J)
C
        J16=MOD(J1,ISIX)
        J2=J16+1
C
C        GO TO (7,1,2,3,4,5),J2
C
        IF(J16.EQ.1)THEN                                          !1
          W=W+(19087*A1+65112*A(N)-46461*A(N+1)+37504*A(N+2)-
     X      20211*A(N+3)+6312*A(N+4)-863*A(N+5))/60480*H
        ELSEIF(J16.EQ.2)THEN                                      !2
          W=W+(1139*A1+5640*A(N)+33*A(N+1)+1328*A(N+2)-807*
     X      A(N+3)+264*A(N+4)-37*A(N+5))/3780*H
        ELSEIF(J16.EQ.3)THEN                                      !3
          W=W+(685*A1+3240*A(N)+1161*A(N+1)+2176*A(N+2)-729*
     X      A(N+3)+216*A(N+4)-29*A(N+5))/2240*H
        ELSEIF(J16.EQ.4)THEN                                      !4
          W=W+2*(143*A1+696*A(N)+192*A(N+1)+752*A(N+2)+87*
     X      A(N+3)+24*A(N+4)-4*A(N+5))/945*H
        ELSEIF(J16.EQ.5)THEN                                      !5
          W=W+5*(743*A1+3480*A(N)+1275*A(N+1)+3200*A(N+2)+
     X      2325*A(N+3)+1128*A(N+4)-55*A(N+5))/12096*H
        ENDIF
C
        IF(J16.NE.0)THEN
          M=N+J2-2
          A1=A(M)
        ENDIF
C
        N=N+J2-1                                                  !7
        J2=J1/6
C
        DO J1=1,J2
          W=W+(41*(A1+A(N+5))+216*(A(N)+A(N+4))+27*(A(N+1)+A(N+3))+
     X      272*A(N+2))*H/140
          N=N+5
          A1=A(N)
          N=N+1
        ENDDO
C
        IF(JH0.EQ.J)GO TO 999
C
      ENDDO
C
  999 RETURN
C
      END SUBROUTINE WEDDLE
C
C                             *******************
C
      FUNCTION WHITEX(R,TL,DL,E,ZN,BNORM)
C
C-----------------------------------------------------------------------
C
C  FN.WHITEX CALCULATES THE VALUE OF THE WHITTAKER FUNCTION AT POINT R
C  L=ANGULAR MOMENTUM (FOR NORM)
C  DL=COEFF OF 1/R**2 (=L(L+1) CASE NON-REL.)
C  E=ENERGY/RY (E.LT.0)
C  ZN=ASYMPTOTIC CHARGE
C  IF WHITEX CANNOT BE NORMALIZED, THEN BNORM=.FALSE. ELSE .TRUE.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (ENFFCT=1.0D-6)
C
      SUPFCT=55
      BNORM=.FALSE.
      A=SQRT(-E)
      P=ZN/A
      H1=P+TL+DONE
      H2=P-TL
C
C     DO NOT NORMALIZE WHITTAKER FUNCTION
C     IF FOR ARGUMENTS H1 OR H2  GAMMA(H) IS OUTSIDE MACHINE RANGE
C
      FN=DONE
      IF(H2.LE.ENFFCT)GO TO 3
      IF(H1.GT.SUPFCT)GO TO 3
C
C     NORMALIZATION CAN BE CALCULATED
C
      BNORM=.TRUE.
      D1=SQRT(GAMA7(H1))
      D2=SQRT(GAMA7(H2))
      D3=SQRT(P/A)
      FN=DONE/(D1*D2*D3)
C
   3  A=A*R
      FN=FN*EXP(-A)*(A+A)**P
C
      A=DONE/(A+A)
C      DL=TL*(TL+1)                                             !NON-REL
      PS2=(DL-(P-1)*P)*A
      PS1=PS2
      SUMM=DONE
C
C     EXPAND TO A MAXIMUM OF 30 TERMS
C     CONTINUE THE EXPANSION AS LONG AS ADDITIONAL TERMS BECOME SMALLER
C     STOP THE EXPANSION OF ADDITIONAL TERMS WHICH BECOME VANISHINGLY
C     SMALL
C
      DO I=1,40
        IF(ABS(PS2).GT.ABS(PS1))GO TO 2
        SUMM=SUMM+PS2
        IF(ABS(PS2).LT.ABS(SUMM)*D1M10)GO TO 2
        PS1=PS2
        PS2=PS2*(DL-(P-I)*(P-I+1))*A/I
      ENDDO
C
C     PRINT A WARNING IF EXPANSION EXHAUSTED
      WRITE(6,999)
C
   2  WHITEX=FN*SUMM
C
      RETURN
C
  999 FORMAT(' WHITEX: EXPANSION TOO RESTRICTED')
C
      END FUNCTION WHITEX
C
C                             *******************
C
      SUBROUTINE WXC(DENS,TPLASMA,U)
C
C-----------------------------------------------------------------------
C
C  SR.WXC EVALUATES FREE ELECTRON PLASMA POTENTIAL, AT GIVEN TEMPERATURE
C  AND DENSITY.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (D3Q=DTHREE/DFOUR)
      PARAMETER (C1=4.7853D0)
      PARAMETER (C2=0.6109D0)
      PARAMETER (C3=3.04363D0)
      PARAMETER (C4=0.09227D0)
      PARAMETER (C5=1.7035D0)
      PARAMETER (C6=8.31051D0)
      PARAMETER (C7=5.1105D0)
      PARAMETER (C8=0.425437D0)
C
      PI=ACOS(-DONE)
C
      IF(DENS.LE.D1M8)THEN
        U=DZERO
      ELSE
        R=(DTHREE/(DFOUR*PI*DENS))**(DONE/DTHREE)
C D4*PIE  NOT D4+PI !!!
        T=(TPLASMA/C1)*DENS**(-DTWO/DTHREE)
C
C     EXCHANGE PART
C
        UX0=-C2/R
        UX=UX0*(D3Q+C3*T**2-C4*T**3-C5*T**4)
        UX=UX/(DONE+C6*T**2+C7*T**4)*TANH(DONE/T)
C
C     CORRELATION PART
C     ASYMPTOTIC FORM FOR HIGH-T ELECTRON GAS
C
        UCHA=-C8/SQRT(T*R)
C
        U=UX+UCHA
      ENDIF
C
      RETURN
C
      END SUBROUTINE WXC
C
C***********************************************************************
C
      FUNCTION XINT(DE,ENERG,NLAG0,RHO,M,ml,mu)
C
C-----------------------------------------------------------------------
C
CFN.XINT INTEPOLATES RHO (REACTANCE) MATRIX
C
C METHODS:
C  LAGRANGE POLYNOMIAL IS THE DEFAULT (IINT=1)
C  LAGRANGE TRIGONOMETRIC IS FOR TESING ONLY (IINT=2)
C  CUBIC SPLINE IS SLOWER (IINT=3)
C
C IT CALLS:
C   FN.SINTER
C   SR.SPLYN
C   SR.SPVAL
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (FRACKY=D1M4)
c
      common /nrbuse/buse(mxeng)   !,busi(mxeng,mxeng),btmp(mxeng,mxeng)
C
      DIMENSION ENERG(*),RHO(*)
      DIMENSION SP1(10),SP2(10),SP3(10),SP4(10),SP5(10)
C
      SAVE IP,NP1,NP2,NPH
C
      DATA IP0,NLAG/0,0/
c
      iint=1                                         !set interp. method
C
      IF(DE.LE.FRACKY*ENERG(M))THEN                  !USE ELASTIC
        XINT=RHO(M)
        RETURN
      ELSE
        TE=ENERG(M)+DE
      ENDIF
C
      blog=mu.lt.0                                   !dipole transition
      mu=abs(mu)
c
c      belas=ml.lt.0                                 !alt. flag
      ml=abs(ml)                                    !currently not used
c
      belas=blog                                     !skip ei=ef for dip
c
      IF(NLAG.EQ.0)THEN
        np1=-999
        NPH=(NLAG0+1)/2
      ENDIF
C
      BBC=mu-ml.lt.NLAG0                             !MENG.LE.
      IF(BBC)THEN
        NP1=ml                                       !1
        NP2=mu                                       !MENG
        NLAG=NP2-NP1+1
        IP=NP2
      ENDIF
C
C FIND INTERPOLATION ENERGIES
C
      IF(.NOT.BBC)THEN
C
C FIRST SEE IF WE EXTRAPOLATING
C
        IF(TE.GT.ENERG(mu))THEN                      !EXTRAPOLATING
          NLAG=MIN(ITHREE,NLAG0)
          NP2=mu                                     !MENG
          NP1=NP2-NLAG+1
          IP=NP2
c          if(te.gt.1.1*energ(mu))
c     x       write(0,*)'*** Extrapolating upwards:',ml,mu,m
          iint=1                                     !for safety
          GO TO 1
        ELSEIF(TE.LT.ENERG(ml))THEN                  !EXTRAPOLATING
          NLAG=MIN(ITHREE,NLAG0)
          NP1=ml                                     !1
          NP2=NLAG+NP1-1
          IP=NP2
c          if(te.lt.0.9*energ(ml))
c     x       write(0,*)'*** Extrapolating downwards:',m,ml,mu
          iint=1                                     !for safety
          GO TO 1
        ENDIF
C
C ELSE CENTRE ON TE
C
        DO I=M+1,mu                                   !MENG
          IF(ENERG(I).GT.TE)THEN
            IP=I
            GO TO 2
          ENDIF
        ENDDO
        IP=mu                                         !MENG
C
   2    IF(NLAG0.EQ.1)THEN
          IF(IP.EQ.1)THEN
            XINT=RHO(IP)
          ELSE
            IF(ENERG(IP)-TE.LT.TE-ENERG(IP-1))THEN
              XINT=RHO(IP)
            ELSE
              XINT=RHO(IP-1)
            ENDIF
          ENDIF
          RETURN
        ENDIF
C
        IF(NLAG0.GT.2.AND.IP.NE.IP0)THEN
          NP2=IP+NPH-1
          NP1=IP-NPH
          IF(MOD(NLAG0,ITWO).NE.0)THEN                !REMOVE EVEN POINT
            i0=0
            if(ip.gt.ml+1.and.ip.lt.mu)i0=1              !2,meng
            IF(ABS(ENERG(IP+i0)-TE).LT.ABS(ENERG(IP-1-i0)-TE))THEN
              NP1=NP1+1
            ELSE
              NP2=NP2-1
            ENDIF
          ELSE
            IP0=IP
          ENDIF
          IF(NP1.LT.ml)THEN                             !1
            NP2=NP2-NP1+ml                              !1
            NP1=ml                                      !1
          ELSEIF(NP2.GT.mu)THEN                         !MENG
            NP1=NP1-NP2+mu                              !MENG
            NP2=mu                                      !MENG
          ENDIF
        ELSEIF(NLAG0.EQ.2)THEN
          NP2=IP
          NP1=IP-1
        ENDIF
C now covered by belas
co        IF(ENERG(M)+ENERG(NP1).EQ.DZERO)THEN !EXCLUDE 0-0 FROM INELAST
co          IF(NP2.LT.mu)NP2=NP2+1                        !MENG
co          IF(NP1+1.LT.NP2)NP1=NP1+1
co        ENDIF
C
      ENDIF
c
c   1  continue   !?
c
c      write(6,*)'fn.xint1: ',m,np1,np2
c
      if(belas.and.m.ge.np1)then                        !skip elastic
        d2=de/2                                         !plus any lt tt
        iu=mu-m
        do i1=1,iu
          if(energ(m+i1)-energ(m).gt.d2)go to 3
        enddo
        i1=iu
   3    im=m-np1+i1
        np2=min(np2+im,mu)
        np1=m+i1
cp        if(np2-np1+1.ne.nlag0)then
cp          write(6,*)'fn.xint: ',m,np1,np2,mu
cp        endif
      endif
c
c      if(belas)write(6,*)'fn.xin3: ',m,np1,np2
C
      NLAG=np2-np1+1                                    !NLAG0
C
C  NOW INTERPOLATE
C
   1  CONTINUE
c
      if(blog)then                            !set-up a log energy scale
cp       write(6,*)m,np1,np2
        deoff=0
        blog=.false.
cold        blog=te.gt.2*de.and.energ(np1).gt.dzero
cold        deoff=energ(m)
cl        blog=energ(np1).gt.dzero
cl        deoff=de/4                              !min offset of log(de)
cl        if(energ(np1).le.te)then
cl          deoff=deoff-(energ(np1)-energ(m))
cl        else
cl          deoff=deoff-(te-energ(m))
cl        endif
cup      deoff=max(0,deoff)                          !no downshift
c
ctest nearest neighbour
ctest        if(energ(ip)-energ(ip-1).gt.de)then
ctest            IF(ABS(ENERG(IP)-TE).LT.ABS(ENERG(IP-1)-TE))THEN
ctest              NP0=ip
ctest            ELSE
ctest              NP0=ip-1
ctest            ENDIF
ctest            xint=rho(np0)
ctest            return
ctest        endif
      endif
c
      if(nlag.eq.1)then
        xint=rho(np1)
        buse(np1)=.true.                              !flag used
c        busi(np1,m)=.true.                            !flag used
      elseIF(NLAG.EQ.2)THEN                           !LAGRANGE POLY-ALL
C
        T10=ENERG(NP1)
        T20=ENERG(NP2)
        if(blog)then
          t=energ(m)-deoff
          te=te-t
          te=log(te)
          t10=t10-t
          t10=log(t10)
          t20=t20-t
          t20=log(t20)
        endif
        T=T20-T10
        T1=T20-TE
        T2=TE-T10
        XINT=(T2*RHO(NP2)+T1*RHO(NP1))/T
        buse(np1)=.true.                              !flag used
        buse(np2)=.true.                              !flag used
c        busi(np1,m)=.true.                            !flag used
c        busi(np2,m)=.true.                            !flag used
C
      ELSEIF(iint.eq.1)THEN                           !LAGRANGE POLY
C
        if(blog)then
          t=energ(m)-deoff
          te=te-t
          te=log(te)
        endif
        XINT=DZERO
        DO J=NP1,NP2
          buse(j)=.true.                              !flag used
c          busi(j,m)=.true.                            !flag used
          TJ=ENERG(J)
          if(blog)then
            tj=tj-t
            tj=log(tj)
          endif
          DD=DONE
          DO N=NP1,NP2
            IF(J.NE.N)THEN
              TN=ENERG(N)
              if(blog)then
                tn=tn-t
                tn=log(tn)
              endif
              DD=DD*(TE-TN)
              DD=DD/(TJ-TN)
            ENDIF
          ENDDO
          XINT=XINT+DD*RHO(J)
        ENDDO
C
      ELSEIF(iint.eq.2)THEN                           !LAGRANGE TRIG
C
        NP0=NP2-NP1+1
        E1=ENERG(NP1)
        E2=ENERG(NP2)
        E21=E2-E1
        E21P=E21*2.05
C
        N=0
        DO NP=NP1,NP2
          N=N+1
          SP1(N)=(ENERG(NP)-E1)/E21P                  !MAP TO [0:<1]
        ENDDO
        T=(TE-E1)/E21P
C
        XINT=SINTER(NP0,SP1,RHO(NP1),T)
C
      ELSEIF(iint.eq.3)THEN                           !SPLINE
c
        do j=np1,np2
          buse(j)=.true.                              !flag used
c          busi(j,m)=.true.                            !flag used
        enddo
C
        NP0=NP2-NP1+1
        CALL SPLYN(NP0,ENERG(NP1),RHO(NP1),ITHREE,DZERO,ITHREE,DZERO
     X                                           ,SP1,SP2,SP3,SP4,SP5)
        JSP=0
        XINT=SPVAL(NP0,ENERG(NP1),RHO(NP1),SP1,SP2,SP3,SP4,TE,JSP)
C
      ENDIF
cp      write(6,*)xint,(rho(i),i=np1,np2)
C
      RETURN
C
      END FUNCTION XINT
C
C                             *******************
C
      FUNCTION XTWO(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.XTWO EVALUATES THE X-TWO INTEGRAL OF 2-BODY DARWIN+
C  CONTACT-SPIN-SPIN INTERACTION, INCLUDING THE (2LBD+1) FACTOR.
C
C-----------------------------------------------------------------------
C
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      ALLOCATABLE :: D1(:)
C
      COMMON /BASIC/NF,MGAP(11)
      COMMON /CHARY/DEY(MAXGR)
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
      DD=DONE
C
      ALLOCATE (D1(MAXRS),STAT=IERR)                              !MAXB1
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'XTWO: ALLOCATION FAILS FOR D1'
        XTWO=DZERO
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
      DO I=1,MAXRS
        D1(I)=DPNL(I,K1)*DPNL(I,K2)*DPNL(I,K3)*DPNL(I,K4)/(DX(I)*DX(I))
      ENDDO
C
      IF(BREL)THEN               !SMALL R CORRECTION
        DE1=DEY(K1)-DUY(K1,K1)
        DE3=DEY(K3)-DUY(K3,K3)
        DE2=DEY(K2)-DUY(K2,K2)
        DE4=DEY(K4)-DUY(K4,K4)
        DZ=NZION
        IF(BREL2)THEN
          T=DALF4*DTWO
          DO I=1,MAXRS
            DD1=DONE+T*(DE1+DZ/DX(I))
            DD3=DONE+T*(DE3+DZ/DX(I))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
            DD2=DONE+T*(DE2+DZ/DX(I))
            DD4=DONE+T*(DE4+DZ/DX(I))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
          ENDDO
        ELSE
          dd=rnorm(k1)*rnorm(k3)*rnorm(k2)*rnorm(k4)
          DO I=1,MAXRS
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
            DSQ=DD1*DD3
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)/DSQ
            DD2=DONE+DALF4*(DQNL(I,K2)/DPNL(I,K2)+DTWO*DZ/DX(I))
            DD4=DONE+DALF4*(DQNL(I,K4)/DPNL(I,K4)+DTWO*DZ/DX(I))
            DSQ=DD2*DD4
            DSQ=SQRT(DSQ)
            D1(I)=D1(I)*dd/DSQ
          ENDDO
        ENDIF
      ENDIF
C
      CALL WEDDLE(DZERO,D1,TT,MNH,DHNS,MJH,MAXRS)
C
      TP=2*LAM+1
      XTWO=DALF*TT*TP*DD
      if(.not.brel)xtwo=xtwo/DTWO                  !add-in 2-body Darwin
C
      DEALLOCATE (D1,STAT=IERR)
C
      IF(IERR.NE.0)THEN
        WRITE(0,*)'XTWO: DEALLOCATION FAILS FOR D1'
        NF=0                                                !NOT TRACKED
        RETURN
      ENDIF
C
C      WRITE(6,100) K1, K2, K3, K4, XTWO
C100   FORMAT(8X,2(I5,I4),F20.7,' =XTWO')
C
      RETURN
C
      END FUNCTION XTWO
c                                                                  !ADAS
C                             *******************                  !ADAS
c                                                                  !ADAS
      subroutine xxcftr(icfsel,cstrgi,cstrgo)                      !ADAS
c                                                                  !ADAS
c dummy routine for normal (non-ADAS) useage.                      !ADAS
c                                                                  !ADAS
      USE PRECSN, ONLY: BP,QP,SP,EP,WP                             !ADAS
      USE PARAM                                                    !ADAS
      USE CONSTANTS                                                !ADAS
C                                                                  !ADAS
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)                            !ADAS
      IMPLICIT LOGICAL(BP) (B)                                     !ADAS
      IMPLICIT INTEGER(SP) (I-N)                                   !ADAS
      IMPLICIT INTEGER(QP) (Q)                                     !ADAS
C                                                                  !ADAS
C      INCLUDE './INCLUDE'                                         !ADAS
c                                                                  !ADAS
      character(len=*) cstrgi,cstrgo                               !ADAS
      character(len=1) cdum                                        !ADAS
c                                                                  !ADAS
c suppress compiler warnings (sigh...)                             !ADAS
c                                                                  !ADAS
      cdum=cstrgi(1:1)                                             !ADAS
      idum=icfsel                                                  !ADAS
c                                                                  !ADAS
      write(cstrgo(1:15),'(a15)')'dummy sr.xxcftr'                 !ADAS
c                                                                  !ADAS
      return                                                       !ADAS
c                                                                  !ADAS
      end subroutine xxcftr                                        !ADAS
C
C                             *******************
C
      SUBROUTINE YLAMK(L,M0,PA,PB,Y1,Y2,NH,HN,JH,MODE)
C
C-----------------------------------------------------------------------
C
C  SR.YLAMK EVALUATES RADIAL MULTIPOLE FUNCTIONS (OUTPUT ARRAY PB) FOR
C  RADIAL FUNCTION PRODUCT (INPUT ARRAY PA) OF LAMDA=L. ALSO OUTPUT
C  Y1 INTEGRAL [0:INF) A*X**L
C  Y2 INTEGRAL [0:INF) A/X**(L+1)
C
C  IT USES THE MODIFIED BODY OF J. A. BELLING'S SR.YLAM.
C
C  MODE.EQ.0: YLAMK COMPUTES  COULOMB INTEGRALS YLAMBDA (REL.TO RLAM)
C  MODE.LT.0:                MAGNETIC INTEGRALS RELATED TO VLAM
C  MODE.GT.0:                                              NLAM
C
C  IT CALLS:
C    SR.YLAMKR
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION PA(*),PB(*),NH(JH),HN(JH),C(5),E(5),F(5)
C
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
C
      M=MIN(M0,I5TEEN)
C
      K=1
      IF(MODE.NE.0)K=ABS(MODE)
      J=L+K
C
C      N=J
C      IF(MODE.NE.0)N=2
      IF(J.LE.0             .OR. JH.LE.0)GO TO 50
C                .OR. M.LT.N
      N=8
      DO I=1,JH
        IF(HN(I).LT.DZERO)GO TO 50
        IF(NH(I).LT.N)GO TO 50
        N=5
      ENDDO
C
      IF(MDEN.EQ.11.AND.DENE.GT.DZERO)THEN!DEBYE-HUCKEL PLASMA SCREENING
        DEL=D1P99
        CALL YLAMKR(L,M0,DEL,PA,PB,Y1,Y2,NH,HN,JH,MODE)
        RETURN
      ENDIF
C
      H=HN(1)
      J1=M-1
      X=DZERO
      DO I=1,4
        X=X+H
        C(I)=PA(I)/X**J1
      ENDDO
C
      Z=H*24
      E(1)=(96*C(1)-72*C(2)+32*C(3)-6*C(4))/Z
      Z=H*Z
      E(2)=(-104*C(1)+114*C(2)-56*C(3)+11*C(4))/Z
      Z=H*Z
      E(3)=(36*C(1)-48*C(2)+28*C(3)-6*C(4))/Z
      Z=H*Z
      E(4)=(-4*(C(1)+C(3))+6*C(2)+C(4))/Z
      X=DZERO
C
      DO N=1,4
        X=X+H
        C(N)=DZERO
        DO I1=1,4
          I2=5-I1
          Z=L+M+I2
          C(N)=E(I2)/Z+C(N)*X
        ENDDO
        PB(N)=C(N)*X**(M-K+1)
        C(N)=PB(N)*X**J
      ENDDO
C
      E(4)=PA(4)*X**L
      N=4
      I1=8
C
      DO J1=1,JH
        H=HN(J1)
        H1=2*H/45
        E(1)=E(4)
        C(1)=C(4)
C
        DO I=2,5
          N=N+1
          X=X+H
          Z=X**L
          E(I)=Z*PA(N)
          F(I)=Z*X**K
        ENDDO
C
        C(2)=C(1)+H*(251*E(1)+646*E(2)-264*E(3)+106*E(4)-19*E(5))/720
        PB(N-3)=C(2)/F(2)
        C(3)=C(1)+H*(29*E(1)+124*E(2)+24*E(3)+4*E(4)-E(5))/90
        PB(N-2)=C(3)/F(3)
        C(4)=C(1)+H*(9*E(1)+34*E(2)+24*E(3)+14*E(4)-E(5))*3/80
        PB(N-1)=C(4)/F(4)
        I2=NH(J1)
C
        IF(I2.GE.I1)THEN
          N=N-1
          X=X-H
          DO I=I1,I2
            N=N+1
            X=X+H
            Z=X**L
            F(5)=Z*X**K
            E(5)=Z*PA(N)
            C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
            PB(N)=C(5)/F(5)
            DO I3=1,4
              C(I3)=C(I3+1)
              E(I3)=E(I3+1)
            ENDDO
          ENDDO
        ENDIF
        I1=4
      ENDDO
C
      Y1=C(5)
      IF(MODE.GT.0)GO TO 90
      C(5)=DZERO
C TEST C(5)=Y2                                !MUST ENSURE Y2 INPUT THEN
      I1=1
      X=X+H
C
      DO J1=1,JH
        I3=JH-J1+1
        H=HN(I3)
        H1=2*H/45
        E(1)=E(5)
        C(1)=C(5)
        I2=NH(I3)
        I3=N
        DO I=I1,5
          X=X-H
          F(I)=X**L
          E(I)=PA(N)/(F(I)*X**K)
          N=N-1
        ENDDO
        C(2)=C(1)+H*(251*E(1)+646*E(2)-264*E(3)+106*E(4)-19*E(5))/720
        C(3)=C(1)+H*(29*E(1)+124*E(2)+24*E(3)+4*E(4)-E(5))/90
        C(4)=C(1)+H*(9*E(1)+34*E(2)+24*E(3)+14*E(4)-E(5))*3/80
        C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
C
        DO I=I1,5
          IF(MODE.LE.-999)PB(I3)=DZERO
          PB(I3)=C(I)*F(I)+PB(I3)
          I3=I3-1
        ENDDO
C
        DO I=5,I2
          DO I3=1,4
            E(I3)=E(I3+1)
            C(I3)=C(I3+1)
          ENDDO
          E(5)=DZERO
          IF(N.NE.0)THEN
            X=X-H
            Z=X**L
            E(5)=PA(N)/(Z*X**K)
          ENDIF
          C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
          IF(N.EQ.0)GO TO 20
          IF(MODE.LE.-999)PB(N)=DZERO
          PB(N)=C(5)*Z+PB(N)
          N=N-1
        ENDDO
        I1=2
      ENDDO
C
  20  Y2=C(5)
C
  90  RETURN
C
C SHOULD NOT HAPPEN SINCE SUITABLE MESH PRE-SET BY RADIAL
C
  50  WRITE(6,999)L,MODE,M,JH,(NH(I),HN(I),I=1,JH)
      WRITE(0,*)'INPUT ERROR IN YLAMK'
C      STOP 'INPUT ERROR IN YLAMK'
      GO TO 90
C
 999  FORMAT(/20X,'INPUT ERROR IN YLAMK',20X,'L,MODE=',2I5,5X,'M=',I3,
     X 5X,'JH=',I3,5X,'NH,HN='/(10X,5(I5,E16.8)))
C
      END SUBROUTINE YLAMK
C
C                             *******************
C
      SUBROUTINE YLAMKR(L,M0,DEL0,PA,PB,Y1,Y2,NH,HN,JH,MOD0)
C
C-----------------------------------------------------------------------
C
C  SR.YLAMKR EVALUATES RADIAL MULTIPOLE FUNCTIONS WITH FULL RETARDATION
C  USING SPHERICAL BESSEL FUNCTIONS OF THE FIRST AND SECOND KIND, I.E.
C  ONLY THE REAL PART IS CONSIDERED.
C  IT USES THE MODIFIED BODY OF SR.YLAMK.
C  ONLY CALLED IF BREL=.TRUE., I.E. RELATIVISTIC WAVEFUNCTIONS IN USE.
C
C  INPUT:
C  MODE.EQ.0: YLAMK COMPUTES  COULOMB INTEGRALS YLAMBDA (REL.TO RLAM)
C      .LT.0:                MAGNETIC INTEGRALS RELATED TO VLAM
C      .GT.0:                                              NLAM
C  L  IS THE MULTIPOLE
C  M0 CHARACTERISES THE SMALL-R BEHAVIOUR OF ARRAY
C  PA  WHICH CONTAINS THE PRODUCT OF THE TWO ORBITALS ON:
C  NH,HN,JH DEFINED STANDARD RADIAL MESH
C
C  DEL IS THE TRANSVERSE PHOTON ENERGY (A.U.).
C  ***IF USER SETS IBREIT IN UNIT5 INPUT THEN
C  IBREIT.GT.0 (REAL PART OF) GENERALIZED BREIT INTERACTION.
C  IBREIT.EQ.0 USUAL YLAMK IS CALLED - ZERO ENERGY TRANSVERSE PHOTON.
C  (TEST: IBREIT.LT.0 APPLIES NON-ZERO ENERGY TO THE COULOMB, AS MOLLER)
C
C  IF MDEN.EQ.11 THEN DEL IS REPLACE BY CORRESPONDING DEBYE WAVELENGTH
C  TO GENERATE 2-BODY DEBYE-HUCKEL SCREENED COULOMB INTEGRALS.
C
C  OUTPUT:
C  YK IN ARRAY PB.
C  Y1,Y2 INTEGRALS ZERO TO INFINITY.
C
C  IT CALLS:
C    SR.YLAMK
C    FN.SBESS
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (WMIN0=0.1D0)
C
      DIMENSION PA(*),PB(*),NH(JH),HN(JH),C(5),E(5),F(5)
C
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      bbreit=ibreit.lt.0.or.ibreit.gt.0.and.mod0.ne.0.or.mden.eq.11
      mode=mod(mod0,I1000)
c
      M=MIN(M0,I5TEEN)
C
      K=1
      IF(MODE.NE.0)K=ABS(MODE)
      J=L+K
C
C      N=J
C      IF(MODE.NE.0)N=2
      IF(J.LE.0             .OR. JH.LE.0)GO TO 50
C               .OR. M.LT.N
      N=8
      MAXRS=0
      DO I=1,JH
        IF(HN(I).LT.DZERO)GO TO 50
        IF(NH(I).LT.N)GO TO 50
        N=5
        MAXRS=MAXRS+NH(I)
      ENDDO
C
      IF(MDEN.EQ.11)THEN                  !DEBYE-HUCKEL PLASMA SCREENING
        IF(DENE.GT.DZERO)THEN
          W=DONE/DEBYE
          WMIN=-WMIN0
          JSWTCH1=-1
          JSWTCH2=-3
          TM=-DTWO/XPI    !COMPENSATE FOR USING ABRAMOWITZ & STEGUN NORM
        ELSE
          W=DZERO
          WMIN=DONE
        ENDIF
C      ELSEIF(MDEN.EQ.22)THEN             !ION-SPHERE PLASMA SCREENING
      ELSE
        DEL=ABS(DEL0)
        W=DFSC*DEL
        WMIN=WMIN0
        JSWTCH1=1
        JSWTCH2=2
        TM=DONE
      ENDIF
C
      IF(W.LT.WMIN.or..not.bbreit)THEN                       !UNRETARDED
        CALL YLAMK(L,M0,PA,PB,Y1,Y2,NH,HN,JH,MODE)
        RETURN
      ENDIF
C
      H=HN(1)
      J1=M-1
      X=DZERO
      DO I=1,4
        X=X+H
        C(I)=PA(I)/X**J1
      ENDDO
C
      Z=H*24
      E(1)=(96*C(1)-72*C(2)+32*C(3)-6*C(4))/Z
      Z=H*Z
      E(2)=(-104*C(1)+114*C(2)-56*C(3)+11*C(4))/Z
      Z=H*Z
      E(3)=(36*C(1)-48*C(2)+28*C(3)-6*C(4))/Z
      Z=H*Z
      E(4)=(-4*(C(1)+C(3))+6*C(2)+C(4))/Z
C
      TW=-(2*L+1)*W**K
      DO I=1,K-1
        TW=TW/(2*(L+I)-1)
      ENDDO
C
      TW=TW*TM
C
      X=DZERO
      DO N=1,4
        X=X+H
        C(N)=DZERO
        DO I1=1,4
          I2=5-I1
          Z=L+M+I2
          C(N)=E(I2)/Z+C(N)*X
        ENDDO
        PB(N)=C(N)*X**(M-K+1)
        C(N)=PB(N)*X**J
      ENDDO
C
      J=J-1
      Z=X*W
      E(4)=SBESS(L,Z,JSWTCH1)*PA(4)
      N=4
      I1=8
C
      DO J1=1,JH
        H=HN(J1)
        H1=2*H/45
        E(1)=E(4)
        C(1)=C(4)
C
        DO I=2,5
          N=N+1
          X=X+H
          Z=X*W
          E(I)=SBESS(L,Z,JSWTCH1)*PA(N)
          F(I)=SBESS(J,Z,JSWTCH2)
        ENDDO
C
        C(2)=C(1)+H*(251*E(1)+646*E(2)-264*E(3)+106*E(4)-19*E(5))/720
        PB(N-3)=C(2)*F(2)
        C(3)=C(1)+H*(29*E(1)+124*E(2)+24*E(3)+4*E(4)-E(5))/90
        PB(N-2)=C(3)*F(3)
        C(4)=C(1)+H*(9*E(1)+34*E(2)+24*E(3)+14*E(4)-E(5))*3/80
        PB(N-1)=C(4)*F(4)
        I2=NH(J1)
C
        IF(I2.GE.I1)THEN
          N=N-1
          X=X-H
          DO I=I1,I2
            N=N+1
            X=X+H
            Z=X*W
            E(5)=SBESS(L,Z,JSWTCH1)*PA(N)
            F(5)=SBESS(J,Z,JSWTCH2)
            C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
            PB(N)=C(5)*F(5)
            DO I3=1,4
              C(I3)=C(I3+1)
              E(I3)=E(I3+1)
            ENDDO
          ENDDO
        ENDIF
        I1=4
      ENDDO
C
      Y1=C(5)
      IF(MODE.GT.0)GO TO 90
C
      C(5)=DZERO
C TEST C(5)=Y2                                !MUST ENSURE Y2 INPUT THEN
      I1=1
      X=X+H
C
      DO J1=1,JH
        I3=JH-J1+1
        H=HN(I3)
        H1=2*H/45
        E(1)=E(5)
        C(1)=C(5)
        I2=NH(I3)
        I3=N
        DO I=I1,5
          X=X-H
          Z=X*W
          E(I)=SBESS(J,Z,JSWTCH2)*PA(N)
          F(I)=SBESS(L,Z,JSWTCH1)
          N=N-1
        ENDDO
        C(2)=C(1)+H*(251*E(1)+646*E(2)-264*E(3)+106*E(4)-19*E(5))/720
        C(3)=C(1)+H*(29*E(1)+124*E(2)+24*E(3)+4*E(4)-E(5))/90
        C(4)=C(1)+H*(9*E(1)+34*E(2)+24*E(3)+14*E(4)-E(5))*3/80
        C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
C
        DO I=I1,5
          IF(MODE.LE.-999)PB(I3)=DZERO
          PB(I3)=C(I)*F(I)+PB(I3)
          I3=I3-1
        ENDDO
C
        DO I=5,I2
          DO I3=1,4
            E(I3)=E(I3+1)
            C(I3)=C(I3+1)
          ENDDO
          E(5)=DZERO
          IF(N.NE.0)THEN
            X=X-H
            Z=X*W
            E(5)=SBESS(J,Z,JSWTCH2)*PA(N)
            F(5)=SBESS(L,Z,JSWTCH1)
          ENDIF
          C(5)=C(1)+H1*(7*(E(1)+E(5))+32*(E(2)+E(4))+12*E(3))
          IF(N.EQ.0)GO TO 20
          IF(MODE.LE.-999)PB(N)=DZERO
          PB(N)=C(5)*F(5)+PB(N)
          N=N-1
        ENDDO
        I1=2
      ENDDO
C
  20  Y2=C(5)
C
      Y2=Y2*TW
  90  Y1=Y1*TW
      DO I=1,MAXRS
        PB(I)=TW*PB(I)
      ENDDO
C
      RETURN
C
C SHOULD NOT HAPPEN SINCE SUITABLE MESH PRE-SET BY RADIAL
C
  50  WRITE(6,999)L,MODE,M,JH,(NH(I),HN(I),I=1,JH)
      WRITE(0,*)'INPUT ERROR IN YLAMKR'
C      STOP 'INPUT ERROR IN YLAMKR'
      RETURN
C
 999  FORMAT(/20X,'INPUT ERROR IN YLAMKR',20X,'L,MODE=',2I5,5X,'M=',I3,
     X 5X,'JH=',I3,5X,'NH,HN='/(10X,5(I5,E16.8)))
C
      END SUBROUTINE YLAMKR
C
C                             *******************
C
      SUBROUTINE YLAMKX(DP1,DP2,DQ1,DQ2,N1,N2,JJ,M1,M2,TM,TN,DEL0,DPA,DP
     X                 ,DX,DPOLA,REM,ovlp)
C
C-----------------------------------------------------------------------
C
C  SR.YLAMKX CALCULATES THE DEIE YK INTEGRAL,
C    INCLUDING ANY LONG-RANGE CONTRIBUTION
C
C  IT CALLS:
C    SR.YLAMKR
C    SR.YLAMK
C    SR.ASS2X
C    SR.ASSX
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION DP1(*),DP2(*),DQ1(*),DQ2(*),DPA(*),DP(*),DX(*)
C
      common /com1/dpot(maxb1),tol,mend
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRB/MAUTO,MODE,ACE,MSHELL,MORT,MGRP,BSTO
      COMMON /NRBDW5/DYY(MXENG),MENG,NLAG
      COMMON /NRBPOL/ALFD(0:3),RCUT(0:3),ALAV,RCAV,IPOLFN
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
C-----------------------------------------------------------------------
      DPOL1(X)=SQRT(DONE-EXP(-(X/RCAV)**6))/X**2
      DPOL2(X)=X/((X*X+RCAV*RCAV)*SQRT(X*X+RCAV*RCAV))
C-----------------------------------------------------------------------
C
      BREL2=ABS(IREL).EQ.2
      IPOLF2=IPOLFN/10
      DZA=-(NZION-MION)                             !CHARGE .LT.0 IN ASS
C
      REM=DZERO
C
      IF(BREL2)THEN
        DO I=1,MAXRS
          DPA(I)=DP1(I)*DP2(I)+DQ1(I)*DQ2(I)
        ENDDO
      ELSE
        DO I=1,MAXRS
          DPA(I)=DP1(I)*DP2(I)
        ENDDO
      ENDIF
c
      if(jj.eq.0)then                   !determine one-body contribution
        if(qn(n2).lt.0.or.mort.ne.-3)then            !direct or exchange
          do i=1,maxrs
            dp(i)=dpa(i)*dpot(i)
          enddo
          call weddle(dzero,dp,rem0,MNH,dhns,mjh,maxrs)
          rem0=-rem0/(dpot(maxrs)*dx(maxrs))          !a.u. per electron
          if(qn(n2).lt.0)rem=rem0                                !direct
        else
          rem0=dzero
        endif
      endif
C
      ML=(QL(N1)+QL(N2))/2+2
      MI=ABS(JJ)/2
C
      IF(BREL)THEN
        DEL=DEL0/DTWO                                           ! A.U.!!
        CALL YLAMKR(MI,ML,DEL,DPA,DP,DD1,DD2,MNH,DHNS,MJH,IZERO)
      ELSE
        CALL YLAMK(MI,ML,DPA,DP,DD1,DD2,MNH,DHNS,MJH,IZERO)
      ENDIF
C
      IF(IPOLF2.GT.0.AND.MI.EQ.1)THEN         !DIELECTRIC POLARIZATION
        IF(IPOLF2.EQ.1)THEN
          DO I=1,MAXRS
            DPA(I)=DPOL1(DX(I))*DPA(I)
          ENDDO
        ELSEIF(IPOLF2.EQ.2)THEN
          DO I=1,MAXRS
            DPA(I)=DPOL2(DX(I))*DPA(I)
          ENDDO
        ELSE
          STOP 'SR.YLAMKX: HERE BE MONSTERS'
        ENDIF
        CALL WEDDLE(DZERO,DPA,DPOLA,MNH,DHNS,MJH,MAXRS)
      ENDIF
C
      IF(JJ.LT.0)RETURN                                  !EXCHANGE
C
      IF(JJ.EQ.0)THEN
        if(rem.eq.dzero)then                       !exchange
          ovlp=dd1
          rem=rem0
        else                                       !direct
          ovlp=dzero
        endif
        RETURN
      ENDIF
C
C  EVALUATE LONG-RANGE INTEGRAL (SO DIRECT)
C
      E1=DYY(M1)                                              !RYD
      E2=DYY(M2)                                              !RYD
      ML1=QL(N1)/2
      ML2=QL(N2)/2
C
      IF(E1*E2.EQ.DZERO.AND.ML1+ML2.GT.60)THEN
        REM=DZERO
        RETURN
      ENDIF
C
      DS=ML1*(ML1+1)
      DC=ML2*(ML2+1)
C
      DX1=DX(MAXRS)
      DTH=DX(MAXRS)-DX(MAXRS-1)
C
      DD1=DP1(MAXRS-1)
      DD2=DP1(MAXRS)
      DD3=DP2(MAXRS-1)
      DD4=DP2(MAXRS)
C
      MN=-MI-1
C
      CALL ASS2X(DX1,DTH,DX2,DD1,DD2,DD3,DD4,E1,E2,DS,DC,DZERO,DZERO
     X          ,DZERO,DZERO,DZA,MN,REM2)
C
      CALL ASSX(DX2,MN,TM,TN,E1,E2,DZA,ML1,ML2,DS,DC,DZERO,DZERO
     X         ,DZERO,DZERO,REM)
C
C      SUM=REM2+REM
C      WRITE(6,1111)E1,E2,DX1,REM2,DX2,REM,SUM
C1111  FORMAT(2F9.3,2(F7.1,F12.6),F13.6)
C
      REM=REM2+REM
C
      RETURN
C
      END SUBROUTINE YLAMKX
C
C                             *******************
C
      SUBROUTINE ZEFR(J,R,ZE)
C
C-----------------------------------------------------------------------
C
C   This subroutine calculates an effective charge ZE such
C   that in a coulomb field of charge ZE the mean radius
C   <R> of orbital J is equal to the input value R .
C      Find ZE such that   <R>-R=0
C   The Newton method is used with accuracy D1M6 and maximum
C   number of iterations ITR .
c
c   Fix for L-spinors           -        nrb 09/01/08
c
C
C  Based on PHN's GRASP0 routine and freely adapted by NRB.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (ITR=30)
C
      DIMENSION TA(3),TB(3)
C
      NN=QN(J)
      L=QL(J)/2
      K=-L-1
    5 CONTINUE
      MK=ABS(K)
      NNS=NN*NN
C
C  Initial estimate using non-relativistic formula.
C
      TA(3)=REAL(NNS+NNS+NNS-L*(L+1),WP)/(R+R)
      FK=REAL(K,WP)
      FKS=FK*FK
      FNR=REAL(NN-MK,WP)
C
C  Begin iterations on the relativistic formula.
C
      I=1
   10 CONTINUE
      TA(1)=TA(3)-D1M5
      TA(2)=TA(3)+D1M5
      DO II=1,3
        WA=TA(II)*DFSC
        WA=WA*WA
        if(fks-wa.lt.0)go to 50                !catch L-spinors
        WB=SQRT(FKS-WA)+FNR
        WA=WB*WB+WA
        if(wa.lt.0)go to 50                    !catch L-spinors
        SWA=SQRT(WA)
        WA=WB*(WA+WA+WA-FKS)-SWA*FK
        WB=TA(II)*SWA
        TB(II)=WA/(WB+WB)-R
      ENDDO
      WB=TA(3)
      WA=D1M5*TB(3)/(TB(2)-TB(1))
      TA(3)=TA(3)-(WA+WA)
      IF(ABS(TA(3)-WB).le.D1M6)go to 40        !40,40,20
c   20 CONTINUE
c      write(6,*)i,a(3)
      I=I+1
      IF(I.le.ITR)go to 10                    !10,10,30
c   30 CONTINUE
      WRITE(6,3000)QN(J),QL(J)/2
C
   40 CONTINUE
      ZE=TA(3)
C
      IF(L.EQ.0)RETURN
C
      IF(K.LT.0)THEN
        ZE3=ZE
        K=L
        GO TO 5
      ELSE
        ZE1=ZE
        ZE=(ZE1+DTWO*ZE3)/DTHREE
      ENDIF
c
      return
c
   50 ze=-done
      return
C
 3000 FORMAT(' WARNING in ZEFR : iteration limit exceeded for ',I2,I2)
C
      END SUBROUTINE ZEFR
C
C                             *******************
C
      FUNCTION ZEFX(I,NI,LI,Z0,S,NSHELL,N,TUMEL,ALFA,R,MEXPOT)
C
C-----------------------------------------------------------------------
C
C  FN.ZEFX EVALUATES THE SLATER-TYPE ORBITAL POTENTIAL AT A SINGLE PT.
C  USING OCCUPPATION NUMBERS DEFINED IN SR.STOPOT, WHICH CALLS IT
C  TO FILL-IN THE RADIAL ARRAY
C
C  A. BURGESS - HARTREE
C  N. R. BADNELL - EXCHANGE
C
C  Z0=NUCLEAR CHARGE (IN ELECTRON POTENTIAL UNITS)
C  NSHELL=NUMBER OF ELECTRON SHELLS
C  N(J),J=1, NSHELL, IS THE PRINCIPAL QUANTUM NUMBER OF SHELL J
C  TUMEL(J) IS THE NUMBER OF ELECTRONS IN SHELL J
C  R IS THE RADIAL DISTANCE COORDINATE IN UNITS OF A0 AND
C  ALFA(J) IS A RADIAL SCALING FACTOR FOR SHELL J.
C  IF I IS SET NEGATIVE, ZEFX IS SET TO THE JUCYS FIT TO THE
C  THOMAS-FERMI EFFECTIVE POTENTIAL.
C  IF I IS SET POSITIVE OR ZERO, SLATER-TYPE ORBITALS ARE USED, AND
C  ZEFX IS THE SHORT RANGE EFFECTIVE POTENTIAL, AS SEEN BY A (SPECTATOR)
C  ELECTRON IN SHELL I, DUE TO THE NUCLEUS PLUS ALL THE OTHER ELECTRON
C  IN SHELLS J=1,NSHELL.
C  N.B. I MAY BE SET GREATER THAN NSHELL (OR ZERO), IN WHICH
C  CASE THERE IS SCREENING BY ALL THE ELECTRONS IN SHELLS J=1,NSHELL
C  SINCE THE SPECTATOR ELECTRON IS NOT ONE OF THEM.
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (DCON1=1.4D2)
      PARAMETER (DCON2=0.2075D0)
      PARAMETER (DCON3=1.19D0)
      PARAMETER (DCON4=0.4236D0)
C
      DIMENSION N(NSHELL),TUMEL(NSHELL),ALFA(NSHELL)
C
      SZ=ABS(S)
      T=DZERO
      VX=DZERO
      IF(NSHELL.LE.0)GO TO 5
      IF(I.GE.0)GO TO 8
      T2=(-Z0)**(DONE/DTHREE)
C
      DO J=1,NSHELL
        T1=TUMEL(J)
        RHO=ALFA(J)*R*T2
        T3=DCON2*RHO
        T4=DZERO
        IF(T3.LT.DCON1)T4=EXP(-T3)
        T=T+T1*T4/(DONE+DCON3*RHO)
      ENDDO
      GO TO 5
C
    8 Z=-Z0
      TI=DZERO
      TE=DZERO
      BMEX=MEXPOT.GT.0
      IF(BMEX)THEN
        XK=DTWO/DTHREE
        IF(MEXPOT.EQ.2)XK=DONE
      ENDIF
C
      DO J=1,NSHELL
        IF(TUMEL(J).NE.DZERO)THEN
          X=ALFA(J)
          X=X*R
          T1=TUMEL(J)-DONE
          Z=Z-T1*SZ/DTWO
          EN=N(J)
          RHO=DTWO*Z*X/EN
          IMAX=N(J)+N(J)-1
          T2=EN+EN
          T3=DONE
          T4=DONE/T2
          DO I1=1,IMAX
            T5=I1
            T2=T2-DONE
            T4=T4*RHO/T5
            T3=T3+T4*T2
          ENDDO
          IF(I.NE.J)T1=TUMEL(J)
          T6=DZERO
          IF(RHO.LT.DCON1)T6=EXP(-RHO)
          T=T+T1*T3*T6
C
          IF(BMEX)THEN                  !EXCHANGE
            TJ=T4*T6*RHO*RHO/R**3
            TE=TUMEL(J)*TJ+TE
            IF(I.EQ.J)TI=TJ
          ENDIF
C
          T1=TUMEL(J)+DONE
          Z=Z-T1*SZ/DTWO
        ENDIF
      ENDDO
C
      IF(BMEX)THEN                      !LOCAL EXCHANGE
        IF(MEXPOT.LT.3)THEN             !LINDGREN AND ROSEN  XK=1 OR 2/3
          IF(I.GT.0.AND.NI.LT.0)TE=TE+TI
          TI=TI+TI
          VX=XK*DCON4*(TE**(DONE/DTHREE)-TI**(DONE/DTHREE))
        ELSE                            !COWAN
          TJ=TE-TI-TI
          IF(I.GT.0.AND.NI.LT.0)TJ=TJ+TI
          XK=DTWO/DTHREE
          FR=DONE
          EN=ABS(NI)
          EL=LI
          IF(TE.GT.D1M70)VX=XK*DCON4*TE**(DONE/DTHREE)*TJ/TE
          VX=VX*FR*(TJ/(TJ+DTWO*ACOS(-DONE)/(EN-EL)))
        ENDIF
      ENDIF
C
    5 ZEFX=-T/R-VX
C
      RETURN
C
      END FUNCTION ZEFX
C
C                             *******************
C
      FUNCTION ZEFXL(X,ZL,DX,I)
C
C-----------------------------------------------------------------------
C
C  N.R.BADNELL D.A.M.T.P. CAMBRIDGE
C  FN.ZEFXL EVALUATES THE INPUT POTENTIAL AT NON-GRID POINT X USING
C  N-PT LAGRANGE INTERPOLATION, WHERE X LIES BETWEEN DX(I) AND DX(I+1).
C  IR REQUIRES I .GT. N/2 , I ALWAYS .GT. 8 WITH THE AS GRID.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      DIMENSION ZL(*),DX(*)
C
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
C
      N=4
      IM=N/2
      IM=I-IM
      V=DZERO
C
      DO J1=1,N
        DD=DONE
        J=IM+J1
C
        DO K1=1,N
          IF(J1.NE.K1)THEN
            K=IM+K1
            DD=DD*(X-DX(K))
            DD=DD/(DX(J)-DX(K))
          ENDIF
        ENDDO
C
        V=V+DD*(ZL(J)+DTWO*VSC(J))
        IF(BREL)V=V+DD*PMVDAR(J,DX(J))
C
      ENDDO
C
      ZEFXL=V
C
      RETURN
C
      END FUNCTION ZEFXL
C
C                             *******************
C
      SUBROUTINE ZERO
C
C-----------------------------------------------------------------------
C
C  SR.ZERO PRINTS DETAILS OF THE PRIMARY DIMENSIONS FOR AUTOSTRUCTURE.
C
C  IT CALLS:
C
C-----------------------------------------------------------------------
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP,XP,RP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      CHARACTER(LEN=5) KNM0,KNAM                      !,local
C
      COMMON /NRBDIM/MXUSED(MXDIM),KNAM(MXDIM)
C
      DIMENSION KDIM(MXDIM),KNM0(MXDIM)
C
C
C NOTES ON PRIMARY DIMENSIONS FOR AUTOSTRUCTURE.
C SEE THE INCLUDE FILE 'PARAM_F95' AND THE MODULE PARAM
C FOR THE ACTUAL VALUES TO BE USED.
C
C
C MXAAI=MAXIMUM NUMBER OF BOUND-CONTINUUM INTERACTIONS IN A GROUP
C         (SAME SL) IN SR.DIAGON. EQUALS NO. OF BOUND TERMS*NO. OF
C         CONTINUUM TERMS=NO. OF AUTOIONIZATION RATES IF ALL
C         BOUND TERMS ARE ENERGETICALLY ACCESSIBLE.
C         SET MXAAI .LT. (MAXDI/2)**2 SINCE ONLY REACHES LIMIT IN SMALL
C         CASES. ARRAY DIMENSION IS MXENG*MXAAI.
C
C MXAAK=MAXIMUM NUMBER OF BOUND-CONTINUUM INTERACTIONS IN A GROUP
C         (SAME J) IN SR.DIAGFS. EQUALS NO. OF BOUND TERMS*NO. OF
C         CONTINUUM TERMS=NO. OF AUTOIONIZATION RATES IF ALL
C         BOUND TERMS ARE ENERGETICALLY ACCESSIBLE.
C         SET MXAAK .LT. (MAXDK/2)**2 SINCE ONLY REACHES LIMIT IN SMALL
C         CASES. ARRAY DIMENSION IS MXENG*MXAAK.
C
C MAXAD=MAXIMUM NUMBER OF DISTINCT MATRIX ELEMENTS ( T ! H ! TP ),
C         (N*(N+1))/2 FOR A N*N H-MATRIX SL (I.E. FOR ONE SL GROUP).
C         UP TO MAXTM ADDITIONAL LOCATIONS ARE NEEDED WHEN COMPUTING
C         RADIATIVE DATA (IF NOT THEN ONLY ONE MORE LOCATION).
C
C MXADJ=MAXIMUM NUMBER OF DISTINCT MATRIX ELEMENTS (LV ! H ! LVP).
C         (N*(N+1))/2 FOR A N*N H-MATRIX J (I.E. FOR ONE J GROUP).
C
C MXAJS=MXADJ FOR TWO-BODY FINE-STRUCTURE, =1 IF NONE.
C
C MAXB1=MAXIMUM NUMBER OF INTEGRATION POINTS FOR RADIAL FUNCTIONS,
C         EFFECTIVE VALUE MAXRS REDUCES ACCORDING TO DEL IN SR.RADIAL
C         MAXB1 FURTHER RELATES TO THE NUMBER OF POINTS OF A USER-
C         SUPPLIED RADIAL FUNCTION P/Q -- POINTS IN EXCESS OF MAXB1
C         (2*MAXB1 IN THE CASE OF PRECISION='DOUBLE') ARE IGNORED.
C         ARRAY DIMENSION MAXB1*MAXGR.
C
C MAXB2=MAXIMUM NUMBER OF INTEGRATION POINTS INVOLVING Q(NL).
C         SET .EQ. MAXB1. USED FOR USER SUPPLIED FUNCTIONS, SMALL
C         COMPONENT OF SEMI-RELATIVISTIC ORBITALS AND NL-DEPENDENT
C         POTENTIALS.
C         ARRAY DIMENSION MAXB1*MAXGR.
C
C MXBIF=MAXIMUM NUMBER OF BORN INTERACTIONS FOR ANY STATE (LS & IC).
C       I.E. IF THERE ARE N-STATES WHICH ALL BORN INTERACT THEN THERE
C       ARE (N*(N+1))/2 DISTINCT INTERACTIONS.
C
C MXBLM=MAXIMUM BORN LAMBDA MULTIPOLE RETAINED (MIN 2). IN GENERAL,
C       NEED TWICE MAX ORBITAL L.
C
C MXCAS=MAXIMUM NUMBER OF CASCADE COEFFICIENTS. SET .EQ. 1 FOR NONE.
C
C MAXCF=MAXIMUM NUMBER OF CONFIGURATIONS.
C
C MXCHG=MAXIMUM NUMBER OF N-ELECTRON TARGET SLP GROUPS WHICH
C       CONTRIBUTE TO AN (N+1)-ELECETRON SLP SYMMETRY.
C
C MAXCL=MAXIMUM NUMBER OF CORE ELECTRONS.
C
C MAXCT=MAXIMUM NUMBER OF (ALGEBRAIC) TERMS.
C
C MAXDC=MAXIMUM NUMBER OF VECTOR COUPLING COEFFICIENTS.
C
C MAXDF=MAXIMUM NUMBER OF TERMS SL IN A CONFIGURATION   (ALGEB1).
C         ARRAY DIMENSION MAXDF**2.
C
C MXDFS=SIZE OF FACTORIAL ARRAY.
C
C MAXDI=MAX. NUMBER OF TERMS IN A GROUP (WITH SAME SL)  (DIAGON).
C         ARRAY DIMENSION MAXDI**2.
C
C MAXDK=MAX. NUMBER OF LEVELS IN A GROUP (WITH SAME J)  (DIAGFS).
C         ARRAY DIMENSION MAXDK**2.
C
C MXEL0=MAXIMUM NUMBER OF VALENCE ELECTRONS.
C
C MXENG=MAXIMUM NUMBER OF INTERPOLATION ENERGIES FOR EACH
C         CONTINUUM ORBITAL. AFFECTS TWO DIMENSIONAL ARRAYS BELOW.
C
C MXEST=SPECIFIES THE SIZE OF TWO DIMENSIONAL QUANTUM NUMBER ARRAYS
C         REPRESENTING SLATER STATES. PROVIDE AT LEAST (NUMBER MAXEL
C         OF VALENCE ELECTRONS)*(NUMBER MAXST OF SLATER STATES+1)
C         LOCATIONS. NOTE: ALTHOUGH MXEST CANNOT EXCEED MXEL0*MXST0,
C         ONE RARELY USES THE MAXIMUM DIMENSIONED MXEL0 & MXST0 AT
C         THE SAME TIME SO DIMENSIONING AS SUCH IS INEFFICIENT.
C
C MXFSL=MAXIMUM NUMBER OF NON-ZERO BOUND-CONTINUUM SLATER INTEGRALS.
C         ARRAY DIMENSION IS MXENG*MXFSL.
C
C MXFSS=MAXIMUM NUMBER OF NON-ZERO BOUND-CONTINUUM FINE-STRUCTURE
C         INTEGRALS. ARRAY DIMENSION IS MXENG*MXFSS.
C
C MXFOO=MAXIMUM NUMBER OF NON-ZERO BOUND-CONTINUUM NON-FINE-STRUCTURE
C         INTEGRALS. ARRAY DIMENSION IS MXENG*MXFOO.
C
C MAXGR=MAXIMUM NUMBER OF DISTINCT ORBITAL VALUES (N,L)  --
C         ADAPT SR.ALGEB1 (LIT, DO39 ETC) IF MAXGR.GT.60 REQUIRED.
C         ARRAY DIMENSION IS MAXGR*MAXB1.
C
C MXGRB=NO. OF NON-CORE (N,L) ORBITALS USED FOR BORN INTEGRALS.
C
C MAXJG=MAXIMUM NUMBER OF DISTINCT LEVEL VALUES J (AND PARITY).
C
C MAXJU=MAXIMUM NUMBER OF CONFIGURATION MIXING COEFFICIENTS IN
C         INTERMEDIATE COUPLING. REQUIRES AT LEAST
C         THE TOTAL NUMBER OF ELEMENTS IN THE REDUCED H-MATRIX.
C         APPROX=2*MXADJ TO CALCULATE RADIATIVE RATES.
C         IF NONE REQUIRED THEN ONLY MAXDK**2 IS NEEDED.
C
C MAXLL=BIGGEST ORBITAL L INCLUDED IN INTERNAL TABLES OF ANGULAR
C         MOMENTUM FUNCTIONS-WHICH SAVE COMPUTING TIME FOR SUCH
C         ORBITALS, THOUGH AT THE EXPENSE OF 2*(MAXLL+1)**5 WORDS.
C         A VALUE OF 8 OR SO (DEPENDING UPON MAXGR OR MAXDF)
C         WILL IN GENERAL NOT INCREASE THE EFFECTIVE SIZE OF AUTO-
C         STRUCTURE-MAXLL AFFECTS THE BRANCHES ALGEB2 AND ALGEB3.
C
C MAXLV=MAXIMUM NUMBER OF LEVELS LV.
C
C MAXMI=MAXIMUM NUMBER OF MAGNETIC INTEGRALS, N AND V.
C
C MXNOR=LOCATIONS (-1) AVAILABLE TO STORE NON-VANISHING ELECTRIC
C         DIPOLE TRANSITION PROBABILITIES (.GE.1.E-2/SEC) IN INTER-
C         MEDIATE COUPLING, USED FOR OPTIONAL CASCADE COEFFICIENTS.
C          SET .EQ. 1 FOR NONE.
C
C MXPOT=NUMBER OF DISTINCT L-DEPENDENT POTENTIALS STORED
C         READY FOR USE IN EVALUATION OF CONTINUUM FUNCTIONS IN
C         SR.RADCON. ARRAY DIMENSION MXPOT*MAXB1.
C
C MAXRK=MAXIMUM NUMBER OF COEFFICIENTS TO SLATER INTEGRALS R.
C         EACH REDUCED ALGEBRAIC MATRIX ELEMENT FOR DIPOLE OR
C         QUADRUPOLE RADIATION REQUIRES ONE ADDITIONAL LOCATION.
C         TERM RESOLVED.
C
C MXRKO=MAXIMUM NUMBER OF COEFFICIENTS TO ORBIT-ORBIT INTEGRALS.
C       =1 FOR NO NON-FINE-STRCUTURE OR =MAXRK FOR NFS.
C
C MXRKS=MAXIMUM NUMBER OF COEFFICIENTS TO SLATER INTEGRALS R.
C       SIMILAR TO MAXRK BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MAXRL=MAXIMUM NUMBER OF SLATER INTEGRALS R (ALL SL SYMMETRIES).
C
C MXRLO=MAXIMUM NUMBER OF ORBIT-ORBIT INTEGRALS.
C       =1 FOR NO NON-FINE-STRCUTURE OR =MAXRL FOR NFS.
C
C MXRLS=MAXIMUM NUMBER OF SLATER INTEGRALS R.
C       SIMILAR TO MAXRL BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MXROS=MAXIMUM NUMBER OF COEFFICIENTS TO ORBIT-ORBIT INTEGRALS.
C       SIMILAR TO MAXRO BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MXRSS=MAXIMUM NUMBER OF ALGEBRAIC COEFFICIENTS E AND D (TO N, V).
C
C MAXSL=MAXIMUM NUMBER OF DISTINCT TERM VALUES SL (AND PARITY).
C
C MXSOC=MAXIMUM NUMBER OF ALGEBRAIC COEFFICIENTS C (TO ZETA).
C
C MXSOI=MAXIMUM NUMBER OF DISTINCT SPIN-ORBIT INTEGRALS ZETA.
C
C MXST0=MAXIMUM NUMBER OF SLATER STATES, ALLOWING FOR ONE
C         ADDITIONAL BUFFER LOCATION. TO MAXIMISE EFFICIENT USE OF
C         MXEST SET MXST0=MXEST/2 IF POSSIBLE.
C
C MXSTX=MAXIMUM NUMBER OF N-ELECTRON TARGET SLATER STATE INTERACTIONS.
C       (OF ORDER (MXST0/2)**2)
C
C MXSYJ=MAXIMUM NUMBER OF (N+1)-ELECTRON SLP SYMMETRIES WHICH
C       CONTRIBUTE TO A JP SYMMETRY
C
C MXS1C=MAXIMUM NUMBER OF COEFFICIENTS TO 1-BODY SPIN-ORBIT INTEGRALS
C       SIMILAR TO MXSOC BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MXS1I=MAXIMUM NUMBER OF 1-BODY SPIN-ORBIT INTEGRALS
C       SIMILAR TO MXSOI BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MXS2C=MAXIMUM NUMBER OF COEFFICIENTS TO 2-BODY FINE-STRUCTURE INTGRLS
C       SIMILAR TO MXRSS BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MXS2I=MAXIMUM NUMBER OF 2-BODY FINE-STRUCTURE INTEGRALS
C       SIMILAR TO MAXMI BUT SLATER STATE RESOLVED, AND PER SYMMETRY.
C
C MAXTM=MAXIMUM NUMBER OF (HAMILTONIAN) TERMS T.
C
C MAXTR=THE SIZE OF A BUFFER ARRAY TO HOLD TERM COUPLING COEFFI-
C         CIENTS, FOR BOTH PARITIES OF ANY VALUE J: .LE.2*MAXDK**2.
C
C MAXUC=MAXIMUM NUMBER OF CONFIGURATION MIXING COEFFICIENTS IN
C         SL COUPLING. REQUIRES AT LEAST
C         THE TOTAL NUMBER OF ELEMENTS IN THE REDUCED H-MATRIX.
C         APPROX=2*MAXAD TO CALCULATE RADIATIVE RATES.
C         IF NONE REQUIRED THEN ONLY MAXDI**2 IS NEEDED.
C
C MXVAR=MAXIMUM NUMBER OF VARIATIONAL PARAMETERS. SET .EQ. MAXGR
C         FOR V(NL) OR 1+MAX(L) FOR V(L), ORBITALS NL.
C
C
      DATA IFIRST/0/
C
      DATA KNM0( 1),KNM0( 2),KNM0( 3)  /'MXAAI','MXAAK','MAXAD'/
      DATA KNM0( 4),KNM0( 5),KNM0( 6)  /'MXADJ','MXAJS','MAXB1'/
      DATA KNM0( 7),KNM0( 8),KNM0( 9)  /'MAXB2','MXBIF','MXBLM'/
      DATA KNM0(10),KNM0(11),KNM0(12)  /'MXCAS','MAXCF','MXCHG'/
      DATA KNM0(13),KNM0(14),KNM0(15)  /'MAXCL','MAXCT','MAXDC'/
      DATA KNM0(16),KNM0(17),KNM0(18)  /'MAXDF','MXDFS','MAXDI'/
      DATA KNM0(19),KNM0(20),KNM0(21)  /'MAXDK','MXEL0','MXENG'/
      DATA KNM0(22),KNM0(23),KNM0(24)  /'MXEST','MXFSL','MXFSS'/
      DATA KNM0(25),KNM0(26),KNM0(27)  /'MXFOO','MAXGR','MXGRB'/
      DATA KNM0(28),KNM0(29),KNM0(30)  /'MAXJG','MAXJU','MAXLL'/
      DATA KNM0(31),KNM0(32),KNM0(33)  /'MAXLV','MAXMI','MXNOR'/
      DATA KNM0(34),KNM0(35),KNM0(36)  /'MXPOT','MAXRK','MXRKO'/
      DATA KNM0(37),KNM0(38),KNM0(39)  /'MXRKS','MAXRL','MXRLO'/
      DATA KNM0(40),KNM0(41),KNM0(42)  /'MXRLS','MXROS','MXRSS'/
      DATA KNM0(43),KNM0(44),KNM0(45)  /'MAXSL','MXSOC','MXSOI'/
      DATA KNM0(46),KNM0(47),KNM0(48)  /'MXST0','MXSTX','MXSYJ'/
      DATA KNM0(49),KNM0(50),KNM0(51)  /'MXS1C','MXS1I','MXS2C'/
      DATA KNM0(52),KNM0(53),KNM0(54)  /'MXS2I','MAXTM','MAXTR'/
      DATA KNM0(55),KNM0(56)           /'MAXUC','MXVAR'/
      DATA KDIM( 1),KDIM( 2),KDIM( 3)    /MXAAI,MXAAK,MAXAD/
      DATA KDIM( 4),KDIM( 5),KDIM( 6)    /MXADJ,MXAJS,MAXB1/
      DATA KDIM( 7),KDIM( 8),KDIM( 9)    /MAXB2,MXBIF,MXBLM/
      DATA KDIM(10),KDIM(11),KDIM(12)    /MXCAS,MAXCF,MXCHG/
      DATA KDIM(13),KDIM(14),KDIM(15)    /MAXCL,MAXCT,MAXDC/
      DATA KDIM(16),KDIM(17),KDIM(18)    /MAXDF,MXDFS,MAXDI/
      DATA KDIM(19),KDIM(20),KDIM(21)    /MAXDK,MXEL0,MXENG/
      DATA KDIM(22),KDIM(23),KDIM(24)    /MXEST,MXFSL,MXFSS/
      DATA KDIM(25),KDIM(26),KDIM(27)    /MXFOO,MAXGR,MXGRB/
      DATA KDIM(28),KDIM(29),KDIM(30)    /MAXJG,MAXJU,MAXLL/
      DATA KDIM(31),KDIM(32),KDIM(33)    /MAXLV,MAXMI,MXNOR/
      DATA KDIM(34),KDIM(35),KDIM(36)    /MXPOT,MAXRK,MXRKO/
      DATA KDIM(37),KDIM(38),KDIM(39)    /MXRKS,MAXRL,MXRLO/
      DATA KDIM(40),KDIM(41),KDIM(42)    /MXRLS,MXROS,MXRSS/
      DATA KDIM(43),KDIM(44),KDIM(45)    /MAXSL,MXSOC,MXSOI/
      DATA KDIM(46),KDIM(47),KDIM(48)    /MXST0,MXSTX,MXSYJ/
      DATA KDIM(49),KDIM(50),KDIM(51)    /MXS1C,MXS1I,MXS2C/
      DATA KDIM(52),KDIM(53),KDIM(54)    /MXS2I,MAXTM,MAXTR/
      DATA KDIM(55),KDIM(56)             /MAXUC,MXVAR/
C
      IF(IFIRST.EQ.0)THEN
C
        WRITE(6,1000)
        WRITE(6,1001)
        WRITE(6,1002)
C
C PRINT INFO ON PRECISION
C
        WRITE(6,2000)
        WRITE(6,2001)KIND(.TRUE._BP)
        WRITE(6,3001)KIND(1_QP),RANGE(1_QP)
        WRITE(6,3002)KIND(1_SP),RANGE(1_SP)
        WRITE(6,3003)KIND(1_EP),RANGE(1_EP)
        WRITE(6,4001)KIND(1.0_RP),RANGE(1.0_RP),PRECISION(1.0_RP)
        WRITE(6,4002)KIND(1.0_WP),RANGE(1.0_WP),PRECISION(1.0_WP)
        IF(XP.NE.WP)
     X  WRITE(6,4003)KIND(1.0_XP),RANGE(1.0_XP),PRECISION(1.0_XP)
C
        IF(QP.GT.SP)THEN
          WRITE(6,*)' *** ERROR: SHORT INTEGER BYTE LENGTH IS'
     X             ,' GREATER THAN THE DEFAULT ONE!'
          STOP ' *** INTEGER BYTE LENGTH MIS-MATCH!'
        ENDIF
C
        IF(EP.LT.SP)THEN
          WRITE(6,*)' *** ERROR: EXTENDED INTEGER BYTE LENGTH IS'
     X             ,' SHORTER THAN THE DEFAULT ONE!'
          STOP ' *** INTEGER BYTE LENGTH MIS-MATCH!'
        ENDIF
C
        IF(PRECISION(1.0_WP).LT.10)THEN
          WRITE(6,*)' *** STRONG WARNING: DEFAULT REAL PRECISION IS'
     X             ,' LIKELY TOO SHORT; AT BEST INACCURATE...'
          WRITE(0,*)' *** STRONG WARNING: DEFAULT REAL PRECISION IS'
     X             ,' LIKELY TOO SHORT; AT BEST INACCURATE...'
        ENDIF
C
C PRINT MAX DIMENSIONS
C
        WRITE(6,1003) (KNM0(I),KDIM(I),I=1,MXDIM)
        IFIRST=1
        DO I=1,MXDIM
          MXUSED(I)=0
          KNAM(I)=KNM0(I)                         !SHOULD USE MODULE NOW
c          local=knm0(i)          !for g77 as above does not transfer...
c          knam(i)=local
        ENDDO
C
      ELSE                                         !PRINT DIMENSION USED
C
        MXUSED(7)=MXUSED(6)                        !MAXB2=MAXB1
        MXUSED(14)=MXUSED(53)                      !MAXCT=MAXTM
        MXUSED(56)=3*MXUSED(26)                    !MXVAR=MAXGR*3
        WRITE(6,1004) (KNM0(I),MXUSED(I),I=1,MXDIM)
        WRITE(6,1005)
C
      ENDIF
C
      RETURN
C
 1000 FORMAT(///132('*')/132('*')//
     X/31X,' AAAAAAAA      UU      UU     TTTTTTTTTT      OOOOOOOO',
     X/31X,'AAAAAAAAAA     UU      UU     TTTTTTTTTT     OOOOOOOOOO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AAAAAAAAAA     UU      UU         TT         OO      OO',
     X/31X,'AAAAAAAAAA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UU      UU         TT         OO      OO',
     X/31X,'AA      AA     UUUUUUUUUU         TT         OOOOOOOOOO',
     X/31X,'AA      AA      UUUUUUUU          TT          OOOOOOOO')
 1001 FORMAT(/
     X/1X,' SSSSSSSS      TTTTTTTTTT     RRRRRRRRR      UU      UU',
     X'      CCCCCCCC      TTTTTTTTTT     UU      UU     RRRRRRRRR  ',
     X'    EEEEEEEEEE'
     X/1X,'SSSSSSSSSS     TTTTTTTTTT     RRRRRRRRRR     UU      UU',
     X'     CCCCCCCCCC     TTTTTTTTTT     UU      UU     RRRRRRRRRR ',
     X'    EEEEEEEEEE'
     X/1X,'SS                 TT         RR      RR     UU      UU',
     X'     CC      CC         TT         UU      UU     RR      RR ',
     X'    EE'
     X/1X,'SS                 TT         RR      RR     UU      UU',
     X'     CC                 TT         UU      UU     RR      RR ',
     X'    EE'
     X/1X,'SS                 TT         RR     RR      UU      UU',
     X'     CC                 TT         UU      UU     RR     RR  ',
     X'    EE'
     X/1X,'SSSSSSSSS          TT         RRRRRRRR       UU      UU',
     X'     CC                 TT         UU      UU     RRRRRRRR   ',
     X'    EEEEEEEEE')
 1002 FORMAT(
     X 1X,' SSSSSSSSS         TT         RRRRRR         UU      UU',
     X'     CC                 TT         UU      UU     RRRRRR     ',
     X'    EEEEEEEEE'
     X/1X,'        SS         TT         RR   RR        UU      UU',
     X'     CC                 TT         UU      UU     RR   RR    ',
     X'    EE'
     X/1X,'        SS         TT         RR    RR       UU      UU',
     X'     CC                 TT         UU      UU     RR    RR   ',
     X'    EE'
     X/1X,'        SS         TT         RR     RR      UU      UU',
     X'     CC     CC          TT         UU      UU     RR     RR  ',
     X'    EE'
     X/1X,'SSSSSSSSSS         TT         RR      RR     UUUUUUUUUU',
     X'     CCCCCCCCC          TT         UUUUUUUUUU     RR      RR ',
     X'    EEEEEEEEEE'
     X/1X,' SSSSSSSS          TT         RR       RR     UUUUUUUU ',
     X'      CCCCCCC           TT          UUUUUUUU      RR       RR',
     X'    EEEEEEEEEE'///132('*')/132('*')////)
 1003 FORMAT(/////' THIS VERSION OF AUTOSTRUCTURE (27.133.5) IS'
     X,' COMPILED WITH THE FOLLOWING STORAGE PARAMETERS-'
     X///4(4X,'NAME',6X,'VALUE',10X)//4(3X,A5,I11,10X))
 1004 FORMAT(///1X,131('-')///' SUMMARY OF STORAGE USED-'
     X///4(4X,'NAME',6X,'VALUE',10X)//4(3X,A5,I11,10X))
 1005 FORMAT(//' *** THIS INCLUDES BUFFER REQUIREMENTS, THE NUMBER OF'
     X,' PHYSICAL QUANTITIES MAYBE LESS (E.G. TERMS) ***'//109('-'))
 2000 FORMAT(/' WORD INFO-')
 2001 FORMAT(/'            LOGICAL BYTE LENGTH=',I3)
 3001 FORMAT(/'      SHORT INTEGER BYTE LENGTH=',I3,5X,'RANGE=',I5)
 3002 FORMAT( '    DEFAULT INTEGER BYTE LENGTH=',I3,5X,'RANGE=',I5)
 3003 FORMAT( '   EXTENDED INTEGER BYTE LENGTH=',I3,5X,'RANGE=',I5)
 4001 FORMAT(/'      SHORT    REAL BYTE LENGTH=',I3,5X,'RANGE=',I5
     X                                             ,5X,'PRECISION=',I2)
 4002 FORMAT( '    DEFAULT    REAL BYTE LENGTH=',I3,5X,'RANGE=',I5
     X                                             ,5X,'PRECISION=',I2)
 4003 FORMAT( '   EXTENDED    REAL BYTE LENGTH=',I3,5X,'RANGE=',I5
     X                                             ,5X,'PRECISION=',I2)
C
      END SUBROUTINE ZERO
C
C                             *******************
C
      SUBROUTINE ZETA(K1,K3,DK)
C
C-----------------------------------------------------------------------
C
C  SR.ZETA EVALUATES THE ORDINARY NUCLEAR SPIN-ORBIT ZETA INTEGRAL,
C  BUT OMITS Z.
C
C  Q.NE.0 (BREL2) CASE IREL.GT.0 ONLY
C  BREL/2 USES SMALL R CORRECTION
C
C-----------------------------------------------------------------------
C
      USE COMMON_RADF,   ONLY: DPNL,DUY,DX,DORIG
      USE COMMON_NRBDQE, ONLY: DQNL
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      PARAMETER (MXNUK=500)     !NO. OF RADIAL POINTS FOR FINITE NUCLEUS
C
      COMMON /CHARY/DEY(MAXGR)
      COMMON /COM1/DP(MAXB1),TDUM,MDMM
      COMMON /COM6/DPA(MAXB1)
      COMMON /COM7/DNUK0(MXNUK),DNUK1(MXNUK),DNUK2(MXNUK)
     X            ,DNUK(MXNUK),ZS0(0:10),ZS(0:10),JZNM
      COMMON /CRAD/DHNS(20),MNH(20),MJH,MAXRS,JEND(MAXGR)
      COMMON /GENINF/DADJUS(MXVAR),SCREEN(MAXGR),MION,NZION,NPARAM
     X              ,ITOL,INCLUD,JPRINT
      COMMON /NRBDEN/MDEN,MP0,DEBYE,GAMQ,ZNP0,DENI,DENE,TKAY,VSC(MAXB1)
     X              ,XC1,XC2,NPITER
      COMMON /NRBHAM/POTHAM(MAXB1),MPSEUD
      COMMON /NRBNUK/RNUK,SKIN,ATM,TK0,INUKE,INUK,INUK0
      COMMON /NRBREL/IREL,KAPPA,IGAGR,irtard,ibreit,BREL,BJUMPR,BMVD
      common /nrbtmp/rnorm(maxgr),ncc0(maxgr),iorb(0:maxgr)
C
      BREL2=ABS(IREL).EQ.2
C
      DZ=NZION
      DD=DONE
      D00=DZERO
      INUKP=INUK+1
C
      DE1=DEY(K1)-DUY(K1,K1)   !BREL K1=K3 CURRENTLY
      DE3=DEY(K3)-DUY(K3,K3)   !BREL K1=K3 CURRENTLY
C
      IF(BREL2)THEN
        T=DALF4*DTWO
        DO I=INUKP,MAXRS
          DD1=DONE+T*(DE1+DZ/DX(I))
          DD3=DONE+T*(DE3+DZ/DX(I))
C          DD1=DONE+T*(DE1+POT(I,1))
C          DD3=DONE+T*(DE3+POT(I,1))
          DP(I)=DPNL(I,K1)*DPNL(I,K3) !+DQNL(I,K1)*DQNL(I,K3)
          DP(I)=DP(I)/(SQRT(DD1*DD3)*DX(I)*DX(I)*DX(I))
        ENDDO
      ELSE
C
        IF(IREL.LT.0)THEN
          IF(MPSEUD.LT.0)THEN
            DO I=1,MAXRS
              DP(I)=POTHAM(I)/DZ-DONE/DX(I)
            ENDDO
          ELSE
            IF(K1.EQ.K3)THEN
              DO I=1,MAXRS
                DP(I)=DQNL(I,K1)/(DTWO*DPNL(I,K1))
                DP(I)=(DP(I)-DE1)/DZ
              ENDDO
            ELSE
              DO I=1,MAXRS
                DP(I)=DQNL(I,K1)*DQNL(I,K3)/(DPNL(I,K1)*DPNL(I,K3))
                DP(I)=-SQRT(DP(I))/(DTWO*DZ)
              ENDDO
            ENDIF
          ENDIF
          CALL DIFF(DP,DPA,MNH,DHNS,MJH)           !POTENTIAL DERIVATIVE
        ENDIF
C
        DO I=INUKP,MAXRS
          DP(I)=DPNL(I,K1)*DPNL(I,K3)/(DX(I)*DX(I)*DX(I))
        ENDDO
C
        IF(IREL.LT.0)THEN
          DO I=INUKP,MAXRS
            DP(I)=DP(I)-DP(I)*DPA(I)*DX(I)*DX(I)
c            dpa(i)=dp(i)*dpa(i)*dx(i)*dx(i)
          ENDDO
        ENDIF
C
        IF(BREL)THEN
c         write(0,*)k1,k3
          T=DALF4*DTWO
          DO I=INUKP,MAXRS
c          write(6,*)i,dqnl(i,k1),dqnl(i,k3),dpnl(i,k1),dpnl(i,k3),dx(i)
            DD1=DONE+DALF4*(DQNL(I,K1)/DPNL(I,K1)+DTWO*DZ/DX(I))
            DD3=DONE+DALF4*(DQNL(I,K3)/DPNL(I,K3)+DTWO*DZ/DX(I))
c            dd1=done+t*(de1+dz/dx(i))
c            dd3=done+t*(de3+dz/dx(i))
            DP(I)=DP(I)/SQRT(DD1*DD3)
c            DP(I)=DP(I)*(1./DD1+1./DD3)*.5     !test k1.ne.k3
          ENDDO
          dd=dd*rnorm(k1)*rnorm(k3)
c          write(0,*)rnorm(k1),rnorm(k3)
        ENDIF
c
c        if(irel.lt.0)then
c          do i=1,maxrs
c            dp(i)=dp(i)-dpa(i)
c          enddo
c        endif
c
      ENDIF
C
      IF(RNUK.GT.DZERO)THEN
        DO I=1,INUK
          DP(I)=-DNUK1(I)/DZ
          IF(IREL.LT.0)DP(I)=DP(I)-DPA(I)
          DP(I)=DP(I)/DX(I)
          DP(I)=DP(I)*DPNL(I,K1)*DPNL(I,K3) !+DQNL(I,K1)*DQNL(I,K3))
        ENDDO
        IF(BREL)THEN
          DO I=1,INUK
            DD1=DONE+T*(DE1+DNUK0(I))
            DD3=DONE+T*(DE3+DNUK0(I))
            DP(I)=DP(I)/SQRT(DD1*DD3)
          ENDDO
        ENDIF
      ENDIF
C
      IF(DENE.GT.DZERO)THEN
        MDEN10=MOD(MDEN,ITEN)
        IF(MDEN10.EQ.1.AND.NPITER.GE.0)THEN      !DEBYE-HUCKEL SCREENING
          DO I=1,MAXRS
            T=-DX(I)/DEBYE
            DP(I)=DP(I)*EXP(T)
          ENDDO
C        ELSEIF(MDEN10.EQ.2)THEN                  !ION-SPHERE SCREENING
        ENDIF
      ENDIF
C
      CALL WEDDLE(D00,DP,DKU,MNH,DHNS,MJH,MAXRS)
C
      DK=DKU*DD*DALF4
C
      RETURN
C
      END SUBROUTINE ZETA
C
C                             *******************
C
      FUNCTION ZLAM(LAM,K1,K2,K3,K4)
C
C-----------------------------------------------------------------------
C
C  FN.ZLAM EVALUATES THE Z-LAMDA INTEGRAL OF ORBIT-ORBIT INTERACTION.
C
C-----------------------------------------------------------------------
C
      USE COMMON_DBD2,   ONLY: QCG,QL,QN
C
      USE PRECSN, ONLY: BP,QP,SP,EP,WP
      USE PARAM
      USE CONSTANTS
C
      IMPLICIT REAL(WP) (A,C-H,O-P,R-Z)
      IMPLICIT LOGICAL(BP) (B)
      IMPLICIT INTEGER(SP) (I-N)
      IMPLICIT INTEGER(QP) (Q)
C
C      INCLUDE './INCLUDE'
C
      Z=DZERO
      IF(LAM.EQ.0.or.k1.eq.k3.or.k2.eq.k4)GO TO 1   !apply anti-symmetry
C
      LP=LAM+1
      LM=LAM-1
      LLP=LAM*LP
      LM2=LAM-2
      L1=QL(K1)/2
      L1P=L1*(L1+1)
      L2=QL(K2)/2
      L2P=L2*(L2+1)
      L3=QL(K3)/2
      L3P=L3*(L3+1)
      L4=QL(K4)/2
      L4P=L4*(L4+1)
      T1=LLP
      L2=L1P-L3P-LLP
      T2=L2
      L3=L2P-L4P-LLP
      T3=L3
      L6=L2*L3
      LAM2=LM2*L6
      T6=L6
C JONES INCORRECT    T6=SQRT(T6)
C
      T=LAM+3
      T7=(LAM+1)*(2*LAM+3)
      T7=-T/T7
      T=LM2
      T8=LAM*(2*LAM-1)
      T8=T/T8
      TP=TLAM(LP,K1,K2,K3,K4)
      TM=TLAM(LM,K1,K2,K3,K4)
      UP1=DZERO
      IF(L2.NE.0)UP1=ULAM(LP,K1,K2,K3,K4)
      UM1=DZERO
      IF(L2.NE.0)UM1=ULAM(LM,K1,K2,K3,K4)
      UP2=DZERO
      IF(L3.NE.0)UP2=ULAM(LP,K2,K1,K4,K3)
      UM2=DZERO
      IF(L3.NE.0)UM2=ULAM(LM,K2,K1,K4,K3)
      V1=DZERO
      IF(L6.NE.0)V1=VLAM(LAM,K1,K2,K3,K4)
      V2=DZERO
      IF(LAM2.NE.0)V2=VLAM(LM2,K1,K2,K3,K4)
      Z=T1*(TP-TM)+T2*(UP1-UM1)+T3*(UP2-UM2)+T6*(T7*V1+T8*V2)
C JONES INCORRECT, -T1
C
   1  ZLAM=Z
C
C     WRITE(6,100) K1, K2, K3, K4, 2*LAM, ZLAM
C100  FORMAT(8X,2(I5,I4),I6,F14.7,' =ZLAM')
C
      RETURN
C
      END FUNCTION ZLAM
